
build/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000100 <Reset_Handler>:
 8000100:	b672      	cpsid	i
 8000102:	4822      	ldr	r0, [pc, #136]	; (800018c <endfiniloop+0x4>)
 8000104:	f380 8809 	msr	PSP, r0
 8000108:	2002      	movs	r0, #2
 800010a:	f380 8814 	msr	CONTROL, r0
 800010e:	f3bf 8f6f 	isb	sy
 8000112:	f000 fa6d 	bl	80005f0 <__core_init>
 8000116:	f001 fe33 	bl	8001d80 <__early_init>
 800011a:	481d      	ldr	r0, [pc, #116]	; (8000190 <endfiniloop+0x8>)
 800011c:	491d      	ldr	r1, [pc, #116]	; (8000194 <endfiniloop+0xc>)
 800011e:	4a1e      	ldr	r2, [pc, #120]	; (8000198 <endfiniloop+0x10>)

08000120 <msloop>:
 8000120:	4291      	cmp	r1, r2
 8000122:	da02      	bge.n	800012a <endmsloop>
 8000124:	6008      	str	r0, [r1, #0]
 8000126:	3104      	adds	r1, #4
 8000128:	e7fa      	b.n	8000120 <msloop>

0800012a <endmsloop>:
 800012a:	491c      	ldr	r1, [pc, #112]	; (800019c <endfiniloop+0x14>)
 800012c:	4a17      	ldr	r2, [pc, #92]	; (800018c <endfiniloop+0x4>)

0800012e <psloop>:
 800012e:	4291      	cmp	r1, r2
 8000130:	da02      	bge.n	8000138 <endpsloop>
 8000132:	6008      	str	r0, [r1, #0]
 8000134:	3104      	adds	r1, #4
 8000136:	e7fa      	b.n	800012e <psloop>

08000138 <endpsloop>:
 8000138:	4919      	ldr	r1, [pc, #100]	; (80001a0 <endfiniloop+0x18>)
 800013a:	4a1a      	ldr	r2, [pc, #104]	; (80001a4 <endfiniloop+0x1c>)
 800013c:	4b1a      	ldr	r3, [pc, #104]	; (80001a8 <endfiniloop+0x20>)

0800013e <dloop>:
 800013e:	429a      	cmp	r2, r3
 8000140:	da04      	bge.n	800014c <enddloop>
 8000142:	6808      	ldr	r0, [r1, #0]
 8000144:	6010      	str	r0, [r2, #0]
 8000146:	3104      	adds	r1, #4
 8000148:	3204      	adds	r2, #4
 800014a:	e7f8      	b.n	800013e <dloop>

0800014c <enddloop>:
 800014c:	2000      	movs	r0, #0
 800014e:	4917      	ldr	r1, [pc, #92]	; (80001ac <endfiniloop+0x24>)
 8000150:	4a17      	ldr	r2, [pc, #92]	; (80001b0 <endfiniloop+0x28>)

08000152 <bloop>:
 8000152:	4291      	cmp	r1, r2
 8000154:	da02      	bge.n	800015c <endbloop>
 8000156:	6008      	str	r0, [r1, #0]
 8000158:	3104      	adds	r1, #4
 800015a:	e7fa      	b.n	8000152 <bloop>

0800015c <endbloop>:
 800015c:	f000 f9e8 	bl	8000530 <__init_ram_areas>
 8000160:	f000 fa3e 	bl	80005e0 <__late_init>
 8000164:	4c13      	ldr	r4, [pc, #76]	; (80001b4 <endfiniloop+0x2c>)
 8000166:	4d14      	ldr	r5, [pc, #80]	; (80001b8 <endfiniloop+0x30>)

08000168 <initloop>:
 8000168:	42ac      	cmp	r4, r5
 800016a:	da03      	bge.n	8000174 <endinitloop>
 800016c:	6821      	ldr	r1, [r4, #0]
 800016e:	4788      	blx	r1
 8000170:	3404      	adds	r4, #4
 8000172:	e7f9      	b.n	8000168 <initloop>

08000174 <endinitloop>:
 8000174:	f001 fbcc 	bl	8001910 <main>
 8000178:	4c10      	ldr	r4, [pc, #64]	; (80001bc <endfiniloop+0x34>)
 800017a:	4d11      	ldr	r5, [pc, #68]	; (80001c0 <endfiniloop+0x38>)

0800017c <finiloop>:
 800017c:	42ac      	cmp	r4, r5
 800017e:	da03      	bge.n	8000188 <endfiniloop>
 8000180:	6821      	ldr	r1, [r4, #0]
 8000182:	4788      	blx	r1
 8000184:	3404      	adds	r4, #4
 8000186:	e7f9      	b.n	800017c <finiloop>

08000188 <endfiniloop>:
 8000188:	490e      	ldr	r1, [pc, #56]	; (80001c4 <endfiniloop+0x3c>)
 800018a:	4708      	bx	r1
 800018c:	20000600 	.word	0x20000600
 8000190:	55555555 	.word	0x55555555
 8000194:	20000000 	.word	0x20000000
 8000198:	20000400 	.word	0x20000400
 800019c:	20000400 	.word	0x20000400
 80001a0:	080022f8 	.word	0x080022f8
 80001a4:	20000600 	.word	0x20000600
 80001a8:	20000a00 	.word	0x20000a00
 80001ac:	20000a00 	.word	0x20000a00
 80001b0:	200016b0 	.word	0x200016b0
 80001b4:	08000100 	.word	0x08000100
 80001b8:	08000100 	.word	0x08000100
 80001bc:	08000100 	.word	0x08000100
 80001c0:	08000100 	.word	0x08000100
 80001c4:	080005d1 	.word	0x080005d1
	...

080001d0 <_port_switch>:
 80001d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001d2:	4644      	mov	r4, r8
 80001d4:	464d      	mov	r5, r9
 80001d6:	4656      	mov	r6, sl
 80001d8:	465f      	mov	r7, fp
 80001da:	b4f0      	push	{r4, r5, r6, r7}
 80001dc:	466b      	mov	r3, sp
 80001de:	60cb      	str	r3, [r1, #12]
 80001e0:	68c3      	ldr	r3, [r0, #12]
 80001e2:	469d      	mov	sp, r3
 80001e4:	bcf0      	pop	{r4, r5, r6, r7}
 80001e6:	46a0      	mov	r8, r4
 80001e8:	46a9      	mov	r9, r5
 80001ea:	46b2      	mov	sl, r6
 80001ec:	46bb      	mov	fp, r7
 80001ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001f0 <_port_thread_start>:
 80001f0:	f000 f96e 	bl	80004d0 <_dbg_check_unlock>
 80001f4:	b662      	cpsie	i
 80001f6:	1c28      	adds	r0, r5, #0
 80001f8:	47a0      	blx	r4
 80001fa:	2000      	movs	r0, #0
 80001fc:	f001 fe48 	bl	8001e90 <chThdExit>

08000200 <_port_switch_from_isr>:
 8000200:	f000 f97e 	bl	8000500 <_dbg_check_lock>
 8000204:	f001 fe14 	bl	8001e30 <chSchDoReschedule>
 8000208:	f000 f962 	bl	80004d0 <_dbg_check_unlock>

0800020c <_port_exit_from_isr>:
 800020c:	4a01      	ldr	r2, [pc, #4]	; (8000214 <_port_exit_from_isr+0x8>)
 800020e:	4b02      	ldr	r3, [pc, #8]	; (8000218 <_port_exit_from_isr+0xc>)
 8000210:	6013      	str	r3, [r2, #0]
 8000212:	e7fe      	b.n	8000212 <_port_exit_from_isr+0x6>
 8000214:	e000ed04 	.word	0xe000ed04
 8000218:	80000000 	.word	0x80000000
 800021c:	00000000 	.word	0x00000000

08000220 <__aeabi_uidiv>:
 8000220:	2900      	cmp	r1, #0
 8000222:	d034      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>

08000224 <.udivsi3_skip_div0_test>:
 8000224:	2301      	movs	r3, #1
 8000226:	2200      	movs	r2, #0
 8000228:	b410      	push	{r4}
 800022a:	4288      	cmp	r0, r1
 800022c:	d32c      	bcc.n	8000288 <.udivsi3_skip_div0_test+0x64>
 800022e:	2401      	movs	r4, #1
 8000230:	0724      	lsls	r4, r4, #28
 8000232:	42a1      	cmp	r1, r4
 8000234:	d204      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 8000236:	4281      	cmp	r1, r0
 8000238:	d202      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 800023a:	0109      	lsls	r1, r1, #4
 800023c:	011b      	lsls	r3, r3, #4
 800023e:	e7f8      	b.n	8000232 <.udivsi3_skip_div0_test+0xe>
 8000240:	00e4      	lsls	r4, r4, #3
 8000242:	42a1      	cmp	r1, r4
 8000244:	d204      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000246:	4281      	cmp	r1, r0
 8000248:	d202      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 800024a:	0049      	lsls	r1, r1, #1
 800024c:	005b      	lsls	r3, r3, #1
 800024e:	e7f8      	b.n	8000242 <.udivsi3_skip_div0_test+0x1e>
 8000250:	4288      	cmp	r0, r1
 8000252:	d301      	bcc.n	8000258 <.udivsi3_skip_div0_test+0x34>
 8000254:	1a40      	subs	r0, r0, r1
 8000256:	431a      	orrs	r2, r3
 8000258:	084c      	lsrs	r4, r1, #1
 800025a:	42a0      	cmp	r0, r4
 800025c:	d302      	bcc.n	8000264 <.udivsi3_skip_div0_test+0x40>
 800025e:	1b00      	subs	r0, r0, r4
 8000260:	085c      	lsrs	r4, r3, #1
 8000262:	4322      	orrs	r2, r4
 8000264:	088c      	lsrs	r4, r1, #2
 8000266:	42a0      	cmp	r0, r4
 8000268:	d302      	bcc.n	8000270 <.udivsi3_skip_div0_test+0x4c>
 800026a:	1b00      	subs	r0, r0, r4
 800026c:	089c      	lsrs	r4, r3, #2
 800026e:	4322      	orrs	r2, r4
 8000270:	08cc      	lsrs	r4, r1, #3
 8000272:	42a0      	cmp	r0, r4
 8000274:	d302      	bcc.n	800027c <.udivsi3_skip_div0_test+0x58>
 8000276:	1b00      	subs	r0, r0, r4
 8000278:	08dc      	lsrs	r4, r3, #3
 800027a:	4322      	orrs	r2, r4
 800027c:	2800      	cmp	r0, #0
 800027e:	d003      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000280:	091b      	lsrs	r3, r3, #4
 8000282:	d001      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000284:	0909      	lsrs	r1, r1, #4
 8000286:	e7e3      	b.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000288:	1c10      	adds	r0, r2, #0
 800028a:	bc10      	pop	{r4}
 800028c:	4770      	bx	lr
 800028e:	2800      	cmp	r0, #0
 8000290:	d001      	beq.n	8000296 <.udivsi3_skip_div0_test+0x72>
 8000292:	2000      	movs	r0, #0
 8000294:	43c0      	mvns	r0, r0
 8000296:	b407      	push	{r0, r1, r2}
 8000298:	4802      	ldr	r0, [pc, #8]	; (80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029a:	a102      	add	r1, pc, #8	; (adr r1, 80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029c:	1840      	adds	r0, r0, r1
 800029e:	9002      	str	r0, [sp, #8]
 80002a0:	bd03      	pop	{r0, r1, pc}
 80002a2:	46c0      	nop			; (mov r8, r8)
 80002a4:	0000001d 	.word	0x0000001d

080002a8 <__aeabi_uidivmod>:
 80002a8:	2900      	cmp	r1, #0
 80002aa:	d0f0      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>
 80002ac:	b503      	push	{r0, r1, lr}
 80002ae:	f7ff ffb9 	bl	8000224 <.udivsi3_skip_div0_test>
 80002b2:	bc0e      	pop	{r1, r2, r3}
 80002b4:	4342      	muls	r2, r0
 80002b6:	1a89      	subs	r1, r1, r2
 80002b8:	4718      	bx	r3
 80002ba:	46c0      	nop			; (mov r8, r8)
 80002bc:	0000      	movs	r0, r0
	...

080002c0 <__aeabi_idiv0>:
 80002c0:	4770      	bx	lr
 80002c2:	46c0      	nop			; (mov r8, r8)
	...

080002d0 <_dbg_check_lock_from_isr.4311>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80002d0:	4b06      	ldr	r3, [pc, #24]	; (80002ec <_dbg_check_lock_from_isr.4311+0x1c>)
 80002d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80002d4:	2a00      	cmp	r2, #0
 80002d6:	dd02      	ble.n	80002de <_dbg_check_lock_from_isr.4311+0xe>
 80002d8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80002da:	2800      	cmp	r0, #0
 80002dc:	d003      	beq.n	80002e6 <_dbg_check_lock_from_isr.4311+0x16>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80002de:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80002e0:	4a03      	ldr	r2, [pc, #12]	; (80002f0 <_dbg_check_lock_from_isr.4311+0x20>)
 80002e2:	62da      	str	r2, [r3, #44]	; 0x2c
 80002e4:	e7fe      	b.n	80002e4 <_dbg_check_lock_from_isr.4311+0x14>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80002e6:	2101      	movs	r1, #1
 80002e8:	6359      	str	r1, [r3, #52]	; 0x34
}
 80002ea:	4770      	bx	lr
 80002ec:	20000fc0 	.word	0x20000fc0
 80002f0:	08002040 	.word	0x08002040
 80002f4:	46c0      	nop			; (mov r8, r8)
 80002f6:	46c0      	nop			; (mov r8, r8)
 80002f8:	46c0      	nop			; (mov r8, r8)
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	46c0      	nop			; (mov r8, r8)
 80002fe:	46c0      	nop			; (mov r8, r8)

08000300 <_dbg_check_unlock_from_isr.4313>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000300:	4b06      	ldr	r3, [pc, #24]	; (800031c <_dbg_check_unlock_from_isr.4313+0x1c>)
 8000302:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000304:	2a00      	cmp	r2, #0
 8000306:	dd05      	ble.n	8000314 <_dbg_check_unlock_from_isr.4313+0x14>
 8000308:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800030a:	2800      	cmp	r0, #0
 800030c:	dd02      	ble.n	8000314 <_dbg_check_unlock_from_isr.4313+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 800030e:	2100      	movs	r1, #0
 8000310:	6359      	str	r1, [r3, #52]	; 0x34
}
 8000312:	4770      	bx	lr
 8000314:	b672      	cpsid	i
 8000316:	4a02      	ldr	r2, [pc, #8]	; (8000320 <_dbg_check_unlock_from_isr.4313+0x20>)
 8000318:	62da      	str	r2, [r3, #44]	; 0x2c
 800031a:	e7fe      	b.n	800031a <_dbg_check_unlock_from_isr.4313+0x1a>
 800031c:	20000fc0 	.word	0x20000fc0
 8000320:	08002048 	.word	0x08002048
 8000324:	46c0      	nop			; (mov r8, r8)
 8000326:	46c0      	nop			; (mov r8, r8)
 8000328:	46c0      	nop			; (mov r8, r8)
 800032a:	46c0      	nop			; (mov r8, r8)
 800032c:	46c0      	nop			; (mov r8, r8)
 800032e:	46c0      	nop			; (mov r8, r8)

08000330 <_dbg_check_enter_isr.4315>:
 8000330:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000332:	4b07      	ldr	r3, [pc, #28]	; (8000350 <_dbg_check_enter_isr.4315+0x20>)
 8000334:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000336:	2a00      	cmp	r2, #0
 8000338:	db02      	blt.n	8000340 <_dbg_check_enter_isr.4315+0x10>
 800033a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800033c:	2900      	cmp	r1, #0
 800033e:	d003      	beq.n	8000348 <_dbg_check_enter_isr.4315+0x18>
 8000340:	b672      	cpsid	i
 8000342:	4804      	ldr	r0, [pc, #16]	; (8000354 <_dbg_check_enter_isr.4315+0x24>)
 8000344:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000346:	e7fe      	b.n	8000346 <_dbg_check_enter_isr.4315+0x16>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 8000348:	3201      	adds	r2, #1
 800034a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800034c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800034e:	4770      	bx	lr
 8000350:	20000fc0 	.word	0x20000fc0
 8000354:	08002050 	.word	0x08002050
 8000358:	46c0      	nop			; (mov r8, r8)
 800035a:	46c0      	nop			; (mov r8, r8)
 800035c:	46c0      	nop			; (mov r8, r8)
 800035e:	46c0      	nop			; (mov r8, r8)

08000360 <_dbg_check_leave_isr.4317>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000360:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000362:	4b07      	ldr	r3, [pc, #28]	; (8000380 <_dbg_check_leave_isr.4317+0x20>)
 8000364:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000366:	2a00      	cmp	r2, #0
 8000368:	dd02      	ble.n	8000370 <_dbg_check_leave_isr.4317+0x10>
 800036a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800036c:	2900      	cmp	r1, #0
 800036e:	d003      	beq.n	8000378 <_dbg_check_leave_isr.4317+0x18>
 8000370:	b672      	cpsid	i
 8000372:	4804      	ldr	r0, [pc, #16]	; (8000384 <_dbg_check_leave_isr.4317+0x24>)
 8000374:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000376:	e7fe      	b.n	8000376 <_dbg_check_leave_isr.4317+0x16>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8000378:	3a01      	subs	r2, #1
 800037a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800037c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800037e:	4770      	bx	lr
 8000380:	20000fc0 	.word	0x20000fc0
 8000384:	08002058 	.word	0x08002058
 8000388:	46c0      	nop			; (mov r8, r8)
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	46c0      	nop			; (mov r8, r8)
 800038e:	46c0      	nop			; (mov r8, r8)

08000390 <stSetAlarm.4337>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000390:	2380      	movs	r3, #128	; 0x80
 8000392:	05db      	lsls	r3, r3, #23
 8000394:	68da      	ldr	r2, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000396:	0791      	lsls	r1, r2, #30
 8000398:	d501      	bpl.n	800039e <stSetAlarm.4337+0xe>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800039a:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
 800039c:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800039e:	b672      	cpsid	i
 80003a0:	4801      	ldr	r0, [pc, #4]	; (80003a8 <stSetAlarm.4337+0x18>)
 80003a2:	4902      	ldr	r1, [pc, #8]	; (80003ac <stSetAlarm.4337+0x1c>)
 80003a4:	62c8      	str	r0, [r1, #44]	; 0x2c
 80003a6:	e7fe      	b.n	80003a6 <stSetAlarm.4337+0x16>
 80003a8:	08002020 	.word	0x08002020
 80003ac:	20000fc0 	.word	0x20000fc0

080003b0 <long_to_string_with_divisor.8448.constprop.3.4346>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 80003b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80003b2:	4657      	mov	r7, sl
 80003b4:	464e      	mov	r6, r9
 80003b6:	4645      	mov	r5, r8
 80003b8:	b4e0      	push	{r5, r6, r7}
 80003ba:	1c0e      	adds	r6, r1, #0
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80003bc:	210b      	movs	r1, #11
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 80003be:	4681      	mov	r9, r0
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80003c0:	468a      	mov	sl, r1
 80003c2:	44ca      	add	sl, r9
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 80003c4:	4690      	mov	r8, r2
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80003c6:	1c37      	adds	r7, r6, #0
 80003c8:	4654      	mov	r4, sl
  do {
    i = (int)(l % radix);
 80003ca:	1c30      	adds	r0, r6, #0
 80003cc:	4641      	mov	r1, r8
 80003ce:	f7ff ff6b 	bl	80002a8 <__aeabi_uidivmod>
    i += '0';
 80003d2:	1c0b      	adds	r3, r1, #0
 80003d4:	3330      	adds	r3, #48	; 0x30
    if (i > '9')
 80003d6:	2b39      	cmp	r3, #57	; 0x39
 80003d8:	dd00      	ble.n	80003dc <long_to_string_with_divisor.8448.constprop.3.4346+0x2c>
      i += 'A' - '0' - 10;
 80003da:	3307      	adds	r3, #7
    *--q = i;
 80003dc:	b2dd      	uxtb	r5, r3
 80003de:	3c01      	subs	r4, #1
    l /= radix;
 80003e0:	1c30      	adds	r0, r6, #0
 80003e2:	4641      	mov	r1, r8
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 80003e4:	7025      	strb	r5, [r4, #0]
    l /= radix;
 80003e6:	f7ff ff1b 	bl	8000220 <__aeabi_uidiv>
  } while ((ll /= radix) != 0);
 80003ea:	4641      	mov	r1, r8
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 80003ec:	1c06      	adds	r6, r0, #0
  } while ((ll /= radix) != 0);
 80003ee:	1c38      	adds	r0, r7, #0
 80003f0:	f7ff ff16 	bl	8000220 <__aeabi_uidiv>
 80003f4:	1e07      	subs	r7, r0, #0
 80003f6:	d1e8      	bne.n	80003ca <long_to_string_with_divisor.8448.constprop.3.4346+0x1a>

  i = (int)(p + MAX_FILLER - q);
 80003f8:	4652      	mov	r2, sl
 80003fa:	1b10      	subs	r0, r2, r4
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 80003fc:	4649      	mov	r1, r9
 80003fe:	1c63      	adds	r3, r4, #1
 8000400:	1808      	adds	r0, r1, r0
 8000402:	43cc      	mvns	r4, r1
 8000404:	1906      	adds	r6, r0, r4
 8000406:	07f4      	lsls	r4, r6, #31
 8000408:	d50b      	bpl.n	8000422 <long_to_string_with_divisor.8448.constprop.3.4346+0x72>
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 800040a:	700d      	strb	r5, [r1, #0]
 800040c:	2501      	movs	r5, #1
 800040e:	44a9      	add	r9, r5
 8000410:	781d      	ldrb	r5, [r3, #0]
 8000412:	3301      	adds	r3, #1
 8000414:	e005      	b.n	8000422 <long_to_string_with_divisor.8448.constprop.3.4346+0x72>
 8000416:	7819      	ldrb	r1, [r3, #0]
 8000418:	3601      	adds	r6, #1
 800041a:	7051      	strb	r1, [r2, #1]
 800041c:	785d      	ldrb	r5, [r3, #1]
 800041e:	46b1      	mov	r9, r6
 8000420:	3302      	adds	r3, #2
 8000422:	464e      	mov	r6, r9
 8000424:	464a      	mov	r2, r9
 8000426:	3601      	adds	r6, #1
 8000428:	7015      	strb	r5, [r2, #0]
  while (--i);
 800042a:	42b0      	cmp	r0, r6
 800042c:	d1f3      	bne.n	8000416 <long_to_string_with_divisor.8448.constprop.3.4346+0x66>

  return p;
}
 800042e:	bc1c      	pop	{r2, r3, r4}
 8000430:	4690      	mov	r8, r2
 8000432:	4699      	mov	r9, r3
 8000434:	46a2      	mov	sl, r4
 8000436:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000438:	46c0      	nop			; (mov r8, r8)
 800043a:	46c0      	nop			; (mov r8, r8)
 800043c:	46c0      	nop			; (mov r8, r8)
 800043e:	46c0      	nop			; (mov r8, r8)

08000440 <notify2.8355>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000440:	4b02      	ldr	r3, [pc, #8]	; (800044c <notify2.8355+0xc>)
 8000442:	2280      	movs	r2, #128	; 0x80
 8000444:	6819      	ldr	r1, [r3, #0]
 8000446:	430a      	orrs	r2, r1
 8000448:	601a      	str	r2, [r3, #0]
}
 800044a:	4770      	bx	lr
 800044c:	40004400 	.word	0x40004400

08000450 <notify1.8358>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000450:	4b02      	ldr	r3, [pc, #8]	; (800045c <notify1.8358+0xc>)
 8000452:	2280      	movs	r2, #128	; 0x80
 8000454:	6819      	ldr	r1, [r3, #0]
 8000456:	430a      	orrs	r2, r1
 8000458:	601a      	str	r2, [r3, #0]
}
 800045a:	4770      	bx	lr
 800045c:	40013800 	.word	0x40013800

08000460 <_port_irq_epilogue.4382>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000460:	300f      	adds	r0, #15
 8000462:	d011      	beq.n	8000488 <_port_irq_epilogue.4382+0x28>
 8000464:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000466:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800046a:	3b20      	subs	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800046c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000470:	2280      	movs	r2, #128	; 0x80
 8000472:	0450      	lsls	r0, r2, #17
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000474:	4a06      	ldr	r2, [pc, #24]	; (8000490 <_port_irq_epilogue.4382+0x30>)
 8000476:	61d8      	str	r0, [r3, #28]
 8000478:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800047a:	6990      	ldr	r0, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800047c:	6889      	ldr	r1, [r1, #8]
 800047e:	6882      	ldr	r2, [r0, #8]
 8000480:	4291      	cmp	r1, r2
 8000482:	d802      	bhi.n	800048a <_port_irq_epilogue.4382+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000484:	4803      	ldr	r0, [pc, #12]	; (8000494 <_port_irq_epilogue.4382+0x34>)
 8000486:	6198      	str	r0, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000488:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800048a:	4903      	ldr	r1, [pc, #12]	; (8000498 <_port_irq_epilogue.4382+0x38>)
 800048c:	6199      	str	r1, [r3, #24]
 800048e:	e7fb      	b.n	8000488 <_port_irq_epilogue.4382+0x28>
 8000490:	20000fc0 	.word	0x20000fc0
 8000494:	0800020c 	.word	0x0800020c
 8000498:	08000201 	.word	0x08000201
 800049c:	46c0      	nop			; (mov r8, r8)
 800049e:	46c0      	nop			; (mov r8, r8)

080004a0 <NMI_Handler.4390>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80004a0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80004a4:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80004a6:	f383 8809 	msr	PSP, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80004aa:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80004ac:	4770      	bx	lr
 80004ae:	46c0      	nop			; (mov r8, r8)

080004b0 <_idle_thread.4252>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80004b0:	e7fe      	b.n	80004b0 <_idle_thread.4252>
 80004b2:	46c0      	nop			; (mov r8, r8)
 80004b4:	46c0      	nop			; (mov r8, r8)
 80004b6:	46c0      	nop			; (mov r8, r8)
 80004b8:	46c0      	nop			; (mov r8, r8)
 80004ba:	46c0      	nop			; (mov r8, r8)
 80004bc:	46c0      	nop			; (mov r8, r8)
 80004be:	46c0      	nop			; (mov r8, r8)

080004c0 <BusFault_Handler.4404>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 80004c0:	e7fe      	b.n	80004c0 <BusFault_Handler.4404>
 80004c2:	46c0      	nop			; (mov r8, r8)
 80004c4:	46c0      	nop			; (mov r8, r8)
 80004c6:	46c0      	nop			; (mov r8, r8)
 80004c8:	46c0      	nop			; (mov r8, r8)
 80004ca:	46c0      	nop			; (mov r8, r8)
 80004cc:	46c0      	nop			; (mov r8, r8)
 80004ce:	46c0      	nop			; (mov r8, r8)

080004d0 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80004d0:	4b06      	ldr	r3, [pc, #24]	; (80004ec <_dbg_check_unlock+0x1c>)
 80004d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80004d4:	2a00      	cmp	r2, #0
 80004d6:	d104      	bne.n	80004e2 <_dbg_check_unlock+0x12>
 80004d8:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80004da:	2900      	cmp	r1, #0
 80004dc:	dd01      	ble.n	80004e2 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80004de:	635a      	str	r2, [r3, #52]	; 0x34
}
 80004e0:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004e2:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80004e4:	4802      	ldr	r0, [pc, #8]	; (80004f0 <_dbg_check_unlock+0x20>)
 80004e6:	62d8      	str	r0, [r3, #44]	; 0x2c
 80004e8:	e7fe      	b.n	80004e8 <_dbg_check_unlock+0x18>
 80004ea:	46c0      	nop			; (mov r8, r8)
 80004ec:	20000fc0 	.word	0x20000fc0
 80004f0:	08002060 	.word	0x08002060
 80004f4:	46c0      	nop			; (mov r8, r8)
 80004f6:	46c0      	nop			; (mov r8, r8)
 80004f8:	46c0      	nop			; (mov r8, r8)
 80004fa:	46c0      	nop			; (mov r8, r8)
 80004fc:	46c0      	nop			; (mov r8, r8)
 80004fe:	46c0      	nop			; (mov r8, r8)

08000500 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000500:	4b06      	ldr	r3, [pc, #24]	; (800051c <_dbg_check_lock+0x1c>)
 8000502:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000504:	2a00      	cmp	r2, #0
 8000506:	d102      	bne.n	800050e <_dbg_check_lock+0xe>
 8000508:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800050a:	2800      	cmp	r0, #0
 800050c:	d003      	beq.n	8000516 <_dbg_check_lock+0x16>
 800050e:	b672      	cpsid	i
 8000510:	4a03      	ldr	r2, [pc, #12]	; (8000520 <_dbg_check_lock+0x20>)
 8000512:	62da      	str	r2, [r3, #44]	; 0x2c
 8000514:	e7fe      	b.n	8000514 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000516:	2101      	movs	r1, #1
 8000518:	6359      	str	r1, [r3, #52]	; 0x34
}
 800051a:	4770      	bx	lr
 800051c:	20000fc0 	.word	0x20000fc0
 8000520:	08002068 	.word	0x08002068
 8000524:	46c0      	nop			; (mov r8, r8)
 8000526:	46c0      	nop			; (mov r8, r8)
 8000528:	46c0      	nop			; (mov r8, r8)
 800052a:	46c0      	nop			; (mov r8, r8)
 800052c:	46c0      	nop			; (mov r8, r8)
 800052e:	46c0      	nop			; (mov r8, r8)

08000530 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000530:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000532:	4647      	mov	r7, r8
 8000534:	b480      	push	{r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000536:	4825      	ldr	r0, [pc, #148]	; (80005cc <__init_ram_areas+0x9c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000538:	2380      	movs	r3, #128	; 0x80
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800053a:	4684      	mov	ip, r0
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800053c:	4698      	mov	r8, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800053e:	2400      	movs	r4, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000540:	44e0      	add	r8, ip
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8000542:	4662      	mov	r2, ip
    uint32_t *p = rap->init_area;
 8000544:	6856      	ldr	r6, [r2, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000546:	6895      	ldr	r5, [r2, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8000548:	6811      	ldr	r1, [r2, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800054a:	42ae      	cmp	r6, r5
 800054c:	d220      	bcs.n	8000590 <__init_ram_areas+0x60>
 800054e:	43f7      	mvns	r7, r6
 8000550:	19e8      	adds	r0, r5, r7
      *p = *tp;
 8000552:	1c0a      	adds	r2, r1, #0
 8000554:	0743      	lsls	r3, r0, #29
 8000556:	ca01      	ldmia	r2!, {r0}
 8000558:	0fdf      	lsrs	r7, r3, #31
 800055a:	1c33      	adds	r3, r6, #0
 800055c:	c301      	stmia	r3!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800055e:	42ab      	cmp	r3, r5
 8000560:	d210      	bcs.n	8000584 <__init_ram_areas+0x54>
 8000562:	2f00      	cmp	r7, #0
 8000564:	d004      	beq.n	8000570 <__init_ram_areas+0x40>
      *p = *tp;
 8000566:	6849      	ldr	r1, [r1, #4]
 8000568:	3204      	adds	r2, #4
 800056a:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800056c:	42ab      	cmp	r3, r5
 800056e:	d209      	bcs.n	8000584 <__init_ram_areas+0x54>
      *p = *tp;
 8000570:	1c10      	adds	r0, r2, #0
 8000572:	c880      	ldmia	r0!, {r7}
 8000574:	1c19      	adds	r1, r3, #0
 8000576:	c180      	stmia	r1!, {r7}
 8000578:	6852      	ldr	r2, [r2, #4]
 800057a:	605a      	str	r2, [r3, #4]
      p++;
 800057c:	1d0b      	adds	r3, r1, #4
 800057e:	1d02      	adds	r2, r0, #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000580:	42ab      	cmp	r3, r5
 8000582:	d3f5      	bcc.n	8000570 <__init_ram_areas+0x40>
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000584:	43f3      	mvns	r3, r6
 8000586:	195d      	adds	r5, r3, r5
 8000588:	08a8      	lsrs	r0, r5, #2
 800058a:	3001      	adds	r0, #1
 800058c:	0087      	lsls	r7, r0, #2
 800058e:	19f6      	adds	r6, r6, r7
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000590:	4661      	mov	r1, ip
 8000592:	68cd      	ldr	r5, [r1, #12]
 8000594:	42ae      	cmp	r6, r5
 8000596:	d211      	bcs.n	80005bc <__init_ram_areas+0x8c>
 8000598:	43f2      	mvns	r2, r6
 800059a:	18ab      	adds	r3, r5, r2
 800059c:	0758      	lsls	r0, r3, #29
      *p = 0;
 800059e:	c610      	stmia	r6!, {r4}
 80005a0:	0fc7      	lsrs	r7, r0, #31
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80005a2:	42ae      	cmp	r6, r5
 80005a4:	d20a      	bcs.n	80005bc <__init_ram_areas+0x8c>
 80005a6:	2f00      	cmp	r7, #0
 80005a8:	d002      	beq.n	80005b0 <__init_ram_areas+0x80>
      *p = 0;
 80005aa:	c610      	stmia	r6!, {r4}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80005ac:	42ae      	cmp	r6, r5
 80005ae:	d205      	bcs.n	80005bc <__init_ram_areas+0x8c>
      *p = 0;
 80005b0:	1c31      	adds	r1, r6, #0
 80005b2:	c110      	stmia	r1!, {r4}
 80005b4:	6074      	str	r4, [r6, #4]
      p++;
 80005b6:	1d0e      	adds	r6, r1, #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80005b8:	42ae      	cmp	r6, r5
 80005ba:	d3f9      	bcc.n	80005b0 <__init_ram_areas+0x80>
      *p = 0;
      p++;
    }
    rap++;
 80005bc:	2510      	movs	r5, #16
 80005be:	44ac      	add	ip, r5
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80005c0:	45c4      	cmp	ip, r8
 80005c2:	d3be      	bcc.n	8000542 <__init_ram_areas+0x12>
#endif
}
 80005c4:	bc04      	pop	{r2}
 80005c6:	4690      	mov	r8, r2
 80005c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005ca:	46c0      	nop			; (mov r8, r8)
 80005cc:	080020e0 	.word	0x080020e0

080005d0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80005d0:	e7fe      	b.n	80005d0 <__default_exit>
 80005d2:	46c0      	nop			; (mov r8, r8)
 80005d4:	46c0      	nop			; (mov r8, r8)
 80005d6:	46c0      	nop			; (mov r8, r8)
 80005d8:	46c0      	nop			; (mov r8, r8)
 80005da:	46c0      	nop			; (mov r8, r8)
 80005dc:	46c0      	nop			; (mov r8, r8)
 80005de:	46c0      	nop			; (mov r8, r8)

080005e0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80005e0:	4770      	bx	lr
 80005e2:	46c0      	nop			; (mov r8, r8)
 80005e4:	46c0      	nop			; (mov r8, r8)
 80005e6:	46c0      	nop			; (mov r8, r8)
 80005e8:	46c0      	nop			; (mov r8, r8)
 80005ea:	46c0      	nop			; (mov r8, r8)
 80005ec:	46c0      	nop			; (mov r8, r8)
 80005ee:	46c0      	nop			; (mov r8, r8)

080005f0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80005f0:	4770      	bx	lr
 80005f2:	46c0      	nop			; (mov r8, r8)
 80005f4:	46c0      	nop			; (mov r8, r8)
 80005f6:	46c0      	nop			; (mov r8, r8)
 80005f8:	46c0      	nop			; (mov r8, r8)
 80005fa:	46c0      	nop			; (mov r8, r8)
 80005fc:	46c0      	nop			; (mov r8, r8)
 80005fe:	46c0      	nop			; (mov r8, r8)

08000600 <chprintf.constprop.1>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000600:	b40e      	push	{r1, r2, r3}
 8000602:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000604:	465f      	mov	r7, fp
 8000606:	4656      	mov	r6, sl
 8000608:	464d      	mov	r5, r9
 800060a:	4644      	mov	r4, r8
 800060c:	b4f0      	push	{r4, r5, r6, r7}
 800060e:	b08a      	sub	sp, #40	; 0x28
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8000610:	466d      	mov	r5, sp
 8000612:	a907      	add	r1, sp, #28
 8000614:	351d      	adds	r5, #29
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000616:	ab14      	add	r3, sp, #80	; 0x50
 8000618:	2242      	movs	r2, #66	; 0x42
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800061a:	2000      	movs	r0, #0
 800061c:	1a6e      	subs	r6, r5, r1
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800061e:	4cc5      	ldr	r4, [pc, #788]	; (8000934 <chprintf.constprop.1+0x334>)
 8000620:	9306      	str	r3, [sp, #24]
 8000622:	1c1f      	adds	r7, r3, #0
 8000624:	4693      	mov	fp, r2
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8000626:	9003      	str	r0, [sp, #12]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8000628:	9101      	str	r1, [sp, #4]
 800062a:	9500      	str	r5, [sp, #0]
 800062c:	9605      	str	r6, [sp, #20]
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    if (c == 0)
 800062e:	465b      	mov	r3, fp
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8000630:	1c65      	adds	r5, r4, #1
    if (c == 0)
 8000632:	2b00      	cmp	r3, #0
 8000634:	d010      	beq.n	8000658 <chprintf.constprop.1+0x58>
      return n;
    if (c != '%') {
 8000636:	2b25      	cmp	r3, #37	; 0x25
 8000638:	d019      	beq.n	800066e <chprintf.constprop.1+0x6e>
      streamPut(chp, (uint8_t)c);
 800063a:	48bf      	ldr	r0, [pc, #764]	; (8000938 <chprintf.constprop.1+0x338>)
 800063c:	6801      	ldr	r1, [r0, #0]
 800063e:	688a      	ldr	r2, [r1, #8]
 8000640:	4659      	mov	r1, fp
 8000642:	4790      	blx	r2
 8000644:	7864      	ldrb	r4, [r4, #1]
      n++;
 8000646:	9803      	ldr	r0, [sp, #12]
 8000648:	46a3      	mov	fp, r4
 800064a:	3001      	adds	r0, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800064c:	1c2c      	adds	r4, r5, #0
    if (c == 0)
 800064e:	465b      	mov	r3, fp
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8000650:	9003      	str	r0, [sp, #12]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8000652:	1c65      	adds	r5, r4, #1
    if (c == 0)
 8000654:	2b00      	cmp	r3, #0
 8000656:	d1ee      	bne.n	8000636 <chprintf.constprop.1+0x36>
  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8000658:	9803      	ldr	r0, [sp, #12]
 800065a:	b00a      	add	sp, #40	; 0x28
 800065c:	bc3c      	pop	{r2, r3, r4, r5}
 800065e:	4690      	mov	r8, r2
 8000660:	4699      	mov	r9, r3
 8000662:	46a2      	mov	sl, r4
 8000664:	46ab      	mov	fp, r5
 8000666:	bcf0      	pop	{r4, r5, r6, r7}
 8000668:	bc08      	pop	{r3}
 800066a:	b003      	add	sp, #12
 800066c:	4718      	bx	r3
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800066e:	7863      	ldrb	r3, [r4, #1]
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8000670:	2000      	movs	r0, #0
 8000672:	4681      	mov	r9, r0
    if (*fmt == '-') {
 8000674:	2b2d      	cmp	r3, #45	; 0x2d
 8000676:	d100      	bne.n	800067a <chprintf.constprop.1+0x7a>
 8000678:	e154      	b.n	8000924 <chprintf.constprop.1+0x324>
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 800067a:	2120      	movs	r1, #32
 800067c:	4688      	mov	r8, r1
    if (*fmt == '0') {
 800067e:	2b30      	cmp	r3, #48	; 0x30
 8000680:	d100      	bne.n	8000684 <chprintf.constprop.1+0x84>
 8000682:	e14a      	b.n	800091a <chprintf.constprop.1+0x31a>
      fmt++;
      filler = '0';
 8000684:	1c2c      	adds	r4, r5, #0
    }
    width = 0;
 8000686:	2600      	movs	r6, #0
 8000688:	e006      	b.n	8000698 <chprintf.constprop.1+0x98>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 800068a:	7838      	ldrb	r0, [r7, #0]
 800068c:	3704      	adds	r7, #4
      else
        break;
      width = width * 10 + c;
 800068e:	00b2      	lsls	r2, r6, #2
 8000690:	1996      	adds	r6, r2, r6
 8000692:	0073      	lsls	r3, r6, #1
 8000694:	181e      	adds	r6, r3, r0
 8000696:	7823      	ldrb	r3, [r4, #0]
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8000698:	1c1a      	adds	r2, r3, #0
 800069a:	3a30      	subs	r2, #48	; 0x30
 800069c:	b2d0      	uxtb	r0, r2
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 800069e:	3401      	adds	r4, #1
      if (c >= '0' && c <= '9')
 80006a0:	2809      	cmp	r0, #9
 80006a2:	d9f4      	bls.n	800068e <chprintf.constprop.1+0x8e>
        c -= '0';
      else if (c == '*')
 80006a4:	2b2a      	cmp	r3, #42	; 0x2a
 80006a6:	d0f0      	beq.n	800068a <chprintf.constprop.1+0x8a>
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
 80006a8:	2100      	movs	r1, #0
    if (c == '.') {
 80006aa:	2b2e      	cmp	r3, #46	; 0x2e
 80006ac:	d100      	bne.n	80006b0 <chprintf.constprop.1+0xb0>
 80006ae:	e0cb      	b.n	8000848 <chprintf.constprop.1+0x248>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80006b0:	2b6c      	cmp	r3, #108	; 0x6c
 80006b2:	d100      	bne.n	80006b6 <chprintf.constprop.1+0xb6>
 80006b4:	e0d4      	b.n	8000860 <chprintf.constprop.1+0x260>
 80006b6:	2b4c      	cmp	r3, #76	; 0x4c
 80006b8:	d100      	bne.n	80006bc <chprintf.constprop.1+0xbc>
 80006ba:	e0d1      	b.n	8000860 <chprintf.constprop.1+0x260>
 80006bc:	7820      	ldrb	r0, [r4, #0]
 80006be:	4683      	mov	fp, r0
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80006c0:	1c18      	adds	r0, r3, #0
 80006c2:	3844      	subs	r0, #68	; 0x44
 80006c4:	b2c2      	uxtb	r2, r0
 80006c6:	2a34      	cmp	r2, #52	; 0x34
 80006c8:	d800      	bhi.n	80006cc <chprintf.constprop.1+0xcc>
 80006ca:	e0d6      	b.n	800087a <chprintf.constprop.1+0x27a>
 80006cc:	9905      	ldr	r1, [sp, #20]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 80006ce:	466a      	mov	r2, sp
 80006d0:	1c0d      	adds	r5, r1, #0
 80006d2:	3d01      	subs	r5, #1
 80006d4:	9504      	str	r5, [sp, #16]
 80006d6:	7713      	strb	r3, [r2, #28]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80006d8:	ad07      	add	r5, sp, #28
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 80006da:	1a76      	subs	r6, r6, r1
 80006dc:	43f3      	mvns	r3, r6
 80006de:	17d9      	asrs	r1, r3, #31
 80006e0:	400e      	ands	r6, r1
      width = 0;
    if (left_align == FALSE)
 80006e2:	4648      	mov	r0, r9
 80006e4:	9602      	str	r6, [sp, #8]
 80006e6:	2800      	cmp	r0, #0
 80006e8:	d140      	bne.n	800076c <chprintf.constprop.1+0x16c>
      width = -width;
 80006ea:	9a02      	ldr	r2, [sp, #8]
 80006ec:	4256      	negs	r6, r2
 80006ee:	9602      	str	r6, [sp, #8]
    if (width < 0) {
 80006f0:	2e00      	cmp	r6, #0
 80006f2:	d03b      	beq.n	800076c <chprintf.constprop.1+0x16c>
      if (*s == '-' && filler == '0') {
 80006f4:	782b      	ldrb	r3, [r5, #0]
 80006f6:	2b2d      	cmp	r3, #45	; 0x2d
 80006f8:	d100      	bne.n	80006fc <chprintf.constprop.1+0xfc>
 80006fa:	e121      	b.n	8000940 <chprintf.constprop.1+0x340>
 80006fc:	4e8e      	ldr	r6, [pc, #568]	; (8000938 <chprintf.constprop.1+0x338>)
 80006fe:	9a02      	ldr	r2, [sp, #8]
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000700:	6833      	ldr	r3, [r6, #0]
 8000702:	2001      	movs	r0, #1
 8000704:	4390      	bics	r0, r2
 8000706:	4641      	mov	r1, r8
 8000708:	689a      	ldr	r2, [r3, #8]
 800070a:	4682      	mov	sl, r0
 800070c:	1c30      	adds	r0, r6, #0
 800070e:	4790      	blx	r2
        n++;
      } while (++width != 0);
 8000710:	9902      	ldr	r1, [sp, #8]
 8000712:	2001      	movs	r0, #1
 8000714:	4689      	mov	r9, r1
 8000716:	4481      	add	r9, r0
 8000718:	464b      	mov	r3, r9
 800071a:	2b00      	cmp	r3, #0
 800071c:	d020      	beq.n	8000760 <chprintf.constprop.1+0x160>
 800071e:	4652      	mov	r2, sl
 8000720:	2a00      	cmp	r2, #0
 8000722:	d009      	beq.n	8000738 <chprintf.constprop.1+0x138>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000724:	6831      	ldr	r1, [r6, #0]
 8000726:	1c30      	adds	r0, r6, #0
 8000728:	688b      	ldr	r3, [r1, #8]
 800072a:	4641      	mov	r1, r8
 800072c:	4798      	blx	r3
        n++;
      } while (++width != 0);
 800072e:	2001      	movs	r0, #1
 8000730:	4481      	add	r9, r0
 8000732:	464a      	mov	r2, r9
 8000734:	2a00      	cmp	r2, #0
 8000736:	d013      	beq.n	8000760 <chprintf.constprop.1+0x160>
 8000738:	46aa      	mov	sl, r5
 800073a:	4645      	mov	r5, r8
 800073c:	46a0      	mov	r8, r4
 800073e:	464c      	mov	r4, r9
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000740:	6833      	ldr	r3, [r6, #0]
 8000742:	1c29      	adds	r1, r5, #0
 8000744:	689a      	ldr	r2, [r3, #8]
 8000746:	1c30      	adds	r0, r6, #0
 8000748:	4790      	blx	r2
 800074a:	6830      	ldr	r0, [r6, #0]
 800074c:	1c29      	adds	r1, r5, #0
 800074e:	6883      	ldr	r3, [r0, #8]
        n++;
      } while (++width != 0);
 8000750:	3402      	adds	r4, #2
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000752:	1c30      	adds	r0, r6, #0
 8000754:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8000756:	2c00      	cmp	r4, #0
 8000758:	d1f2      	bne.n	8000740 <chprintf.constprop.1+0x140>
 800075a:	4644      	mov	r4, r8
 800075c:	46a8      	mov	r8, r5
 800075e:	4655      	mov	r5, sl
 8000760:	9e03      	ldr	r6, [sp, #12]
 8000762:	9902      	ldr	r1, [sp, #8]
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000764:	2000      	movs	r0, #0
 8000766:	1a72      	subs	r2, r6, r1
 8000768:	9203      	str	r2, [sp, #12]
 800076a:	9002      	str	r0, [sp, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800076c:	9b04      	ldr	r3, [sp, #16]
 800076e:	2b00      	cmp	r3, #0
 8000770:	db31      	blt.n	80007d6 <chprintf.constprop.1+0x1d6>
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000772:	1c1e      	adds	r6, r3, #0
 8000774:	3601      	adds	r6, #1
 8000776:	1971      	adds	r1, r6, r5
 8000778:	4e6f      	ldr	r6, [pc, #444]	; (8000938 <chprintf.constprop.1+0x338>)
 800077a:	468a      	mov	sl, r1
 800077c:	43e8      	mvns	r0, r5
 800077e:	4450      	add	r0, sl
 8000780:	2201      	movs	r2, #1
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8000782:	6833      	ldr	r3, [r6, #0]
 8000784:	4002      	ands	r2, r0
 8000786:	4691      	mov	r9, r2
 8000788:	7829      	ldrb	r1, [r5, #0]
 800078a:	689a      	ldr	r2, [r3, #8]
 800078c:	3501      	adds	r5, #1
 800078e:	1c30      	adds	r0, r6, #0
 8000790:	4790      	blx	r2
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8000792:	4555      	cmp	r5, sl
 8000794:	d01a      	beq.n	80007cc <chprintf.constprop.1+0x1cc>
 8000796:	4649      	mov	r1, r9
 8000798:	2900      	cmp	r1, #0
 800079a:	d007      	beq.n	80007ac <chprintf.constprop.1+0x1ac>
      streamPut(chp, (uint8_t)*s++);
 800079c:	6830      	ldr	r0, [r6, #0]
 800079e:	7829      	ldrb	r1, [r5, #0]
 80007a0:	6883      	ldr	r3, [r0, #8]
 80007a2:	3501      	adds	r5, #1
 80007a4:	1c30      	adds	r0, r6, #0
 80007a6:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80007a8:	4555      	cmp	r5, sl
 80007aa:	d00f      	beq.n	80007cc <chprintf.constprop.1+0x1cc>
 80007ac:	46a1      	mov	r9, r4
 80007ae:	4654      	mov	r4, sl
      streamPut(chp, (uint8_t)*s++);
 80007b0:	6832      	ldr	r2, [r6, #0]
 80007b2:	7829      	ldrb	r1, [r5, #0]
 80007b4:	6893      	ldr	r3, [r2, #8]
 80007b6:	1c30      	adds	r0, r6, #0
 80007b8:	4798      	blx	r3
 80007ba:	6830      	ldr	r0, [r6, #0]
 80007bc:	7869      	ldrb	r1, [r5, #1]
 80007be:	6882      	ldr	r2, [r0, #8]
 80007c0:	3502      	adds	r5, #2
 80007c2:	1c30      	adds	r0, r6, #0
 80007c4:	4790      	blx	r2
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80007c6:	42a5      	cmp	r5, r4
 80007c8:	d1f2      	bne.n	80007b0 <chprintf.constprop.1+0x1b0>
 80007ca:	464c      	mov	r4, r9
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80007cc:	9d03      	ldr	r5, [sp, #12]
 80007ce:	9e04      	ldr	r6, [sp, #16]
 80007d0:	3501      	adds	r5, #1
 80007d2:	19a9      	adds	r1, r5, r6
 80007d4:	9103      	str	r1, [sp, #12]
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80007d6:	9b02      	ldr	r3, [sp, #8]
 80007d8:	2b00      	cmp	r3, #0
 80007da:	d100      	bne.n	80007de <chprintf.constprop.1+0x1de>
 80007dc:	e727      	b.n	800062e <chprintf.constprop.1+0x2e>
 80007de:	4d56      	ldr	r5, [pc, #344]	; (8000938 <chprintf.constprop.1+0x338>)
 80007e0:	1c1e      	adds	r6, r3, #0
 80007e2:	3e01      	subs	r6, #1
 80007e4:	2001      	movs	r0, #1
      streamPut(chp, (uint8_t)filler);
 80007e6:	682a      	ldr	r2, [r5, #0]
 80007e8:	4030      	ands	r0, r6
 80007ea:	4682      	mov	sl, r0
 80007ec:	6893      	ldr	r3, [r2, #8]
 80007ee:	1c28      	adds	r0, r5, #0
 80007f0:	4641      	mov	r1, r8
 80007f2:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80007f4:	2e00      	cmp	r6, #0
 80007f6:	d01c      	beq.n	8000832 <chprintf.constprop.1+0x232>
 80007f8:	4651      	mov	r1, sl
 80007fa:	2900      	cmp	r1, #0
 80007fc:	d008      	beq.n	8000810 <chprintf.constprop.1+0x210>
      streamPut(chp, (uint8_t)filler);
 80007fe:	682e      	ldr	r6, [r5, #0]
 8000800:	1c28      	adds	r0, r5, #0
 8000802:	68b2      	ldr	r2, [r6, #8]
 8000804:	4641      	mov	r1, r8
 8000806:	4790      	blx	r2
      n++;
      width--;
 8000808:	9e02      	ldr	r6, [sp, #8]
 800080a:	3e02      	subs	r6, #2
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800080c:	2e00      	cmp	r6, #0
 800080e:	d010      	beq.n	8000832 <chprintf.constprop.1+0x232>
 8000810:	4640      	mov	r0, r8
 8000812:	46a0      	mov	r8, r4
 8000814:	1c04      	adds	r4, r0, #0
      streamPut(chp, (uint8_t)filler);
 8000816:	682b      	ldr	r3, [r5, #0]
 8000818:	1c21      	adds	r1, r4, #0
 800081a:	689a      	ldr	r2, [r3, #8]
 800081c:	1c28      	adds	r0, r5, #0
 800081e:	4790      	blx	r2
 8000820:	6829      	ldr	r1, [r5, #0]
 8000822:	1c28      	adds	r0, r5, #0
 8000824:	688b      	ldr	r3, [r1, #8]
      n++;
      width--;
 8000826:	3e02      	subs	r6, #2
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8000828:	1c21      	adds	r1, r4, #0
 800082a:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800082c:	2e00      	cmp	r6, #0
 800082e:	d1f2      	bne.n	8000816 <chprintf.constprop.1+0x216>
 8000830:	4644      	mov	r4, r8
 8000832:	9d03      	ldr	r5, [sp, #12]
 8000834:	9e02      	ldr	r6, [sp, #8]
 8000836:	19a8      	adds	r0, r5, r6
 8000838:	9003      	str	r0, [sp, #12]
 800083a:	e6f8      	b.n	800062e <chprintf.constprop.1+0x2e>
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 800083c:	783a      	ldrb	r2, [r7, #0]
 800083e:	3704      	adds	r7, #4
        else
          break;
        precision *= 10;
 8000840:	008b      	lsls	r3, r1, #2
 8000842:	1859      	adds	r1, r3, r1
 8000844:	004d      	lsls	r5, r1, #1
        precision += c;
 8000846:	18a9      	adds	r1, r5, r2
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8000848:	7823      	ldrb	r3, [r4, #0]
 800084a:	3401      	adds	r4, #1
        if (c >= '0' && c <= '9')
 800084c:	1c18      	adds	r0, r3, #0
 800084e:	3830      	subs	r0, #48	; 0x30
 8000850:	b2c2      	uxtb	r2, r0
 8000852:	2a09      	cmp	r2, #9
 8000854:	d9f4      	bls.n	8000840 <chprintf.constprop.1+0x240>
          c -= '0';
        else if (c == '*')
 8000856:	2b2a      	cmp	r3, #42	; 0x2a
 8000858:	d0f0      	beq.n	800083c <chprintf.constprop.1+0x23c>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800085a:	2b6c      	cmp	r3, #108	; 0x6c
 800085c:	d000      	beq.n	8000860 <chprintf.constprop.1+0x260>
 800085e:	e72a      	b.n	80006b6 <chprintf.constprop.1+0xb6>
      is_long = TRUE;
      if (*fmt)
 8000860:	7822      	ldrb	r2, [r4, #0]
 8000862:	2a00      	cmp	r2, #0
 8000864:	d063      	beq.n	800092e <chprintf.constprop.1+0x32e>
 8000866:	7863      	ldrb	r3, [r4, #1]
        c = *fmt++;
 8000868:	3401      	adds	r4, #1
 800086a:	469b      	mov	fp, r3
 800086c:	1c13      	adds	r3, r2, #0
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800086e:	1c18      	adds	r0, r3, #0
 8000870:	3844      	subs	r0, #68	; 0x44
 8000872:	b2c2      	uxtb	r2, r0
 8000874:	2a34      	cmp	r2, #52	; 0x34
 8000876:	d900      	bls.n	800087a <chprintf.constprop.1+0x27a>
 8000878:	e728      	b.n	80006cc <chprintf.constprop.1+0xcc>
 800087a:	4d30      	ldr	r5, [pc, #192]	; (800093c <chprintf.constprop.1+0x33c>)
 800087c:	0090      	lsls	r0, r2, #2
 800087e:	582a      	ldr	r2, [r5, r0]
 8000880:	4697      	mov	pc, r2
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8000882:	683d      	ldr	r5, [r7, #0]
 8000884:	1d38      	adds	r0, r7, #4
 8000886:	2d00      	cmp	r5, #0
 8000888:	d075      	beq.n	8000976 <chprintf.constprop.1+0x376>
        s = "(null)";
      if (precision == 0)
 800088a:	2900      	cmp	r1, #0
 800088c:	d06a      	beq.n	8000964 <chprintf.constprop.1+0x364>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800088e:	782f      	ldrb	r7, [r5, #0]
 8000890:	2f00      	cmp	r7, #0
 8000892:	d072      	beq.n	800097a <chprintf.constprop.1+0x37a>
 8000894:	43ef      	mvns	r7, r5
 8000896:	2201      	movs	r2, #1
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000898:	1869      	adds	r1, r5, r1
 800089a:	19cb      	adds	r3, r1, r7
 800089c:	1c17      	adds	r7, r2, #0
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800089e:	786a      	ldrb	r2, [r5, #1]
 80008a0:	401f      	ands	r7, r3
 80008a2:	1c6b      	adds	r3, r5, #1
 80008a4:	2a00      	cmp	r2, #0
 80008a6:	d00e      	beq.n	80008c6 <chprintf.constprop.1+0x2c6>
 80008a8:	428b      	cmp	r3, r1
 80008aa:	d00c      	beq.n	80008c6 <chprintf.constprop.1+0x2c6>
 80008ac:	2f00      	cmp	r7, #0
 80008ae:	d002      	beq.n	80008b6 <chprintf.constprop.1+0x2b6>
 80008b0:	e005      	b.n	80008be <chprintf.constprop.1+0x2be>
 80008b2:	428b      	cmp	r3, r1
 80008b4:	d007      	beq.n	80008c6 <chprintf.constprop.1+0x2c6>
 80008b6:	3301      	adds	r3, #1
 80008b8:	781a      	ldrb	r2, [r3, #0]
 80008ba:	2a00      	cmp	r2, #0
 80008bc:	d003      	beq.n	80008c6 <chprintf.constprop.1+0x2c6>
 80008be:	3301      	adds	r3, #1
 80008c0:	781f      	ldrb	r7, [r3, #0]
 80008c2:	2f00      	cmp	r7, #0
 80008c4:	d1f5      	bne.n	80008b2 <chprintf.constprop.1+0x2b2>
 80008c6:	1b59      	subs	r1, r3, r5
 80008c8:	1e4f      	subs	r7, r1, #1
 80008ca:	9704      	str	r7, [sp, #16]
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80008cc:	1c07      	adds	r7, r0, #0
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80008ce:	2020      	movs	r0, #32
 80008d0:	4680      	mov	r8, r0
 80008d2:	e702      	b.n	80006da <chprintf.constprop.1+0xda>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 80008d4:	683d      	ldr	r5, [r7, #0]
 80008d6:	4669      	mov	r1, sp
 80008d8:	770d      	strb	r5, [r1, #28]
 80008da:	9905      	ldr	r1, [sp, #20]
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 80008dc:	2220      	movs	r2, #32
 80008de:	1c0b      	adds	r3, r1, #0
 80008e0:	3b01      	subs	r3, #1
 80008e2:	9304      	str	r3, [sp, #16]
      *p++ = va_arg(ap, int);
 80008e4:	3704      	adds	r7, #4
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 80008e6:	4690      	mov	r8, r2
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80008e8:	ad07      	add	r5, sp, #28
 80008ea:	e6f6      	b.n	80006da <chprintf.constprop.1+0xda>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80008ec:	2210      	movs	r2, #16
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 80008ee:	6839      	ldr	r1, [r7, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80008f0:	a807      	add	r0, sp, #28
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 80008f2:	3704      	adds	r7, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80008f4:	f7ff fd5c 	bl	80003b0 <long_to_string_with_divisor.8448.constprop.3.4346>
 80008f8:	9901      	ldr	r1, [sp, #4]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80008fa:	ad07      	add	r5, sp, #28
 80008fc:	1a41      	subs	r1, r0, r1
 80008fe:	1e48      	subs	r0, r1, #1
 8000900:	9004      	str	r0, [sp, #16]
 8000902:	e6ea      	b.n	80006da <chprintf.constprop.1+0xda>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8000904:	220a      	movs	r2, #10
 8000906:	e7f2      	b.n	80008ee <chprintf.constprop.1+0x2ee>
 8000908:	2208      	movs	r2, #8
 800090a:	e7f0      	b.n	80008ee <chprintf.constprop.1+0x2ee>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 800090c:	6839      	ldr	r1, [r7, #0]
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800090e:	a807      	add	r0, sp, #28
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 8000910:	3704      	adds	r7, #4
      else
        l = va_arg(ap, int);
      if (l < 0) {
 8000912:	2900      	cmp	r1, #0
 8000914:	db28      	blt.n	8000968 <chprintf.constprop.1+0x368>
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8000916:	220a      	movs	r2, #10
 8000918:	e7ec      	b.n	80008f4 <chprintf.constprop.1+0x2f4>
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
 800091a:	2630      	movs	r6, #48	; 0x30
 800091c:	786b      	ldrb	r3, [r5, #1]
 800091e:	46b0      	mov	r8, r6
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
 8000920:	3501      	adds	r5, #1
 8000922:	e6af      	b.n	8000684 <chprintf.constprop.1+0x84>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
 8000924:	1ca5      	adds	r5, r4, #2
 8000926:	78a3      	ldrb	r3, [r4, #2]
      left_align = TRUE;
 8000928:	2401      	movs	r4, #1
 800092a:	46a1      	mov	r9, r4
 800092c:	e6a5      	b.n	800067a <chprintf.constprop.1+0x7a>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
 800092e:	2500      	movs	r5, #0
 8000930:	46ab      	mov	fp, r5
 8000932:	e6c5      	b.n	80006c0 <chprintf.constprop.1+0xc0>
 8000934:	08002070 	.word	0x08002070
 8000938:	20000a00 	.word	0x20000a00
 800093c:	08001ef0 	.word	0x08001ef0
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8000940:	4641      	mov	r1, r8
 8000942:	2930      	cmp	r1, #48	; 0x30
 8000944:	d000      	beq.n	8000948 <chprintf.constprop.1+0x348>
 8000946:	e6d9      	b.n	80006fc <chprintf.constprop.1+0xfc>
        streamPut(chp, (uint8_t)*s++);
 8000948:	4e10      	ldr	r6, [pc, #64]	; (800098c <chprintf.constprop.1+0x38c>)
 800094a:	212d      	movs	r1, #45	; 0x2d
 800094c:	6830      	ldr	r0, [r6, #0]
 800094e:	3501      	adds	r5, #1
 8000950:	6882      	ldr	r2, [r0, #8]
 8000952:	1c30      	adds	r0, r6, #0
 8000954:	4790      	blx	r2
        n++;
 8000956:	9b03      	ldr	r3, [sp, #12]
 8000958:	9904      	ldr	r1, [sp, #16]
 800095a:	3301      	adds	r3, #1
 800095c:	3901      	subs	r1, #1
 800095e:	9303      	str	r3, [sp, #12]
 8000960:	9104      	str	r1, [sp, #16]
 8000962:	e6cc      	b.n	80006fe <chprintf.constprop.1+0xfe>
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
 8000964:	490a      	ldr	r1, [pc, #40]	; (8000990 <chprintf.constprop.1+0x390>)
 8000966:	e792      	b.n	800088e <chprintf.constprop.1+0x28e>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8000968:	252d      	movs	r5, #45	; 0x2d
 800096a:	466b      	mov	r3, sp
 800096c:	771d      	strb	r5, [r3, #28]
        l = -l;
 800096e:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8000970:	3001      	adds	r0, #1
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8000972:	220a      	movs	r2, #10
 8000974:	e7be      	b.n	80008f4 <chprintf.constprop.1+0x2f4>
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
 8000976:	4d07      	ldr	r5, [pc, #28]	; (8000994 <chprintf.constprop.1+0x394>)
 8000978:	e787      	b.n	800088a <chprintf.constprop.1+0x28a>
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800097a:	2301      	movs	r3, #1
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 800097c:	1c07      	adds	r7, r0, #0
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800097e:	2220      	movs	r2, #32
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8000980:	4258      	negs	r0, r3
 8000982:	9004      	str	r0, [sp, #16]
 8000984:	2100      	movs	r1, #0
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8000986:	4690      	mov	r8, r2
 8000988:	e6a7      	b.n	80006da <chprintf.constprop.1+0xda>
 800098a:	46c0      	nop			; (mov r8, r8)
 800098c:	20000a00 	.word	0x20000a00
 8000990:	00007fff 	.word	0x00007fff
 8000994:	08002080 	.word	0x08002080
 8000998:	46c0      	nop			; (mov r8, r8)
 800099a:	46c0      	nop			; (mov r8, r8)
 800099c:	46c0      	nop			; (mov r8, r8)
 800099e:	46c0      	nop			; (mov r8, r8)

080009a0 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80009a0:	4b05      	ldr	r3, [pc, #20]	; (80009b8 <chDbgCheckClassI+0x18>)
 80009a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009a4:	2a00      	cmp	r2, #0
 80009a6:	db03      	blt.n	80009b0 <chDbgCheckClassI+0x10>
 80009a8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80009aa:	2800      	cmp	r0, #0
 80009ac:	dd00      	ble.n	80009b0 <chDbgCheckClassI+0x10>
    chSysHalt("SV#10");
  }
}
 80009ae:	4770      	bx	lr
 80009b0:	b672      	cpsid	i
 80009b2:	4902      	ldr	r1, [pc, #8]	; (80009bc <chDbgCheckClassI+0x1c>)
 80009b4:	62d9      	str	r1, [r3, #44]	; 0x2c
 80009b6:	e7fe      	b.n	80009b6 <chDbgCheckClassI+0x16>
 80009b8:	20000fc0 	.word	0x20000fc0
 80009bc:	08002088 	.word	0x08002088

080009c0 <Vector7C.4296>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80009c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80009c2:	464e      	mov	r6, r9
 80009c4:	4657      	mov	r7, sl
 80009c6:	4645      	mov	r5, r8
 80009c8:	b4e0      	push	{r5, r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80009ca:	2680      	movs	r6, #128	; 0x80
 80009cc:	05f6      	lsls	r6, r6, #23
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 80009ce:	46f1      	mov	r9, lr
 80009d0:	f7ff fcae 	bl	8000330 <_dbg_check_enter_isr.4315>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80009d4:	6933      	ldr	r3, [r6, #16]
 80009d6:	079a      	lsls	r2, r3, #30
 80009d8:	d409      	bmi.n	80009ee <Vector7C.4296+0x2e>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80009da:	f7ff fcc1 	bl	8000360 <_dbg_check_leave_isr.4317>
 80009de:	4648      	mov	r0, r9
 80009e0:	f7ff fd3e 	bl	8000460 <_port_irq_epilogue.4382>
}
 80009e4:	bc1c      	pop	{r2, r3, r4}
 80009e6:	4690      	mov	r8, r2
 80009e8:	4699      	mov	r9, r3
 80009ea:	46a2      	mov	sl, r4
 80009ec:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 80009ee:	2000      	movs	r0, #0
 80009f0:	6130      	str	r0, [r6, #16]
 80009f2:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80009f4:	f7ff fc6c 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 80009f8:	f7ff ffd2 	bl	80009a0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 80009fc:	f7ff ffd0 	bl	80009a0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8000a00:	4c22      	ldr	r4, [pc, #136]	; (8000a8c <Vector7C.4296+0xcc>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000a02:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8000a04:	69e5      	ldr	r5, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000a06:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000a08:	68aa      	ldr	r2, [r5, #8]
 8000a0a:	1a5f      	subs	r7, r3, r1
 8000a0c:	4297      	cmp	r7, r2
 8000a0e:	d31d      	bcc.n	8000a4c <Vector7C.4296+0x8c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000a10:	231c      	movs	r3, #28
 8000a12:	1918      	adds	r0, r3, r4
 8000a14:	4680      	mov	r8, r0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8000a16:	2700      	movs	r7, #0
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000a18:	188a      	adds	r2, r1, r2

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000a1a:	68e8      	ldr	r0, [r5, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000a1c:	6829      	ldr	r1, [r5, #0]
 8000a1e:	4643      	mov	r3, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000a20:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000a22:	4682      	mov	sl, r0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000a24:	604b      	str	r3, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8000a26:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8000a28:	60ef      	str	r7, [r5, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000a2a:	4541      	cmp	r1, r8
 8000a2c:	d02b      	beq.n	8000a86 <Vector7C.4296+0xc6>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000a2e:	f7ff fc67 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a32:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8000a34:	6928      	ldr	r0, [r5, #16]
 8000a36:	47d0      	blx	sl
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a38:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000a3a:	f7ff fc49 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8000a3e:	69e5      	ldr	r5, [r4, #28]
 8000a40:	6a73      	ldr	r3, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000a42:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000a44:	68aa      	ldr	r2, [r5, #8]
 8000a46:	1a58      	subs	r0, r3, r1
 8000a48:	4282      	cmp	r2, r0
 8000a4a:	d9e5      	bls.n	8000a18 <Vector7C.4296+0x58>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000a4c:	4e10      	ldr	r6, [pc, #64]	; (8000a90 <Vector7C.4296+0xd0>)
 8000a4e:	42b5      	cmp	r5, r6
 8000a50:	d013      	beq.n	8000a7a <Vector7C.4296+0xba>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8000a52:	188f      	adds	r7, r1, r2
 8000a54:	1afd      	subs	r5, r7, r3
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000a56:	2d01      	cmp	r5, #1
 8000a58:	d913      	bls.n	8000a82 <Vector7C.4296+0xc2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 8000a5a:	18ee      	adds	r6, r5, r3
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000a5c:	1c30      	adds	r0, r6, #0
 8000a5e:	f7ff fc97 	bl	8000390 <stSetAlarm.4337>
 8000a62:	2380      	movs	r3, #128	; 0x80
 8000a64:	05da      	lsls	r2, r3, #23

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 8000a66:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000a68:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8000a6a:	1a75      	subs	r5, r6, r1
 8000a6c:	1a47      	subs	r7, r0, r1
 8000a6e:	42af      	cmp	r7, r5
 8000a70:	d903      	bls.n	8000a7a <Vector7C.4296+0xba>
 8000a72:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000a74:	4e07      	ldr	r6, [pc, #28]	; (8000a94 <Vector7C.4296+0xd4>)
 8000a76:	62e6      	str	r6, [r4, #44]	; 0x2c
 8000a78:	e7fe      	b.n	8000a78 <Vector7C.4296+0xb8>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000a7a:	f7ff fc41 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a7e:	b662      	cpsie	i
 8000a80:	e7ab      	b.n	80009da <Vector7C.4296+0x1a>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000a82:	2502      	movs	r5, #2
 8000a84:	e7e9      	b.n	8000a5a <Vector7C.4296+0x9a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000a86:	60f7      	str	r7, [r6, #12]
 8000a88:	e7d1      	b.n	8000a2e <Vector7C.4296+0x6e>
 8000a8a:	46c0      	nop			; (mov r8, r8)
 8000a8c:	20000fc0 	.word	0x20000fc0
 8000a90:	20000fdc 	.word	0x20000fdc
 8000a94:	08002160 	.word	0x08002160
 8000a98:	46c0      	nop			; (mov r8, r8)
 8000a9a:	46c0      	nop			; (mov r8, r8)
 8000a9c:	46c0      	nop			; (mov r8, r8)
 8000a9e:	46c0      	nop			; (mov r8, r8)

08000aa0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000aa0:	b510      	push	{r4, lr}
 8000aa2:	1c04      	adds	r4, r0, #0
  thread_t *cp;

  chDbgCheckClassI();
 8000aa4:	f7ff ff7c 	bl	80009a0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000aa8:	2c00      	cmp	r4, #0
 8000aaa:	d019      	beq.n	8000ae0 <chSchReadyI+0x40>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 8000aac:	2320      	movs	r3, #32
 8000aae:	5ce2      	ldrb	r2, [r4, r3]
 8000ab0:	2a00      	cmp	r2, #0
 8000ab2:	d010      	beq.n	8000ad6 <chSchReadyI+0x36>
 8000ab4:	2a0f      	cmp	r2, #15
 8000ab6:	d00e      	beq.n	8000ad6 <chSchReadyI+0x36>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ab8:	2000      	movs	r0, #0
 8000aba:	54e0      	strb	r0, [r4, r3]
 8000abc:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000abe:	4b0b      	ldr	r3, [pc, #44]	; (8000aec <chSchReadyI+0x4c>)
  do {
    cp = cp->p_next;
 8000ac0:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000ac2:	6899      	ldr	r1, [r3, #8]
 8000ac4:	4291      	cmp	r1, r2
 8000ac6:	d2fb      	bcs.n	8000ac0 <chSchReadyI+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000ac8:	6858      	ldr	r0, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000aca:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8000acc:	6060      	str	r0, [r4, #4]
  tp->p_prev->p_next = tp;
 8000ace:	6004      	str	r4, [r0, #0]
  cp->p_prev = tp;
 8000ad0:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000ad2:	1c20      	adds	r0, r4, #0
 8000ad4:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ad6:	b672      	cpsid	i
 8000ad8:	4c05      	ldr	r4, [pc, #20]	; (8000af0 <chSchReadyI+0x50>)
 8000ada:	4a04      	ldr	r2, [pc, #16]	; (8000aec <chSchReadyI+0x4c>)
 8000adc:	62d4      	str	r4, [r2, #44]	; 0x2c
 8000ade:	e7fe      	b.n	8000ade <chSchReadyI+0x3e>
 8000ae0:	b672      	cpsid	i
 8000ae2:	4903      	ldr	r1, [pc, #12]	; (8000af0 <chSchReadyI+0x50>)
 8000ae4:	4b01      	ldr	r3, [pc, #4]	; (8000aec <chSchReadyI+0x4c>)
 8000ae6:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000ae8:	e7fe      	b.n	8000ae8 <chSchReadyI+0x48>
 8000aea:	46c0      	nop			; (mov r8, r8)
 8000aec:	20000fc0 	.word	0x20000fc0
 8000af0:	08001ff0 	.word	0x08001ff0
 8000af4:	46c0      	nop			; (mov r8, r8)
 8000af6:	46c0      	nop			; (mov r8, r8)
 8000af8:	46c0      	nop			; (mov r8, r8)
 8000afa:	46c0      	nop			; (mov r8, r8)
 8000afc:	46c0      	nop			; (mov r8, r8)
 8000afe:	46c0      	nop			; (mov r8, r8)

08000b00 <wakeup.4792.4152>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000b00:	b538      	push	{r3, r4, r5, lr}
 8000b02:	1c04      	adds	r4, r0, #0
 8000b04:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000b06:	f7ff fbe3 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000b0a:	2320      	movs	r3, #32
 8000b0c:	5ce0      	ldrb	r0, [r4, r3]
 8000b0e:	2807      	cmp	r0, #7
 8000b10:	d80e      	bhi.n	8000b30 <wakeup.4792.4152+0x30>
 8000b12:	4a11      	ldr	r2, [pc, #68]	; (8000b58 <wakeup.4792.4152+0x58>)
 8000b14:	0081      	lsls	r1, r0, #2
 8000b16:	5855      	ldr	r5, [r2, r1]
 8000b18:	46af      	mov	pc, r5
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000b1a:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8000b1c:	f7ff ff40 	bl	80009a0 <chDbgCheckClassI>

  sp->s_cnt++;
 8000b20:	68ab      	ldr	r3, [r5, #8]
 8000b22:	3301      	adds	r3, #1
 8000b24:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000b26:	6860      	ldr	r0, [r4, #4]
 8000b28:	6821      	ldr	r1, [r4, #0]
 8000b2a:	6001      	str	r1, [r0, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000b2c:	6822      	ldr	r2, [r4, #0]
 8000b2e:	6050      	str	r0, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000b30:	2001      	movs	r0, #1
 8000b32:	4241      	negs	r1, r0
 8000b34:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000b36:	1c20      	adds	r0, r4, #0
 8000b38:	f7ff ffb2 	bl	8000aa0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000b3c:	f7ff fbe0 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b40:	b662      	cpsie	i
  chSysUnlockFromISR();
}
 8000b42:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000b44:	6a65      	ldr	r5, [r4, #36]	; 0x24
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000b46:	2001      	movs	r0, #1
 8000b48:	4241      	negs	r1, r0
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000b4a:	2300      	movs	r3, #0
 8000b4c:	602b      	str	r3, [r5, #0]
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
 8000b4e:	1c20      	adds	r0, r4, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000b50:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000b52:	f7ff ffa5 	bl	8000aa0 <chSchReadyI>
 8000b56:	e7f1      	b.n	8000b3c <wakeup.4792.4152+0x3c>
 8000b58:	08001fd0 	.word	0x08001fd0
 8000b5c:	46c0      	nop			; (mov r8, r8)
 8000b5e:	46c0      	nop			; (mov r8, r8)

08000b60 <chEvtBroadcastFlagsI.4319>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000b60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b62:	4657      	mov	r7, sl
 8000b64:	464e      	mov	r6, r9
 8000b66:	4645      	mov	r5, r8
 8000b68:	b4e0      	push	{r5, r6, r7}
 8000b6a:	1c06      	adds	r6, r0, #0
 8000b6c:	1c0f      	adds	r7, r1, #0
  event_listener_t *elp;

  chDbgCheckClassI();
 8000b6e:	f7ff ff17 	bl	80009a0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8000b72:	2e00      	cmp	r6, #0
 8000b74:	d042      	beq.n	8000bfc <chEvtBroadcastFlagsI.4319+0x9c>

  elp = esp->es_next;
 8000b76:	6834      	ldr	r4, [r6, #0]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000b78:	2120      	movs	r1, #32
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000b7a:	2200      	movs	r2, #0
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000b7c:	4689      	mov	r9, r1
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000b7e:	4690      	mov	r8, r2
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000b80:	42a6      	cmp	r6, r4
 8000b82:	d103      	bne.n	8000b8c <chEvtBroadcastFlagsI.4319+0x2c>
 8000b84:	e027      	b.n	8000bd6 <chEvtBroadcastFlagsI.4319+0x76>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8000b86:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000b88:	42a6      	cmp	r6, r4
 8000b8a:	d024      	beq.n	8000bd6 <chEvtBroadcastFlagsI.4319+0x76>
  /*lint -restore*/
    elp->el_flags |= flags;
 8000b8c:	68e3      	ldr	r3, [r4, #12]
 8000b8e:	433b      	orrs	r3, r7
 8000b90:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000b92:	2f00      	cmp	r7, #0
 8000b94:	d002      	beq.n	8000b9c <chEvtBroadcastFlagsI.4319+0x3c>
 8000b96:	6920      	ldr	r0, [r4, #16]
 8000b98:	4218      	tst	r0, r3
 8000b9a:	d0f4      	beq.n	8000b86 <chEvtBroadcastFlagsI.4319+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000b9c:	6865      	ldr	r5, [r4, #4]
 8000b9e:	68a1      	ldr	r1, [r4, #8]
 8000ba0:	468a      	mov	sl, r1
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 8000ba2:	f7ff fefd 	bl	80009a0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000ba6:	2d00      	cmp	r5, #0
 8000ba8:	d023      	beq.n	8000bf2 <chEvtBroadcastFlagsI.4319+0x92>

  tp->p_epending |= events;
 8000baa:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000bac:	4653      	mov	r3, sl
 8000bae:	4313      	orrs	r3, r2
 8000bb0:	63ab      	str	r3, [r5, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000bb2:	4648      	mov	r0, r9
 8000bb4:	5c29      	ldrb	r1, [r5, r0]
 8000bb6:	290a      	cmp	r1, #10
 8000bb8:	d012      	beq.n	8000be0 <chEvtBroadcastFlagsI.4319+0x80>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000bba:	290b      	cmp	r1, #11
 8000bbc:	d1e3      	bne.n	8000b86 <chEvtBroadcastFlagsI.4319+0x26>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000bbe:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000bc0:	4013      	ands	r3, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000bc2:	429a      	cmp	r2, r3
 8000bc4:	d1df      	bne.n	8000b86 <chEvtBroadcastFlagsI.4319+0x26>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000bc6:	4643      	mov	r3, r8
 8000bc8:	626b      	str	r3, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000bca:	1c28      	adds	r0, r5, #0
 8000bcc:	f7ff ff68 	bl	8000aa0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8000bd0:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000bd2:	42a6      	cmp	r6, r4
 8000bd4:	d1da      	bne.n	8000b8c <chEvtBroadcastFlagsI.4319+0x2c>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8000bd6:	bc1c      	pop	{r2, r3, r4}
 8000bd8:	4690      	mov	r8, r2
 8000bda:	4699      	mov	r9, r3
 8000bdc:	46a2      	mov	sl, r4
 8000bde:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000be0:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8000be2:	4218      	tst	r0, r3
 8000be4:	d0cf      	beq.n	8000b86 <chEvtBroadcastFlagsI.4319+0x26>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000be6:	4643      	mov	r3, r8
 8000be8:	626b      	str	r3, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000bea:	1c28      	adds	r0, r5, #0
 8000bec:	f7ff ff58 	bl	8000aa0 <chSchReadyI>
 8000bf0:	e7ee      	b.n	8000bd0 <chEvtBroadcastFlagsI.4319+0x70>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000bf2:	b672      	cpsid	i
 8000bf4:	4e04      	ldr	r6, [pc, #16]	; (8000c08 <chEvtBroadcastFlagsI.4319+0xa8>)
 8000bf6:	4f05      	ldr	r7, [pc, #20]	; (8000c0c <chEvtBroadcastFlagsI.4319+0xac>)
 8000bf8:	62fe      	str	r6, [r7, #44]	; 0x2c
 8000bfa:	e7fe      	b.n	8000bfa <chEvtBroadcastFlagsI.4319+0x9a>
 8000bfc:	b672      	cpsid	i
 8000bfe:	4d04      	ldr	r5, [pc, #16]	; (8000c10 <chEvtBroadcastFlagsI.4319+0xb0>)
 8000c00:	4902      	ldr	r1, [pc, #8]	; (8000c0c <chEvtBroadcastFlagsI.4319+0xac>)
 8000c02:	62cd      	str	r5, [r1, #44]	; 0x2c
 8000c04:	e7fe      	b.n	8000c04 <chEvtBroadcastFlagsI.4319+0xa4>
 8000c06:	46c0      	nop			; (mov r8, r8)
 8000c08:	080020d0 	.word	0x080020d0
 8000c0c:	20000fc0 	.word	0x20000fc0
 8000c10:	080020b0 	.word	0x080020b0
 8000c14:	46c0      	nop			; (mov r8, r8)
 8000c16:	46c0      	nop			; (mov r8, r8)
 8000c18:	46c0      	nop			; (mov r8, r8)
 8000c1a:	46c0      	nop			; (mov r8, r8)
 8000c1c:	46c0      	nop			; (mov r8, r8)
 8000c1e:	46c0      	nop			; (mov r8, r8)

08000c20 <serve_interrupt.8373.4177>:
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000c20:	23b5      	movs	r3, #181	; 0xb5
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000c22:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000c24:	1c04      	adds	r4, r0, #0
  USART_TypeDef *u = sdp->usart;
 8000c26:	0098      	lsls	r0, r3, #2
 8000c28:	5826      	ldr	r6, [r4, r0]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000c2a:	4647      	mov	r7, r8
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000c2c:	6832      	ldr	r2, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000c2e:	69f5      	ldr	r5, [r6, #28]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000c30:	b480      	push	{r7}
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000c32:	4690      	mov	r8, r2
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;
 8000c34:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000c36:	072b      	lsls	r3, r5, #28
 8000c38:	d14b      	bne.n	8000cd2 <serve_interrupt.8373.4177+0xb2>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000c3a:	05eb      	lsls	r3, r5, #23
 8000c3c:	d465      	bmi.n	8000d0a <serve_interrupt.8373.4177+0xea>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000c3e:	06aa      	lsls	r2, r5, #26
 8000c40:	d500      	bpl.n	8000c44 <serve_interrupt.8373.4177+0x24>
 8000c42:	e070      	b.n	8000d26 <serve_interrupt.8373.4177+0x106>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000c44:	2080      	movs	r0, #128	; 0x80
 8000c46:	4643      	mov	r3, r8
 8000c48:	4218      	tst	r0, r3
 8000c4a:	d001      	beq.n	8000c50 <serve_interrupt.8373.4177+0x30>
 8000c4c:	4228      	tst	r0, r5
 8000c4e:	d104      	bne.n	8000c5a <serve_interrupt.8373.4177+0x3a>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000c50:	066a      	lsls	r2, r5, #25
 8000c52:	d42c      	bmi.n	8000cae <serve_interrupt.8373.4177+0x8e>
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    osalSysUnlockFromISR();
  }
}
 8000c54:	bc04      	pop	{r2}
 8000c56:	4690      	mov	r8, r2
 8000c58:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c5a:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000c5c:	f7ff fb38 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
  uint8_t b;

  chDbgCheckClassI();
 8000c60:	f7ff fe9e 	bl	80009a0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000c64:	f7ff fe9c 	bl	80009a0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000c68:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8000c6a:	6c67      	ldr	r7, [r4, #68]	; 0x44
 8000c6c:	428f      	cmp	r7, r1
 8000c6e:	d100      	bne.n	8000c72 <serve_interrupt.8373.4177+0x52>
 8000c70:	e095      	b.n	8000d9e <serve_interrupt.8373.4177+0x17e>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000c72:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000c74:	6c23      	ldr	r3, [r4, #64]	; 0x40

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000c76:	3001      	adds	r0, #1
 8000c78:	63a0      	str	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8000c7a:	780f      	ldrb	r7, [r1, #0]
 8000c7c:	3101      	adds	r1, #1
 8000c7e:	64a1      	str	r1, [r4, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 8000c80:	4299      	cmp	r1, r3
 8000c82:	d301      	bcc.n	8000c88 <serve_interrupt.8373.4177+0x68>
    oqp->q_rdptr = oqp->q_buffer;
 8000c84:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8000c86:	64a1      	str	r1, [r4, #72]	; 0x48
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8000c88:	1c22      	adds	r2, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000c8a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8000c8c:	3230      	adds	r2, #48	; 0x30
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000c8e:	4282      	cmp	r2, r0
 8000c90:	d100      	bne.n	8000c94 <serve_interrupt.8373.4177+0x74>
 8000c92:	e0ab      	b.n	8000dec <serve_interrupt.8373.4177+0x1cc>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000c94:	6803      	ldr	r3, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8000c96:	2120      	movs	r1, #32
 8000c98:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000c9a:	605a      	str	r2, [r3, #4]
 8000c9c:	5c42      	ldrb	r2, [r0, r1]
 8000c9e:	2a04      	cmp	r2, #4
 8000ca0:	d100      	bne.n	8000ca4 <serve_interrupt.8373.4177+0x84>
 8000ca2:	e09f      	b.n	8000de4 <serve_interrupt.8373.4177+0x1c4>
 8000ca4:	b672      	cpsid	i
 8000ca6:	4852      	ldr	r0, [pc, #328]	; (8000df0 <serve_interrupt.8373.4177+0x1d0>)
 8000ca8:	4f52      	ldr	r7, [pc, #328]	; (8000df4 <serve_interrupt.8373.4177+0x1d4>)
 8000caa:	62f8      	str	r0, [r7, #44]	; 0x2c
 8000cac:	e7fe      	b.n	8000cac <serve_interrupt.8373.4177+0x8c>
 8000cae:	b672      	cpsid	i
 8000cb0:	f7ff fb0e 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000cb4:	f7ff fe74 	bl	80009a0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000cb8:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8000cba:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8000cbc:	4285      	cmp	r5, r0
 8000cbe:	d100      	bne.n	8000cc2 <serve_interrupt.8373.4177+0xa2>
 8000cc0:	e087      	b.n	8000dd2 <serve_interrupt.8373.4177+0x1b2>
  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000cc2:	2440      	movs	r4, #64	; 0x40
 8000cc4:	4641      	mov	r1, r8
 8000cc6:	43a1      	bics	r1, r4
 8000cc8:	6031      	str	r1, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000cca:	f7ff fb19 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cce:	b662      	cpsie	i
 8000cd0:	e7c0      	b.n	8000c54 <serve_interrupt.8373.4177+0x34>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 8000cd2:	072f      	lsls	r7, r5, #28
    sts |= SD_OVERRUN_ERROR;
 8000cd4:	0ff9      	lsrs	r1, r7, #31
 8000cd6:	01cf      	lsls	r7, r1, #7
  if (isr & USART_ISR_PE)
 8000cd8:	07ea      	lsls	r2, r5, #31
 8000cda:	d501      	bpl.n	8000ce0 <serve_interrupt.8373.4177+0xc0>
    sts |= SD_PARITY_ERROR;
 8000cdc:	2320      	movs	r3, #32
 8000cde:	431f      	orrs	r7, r3
  if (isr & USART_ISR_FE)
 8000ce0:	07ab      	lsls	r3, r5, #30
 8000ce2:	d501      	bpl.n	8000ce8 <serve_interrupt.8373.4177+0xc8>
    sts |= SD_FRAMING_ERROR;
 8000ce4:	2040      	movs	r0, #64	; 0x40
 8000ce6:	4307      	orrs	r7, r0
  if (isr & USART_ISR_NE)
 8000ce8:	076a      	lsls	r2, r5, #29
 8000cea:	d502      	bpl.n	8000cf2 <serve_interrupt.8373.4177+0xd2>
    sts |= SD_NOISE_ERROR;
 8000cec:	2280      	movs	r2, #128	; 0x80
 8000cee:	0051      	lsls	r1, r2, #1
 8000cf0:	430f      	orrs	r7, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cf2:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000cf4:	f7ff faec 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
  osalSysLockFromISR();
  chnAddFlagsI(sdp, sts);
 8000cf8:	1d20      	adds	r0, r4, #4
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000cfa:	1c39      	adds	r1, r7, #0
 8000cfc:	f7ff ff30 	bl	8000b60 <chEvtBroadcastFlagsI.4319>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000d00:	f7ff fafe 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d04:	b662      	cpsie	i
  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000d06:	05eb      	lsls	r3, r5, #23
 8000d08:	d599      	bpl.n	8000c3e <serve_interrupt.8373.4177+0x1e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d0a:	b672      	cpsid	i
 8000d0c:	2780      	movs	r7, #128	; 0x80
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000d0e:	f7ff fadf 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000d12:	1d20      	adds	r0, r4, #4
 8000d14:	00b9      	lsls	r1, r7, #2
 8000d16:	f7ff ff23 	bl	8000b60 <chEvtBroadcastFlagsI.4319>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000d1a:	f7ff faf1 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d1e:	b662      	cpsie	i
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000d20:	06aa      	lsls	r2, r5, #26
 8000d22:	d400      	bmi.n	8000d26 <serve_interrupt.8373.4177+0x106>
 8000d24:	e78e      	b.n	8000c44 <serve_interrupt.8373.4177+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d26:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000d28:	f7ff fad2 	bl	80002d0 <_dbg_check_lock_from_isr.4311>
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000d2c:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
 8000d2e:	b2df      	uxtb	r7, r3
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8000d30:	f7ff fe36 	bl	80009a0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000d34:	f7ff fe34 	bl	80009a0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8000d38:	6960      	ldr	r0, [r4, #20]
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000d3a:	2800      	cmp	r0, #0
 8000d3c:	d103      	bne.n	8000d46 <serve_interrupt.8373.4177+0x126>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8000d3e:	1d20      	adds	r0, r4, #4
 8000d40:	2104      	movs	r1, #4
 8000d42:	f7ff ff0d 	bl	8000b60 <chEvtBroadcastFlagsI.4319>
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();
 8000d46:	f7ff fe2b 	bl	80009a0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000d4a:	f7ff fe29 	bl	80009a0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000d4e:	6a21      	ldr	r1, [r4, #32]
 8000d50:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000d52:	4291      	cmp	r1, r2
 8000d54:	d035      	beq.n	8000dc2 <serve_interrupt.8373.4177+0x1a2>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000d56:	6960      	ldr	r0, [r4, #20]
 8000d58:	3001      	adds	r0, #1
 8000d5a:	6160      	str	r0, [r4, #20]
  *iqp->q_wrptr++ = b;
 8000d5c:	700f      	strb	r7, [r1, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000d5e:	69e7      	ldr	r7, [r4, #28]
  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
 8000d60:	3101      	adds	r1, #1
 8000d62:	6221      	str	r1, [r4, #32]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000d64:	42b9      	cmp	r1, r7
 8000d66:	d301      	bcc.n	8000d6c <serve_interrupt.8373.4177+0x14c>
    iqp->q_wrptr = iqp->q_buffer;
 8000d68:	69a1      	ldr	r1, [r4, #24]
 8000d6a:	6221      	str	r1, [r4, #32]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8000d6c:	1c22      	adds	r2, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000d6e:	68e0      	ldr	r0, [r4, #12]
 8000d70:	320c      	adds	r2, #12
 8000d72:	4282      	cmp	r2, r0
 8000d74:	d00f      	beq.n	8000d96 <serve_interrupt.8373.4177+0x176>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000d76:	6803      	ldr	r3, [r0, #0]
 8000d78:	2720      	movs	r7, #32
 8000d7a:	60e3      	str	r3, [r4, #12]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000d7c:	605a      	str	r2, [r3, #4]
 8000d7e:	5dc1      	ldrb	r1, [r0, r7]
 8000d80:	2904      	cmp	r1, #4
 8000d82:	d004      	beq.n	8000d8e <serve_interrupt.8373.4177+0x16e>
 8000d84:	b672      	cpsid	i
 8000d86:	4c1a      	ldr	r4, [pc, #104]	; (8000df0 <serve_interrupt.8373.4177+0x1d0>)
 8000d88:	4d1a      	ldr	r5, [pc, #104]	; (8000df4 <serve_interrupt.8373.4177+0x1d4>)
 8000d8a:	62ec      	str	r4, [r5, #44]	; 0x2c
 8000d8c:	e7fe      	b.n	8000d8c <serve_interrupt.8373.4177+0x16c>

  tp->p_u.rdymsg = msg;
 8000d8e:	2200      	movs	r2, #0
 8000d90:	6242      	str	r2, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000d92:	f7ff fe85 	bl	8000aa0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000d96:	f7ff fab3 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d9a:	b662      	cpsie	i
 8000d9c:	e752      	b.n	8000c44 <serve_interrupt.8373.4177+0x24>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000d9e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000da0:	2a00      	cmp	r2, #0
 8000da2:	d100      	bne.n	8000da6 <serve_interrupt.8373.4177+0x186>
 8000da4:	e765      	b.n	8000c72 <serve_interrupt.8373.4177+0x52>
 8000da6:	2108      	movs	r1, #8
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000da8:	1d20      	adds	r0, r4, #4
 8000daa:	f7ff fed9 	bl	8000b60 <chEvtBroadcastFlagsI.4319>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000dae:	21c0      	movs	r1, #192	; 0xc0
 8000db0:	4642      	mov	r2, r8
 8000db2:	438a      	bics	r2, r1
 8000db4:	2340      	movs	r3, #64	; 0x40
 8000db6:	4313      	orrs	r3, r2
 8000db8:	6033      	str	r3, [r6, #0]
 8000dba:	f7ff faa1 	bl	8000300 <_dbg_check_unlock_from_isr.4313>
 8000dbe:	b662      	cpsie	i
 8000dc0:	e746      	b.n	8000c50 <serve_interrupt.8373.4177+0x30>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000dc2:	6963      	ldr	r3, [r4, #20]
 8000dc4:	2b00      	cmp	r3, #0
 8000dc6:	d0c6      	beq.n	8000d56 <serve_interrupt.8373.4177+0x136>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8000dc8:	1d20      	adds	r0, r4, #4
 8000dca:	2180      	movs	r1, #128	; 0x80
 8000dcc:	f7ff fec8 	bl	8000b60 <chEvtBroadcastFlagsI.4319>
 8000dd0:	e7e1      	b.n	8000d96 <serve_interrupt.8373.4177+0x176>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000dd2:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8000dd4:	2f00      	cmp	r7, #0
 8000dd6:	d100      	bne.n	8000dda <serve_interrupt.8373.4177+0x1ba>
 8000dd8:	e773      	b.n	8000cc2 <serve_interrupt.8373.4177+0xa2>

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000dda:	1d20      	adds	r0, r4, #4
 8000ddc:	2110      	movs	r1, #16
 8000dde:	f7ff febf 	bl	8000b60 <chEvtBroadcastFlagsI.4319>
 8000de2:	e76e      	b.n	8000cc2 <serve_interrupt.8373.4177+0xa2>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000de4:	2300      	movs	r3, #0
 8000de6:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000de8:	f7ff fe5a 	bl	8000aa0 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8000dec:	8537      	strh	r7, [r6, #40]	; 0x28
 8000dee:	e7e4      	b.n	8000dba <serve_interrupt.8373.4177+0x19a>
 8000df0:	08002000 	.word	0x08002000
 8000df4:	20000fc0 	.word	0x20000fc0
 8000df8:	46c0      	nop			; (mov r8, r8)
 8000dfa:	46c0      	nop			; (mov r8, r8)
 8000dfc:	46c0      	nop			; (mov r8, r8)
 8000dfe:	46c0      	nop			; (mov r8, r8)

08000e00 <VectorB0.4172>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000e00:	b510      	push	{r4, lr}
 8000e02:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000e04:	f7ff fa94 	bl	8000330 <_dbg_check_enter_isr.4315>

  serve_interrupt(&SD2);
 8000e08:	4804      	ldr	r0, [pc, #16]	; (8000e1c <VectorB0.4172+0x1c>)
 8000e0a:	f7ff ff09 	bl	8000c20 <serve_interrupt.8373.4177>

  OSAL_IRQ_EPILOGUE();
 8000e0e:	f7ff faa7 	bl	8000360 <_dbg_check_leave_isr.4317>
 8000e12:	1c20      	adds	r0, r4, #0
 8000e14:	f7ff fb24 	bl	8000460 <_port_irq_epilogue.4382>
}
 8000e18:	bd10      	pop	{r4, pc}
 8000e1a:	46c0      	nop			; (mov r8, r8)
 8000e1c:	20000cdc 	.word	0x20000cdc

08000e20 <VectorAC.4175>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000e20:	b510      	push	{r4, lr}
 8000e22:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000e24:	f7ff fa84 	bl	8000330 <_dbg_check_enter_isr.4315>

  serve_interrupt(&SD1);
 8000e28:	4804      	ldr	r0, [pc, #16]	; (8000e3c <VectorAC.4175+0x1c>)
 8000e2a:	f7ff fef9 	bl	8000c20 <serve_interrupt.8373.4177>

  OSAL_IRQ_EPILOGUE();
 8000e2e:	f7ff fa97 	bl	8000360 <_dbg_check_leave_isr.4317>
 8000e32:	1c20      	adds	r0, r4, #0
 8000e34:	f7ff fb14 	bl	8000460 <_port_irq_epilogue.4382>
}
 8000e38:	bd10      	pop	{r4, pc}
 8000e3a:	46c0      	nop			; (mov r8, r8)
 8000e3c:	20000a00 	.word	0x20000a00

08000e40 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000e40:	4b05      	ldr	r3, [pc, #20]	; (8000e58 <chDbgCheckClassS+0x18>)
 8000e42:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000e44:	2a00      	cmp	r2, #0
 8000e46:	d103      	bne.n	8000e50 <chDbgCheckClassS+0x10>
 8000e48:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8000e4a:	2800      	cmp	r0, #0
 8000e4c:	dd00      	ble.n	8000e50 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 8000e4e:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e50:	b672      	cpsid	i
 8000e52:	4902      	ldr	r1, [pc, #8]	; (8000e5c <chDbgCheckClassS+0x1c>)
 8000e54:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000e56:	e7fe      	b.n	8000e56 <chDbgCheckClassS+0x16>
 8000e58:	20000fc0 	.word	0x20000fc0
 8000e5c:	08002090 	.word	0x08002090

08000e60 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000e60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e62:	465f      	mov	r7, fp
 8000e64:	4656      	mov	r6, sl
 8000e66:	464d      	mov	r5, r9
 8000e68:	4644      	mov	r4, r8
 8000e6a:	b4f0      	push	{r4, r5, r6, r7}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000e6c:	2403      	movs	r4, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000e6e:	0757      	lsls	r7, r2, #29
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000e70:	06d6      	lsls	r6, r2, #27
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8000e72:	0655      	lsls	r5, r2, #25
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000e74:	4014      	ands	r4, r2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000e76:	0552      	lsls	r2, r2, #21
 8000e78:	0f13      	lsrs	r3, r2, #28
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000e7a:	b083      	sub	sp, #12

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8000e7c:	0fad      	lsrs	r5, r5, #30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8000e7e:	2201      	movs	r2, #1

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000e80:	469b      	mov	fp, r3
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000e82:	0fff      	lsrs	r7, r7, #31
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000e84:	0fb6      	lsrs	r6, r6, #30
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000e86:	2300      	movs	r3, #0
  while (true) {
    if ((mask & 1) != 0) {
 8000e88:	4694      	mov	ip, r2
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000e8a:	9500      	str	r5, [sp, #0]
 8000e8c:	e00e      	b.n	8000eac <_pal_lld_setgroupmode+0x4c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000e8e:	6a02      	ldr	r2, [r0, #32]
 8000e90:	464d      	mov	r5, r9
 8000e92:	43aa      	bics	r2, r5
 8000e94:	4645      	mov	r5, r8
 8000e96:	432a      	orrs	r2, r5
 8000e98:	6202      	str	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 8000e9a:	0849      	lsrs	r1, r1, #1
    if (!mask)
 8000e9c:	d03d      	beq.n	8000f1a <_pal_lld_setgroupmode+0xba>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
 8000e9e:	9a00      	ldr	r2, [sp, #0]
      }
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
 8000ea0:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
    pupdr <<= 2;
 8000ea2:	0095      	lsls	r5, r2, #2
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8000ea4:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8000ea6:	9500      	str	r5, [sp, #0]
    moder <<= 2;
 8000ea8:	00a4      	lsls	r4, r4, #2
    bit++;
 8000eaa:	3301      	adds	r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8000eac:	4665      	mov	r5, ip
 8000eae:	420d      	tst	r5, r1
 8000eb0:	d0f3      	beq.n	8000e9a <_pal_lld_setgroupmode+0x3a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000eb2:	2207      	movs	r2, #7
 8000eb4:	401a      	ands	r2, r3
 8000eb6:	0095      	lsls	r5, r2, #2
 8000eb8:	465a      	mov	r2, fp
 8000eba:	40aa      	lsls	r2, r5
 8000ebc:	4690      	mov	r8, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000ebe:	220f      	movs	r2, #15
 8000ec0:	40aa      	lsls	r2, r5
 8000ec2:	4691      	mov	r9, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000ec4:	6845      	ldr	r5, [r0, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8000ec6:	4662      	mov	r2, ip
 8000ec8:	409a      	lsls	r2, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000eca:	4395      	bics	r5, r2
 8000ecc:	433d      	orrs	r5, r7
 8000ece:	6045      	str	r5, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000ed0:	6882      	ldr	r2, [r0, #8]
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8000ed2:	005d      	lsls	r5, r3, #1
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000ed4:	4692      	mov	sl, r2
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000ed6:	2203      	movs	r2, #3
 8000ed8:	40aa      	lsls	r2, r5
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000eda:	43d5      	mvns	r5, r2
 8000edc:	4652      	mov	r2, sl
 8000ede:	402a      	ands	r2, r5
 8000ee0:	4332      	orrs	r2, r6
 8000ee2:	6082      	str	r2, [r0, #8]
 8000ee4:	9501      	str	r5, [sp, #4]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000ee6:	68c5      	ldr	r5, [r0, #12]
 8000ee8:	1c2a      	adds	r2, r5, #0
 8000eea:	9d01      	ldr	r5, [sp, #4]
 8000eec:	402a      	ands	r2, r5
 8000eee:	9d00      	ldr	r5, [sp, #0]
 8000ef0:	432a      	orrs	r2, r5
 8000ef2:	60c2      	str	r2, [r0, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8000ef4:	2c02      	cmp	r4, #2
 8000ef6:	d017      	beq.n	8000f28 <_pal_lld_setgroupmode+0xc8>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8000ef8:	6802      	ldr	r2, [r0, #0]
 8000efa:	4692      	mov	sl, r2
 8000efc:	9a01      	ldr	r2, [sp, #4]
 8000efe:	4655      	mov	r5, sl
 8000f00:	402a      	ands	r2, r5
 8000f02:	4322      	orrs	r2, r4
 8000f04:	6002      	str	r2, [r0, #0]
        if (bit < 8)
 8000f06:	2b07      	cmp	r3, #7
 8000f08:	d9c1      	bls.n	8000e8e <_pal_lld_setgroupmode+0x2e>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000f0a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000f0c:	464d      	mov	r5, r9
 8000f0e:	43aa      	bics	r2, r5
 8000f10:	4645      	mov	r5, r8
 8000f12:	432a      	orrs	r2, r5
 8000f14:	6242      	str	r2, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
 8000f16:	0849      	lsrs	r1, r1, #1
    if (!mask)
 8000f18:	d1c1      	bne.n	8000e9e <_pal_lld_setgroupmode+0x3e>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8000f1a:	b003      	add	sp, #12
 8000f1c:	bc3c      	pop	{r2, r3, r4, r5}
 8000f1e:	4690      	mov	r8, r2
 8000f20:	4699      	mov	r9, r3
 8000f22:	46a2      	mov	sl, r4
 8000f24:	46ab      	mov	fp, r5
 8000f26:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8000f28:	2b07      	cmp	r3, #7
 8000f2a:	d80d      	bhi.n	8000f48 <_pal_lld_setgroupmode+0xe8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000f2c:	6a02      	ldr	r2, [r0, #32]
 8000f2e:	1c15      	adds	r5, r2, #0
 8000f30:	464a      	mov	r2, r9
 8000f32:	4395      	bics	r5, r2
 8000f34:	4642      	mov	r2, r8
 8000f36:	4315      	orrs	r5, r2
 8000f38:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000f3a:	6805      	ldr	r5, [r0, #0]
 8000f3c:	9a01      	ldr	r2, [sp, #4]
 8000f3e:	402a      	ands	r2, r5
 8000f40:	2502      	movs	r5, #2
 8000f42:	432a      	orrs	r2, r5
 8000f44:	6002      	str	r2, [r0, #0]
 8000f46:	e7a8      	b.n	8000e9a <_pal_lld_setgroupmode+0x3a>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000f48:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000f4a:	464d      	mov	r5, r9
 8000f4c:	43aa      	bics	r2, r5
 8000f4e:	4645      	mov	r5, r8
 8000f50:	432a      	orrs	r2, r5
 8000f52:	6242      	str	r2, [r0, #36]	; 0x24
 8000f54:	e7f1      	b.n	8000f3a <_pal_lld_setgroupmode+0xda>
 8000f56:	46c0      	nop			; (mov r8, r8)
 8000f58:	46c0      	nop			; (mov r8, r8)
 8000f5a:	46c0      	nop			; (mov r8, r8)
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46c0      	nop			; (mov r8, r8)

08000f60 <_dbg_trace>:
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8000f60:	4a0b      	ldr	r2, [pc, #44]	; (8000f90 <_dbg_trace+0x30>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000f62:	2180      	movs	r1, #128	; 0x80
 8000f64:	05c9      	lsls	r1, r1, #23
 8000f66:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000f68:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8000f6a:	6019      	str	r1, [r3, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 8000f6c:	6991      	ldr	r1, [r2, #24]
 8000f6e:	6059      	str	r1, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8000f70:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000f72:	6099      	str	r1, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000f74:	2120      	movs	r1, #32
 8000f76:	5c40      	ldrb	r0, [r0, r1]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8000f78:	2188      	movs	r1, #136	; 0x88
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000f7a:	7318      	strb	r0, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8000f7c:	00c8      	lsls	r0, r1, #3
 8000f7e:	3310      	adds	r3, #16
 8000f80:	1811      	adds	r1, r2, r0
 8000f82:	428b      	cmp	r3, r1
 8000f84:	d301      	bcc.n	8000f8a <_dbg_trace+0x2a>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8000f86:	1c13      	adds	r3, r2, #0
 8000f88:	3340      	adds	r3, #64	; 0x40
 8000f8a:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8000f8c:	4770      	bx	lr
 8000f8e:	46c0      	nop			; (mov r8, r8)
 8000f90:	20000fc0 	.word	0x20000fc0
 8000f94:	46c0      	nop			; (mov r8, r8)
 8000f96:	46c0      	nop			; (mov r8, r8)
 8000f98:	46c0      	nop			; (mov r8, r8)
 8000f9a:	46c0      	nop			; (mov r8, r8)
 8000f9c:	46c0      	nop			; (mov r8, r8)
 8000f9e:	46c0      	nop			; (mov r8, r8)

08000fa0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000fa0:	b570      	push	{r4, r5, r6, lr}
 8000fa2:	1c06      	adds	r6, r0, #0
  thread_t *otp;

  chDbgCheckClassS();
 8000fa4:	f7ff ff4c 	bl	8000e40 <chDbgCheckClassS>

  otp = currp;
 8000fa8:	4c0e      	ldr	r4, [pc, #56]	; (8000fe4 <chSchGoSleepS+0x44>)
  otp->p_state = newstate;
 8000faa:	2220      	movs	r2, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000fac:	6823      	ldr	r3, [r4, #0]
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000fae:	69a5      	ldr	r5, [r4, #24]

  tqp->p_next = tp->p_next;
 8000fb0:	6819      	ldr	r1, [r3, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000fb2:	2001      	movs	r0, #1
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 8000fb4:	54ae      	strb	r6, [r5, r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000fb6:	604c      	str	r4, [r1, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000fb8:	5498      	strb	r0, [r3, r2]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000fba:	6021      	str	r1, [r4, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000fbc:	61a3      	str	r3, [r4, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000fbe:	1c28      	adds	r0, r5, #0
 8000fc0:	f7ff ffce 	bl	8000f60 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000fc4:	f3ef 8609 	mrs	r6, PSP
 8000fc8:	69ea      	ldr	r2, [r5, #28]
 8000fca:	3e24      	subs	r6, #36	; 0x24
 8000fcc:	42b2      	cmp	r2, r6
 8000fce:	d804      	bhi.n	8000fda <chSchGoSleepS+0x3a>
 8000fd0:	1c29      	adds	r1, r5, #0
 8000fd2:	69a0      	ldr	r0, [r4, #24]
 8000fd4:	f7ff f8fc 	bl	80001d0 <_port_switch>
}
 8000fd8:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fda:	b672      	cpsid	i
 8000fdc:	4d02      	ldr	r5, [pc, #8]	; (8000fe8 <chSchGoSleepS+0x48>)
 8000fde:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000fe0:	e7fe      	b.n	8000fe0 <chSchGoSleepS+0x40>
 8000fe2:	46c0      	nop			; (mov r8, r8)
 8000fe4:	20000fc0 	.word	0x20000fc0
 8000fe8:	08002098 	.word	0x08002098
 8000fec:	46c0      	nop			; (mov r8, r8)
 8000fee:	46c0      	nop			; (mov r8, r8)

08000ff0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ff2:	4647      	mov	r7, r8
 8000ff4:	b480      	push	{r7}
 8000ff6:	1c0e      	adds	r6, r1, #0
 8000ff8:	b086      	sub	sp, #24
 8000ffa:	1c07      	adds	r7, r0, #0

  chDbgCheckClassS();
 8000ffc:	f7ff ff20 	bl	8000e40 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8001000:	1c71      	adds	r1, r6, #1
 8001002:	d053      	beq.n	80010ac <chSchGoSleepTimeoutS+0xbc>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001004:	4d4c      	ldr	r5, [pc, #304]	; (8001138 <chSchGoSleepTimeoutS+0x148>)
 8001006:	69aa      	ldr	r2, [r5, #24]
 8001008:	4690      	mov	r8, r2
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800100a:	f7ff fcc9 	bl	80009a0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800100e:	2e00      	cmp	r6, #0
 8001010:	d103      	bne.n	800101a <chSchGoSleepTimeoutS+0x2a>
 8001012:	b672      	cpsid	i
 8001014:	4b49      	ldr	r3, [pc, #292]	; (800113c <chSchGoSleepTimeoutS+0x14c>)
 8001016:	62eb      	str	r3, [r5, #44]	; 0x2c
 8001018:	e7fe      	b.n	8001018 <chSchGoSleepTimeoutS+0x28>

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800101a:	4849      	ldr	r0, [pc, #292]	; (8001140 <chSchGoSleepTimeoutS+0x150>)
 800101c:	2180      	movs	r1, #128	; 0x80
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800101e:	ac01      	add	r4, sp, #4
 8001020:	4643      	mov	r3, r8
 8001022:	05ca      	lsls	r2, r1, #23
  vtp->vt_func = vtfunc;
 8001024:	60e0      	str	r0, [r4, #12]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001026:	6123      	str	r3, [r4, #16]
 8001028:	6a50      	ldr	r0, [r2, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800102a:	2e01      	cmp	r6, #1
 800102c:	d943      	bls.n	80010b6 <chSchGoSleepTimeoutS+0xc6>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800102e:	1c29      	adds	r1, r5, #0
 8001030:	69eb      	ldr	r3, [r5, #28]
 8001032:	311c      	adds	r1, #28
 8001034:	428b      	cmp	r3, r1
 8001036:	d044      	beq.n	80010c2 <chSchGoSleepTimeoutS+0xd2>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001038:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800103a:	6899      	ldr	r1, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800103c:	1830      	adds	r0, r6, r0
 800103e:	1a86      	subs	r6, r0, r2
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001040:	428e      	cmp	r6, r1
 8001042:	d203      	bcs.n	800104c <chSchGoSleepTimeoutS+0x5c>
 8001044:	e06e      	b.n	8001124 <chSchGoSleepTimeoutS+0x134>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
    p = p->vt_next;
 8001046:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001048:	1a76      	subs	r6, r6, r1
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800104a:	6899      	ldr	r1, [r3, #8]
 800104c:	42b1      	cmp	r1, r6
 800104e:	d3fa      	bcc.n	8001046 <chSchGoSleepTimeoutS+0x56>
  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
  vtp->vt_delta = delta
 8001050:	60a6      	str	r6, [r4, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001052:	6899      	ldr	r1, [r3, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001054:	6858      	ldr	r0, [r3, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001056:	1b8e      	subs	r6, r1, r6
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001058:	9301      	str	r3, [sp, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800105a:	609e      	str	r6, [r3, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800105c:	6060      	str	r0, [r4, #4]
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
 800105e:	605c      	str	r4, [r3, #4]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001060:	2301      	movs	r3, #1
 8001062:	425a      	negs	r2, r3
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8001064:	6004      	str	r4, [r0, #0]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001066:	626a      	str	r2, [r5, #36]	; 0x24
    chSchGoSleepS(newstate);
 8001068:	1c38      	adds	r0, r7, #0
 800106a:	f7ff ff99 	bl	8000fa0 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800106e:	f7ff fc97 	bl	80009a0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8001072:	68e7      	ldr	r7, [r4, #12]
 8001074:	2f00      	cmp	r7, #0
 8001076:	d013      	beq.n	80010a0 <chSchGoSleepTimeoutS+0xb0>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8001078:	f7ff fc92 	bl	80009a0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 800107c:	69ea      	ldr	r2, [r5, #28]
 800107e:	42a2      	cmp	r2, r4
 8001080:	d030      	beq.n	80010e4 <chSchGoSleepTimeoutS+0xf4>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001082:	6860      	ldr	r0, [r4, #4]
 8001084:	6826      	ldr	r6, [r4, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001086:	1c2f      	adds	r7, r5, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001088:	6006      	str	r6, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800108a:	6823      	ldr	r3, [r4, #0]
    vtp->vt_func = NULL;
 800108c:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800108e:	371c      	adds	r7, #28
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001090:	6058      	str	r0, [r3, #4]
    vtp->vt_func = NULL;
 8001092:	60e1      	str	r1, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001094:	42bb      	cmp	r3, r7
 8001096:	d003      	beq.n	80010a0 <chSchGoSleepTimeoutS+0xb0>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8001098:	68a4      	ldr	r4, [r4, #8]
 800109a:	689a      	ldr	r2, [r3, #8]
 800109c:	1910      	adds	r0, r2, r4
 800109e:	6098      	str	r0, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80010a0:	69ad      	ldr	r5, [r5, #24]
 80010a2:	6a68      	ldr	r0, [r5, #36]	; 0x24
}
 80010a4:	b006      	add	sp, #24
 80010a6:	bc04      	pop	{r2}
 80010a8:	4690      	mov	r8, r2
 80010aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80010ac:	1c38      	adds	r0, r7, #0
 80010ae:	f7ff ff77 	bl	8000fa0 <chSchGoSleepS>
 80010b2:	4d21      	ldr	r5, [pc, #132]	; (8001138 <chSchGoSleepTimeoutS+0x148>)
 80010b4:	e7f4      	b.n	80010a0 <chSchGoSleepTimeoutS+0xb0>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80010b6:	1c29      	adds	r1, r5, #0
 80010b8:	69eb      	ldr	r3, [r5, #28]
 80010ba:	311c      	adds	r1, #28
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80010bc:	2602      	movs	r6, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80010be:	428b      	cmp	r3, r1
 80010c0:	d1ba      	bne.n	8001038 <chSchGoSleepTimeoutS+0x48>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 80010c2:	62a8      	str	r0, [r5, #40]	; 0x28
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 80010c4:	1832      	adds	r2, r6, r0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80010c6:	2080      	movs	r0, #128	; 0x80
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;
 80010c8:	60a6      	str	r6, [r4, #8]
 80010ca:	05c6      	lsls	r6, r0, #23
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 80010cc:	9301      	str	r3, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80010ce:	6063      	str	r3, [r4, #4]
 80010d0:	68f3      	ldr	r3, [r6, #12]
 80010d2:	2102      	movs	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 80010d4:	61ec      	str	r4, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 80010d6:	622c      	str	r4, [r5, #32]
 80010d8:	400b      	ands	r3, r1
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80010da:	d128      	bne.n	800112e <chSchGoSleepTimeoutS+0x13e>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80010dc:	6372      	str	r2, [r6, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80010de:	6133      	str	r3, [r6, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80010e0:	60f1      	str	r1, [r6, #12]
 80010e2:	e7c1      	b.n	8001068 <chSchGoSleepTimeoutS+0x78>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80010e4:	6820      	ldr	r0, [r4, #0]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80010e6:	1c2e      	adds	r6, r5, #0
 80010e8:	361c      	adds	r6, #28
  vtp->vt_func = NULL;
 80010ea:	2100      	movs	r1, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80010ec:	61e8      	str	r0, [r5, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80010ee:	60e1      	str	r1, [r4, #12]
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80010f0:	6046      	str	r6, [r0, #4]
  vtp->vt_func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80010f2:	42b0      	cmp	r0, r6
 80010f4:	d012      	beq.n	800111c <chSchGoSleepTimeoutS+0x12c>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80010f6:	68a4      	ldr	r4, [r4, #8]
 80010f8:	6883      	ldr	r3, [r0, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80010fa:	2280      	movs	r2, #128	; 0x80
 80010fc:	18e7      	adds	r7, r4, r3
 80010fe:	6087      	str	r7, [r0, #8]
 8001100:	05d0      	lsls	r0, r2, #23
 8001102:	6a46      	ldr	r6, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8001104:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001106:	1a74      	subs	r4, r6, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8001108:	42a7      	cmp	r7, r4
 800110a:	d9c9      	bls.n	80010a0 <chSchGoSleepTimeoutS+0xb0>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 800110c:	1b3b      	subs	r3, r7, r4

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800110e:	2b01      	cmp	r3, #1
 8001110:	d800      	bhi.n	8001114 <chSchGoSleepTimeoutS+0x124>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001112:	2302      	movs	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8001114:	1998      	adds	r0, r3, r6
 8001116:	f7ff f93b 	bl	8000390 <stSetAlarm.4337>
 800111a:	e7c1      	b.n	80010a0 <chSchGoSleepTimeoutS+0xb0>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800111c:	2780      	movs	r7, #128	; 0x80
 800111e:	05fa      	lsls	r2, r7, #23
 8001120:	60d1      	str	r1, [r2, #12]
 8001122:	e7bd      	b.n	80010a0 <chSchGoSleepTimeoutS+0xb0>
 8001124:	f7ff f934 	bl	8000390 <stSetAlarm.4337>
 8001128:	69eb      	ldr	r3, [r5, #28]
 800112a:	6899      	ldr	r1, [r3, #8]
 800112c:	e78e      	b.n	800104c <chSchGoSleepTimeoutS+0x5c>
 800112e:	b672      	cpsid	i
 8001130:	4e04      	ldr	r6, [pc, #16]	; (8001144 <chSchGoSleepTimeoutS+0x154>)
 8001132:	62ee      	str	r6, [r5, #44]	; 0x2c
 8001134:	e7fe      	b.n	8001134 <chSchGoSleepTimeoutS+0x144>
 8001136:	46c0      	nop			; (mov r8, r8)
 8001138:	20000fc0 	.word	0x20000fc0
 800113c:	08002030 	.word	0x08002030
 8001140:	08000b01 	.word	0x08000b01
 8001144:	08002170 	.word	0x08002170
 8001148:	46c0      	nop			; (mov r8, r8)
 800114a:	46c0      	nop			; (mov r8, r8)
 800114c:	46c0      	nop			; (mov r8, r8)
 800114e:	46c0      	nop			; (mov r8, r8)

08001150 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001150:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8001152:	2900      	cmp	r1, #0
 8001154:	d00a      	beq.n	800116c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001156:	4b07      	ldr	r3, [pc, #28]	; (8001174 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001158:	6842      	ldr	r2, [r0, #4]
 800115a:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800115c:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800115e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001160:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8001162:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001164:	2004      	movs	r0, #4
 8001166:	f7ff ff43 	bl	8000ff0 <chSchGoSleepTimeoutS>
}
 800116a:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 800116c:	2001      	movs	r0, #1
 800116e:	4240      	negs	r0, r0
 8001170:	e7fb      	b.n	800116a <chThdEnqueueTimeoutS+0x1a>
 8001172:	46c0      	nop			; (mov r8, r8)
 8001174:	20000fc0 	.word	0x20000fc0
 8001178:	46c0      	nop			; (mov r8, r8)
 800117a:	46c0      	nop			; (mov r8, r8)
 800117c:	46c0      	nop			; (mov r8, r8)
 800117e:	46c0      	nop			; (mov r8, r8)

08001180 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001180:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001182:	464e      	mov	r6, r9
 8001184:	4645      	mov	r5, r8
 8001186:	4657      	mov	r7, sl
 8001188:	b4e0      	push	{r5, r6, r7}
 800118a:	1c15      	adds	r5, r2, #0
  qnotify_t nfy = iqp->q_notify;
 800118c:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800118e:	1c04      	adds	r4, r0, #0
 8001190:	1c0e      	adds	r6, r1, #0
 8001192:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8001194:	4690      	mov	r8, r2
 8001196:	b672      	cpsid	i
  size_t r = 0;

  chDbgCheck(n > 0U);
 8001198:	2d00      	cmp	r5, #0
 800119a:	d04b      	beq.n	8001234 <chIQReadTimeout+0xb4>
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
 800119c:	3d01      	subs	r5, #1
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800119e:	f7ff f9af 	bl	8000500 <_dbg_check_lock>
 80011a2:	19a8      	adds	r0, r5, r6
 80011a4:	4d27      	ldr	r5, [pc, #156]	; (8001244 <chIQReadTimeout+0xc4>)
 80011a6:	4682      	mov	sl, r0
                       size_t n, systime_t timeout) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 80011a8:	2700      	movs	r7, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 80011aa:	4643      	mov	r3, r8
 80011ac:	2b00      	cmp	r3, #0
 80011ae:	d001      	beq.n	80011b4 <chIQReadTimeout+0x34>
      nfy(iqp);
 80011b0:	1c20      	adds	r0, r4, #0
 80011b2:	47c0      	blx	r8
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80011b4:	f7ff fbf4 	bl	80009a0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 80011b8:	68a1      	ldr	r1, [r4, #8]
    }

    while (chIQIsEmptyI(iqp)) {
 80011ba:	2900      	cmp	r1, #0
 80011bc:	d11a      	bne.n	80011f4 <chIQReadTimeout+0x74>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 80011be:	1c20      	adds	r0, r4, #0
 80011c0:	4649      	mov	r1, r9
 80011c2:	f7ff ffc5 	bl	8001150 <chThdEnqueueTimeoutS>
 80011c6:	2800      	cmp	r0, #0
 80011c8:	d0f4      	beq.n	80011b4 <chIQReadTimeout+0x34>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80011ca:	f7ff f981 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80011ce:	6828      	ldr	r0, [r5, #0]
 80011d0:	42a8      	cmp	r0, r5
 80011d2:	d004      	beq.n	80011de <chIQReadTimeout+0x5e>
 80011d4:	69ab      	ldr	r3, [r5, #24]
 80011d6:	6882      	ldr	r2, [r0, #8]
 80011d8:	6899      	ldr	r1, [r3, #8]
 80011da:	4291      	cmp	r1, r2
 80011dc:	d306      	bcc.n	80011ec <chIQReadTimeout+0x6c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011de:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 80011e0:	1c38      	adds	r0, r7, #0
 80011e2:	bc1c      	pop	{r2, r3, r4}
 80011e4:	4690      	mov	r8, r2
 80011e6:	4699      	mov	r9, r3
 80011e8:	46a2      	mov	sl, r4
 80011ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011ec:	b672      	cpsid	i
 80011ee:	4c16      	ldr	r4, [pc, #88]	; (8001248 <chIQReadTimeout+0xc8>)
 80011f0:	62ec      	str	r4, [r5, #44]	; 0x2c
 80011f2:	e7fe      	b.n	80011f2 <chIQReadTimeout+0x72>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80011f4:	68a2      	ldr	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80011f6:	69a0      	ldr	r0, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80011f8:	3a01      	subs	r2, #1
 80011fa:	60a2      	str	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80011fc:	7803      	ldrb	r3, [r0, #0]
 80011fe:	3001      	adds	r0, #1
 8001200:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001202:	6921      	ldr	r1, [r4, #16]
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001204:	61a0      	str	r0, [r4, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001206:	4288      	cmp	r0, r1
 8001208:	d301      	bcc.n	800120e <chIQReadTimeout+0x8e>
      iqp->q_rdptr = iqp->q_buffer;
 800120a:	68e2      	ldr	r2, [r4, #12]
 800120c:	61a2      	str	r2, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800120e:	f7ff f95f 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001212:	6828      	ldr	r0, [r5, #0]
 8001214:	42a8      	cmp	r0, r5
 8001216:	d004      	beq.n	8001222 <chIQReadTimeout+0xa2>
 8001218:	69ab      	ldr	r3, [r5, #24]
 800121a:	6882      	ldr	r2, [r0, #8]
 800121c:	6899      	ldr	r1, [r3, #8]
 800121e:	4291      	cmp	r1, r2
 8001220:	d30c      	bcc.n	800123c <chIQReadTimeout+0xbc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001222:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8001224:	3701      	adds	r7, #1
    if (--n == 0U) {
 8001226:	4556      	cmp	r6, sl
 8001228:	d0da      	beq.n	80011e0 <chIQReadTimeout+0x60>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800122a:	3601      	adds	r6, #1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800122c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800122e:	f7ff f967 	bl	8000500 <_dbg_check_lock>
 8001232:	e7ba      	b.n	80011aa <chIQReadTimeout+0x2a>
 8001234:	4d05      	ldr	r5, [pc, #20]	; (800124c <chIQReadTimeout+0xcc>)
 8001236:	4e03      	ldr	r6, [pc, #12]	; (8001244 <chIQReadTimeout+0xc4>)
 8001238:	62f5      	str	r5, [r6, #44]	; 0x2c
 800123a:	e7fe      	b.n	800123a <chIQReadTimeout+0xba>
 800123c:	b672      	cpsid	i
 800123e:	4c02      	ldr	r4, [pc, #8]	; (8001248 <chIQReadTimeout+0xc8>)
 8001240:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001242:	e7fe      	b.n	8001242 <chIQReadTimeout+0xc2>
 8001244:	20000fc0 	.word	0x20000fc0
 8001248:	08002180 	.word	0x08002180
 800124c:	080021e0 	.word	0x080021e0

08001250 <chOQPutTimeout.4188>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001252:	1c04      	adds	r4, r0, #0
 8001254:	1c0f      	adds	r7, r1, #0
 8001256:	1c16      	adds	r6, r2, #0
 8001258:	b672      	cpsid	i
 800125a:	f7ff f951 	bl	8000500 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800125e:	f7ff fb9f 	bl	80009a0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001262:	68a3      	ldr	r3, [r4, #8]

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8001264:	2b00      	cmp	r3, #0
 8001266:	d113      	bne.n	8001290 <chOQPutTimeout.4188+0x40>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001268:	1c20      	adds	r0, r4, #0
 800126a:	1c31      	adds	r1, r6, #0
 800126c:	f7ff ff70 	bl	8001150 <chThdEnqueueTimeoutS>
 8001270:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 8001272:	daf4      	bge.n	800125e <chOQPutTimeout.4188+0xe>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001274:	f7ff f92c 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001278:	4b19      	ldr	r3, [pc, #100]	; (80012e0 <chOQPutTimeout.4188+0x90>)
 800127a:	6818      	ldr	r0, [r3, #0]
 800127c:	4298      	cmp	r0, r3
 800127e:	d004      	beq.n	800128a <chOQPutTimeout.4188+0x3a>
 8001280:	6999      	ldr	r1, [r3, #24]
 8001282:	6882      	ldr	r2, [r0, #8]
 8001284:	688c      	ldr	r4, [r1, #8]
 8001286:	4294      	cmp	r4, r2
 8001288:	d321      	bcc.n	80012ce <chOQPutTimeout.4188+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800128a:	b662      	cpsie	i
    oqp->q_notify(oqp);
  }
  chSysUnlock();

  return Q_OK;
}
 800128c:	1c28      	adds	r0, r5, #0
 800128e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001290:	68a0      	ldr	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001292:	6961      	ldr	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001294:	3801      	subs	r0, #1
 8001296:	60a0      	str	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001298:	700f      	strb	r7, [r1, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800129a:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 800129c:	3101      	adds	r1, #1
 800129e:	6161      	str	r1, [r4, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 80012a0:	4291      	cmp	r1, r2
 80012a2:	d301      	bcc.n	80012a8 <chOQPutTimeout.4188+0x58>
    oqp->q_wrptr = oqp->q_buffer;
 80012a4:	68e5      	ldr	r5, [r4, #12]
 80012a6:	6165      	str	r5, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 80012a8:	69e6      	ldr	r6, [r4, #28]
 80012aa:	2e00      	cmp	r6, #0
 80012ac:	d001      	beq.n	80012b2 <chOQPutTimeout.4188+0x62>
    oqp->q_notify(oqp);
 80012ae:	1c20      	adds	r0, r4, #0
 80012b0:	47b0      	blx	r6
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012b2:	f7ff f90d 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80012b6:	4c0a      	ldr	r4, [pc, #40]	; (80012e0 <chOQPutTimeout.4188+0x90>)
 80012b8:	6827      	ldr	r7, [r4, #0]
 80012ba:	42a7      	cmp	r7, r4
 80012bc:	d004      	beq.n	80012c8 <chOQPutTimeout.4188+0x78>
 80012be:	69a3      	ldr	r3, [r4, #24]
 80012c0:	68b9      	ldr	r1, [r7, #8]
 80012c2:	6898      	ldr	r0, [r3, #8]
 80012c4:	4288      	cmp	r0, r1
 80012c6:	d306      	bcc.n	80012d6 <chOQPutTimeout.4188+0x86>
 80012c8:	b662      	cpsie	i
 80012ca:	2500      	movs	r5, #0
 80012cc:	e7de      	b.n	800128c <chOQPutTimeout.4188+0x3c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80012ce:	b672      	cpsid	i
 80012d0:	4d04      	ldr	r5, [pc, #16]	; (80012e4 <chOQPutTimeout.4188+0x94>)
 80012d2:	62dd      	str	r5, [r3, #44]	; 0x2c
 80012d4:	e7fe      	b.n	80012d4 <chOQPutTimeout.4188+0x84>
 80012d6:	b672      	cpsid	i
 80012d8:	4a02      	ldr	r2, [pc, #8]	; (80012e4 <chOQPutTimeout.4188+0x94>)
 80012da:	62e2      	str	r2, [r4, #44]	; 0x2c
 80012dc:	e7fe      	b.n	80012dc <chOQPutTimeout.4188+0x8c>
 80012de:	46c0      	nop			; (mov r8, r8)
 80012e0:	20000fc0 	.word	0x20000fc0
 80012e4:	08002180 	.word	0x08002180
 80012e8:	46c0      	nop			; (mov r8, r8)
 80012ea:	46c0      	nop			; (mov r8, r8)
 80012ec:	46c0      	nop			; (mov r8, r8)
 80012ee:	46c0      	nop			; (mov r8, r8)

080012f0 <putt.7878>:
static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80012f0:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80012f2:	3030      	adds	r0, #48	; 0x30
 80012f4:	f7ff ffac 	bl	8001250 <chOQPutTimeout.4188>
}
 80012f8:	bd08      	pop	{r3, pc}
 80012fa:	46c0      	nop			; (mov r8, r8)
 80012fc:	46c0      	nop			; (mov r8, r8)
 80012fe:	46c0      	nop			; (mov r8, r8)

08001300 <put.7883>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8001300:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001302:	2201      	movs	r2, #1
 8001304:	3030      	adds	r0, #48	; 0x30
 8001306:	4252      	negs	r2, r2
 8001308:	f7ff ffa2 	bl	8001250 <chOQPutTimeout.4188>
}
 800130c:	bd08      	pop	{r3, pc}
 800130e:	46c0      	nop			; (mov r8, r8)

08001310 <chIQGetTimeout.4204>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001310:	b570      	push	{r4, r5, r6, lr}
 8001312:	1c04      	adds	r4, r0, #0
 8001314:	1c0e      	adds	r6, r1, #0
 8001316:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001318:	f7ff f8f2 	bl	8000500 <_dbg_check_lock>
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800131c:	69e3      	ldr	r3, [r4, #28]
 800131e:	2b00      	cmp	r3, #0
 8001320:	d001      	beq.n	8001326 <chIQGetTimeout.4204+0x16>
    iqp->q_notify(iqp);
 8001322:	1c20      	adds	r0, r4, #0
 8001324:	4798      	blx	r3
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001326:	f7ff fb3b 	bl	80009a0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800132a:	68a0      	ldr	r0, [r4, #8]
  }

  while (chIQIsEmptyI(iqp)) {
 800132c:	2800      	cmp	r0, #0
 800132e:	d113      	bne.n	8001358 <chIQGetTimeout.4204+0x48>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001330:	1c20      	adds	r0, r4, #0
 8001332:	1c31      	adds	r1, r6, #0
 8001334:	f7ff ff0c 	bl	8001150 <chThdEnqueueTimeoutS>
 8001338:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 800133a:	daf4      	bge.n	8001326 <chIQGetTimeout.4204+0x16>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800133c:	f7ff f8c8 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001340:	4b15      	ldr	r3, [pc, #84]	; (8001398 <chIQGetTimeout.4204+0x88>)
 8001342:	6818      	ldr	r0, [r3, #0]
 8001344:	4298      	cmp	r0, r3
 8001346:	d004      	beq.n	8001352 <chIQGetTimeout.4204+0x42>
 8001348:	6999      	ldr	r1, [r3, #24]
 800134a:	6882      	ldr	r2, [r0, #8]
 800134c:	688c      	ldr	r4, [r1, #8]
 800134e:	4294      	cmp	r4, r2
 8001350:	d31d      	bcc.n	800138e <chIQGetTimeout.4204+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001352:	b662      	cpsie	i
    iqp->q_rdptr = iqp->q_buffer;
  }
  chSysUnlock();

  return (msg_t)b;
}
 8001354:	1c28      	adds	r0, r5, #0
 8001356:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001358:	68a1      	ldr	r1, [r4, #8]
  b = *iqp->q_rdptr++;
 800135a:	69a6      	ldr	r6, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800135c:	3901      	subs	r1, #1
 800135e:	60a1      	str	r1, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001360:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001362:	7835      	ldrb	r5, [r6, #0]
 8001364:	3601      	adds	r6, #1
 8001366:	61a6      	str	r6, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001368:	4296      	cmp	r6, r2
 800136a:	d301      	bcc.n	8001370 <chIQGetTimeout.4204+0x60>
    iqp->q_rdptr = iqp->q_buffer;
 800136c:	68e3      	ldr	r3, [r4, #12]
 800136e:	61a3      	str	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001370:	f7ff f8ae 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001374:	4c08      	ldr	r4, [pc, #32]	; (8001398 <chIQGetTimeout.4204+0x88>)
 8001376:	6820      	ldr	r0, [r4, #0]
 8001378:	42a0      	cmp	r0, r4
 800137a:	d0ea      	beq.n	8001352 <chIQGetTimeout.4204+0x42>
 800137c:	69a1      	ldr	r1, [r4, #24]
 800137e:	6882      	ldr	r2, [r0, #8]
 8001380:	688e      	ldr	r6, [r1, #8]
 8001382:	4296      	cmp	r6, r2
 8001384:	d2e5      	bcs.n	8001352 <chIQGetTimeout.4204+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001386:	b672      	cpsid	i
 8001388:	4d04      	ldr	r5, [pc, #16]	; (800139c <chIQGetTimeout.4204+0x8c>)
 800138a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800138c:	e7fe      	b.n	800138c <chIQGetTimeout.4204+0x7c>
 800138e:	b672      	cpsid	i
 8001390:	4d02      	ldr	r5, [pc, #8]	; (800139c <chIQGetTimeout.4204+0x8c>)
 8001392:	62dd      	str	r5, [r3, #44]	; 0x2c
 8001394:	e7fe      	b.n	8001394 <chIQGetTimeout.4204+0x84>
 8001396:	46c0      	nop			; (mov r8, r8)
 8001398:	20000fc0 	.word	0x20000fc0
 800139c:	08002180 	.word	0x08002180

080013a0 <gett.7871>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 80013a0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80013a2:	300c      	adds	r0, #12
 80013a4:	f7ff ffb4 	bl	8001310 <chIQGetTimeout.4204>
}
 80013a8:	bd08      	pop	{r3, pc}
 80013aa:	46c0      	nop			; (mov r8, r8)
 80013ac:	46c0      	nop			; (mov r8, r8)
 80013ae:	46c0      	nop			; (mov r8, r8)

080013b0 <get.7875>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 80013b0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80013b2:	2101      	movs	r1, #1
 80013b4:	300c      	adds	r0, #12
 80013b6:	4249      	negs	r1, r1
 80013b8:	f7ff ffaa 	bl	8001310 <chIQGetTimeout.4204>
}
 80013bc:	bd08      	pop	{r3, pc}
 80013be:	46c0      	nop			; (mov r8, r8)

080013c0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80013c0:	b510      	push	{r4, lr}
 80013c2:	1c04      	adds	r4, r0, #0
 80013c4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80013c6:	f7ff f89b 	bl	8000500 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 80013ca:	2c00      	cmp	r4, #0
 80013cc:	d010      	beq.n	80013f0 <chThdSleep+0x30>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80013ce:	1c21      	adds	r1, r4, #0
 80013d0:	2008      	movs	r0, #8
 80013d2:	f7ff fe0d 	bl	8000ff0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80013d6:	f7ff f87b 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80013da:	4b0a      	ldr	r3, [pc, #40]	; (8001404 <chThdSleep+0x44>)
 80013dc:	681a      	ldr	r2, [r3, #0]
 80013de:	429a      	cmp	r2, r3
 80013e0:	d004      	beq.n	80013ec <chThdSleep+0x2c>
 80013e2:	6999      	ldr	r1, [r3, #24]
 80013e4:	6894      	ldr	r4, [r2, #8]
 80013e6:	6888      	ldr	r0, [r1, #8]
 80013e8:	42a0      	cmp	r0, r4
 80013ea:	d306      	bcc.n	80013fa <chThdSleep+0x3a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80013ec:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 80013ee:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013f0:	b672      	cpsid	i
 80013f2:	4905      	ldr	r1, [pc, #20]	; (8001408 <chThdSleep+0x48>)
 80013f4:	4b03      	ldr	r3, [pc, #12]	; (8001404 <chThdSleep+0x44>)
 80013f6:	62d9      	str	r1, [r3, #44]	; 0x2c
 80013f8:	e7fe      	b.n	80013f8 <chThdSleep+0x38>
 80013fa:	b672      	cpsid	i
 80013fc:	4a03      	ldr	r2, [pc, #12]	; (800140c <chThdSleep+0x4c>)
 80013fe:	62da      	str	r2, [r3, #44]	; 0x2c
 8001400:	e7fe      	b.n	8001400 <chThdSleep+0x40>
 8001402:	46c0      	nop			; (mov r8, r8)
 8001404:	20000fc0 	.word	0x20000fc0
 8001408:	080021b0 	.word	0x080021b0
 800140c:	080021d0 	.word	0x080021d0

08001410 <chOQWriteTimeout.4236>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001410:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001412:	4645      	mov	r5, r8
 8001414:	4688      	mov	r8, r1
  qnotify_t nfy = oqp->q_notify;
 8001416:	69c1      	ldr	r1, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001418:	4657      	mov	r7, sl
 800141a:	464e      	mov	r6, r9
 800141c:	b4e0      	push	{r5, r6, r7}
 800141e:	1c04      	adds	r4, r0, #0
 8001420:	1c16      	adds	r6, r2, #0
 8001422:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8001424:	4689      	mov	r9, r1
 8001426:	b672      	cpsid	i
  size_t w = 0;

  chDbgCheck(n > 0U);
 8001428:	2a00      	cmp	r2, #0
 800142a:	d04f      	beq.n	80014cc <chOQWriteTimeout.4236+0xbc>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800142c:	f7ff f868 	bl	8000500 <_dbg_check_lock>
 8001430:	4d2a      	ldr	r5, [pc, #168]	; (80014dc <chOQWriteTimeout.4236+0xcc>)
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8001432:	2700      	movs	r7, #0
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001434:	f7ff fab4 	bl	80009a0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001438:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800143a:	2b00      	cmp	r3, #0
 800143c:	d02b      	beq.n	8001496 <chOQWriteTimeout.4236+0x86>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800143e:	68a0      	ldr	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001440:	4642      	mov	r2, r8
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001442:	3801      	subs	r0, #1
 8001444:	60a0      	str	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001446:	6963      	ldr	r3, [r4, #20]
 8001448:	7811      	ldrb	r1, [r2, #0]
 800144a:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800144c:	6920      	ldr	r0, [r4, #16]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800144e:	3301      	adds	r3, #1
 8001450:	6163      	str	r3, [r4, #20]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001452:	4283      	cmp	r3, r0
 8001454:	d301      	bcc.n	800145a <chOQWriteTimeout.4236+0x4a>
      oqp->q_wrptr = oqp->q_buffer;
 8001456:	68e3      	ldr	r3, [r4, #12]
 8001458:	6163      	str	r3, [r4, #20]
    }

    if (nfy != NULL) {
 800145a:	464a      	mov	r2, r9
 800145c:	2a00      	cmp	r2, #0
 800145e:	d001      	beq.n	8001464 <chOQWriteTimeout.4236+0x54>
      nfy(oqp);
 8001460:	1c20      	adds	r0, r4, #0
 8001462:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001464:	f7ff f834 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001468:	6828      	ldr	r0, [r5, #0]
 800146a:	42a8      	cmp	r0, r5
 800146c:	d004      	beq.n	8001478 <chOQWriteTimeout.4236+0x68>
 800146e:	69a9      	ldr	r1, [r5, #24]
 8001470:	6883      	ldr	r3, [r0, #8]
 8001472:	688a      	ldr	r2, [r1, #8]
 8001474:	429a      	cmp	r2, r3
 8001476:	d325      	bcc.n	80014c4 <chOQWriteTimeout.4236+0xb4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001478:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 800147a:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 800147c:	3701      	adds	r7, #1
    if (--n == 0U) {
 800147e:	2e00      	cmp	r6, #0
 8001480:	d01a      	beq.n	80014b8 <chOQWriteTimeout.4236+0xa8>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001482:	2001      	movs	r0, #1
 8001484:	4480      	add	r8, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001486:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001488:	f7ff f83a 	bl	8000500 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800148c:	f7ff fa88 	bl	80009a0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001490:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001492:	2b00      	cmp	r3, #0
 8001494:	d1d3      	bne.n	800143e <chOQWriteTimeout.4236+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8001496:	1c20      	adds	r0, r4, #0
 8001498:	4651      	mov	r1, sl
 800149a:	f7ff fe59 	bl	8001150 <chThdEnqueueTimeoutS>
 800149e:	2800      	cmp	r0, #0
 80014a0:	d0c8      	beq.n	8001434 <chOQWriteTimeout.4236+0x24>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80014a2:	f7ff f815 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80014a6:	6829      	ldr	r1, [r5, #0]
 80014a8:	42a9      	cmp	r1, r5
 80014aa:	d004      	beq.n	80014b6 <chOQWriteTimeout.4236+0xa6>
 80014ac:	69aa      	ldr	r2, [r5, #24]
 80014ae:	688b      	ldr	r3, [r1, #8]
 80014b0:	6890      	ldr	r0, [r2, #8]
 80014b2:	4298      	cmp	r0, r3
 80014b4:	d30e      	bcc.n	80014d4 <chOQWriteTimeout.4236+0xc4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014b6:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80014b8:	1c38      	adds	r0, r7, #0
 80014ba:	bc1c      	pop	{r2, r3, r4}
 80014bc:	4690      	mov	r8, r2
 80014be:	4699      	mov	r9, r3
 80014c0:	46a2      	mov	sl, r4
 80014c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014c4:	b672      	cpsid	i
 80014c6:	4c06      	ldr	r4, [pc, #24]	; (80014e0 <chOQWriteTimeout.4236+0xd0>)
 80014c8:	62ec      	str	r4, [r5, #44]	; 0x2c
 80014ca:	e7fe      	b.n	80014ca <chOQWriteTimeout.4236+0xba>
 80014cc:	4d05      	ldr	r5, [pc, #20]	; (80014e4 <chOQWriteTimeout.4236+0xd4>)
 80014ce:	4e03      	ldr	r6, [pc, #12]	; (80014dc <chOQWriteTimeout.4236+0xcc>)
 80014d0:	62f5      	str	r5, [r6, #44]	; 0x2c
 80014d2:	e7fe      	b.n	80014d2 <chOQWriteTimeout.4236+0xc2>
 80014d4:	b672      	cpsid	i
 80014d6:	4c02      	ldr	r4, [pc, #8]	; (80014e0 <chOQWriteTimeout.4236+0xd0>)
 80014d8:	62ec      	str	r4, [r5, #44]	; 0x2c
 80014da:	e7fe      	b.n	80014da <chOQWriteTimeout.4236+0xca>
 80014dc:	20000fc0 	.word	0x20000fc0
 80014e0:	08002180 	.word	0x08002180
 80014e4:	08002200 	.word	0x08002200
 80014e8:	46c0      	nop			; (mov r8, r8)
 80014ea:	46c0      	nop			; (mov r8, r8)
 80014ec:	46c0      	nop			; (mov r8, r8)
 80014ee:	46c0      	nop			; (mov r8, r8)

080014f0 <debug_write.8757>:
 */

char stn_rx_buf[1024] = "booo\r\n";

static void debug_write(char *msg)
{
 80014f0:	b570      	push	{r4, r5, r6, lr}
    sdWrite(&SD1, (uint8_t*)"stuff: ", 7);
 80014f2:	4d0f      	ldr	r5, [pc, #60]	; (8001530 <debug_write.8757+0x40>)
 80014f4:	2401      	movs	r4, #1
 80014f6:	4264      	negs	r4, r4
 */

char stn_rx_buf[1024] = "booo\r\n";

static void debug_write(char *msg)
{
 80014f8:	1c06      	adds	r6, r0, #0
    sdWrite(&SD1, (uint8_t*)"stuff: ", 7);
 80014fa:	1c23      	adds	r3, r4, #0
 80014fc:	1c28      	adds	r0, r5, #0
 80014fe:	490d      	ldr	r1, [pc, #52]	; (8001534 <debug_write.8757+0x44>)
 8001500:	2207      	movs	r2, #7
 8001502:	f7ff ff85 	bl	8001410 <chOQWriteTimeout.4236>
    sdWrite(&SD1, (uint8_t*)msg, strlen(msg));
 8001506:	1c30      	adds	r0, r6, #0
 8001508:	f000 fcea 	bl	8001ee0 <strlen>
 800150c:	1c31      	adds	r1, r6, #0
 800150e:	1c23      	adds	r3, r4, #0
 8001510:	1c02      	adds	r2, r0, #0
 8001512:	1c28      	adds	r0, r5, #0
 8001514:	f7ff ff7c 	bl	8001410 <chOQWriteTimeout.4236>
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8001518:	1c28      	adds	r0, r5, #0
 800151a:	1c22      	adds	r2, r4, #0
 800151c:	210d      	movs	r1, #13
 800151e:	f7ff fe97 	bl	8001250 <chOQPutTimeout.4188>
 8001522:	1c28      	adds	r0, r5, #0
 8001524:	210a      	movs	r1, #10
 8001526:	1c22      	adds	r2, r4, #0
 8001528:	f7ff fe92 	bl	8001250 <chOQPutTimeout.4188>
    sdPut(&SD1, '\r');
    sdPut(&SD1, '\n');
}
 800152c:	bd70      	pop	{r4, r5, r6, pc}
 800152e:	46c0      	nop			; (mov r8, r8)
 8001530:	20000a30 	.word	0x20000a30
 8001534:	080021f0 	.word	0x080021f0
 8001538:	46c0      	nop			; (mov r8, r8)
 800153a:	46c0      	nop			; (mov r8, r8)
 800153c:	46c0      	nop			; (mov r8, r8)
 800153e:	46c0      	nop			; (mov r8, r8)

08001540 <send_at.8750>:
    chThdSleepMilliseconds(1000);
    debug_write("after reset");
}

static void send_at(char *at_cmd)
{
 8001540:	b510      	push	{r4, lr}
 8001542:	1c04      	adds	r4, r0, #0
    sdWrite(&SD2, (uint8_t*)at_cmd, strlen(at_cmd));
 8001544:	f000 fccc 	bl	8001ee0 <strlen>
 8001548:	2301      	movs	r3, #1
 800154a:	1c02      	adds	r2, r0, #0
 800154c:	1c21      	adds	r1, r4, #0
 800154e:	425b      	negs	r3, r3
 8001550:	4803      	ldr	r0, [pc, #12]	; (8001560 <send_at.8750+0x20>)
 8001552:	f7ff ff5d 	bl	8001410 <chOQWriteTimeout.4236>
    chThdSleepMilliseconds(1000);
 8001556:	4803      	ldr	r0, [pc, #12]	; (8001564 <send_at.8750+0x24>)
 8001558:	f7ff ff32 	bl	80013c0 <chThdSleep>
}
 800155c:	bd10      	pop	{r4, pc}
 800155e:	46c0      	nop			; (mov r8, r8)
 8001560:	20000d0c 	.word	0x20000d0c
 8001564:	00002710 	.word	0x00002710
 8001568:	46c0      	nop			; (mov r8, r8)
 800156a:	46c0      	nop			; (mov r8, r8)
 800156c:	46c0      	nop			; (mov r8, r8)
 800156e:	46c0      	nop			; (mov r8, r8)

08001570 <writet.7860>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8001570:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001572:	3030      	adds	r0, #48	; 0x30
 8001574:	f7ff ff4c 	bl	8001410 <chOQWriteTimeout.4236>
}
 8001578:	bd08      	pop	{r3, pc}
 800157a:	46c0      	nop			; (mov r8, r8)
 800157c:	46c0      	nop			; (mov r8, r8)
 800157e:	46c0      	nop			; (mov r8, r8)

08001580 <write.7866>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8001580:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001582:	2301      	movs	r3, #1
 8001584:	3030      	adds	r0, #48	; 0x30
 8001586:	425b      	negs	r3, r3
 8001588:	f7ff ff42 	bl	8001410 <chOQWriteTimeout.4236>
                        n, TIME_INFINITE);
}
 800158c:	bd08      	pop	{r3, pc}
 800158e:	46c0      	nop			; (mov r8, r8)

08001590 <chThdCreateStatic.constprop.15>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8001590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001592:	464f      	mov	r7, r9
 8001594:	4646      	mov	r6, r8
 8001596:	b4c0      	push	{r6, r7}
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8001598:	1c06      	adds	r6, r0, #0
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 800159a:	1c04      	adds	r4, r0, #0
 800159c:	4688      	mov	r8, r1
 800159e:	1c17      	adds	r7, r2, #0
 80015a0:	4699      	mov	r9, r3
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80015a2:	3648      	adds	r6, #72	; 0x48
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80015a4:	25ff      	movs	r5, #255	; 0xff
 80015a6:	7005      	strb	r5, [r0, #0]
 80015a8:	7045      	strb	r5, [r0, #1]
 80015aa:	3002      	adds	r0, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80015ac:	4286      	cmp	r6, r0
 80015ae:	d1fa      	bne.n	80015a6 <chThdCreateStatic.constprop.15+0x16>
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 80015b0:	4642      	mov	r2, r8
 80015b2:	18a3      	adds	r3, r4, r2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80015b4:	429e      	cmp	r6, r3
 80015b6:	d213      	bcs.n	80015e0 <chThdCreateStatic.constprop.15+0x50>
 80015b8:	43f1      	mvns	r1, r6
 80015ba:	185a      	adds	r2, r3, r1
    *startp++ = v;
 80015bc:	2555      	movs	r5, #85	; 0x55
 80015be:	2001      	movs	r0, #1
 80015c0:	1c71      	adds	r1, r6, #1
 80015c2:	4002      	ands	r2, r0
 80015c4:	7035      	strb	r5, [r6, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80015c6:	4299      	cmp	r1, r3
 80015c8:	d00a      	beq.n	80015e0 <chThdCreateStatic.constprop.15+0x50>
 80015ca:	2a00      	cmp	r2, #0
 80015cc:	d003      	beq.n	80015d6 <chThdCreateStatic.constprop.15+0x46>
    *startp++ = v;
 80015ce:	700d      	strb	r5, [r1, #0]
 80015d0:	3101      	adds	r1, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80015d2:	4299      	cmp	r1, r3
 80015d4:	d004      	beq.n	80015e0 <chThdCreateStatic.constprop.15+0x50>
    *startp++ = v;
 80015d6:	700d      	strb	r5, [r1, #0]
 80015d8:	704d      	strb	r5, [r1, #1]
 80015da:	3102      	adds	r1, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80015dc:	4299      	cmp	r1, r3
 80015de:	d1fa      	bne.n	80015d6 <chThdCreateStatic.constprop.15+0x46>
 80015e0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80015e2:	f7fe ff8d 	bl	8000500 <_dbg_check_lock>
                       tprio_t prio, tfunc_t pf, void *arg) {
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
 80015e6:	f7ff f9db 	bl	80009a0 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 80015ea:	2c00      	cmp	r4, #0
 80015ec:	d05c      	beq.n	80016a8 <chThdCreateStatic.constprop.15+0x118>
 80015ee:	4643      	mov	r3, r8
 80015f0:	2bcf      	cmp	r3, #207	; 0xcf
 80015f2:	d959      	bls.n	80016a8 <chThdCreateStatic.constprop.15+0x118>
 80015f4:	2f7f      	cmp	r7, #127	; 0x7f
 80015f6:	d857      	bhi.n	80016a8 <chThdCreateStatic.constprop.15+0x118>
 80015f8:	464d      	mov	r5, r9
 80015fa:	2d00      	cmp	r5, #0
 80015fc:	d054      	beq.n	80016a8 <chThdCreateStatic.constprop.15+0x118>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80015fe:	4642      	mov	r2, r8
 8001600:	3a24      	subs	r2, #36	; 0x24
 8001602:	18a0      	adds	r0, r4, r2
 8001604:	60e0      	str	r0, [r4, #12]
 8001606:	6105      	str	r5, [r0, #16]
 8001608:	4d32      	ldr	r5, [pc, #200]	; (80016d4 <chThdCreateStatic.constprop.15+0x144>)
 800160a:	2300      	movs	r3, #0
 800160c:	6143      	str	r3, [r0, #20]
 800160e:	6205      	str	r5, [r0, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001610:	2220      	movs	r2, #32
 8001612:	2002      	movs	r0, #2
 8001614:	54a0      	strb	r0, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001616:	2501      	movs	r5, #1
 8001618:	2022      	movs	r0, #34	; 0x22
 800161a:	5425      	strb	r5, [r4, r0]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800161c:	4d2e      	ldr	r5, [pc, #184]	; (80016d8 <chThdCreateStatic.constprop.15+0x148>)
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800161e:	2121      	movs	r1, #33	; 0x21
 8001620:	5463      	strb	r3, [r4, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001622:	63e3      	str	r3, [r4, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001624:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001626:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001628:	1c22      	adds	r2, r4, #0
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800162a:	696b      	ldr	r3, [r5, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800162c:	3228      	adds	r2, #40	; 0x28
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800162e:	6125      	str	r5, [r4, #16]
 8001630:	611c      	str	r4, [r3, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001632:	62a2      	str	r2, [r4, #40]	; 0x28
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001634:	3204      	adds	r2, #4
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001636:	60a7      	str	r7, [r4, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001638:	6163      	str	r3, [r4, #20]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800163a:	61e6      	str	r6, [r4, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800163c:	6427      	str	r7, [r4, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800163e:	62e2      	str	r2, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 8001640:	6322      	str	r2, [r4, #48]	; 0x30
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001642:	616c      	str	r4, [r5, #20]
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {

  chDbgCheckClassS();
 8001644:	f7ff fbfc 	bl	8000e40 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001648:	69a8      	ldr	r0, [r5, #24]
 800164a:	682e      	ldr	r6, [r5, #0]
 800164c:	6881      	ldr	r1, [r0, #8]
 800164e:	42ae      	cmp	r6, r5
 8001650:	d002      	beq.n	8001658 <chThdCreateStatic.constprop.15+0xc8>
 8001652:	68b3      	ldr	r3, [r6, #8]
 8001654:	4299      	cmp	r1, r3
 8001656:	d330      	bcc.n	80016ba <chThdCreateStatic.constprop.15+0x12a>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8001658:	2200      	movs	r2, #0
 800165a:	6262      	str	r2, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800165c:	428f      	cmp	r7, r1
 800165e:	d930      	bls.n	80016c2 <chThdCreateStatic.constprop.15+0x132>
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8001660:	f7ff fa1e 	bl	8000aa0 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001664:	2620      	movs	r6, #32
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8001666:	1c07      	adds	r7, r0, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001668:	2001      	movs	r0, #1
 800166a:	55a0      	strb	r0, [r4, r6]
    chSysSwitch(ntp, otp);
 800166c:	1c38      	adds	r0, r7, #0
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800166e:	61ac      	str	r4, [r5, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001670:	f7ff fc76 	bl	8000f60 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001674:	f3ef 8109 	mrs	r1, PSP
 8001678:	69fb      	ldr	r3, [r7, #28]
 800167a:	3924      	subs	r1, #36	; 0x24
 800167c:	428b      	cmp	r3, r1
 800167e:	d818      	bhi.n	80016b2 <chThdCreateStatic.constprop.15+0x122>
 8001680:	1c20      	adds	r0, r4, #0
 8001682:	1c39      	adds	r1, r7, #0
 8001684:	f7fe fda4 	bl	80001d0 <_port_switch>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001688:	f7fe ff22 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800168c:	682f      	ldr	r7, [r5, #0]
 800168e:	42af      	cmp	r7, r5
 8001690:	d004      	beq.n	800169c <chThdCreateStatic.constprop.15+0x10c>
 8001692:	69aa      	ldr	r2, [r5, #24]
 8001694:	68be      	ldr	r6, [r7, #8]
 8001696:	6890      	ldr	r0, [r2, #8]
 8001698:	42b0      	cmp	r0, r6
 800169a:	d316      	bcc.n	80016ca <chThdCreateStatic.constprop.15+0x13a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800169c:	b662      	cpsie	i
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
  chSysUnlock();

  return tp;
}
 800169e:	1c20      	adds	r0, r4, #0
 80016a0:	bc0c      	pop	{r2, r3}
 80016a2:	4690      	mov	r8, r2
 80016a4:	4699      	mov	r9, r3
 80016a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016a8:	b672      	cpsid	i
 80016aa:	4d0c      	ldr	r5, [pc, #48]	; (80016dc <chThdCreateStatic.constprop.15+0x14c>)
 80016ac:	4c0a      	ldr	r4, [pc, #40]	; (80016d8 <chThdCreateStatic.constprop.15+0x148>)
 80016ae:	62e5      	str	r5, [r4, #44]	; 0x2c
 80016b0:	e7fe      	b.n	80016b0 <chThdCreateStatic.constprop.15+0x120>
 80016b2:	b672      	cpsid	i
 80016b4:	4c0a      	ldr	r4, [pc, #40]	; (80016e0 <chThdCreateStatic.constprop.15+0x150>)
 80016b6:	62ec      	str	r4, [r5, #44]	; 0x2c
 80016b8:	e7fe      	b.n	80016b8 <chThdCreateStatic.constprop.15+0x128>
 80016ba:	b672      	cpsid	i
 80016bc:	4b09      	ldr	r3, [pc, #36]	; (80016e4 <chThdCreateStatic.constprop.15+0x154>)
 80016be:	62eb      	str	r3, [r5, #44]	; 0x2c
 80016c0:	e7fe      	b.n	80016c0 <chThdCreateStatic.constprop.15+0x130>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
 80016c2:	1c20      	adds	r0, r4, #0
 80016c4:	f7ff f9ec 	bl	8000aa0 <chSchReadyI>
 80016c8:	e7de      	b.n	8001688 <chThdCreateStatic.constprop.15+0xf8>
 80016ca:	b672      	cpsid	i
 80016cc:	4906      	ldr	r1, [pc, #24]	; (80016e8 <chThdCreateStatic.constprop.15+0x158>)
 80016ce:	62e9      	str	r1, [r5, #44]	; 0x2c
 80016d0:	e7fe      	b.n	80016d0 <chThdCreateStatic.constprop.15+0x140>
 80016d2:	46c0      	nop			; (mov r8, r8)
 80016d4:	080001f1 	.word	0x080001f1
 80016d8:	20000fc0 	.word	0x20000fc0
 80016dc:	080021a0 	.word	0x080021a0
 80016e0:	08002098 	.word	0x08002098
 80016e4:	08002230 	.word	0x08002230
 80016e8:	080021d0 	.word	0x080021d0
 80016ec:	46c0      	nop			; (mov r8, r8)
 80016ee:	46c0      	nop			; (mov r8, r8)

080016f0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80016f0:	b510      	push	{r4, lr}
 80016f2:	1c04      	adds	r4, r0, #0
 80016f4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80016f6:	f7fe ff03 	bl	8000500 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();
 80016fa:	f7ff f951 	bl	80009a0 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80016fe:	4910      	ldr	r1, [pc, #64]	; (8001740 <chCoreAlloc+0x50>)
 8001700:	4810      	ldr	r0, [pc, #64]	; (8001744 <chCoreAlloc+0x54>)
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001702:	1de2      	adds	r2, r4, #7
 8001704:	2307      	movs	r3, #7
 8001706:	439a      	bics	r2, r3
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8001708:	6804      	ldr	r4, [r0, #0]
 800170a:	680b      	ldr	r3, [r1, #0]
 800170c:	1b19      	subs	r1, r3, r4
 800170e:	428a      	cmp	r2, r1
 8001710:	d813      	bhi.n	800173a <chCoreAlloc+0x4a>
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8001712:	18a2      	adds	r2, r4, r2
 8001714:	6002      	str	r2, [r0, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001716:	f7fe fedb 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800171a:	480b      	ldr	r0, [pc, #44]	; (8001748 <chCoreAlloc+0x58>)
 800171c:	6803      	ldr	r3, [r0, #0]
 800171e:	4283      	cmp	r3, r0
 8001720:	d004      	beq.n	800172c <chCoreAlloc+0x3c>
 8001722:	6981      	ldr	r1, [r0, #24]
 8001724:	689a      	ldr	r2, [r3, #8]
 8001726:	6889      	ldr	r1, [r1, #8]
 8001728:	4291      	cmp	r1, r2
 800172a:	d302      	bcc.n	8001732 <chCoreAlloc+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800172c:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800172e:	1c20      	adds	r0, r4, #0
 8001730:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001732:	b672      	cpsid	i
 8001734:	4c05      	ldr	r4, [pc, #20]	; (800174c <chCoreAlloc+0x5c>)
 8001736:	62c4      	str	r4, [r0, #44]	; 0x2c
 8001738:	e7fe      	b.n	8001738 <chCoreAlloc+0x48>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800173a:	2400      	movs	r4, #0
 800173c:	e7eb      	b.n	8001716 <chCoreAlloc+0x26>
 800173e:	46c0      	nop			; (mov r8, r8)
 8001740:	20001528 	.word	0x20001528
 8001744:	20000fb8 	.word	0x20000fb8
 8001748:	20000fc0 	.word	0x20000fc0
 800174c:	08002220 	.word	0x08002220

08001750 <sdStart.constprop.4>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001750:	b538      	push	{r3, r4, r5, lr}
 8001752:	1c04      	adds	r4, r0, #0
 8001754:	b672      	cpsid	i

  osalDbgCheck(sdp != NULL);
 8001756:	2800      	cmp	r0, #0
 8001758:	d03c      	beq.n	80017d4 <sdStart.constprop.4+0x84>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800175a:	f7fe fed1 	bl	8000500 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 800175e:	7a23      	ldrb	r3, [r4, #8]
 8001760:	1e5a      	subs	r2, r3, #1
 8001762:	2a01      	cmp	r2, #1
 8001764:	d904      	bls.n	8001770 <sdStart.constprop.4+0x20>
 8001766:	b672      	cpsid	i
 8001768:	4c22      	ldr	r4, [pc, #136]	; (80017f4 <sdStart.constprop.4+0xa4>)
 800176a:	4b23      	ldr	r3, [pc, #140]	; (80017f8 <sdStart.constprop.4+0xa8>)
 800176c:	62dc      	str	r4, [r3, #44]	; 0x2c
 800176e:	e7fe      	b.n	800176e <sdStart.constprop.4+0x1e>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001770:	2b01      	cmp	r3, #1
 8001772:	d022      	beq.n	80017ba <sdStart.constprop.4+0x6a>
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8001774:	21b6      	movs	r1, #182	; 0xb6
 8001776:	008b      	lsls	r3, r1, #2
 8001778:	2296      	movs	r2, #150	; 0x96
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800177a:	20b5      	movs	r0, #181	; 0xb5
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800177c:	0191      	lsls	r1, r2, #6
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800177e:	0085      	lsls	r5, r0, #2
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8001780:	58e0      	ldr	r0, [r4, r3]
 8001782:	f7fe fd4d 	bl	8000220 <__aeabi_uidiv>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8001786:	5965      	ldr	r5, [r4, r5]
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001788:	4b1c      	ldr	r3, [pc, #112]	; (80017fc <sdStart.constprop.4+0xac>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800178a:	60e8      	str	r0, [r5, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800178c:	481c      	ldr	r0, [pc, #112]	; (8001800 <sdStart.constprop.4+0xb0>)
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800178e:	2201      	movs	r2, #1
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001790:	6068      	str	r0, [r5, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001792:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8001794:	4250      	negs	r0, r2
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001796:	60a9      	str	r1, [r5, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001798:	602b      	str	r3, [r5, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800179a:	6228      	str	r0, [r5, #32]
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 800179c:	2502      	movs	r5, #2
 800179e:	7225      	strb	r5, [r4, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80017a0:	f7fe fe96 	bl	80004d0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80017a4:	4c14      	ldr	r4, [pc, #80]	; (80017f8 <sdStart.constprop.4+0xa8>)
 80017a6:	6823      	ldr	r3, [r4, #0]
 80017a8:	42a3      	cmp	r3, r4
 80017aa:	d004      	beq.n	80017b6 <sdStart.constprop.4+0x66>
 80017ac:	69a1      	ldr	r1, [r4, #24]
 80017ae:	689a      	ldr	r2, [r3, #8]
 80017b0:	6888      	ldr	r0, [r1, #8]
 80017b2:	4290      	cmp	r0, r2
 80017b4:	d312      	bcc.n	80017dc <sdStart.constprop.4+0x8c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80017b6:	b662      	cpsie	i
  osalSysUnlock();
}
 80017b8:	bd38      	pop	{r3, r4, r5, pc}
  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 80017ba:	4812      	ldr	r0, [pc, #72]	; (8001804 <sdStart.constprop.4+0xb4>)
 80017bc:	4284      	cmp	r4, r0
 80017be:	d011      	beq.n	80017e4 <sdStart.constprop.4+0x94>
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 80017c0:	4911      	ldr	r1, [pc, #68]	; (8001808 <sdStart.constprop.4+0xb8>)
 80017c2:	428c      	cmp	r4, r1
 80017c4:	d1d6      	bne.n	8001774 <sdStart.constprop.4+0x24>
      rccEnableUSART2(FALSE);
 80017c6:	4d11      	ldr	r5, [pc, #68]	; (800180c <sdStart.constprop.4+0xbc>)
 80017c8:	2280      	movs	r2, #128	; 0x80
 80017ca:	69eb      	ldr	r3, [r5, #28]
 80017cc:	0290      	lsls	r0, r2, #10
 80017ce:	4318      	orrs	r0, r3
 80017d0:	61e8      	str	r0, [r5, #28]
 80017d2:	e7cf      	b.n	8001774 <sdStart.constprop.4+0x24>
 80017d4:	4907      	ldr	r1, [pc, #28]	; (80017f4 <sdStart.constprop.4+0xa4>)
 80017d6:	4808      	ldr	r0, [pc, #32]	; (80017f8 <sdStart.constprop.4+0xa8>)
 80017d8:	62c1      	str	r1, [r0, #44]	; 0x2c
 80017da:	e7fe      	b.n	80017da <sdStart.constprop.4+0x8a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80017dc:	b672      	cpsid	i
 80017de:	4d0c      	ldr	r5, [pc, #48]	; (8001810 <sdStart.constprop.4+0xc0>)
 80017e0:	62e5      	str	r5, [r4, #44]	; 0x2c
 80017e2:	e7fe      	b.n	80017e2 <sdStart.constprop.4+0x92>
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 80017e4:	4d09      	ldr	r5, [pc, #36]	; (800180c <sdStart.constprop.4+0xbc>)
 80017e6:	2380      	movs	r3, #128	; 0x80
 80017e8:	69a9      	ldr	r1, [r5, #24]
 80017ea:	01da      	lsls	r2, r3, #7
 80017ec:	430a      	orrs	r2, r1
 80017ee:	61aa      	str	r2, [r5, #24]
 80017f0:	e7c0      	b.n	8001774 <sdStart.constprop.4+0x24>
 80017f2:	46c0      	nop			; (mov r8, r8)
 80017f4:	08002190 	.word	0x08002190
 80017f8:	20000fc0 	.word	0x20000fc0
 80017fc:	0000012d 	.word	0x0000012d
 8001800:	00004040 	.word	0x00004040
 8001804:	20000a00 	.word	0x20000a00
 8001808:	20000cdc 	.word	0x20000cdc
 800180c:	40021000 	.word	0x40021000
 8001810:	080021c0 	.word	0x080021c0
 8001814:	46c0      	nop			; (mov r8, r8)
 8001816:	46c0      	nop			; (mov r8, r8)
 8001818:	46c0      	nop			; (mov r8, r8)
 800181a:	46c0      	nop			; (mov r8, r8)
 800181c:	46c0      	nop			; (mov r8, r8)
 800181e:	46c0      	nop			; (mov r8, r8)

08001820 <readt.7849.4368>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8001820:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001822:	300c      	adds	r0, #12
 8001824:	f7ff fcac 	bl	8001180 <chIQReadTimeout>
}
 8001828:	bd08      	pop	{r3, pc}
 800182a:	46c0      	nop			; (mov r8, r8)
 800182c:	46c0      	nop			; (mov r8, r8)
 800182e:	46c0      	nop			; (mov r8, r8)

08001830 <read.7855.4374>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8001830:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001832:	2301      	movs	r3, #1
 8001834:	300c      	adds	r0, #12
 8001836:	425b      	negs	r3, r3
 8001838:	f7ff fca2 	bl	8001180 <chIQReadTimeout>
                       n, TIME_INFINITE);
}
 800183c:	bd08      	pop	{r3, pc}
 800183e:	46c0      	nop			; (mov r8, r8)

08001840 <STN1110_rx.8747.4242>:

static THD_WORKING_AREA(wa_STN1110_rx, 128);
static THD_FUNCTION(STN1110_rx, arg) {
 8001840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001842:	4b24      	ldr	r3, [pc, #144]	; (80018d4 <STN1110_rx.8747.4242+0x94>)
 8001844:	4a24      	ldr	r2, [pc, #144]	; (80018d8 <STN1110_rx.8747.4242+0x98>)
 8001846:	6998      	ldr	r0, [r3, #24]
 8001848:	464f      	mov	r7, r9
 800184a:	4646      	mov	r6, r8
 800184c:	b4c0      	push	{r6, r7}
 800184e:	6182      	str	r2, [r0, #24]
    sdPut(&SD1, '\n');
}

static void reset_stn1110(void)
{
    debug_write("resetting");
 8001850:	4822      	ldr	r0, [pc, #136]	; (80018dc <STN1110_rx.8747.4242+0x9c>)
 8001852:	f7ff fe4d 	bl	80014f0 <debug_write.8757>
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8001856:	4c22      	ldr	r4, [pc, #136]	; (80018e0 <STN1110_rx.8747.4242+0xa0>)
    debug_write("resetting");

    /* set STN1110 NVM reset to disbled (normal running mode)
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);
 8001858:	2190      	movs	r1, #144	; 0x90
 800185a:	05c8      	lsls	r0, r1, #23
 800185c:	2220      	movs	r2, #32
 800185e:	2102      	movs	r1, #2
 8001860:	f7ff fafe 	bl	8000e60 <_pal_lld_setgroupmode>

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001864:	2504      	movs	r5, #4
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8001866:	2104      	movs	r1, #4
 8001868:	2201      	movs	r2, #1
 800186a:	1c20      	adds	r0, r4, #0
 800186c:	f7ff faf8 	bl	8000e60 <_pal_lld_setgroupmode>
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001870:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(10);
 8001872:	2064      	movs	r0, #100	; 0x64
 8001874:	f7ff fda4 	bl	80013c0 <chThdSleep>
    palSetPad(GPIOB, GPIOB_RESET_STN1110);
 8001878:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(1000);
 800187a:	481a      	ldr	r0, [pc, #104]	; (80018e4 <STN1110_rx.8747.4242+0xa4>)
 800187c:	f7ff fda0 	bl	80013c0 <chThdSleep>
    debug_write("after reset");
 8001880:	4819      	ldr	r0, [pc, #100]	; (80018e8 <STN1110_rx.8747.4242+0xa8>)
 8001882:	f7ff fe35 	bl	80014f0 <debug_write.8757>
static THD_FUNCTION(STN1110_rx, arg) {
  (void)arg;
  chRegSetThreadName("STN1110_RX");

  reset_stn1110();
  send_at("AT E0\r");
 8001886:	4819      	ldr	r0, [pc, #100]	; (80018ec <STN1110_rx.8747.4242+0xac>)
 8001888:	f7ff fe5a 	bl	8001540 <send_at.8750>
  send_at("AT SP 0\r");
 800188c:	4818      	ldr	r0, [pc, #96]	; (80018f0 <STN1110_rx.8747.4242+0xb0>)
 800188e:	f7ff fe57 	bl	8001540 <send_at.8750>
 8001892:	4e18      	ldr	r6, [pc, #96]	; (80018f4 <STN1110_rx.8747.4242+0xb4>)
 8001894:	4f18      	ldr	r7, [pc, #96]	; (80018f8 <STN1110_rx.8747.4242+0xb8>)

  while (true) {
      /* Reset the STN1110 */
      send_at("010C\r");
      debug_write("Waiting for AT response");
      int bytes_read = sdReadTimeout(&SD2,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf), 50000);
 8001896:	4d19      	ldr	r5, [pc, #100]	; (80018fc <STN1110_rx.8747.4242+0xbc>)
 8001898:	46b1      	mov	r9, r6
 800189a:	46b8      	mov	r8, r7
 800189c:	4c18      	ldr	r4, [pc, #96]	; (8001900 <STN1110_rx.8747.4242+0xc0>)
 800189e:	4f19      	ldr	r7, [pc, #100]	; (8001904 <STN1110_rx.8747.4242+0xc4>)
 80018a0:	4e19      	ldr	r6, [pc, #100]	; (8001908 <STN1110_rx.8747.4242+0xc8>)
 80018a2:	350c      	adds	r5, #12
  send_at("AT E0\r");
  send_at("AT SP 0\r");

  while (true) {
      /* Reset the STN1110 */
      send_at("010C\r");
 80018a4:	4648      	mov	r0, r9
 80018a6:	f7ff fe4b 	bl	8001540 <send_at.8750>
      debug_write("Waiting for AT response");
 80018aa:	4640      	mov	r0, r8
 80018ac:	f7ff fe20 	bl	80014f0 <debug_write.8757>
      int bytes_read = sdReadTimeout(&SD2,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf), 50000);
 80018b0:	2380      	movs	r3, #128	; 0x80
 80018b2:	1c21      	adds	r1, r4, #0
 80018b4:	00da      	lsls	r2, r3, #3
 80018b6:	1c28      	adds	r0, r5, #0
 80018b8:	4b14      	ldr	r3, [pc, #80]	; (800190c <STN1110_rx.8747.4242+0xcc>)
 80018ba:	f7ff fc61 	bl	8001180 <chIQReadTimeout>
 80018be:	1c02      	adds	r2, r0, #0
      stn_rx_buf[bytes_read] = '\0';
 80018c0:	2000      	movs	r0, #0
 80018c2:	54a0      	strb	r0, [r4, r2]
      chprintf(&SD1, "Bytes read %i\r\n", bytes_read);
 80018c4:	1c31      	adds	r1, r6, #0
 80018c6:	1c38      	adds	r0, r7, #0
 80018c8:	f7fe fe9a 	bl	8000600 <chprintf.constprop.1>
      debug_write(stn_rx_buf);
 80018cc:	1c20      	adds	r0, r4, #0
 80018ce:	f7ff fe0f 	bl	80014f0 <debug_write.8757>
 80018d2:	e7e7      	b.n	80018a4 <STN1110_rx.8747.4242+0x64>
 80018d4:	20000fc0 	.word	0x20000fc0
 80018d8:	08002260 	.word	0x08002260
 80018dc:	0800226c 	.word	0x0800226c
 80018e0:	48000400 	.word	0x48000400
 80018e4:	00002710 	.word	0x00002710
 80018e8:	08002278 	.word	0x08002278
 80018ec:	08002284 	.word	0x08002284
 80018f0:	0800228c 	.word	0x0800228c
 80018f4:	08002298 	.word	0x08002298
 80018f8:	080022a0 	.word	0x080022a0
 80018fc:	20000cdc 	.word	0x20000cdc
 8001900:	20000600 	.word	0x20000600
 8001904:	20000a00 	.word	0x20000a00
 8001908:	08002070 	.word	0x08002070
 800190c:	0000c350 	.word	0x0000c350

08001910 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8001910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8001912:	4be7      	ldr	r3, [pc, #924]	; (8001cb0 <main+0x3a0>)
 8001914:	465f      	mov	r7, fp
 8001916:	4656      	mov	r6, sl
 8001918:	464d      	mov	r5, r9
 800191a:	4644      	mov	r4, r8
 800191c:	2101      	movs	r1, #1
 800191e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001920:	b4f0      	push	{r4, r5, r6, r7}
 8001922:	2200      	movs	r2, #0
 8001924:	424c      	negs	r4, r1
 8001926:	629c      	str	r4, [r3, #40]	; 0x28
 8001928:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 800192a:	6918      	ldr	r0, [r3, #16]
 800192c:	611c      	str	r4, [r3, #16]
 800192e:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001930:	68dd      	ldr	r5, [r3, #12]
 8001932:	48e0      	ldr	r0, [pc, #896]	; (8001cb4 <main+0x3a4>)

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001934:	2780      	movs	r7, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001936:	4305      	orrs	r5, r0
 8001938:	60dd      	str	r5, [r3, #12]
 800193a:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800193c:	69de      	ldr	r6, [r3, #28]
 800193e:	0579      	lsls	r1, r7, #21
 8001940:	4331      	orrs	r1, r6
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001942:	4ddd      	ldr	r5, [pc, #884]	; (8001cb8 <main+0x3a8>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001944:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001946:	682c      	ldr	r4, [r5, #0]
 8001948:	2080      	movs	r0, #128	; 0x80
 800194a:	0046      	lsls	r6, r0, #1
 800194c:	4326      	orrs	r6, r4
 800194e:	602e      	str	r6, [r5, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8001950:	6a1f      	ldr	r7, [r3, #32]
 8001952:	21c0      	movs	r1, #192	; 0xc0
 8001954:	008d      	lsls	r5, r1, #2
 8001956:	2480      	movs	r4, #128	; 0x80
 8001958:	402f      	ands	r7, r5
 800195a:	00a0      	lsls	r0, r4, #2
 800195c:	4287      	cmp	r7, r0
 800195e:	d003      	beq.n	8001968 <main+0x58>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001960:	2680      	movs	r6, #128	; 0x80
 8001962:	0277      	lsls	r7, r6, #9
 8001964:	621f      	str	r7, [r3, #32]
    RCC->BDCR = 0;
 8001966:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8001968:	4bd1      	ldr	r3, [pc, #836]	; (8001cb0 <main+0x3a0>)
 800196a:	2280      	movs	r2, #128	; 0x80
 800196c:	6a19      	ldr	r1, [r3, #32]
 800196e:	0215      	lsls	r5, r2, #8
 8001970:	4229      	tst	r1, r5
 8001972:	d107      	bne.n	8001984 <main+0x74>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8001974:	6a1c      	ldr	r4, [r3, #32]
 8001976:	2080      	movs	r0, #128	; 0x80
 8001978:	0086      	lsls	r6, r0, #2
 800197a:	4326      	orrs	r6, r4
 800197c:	621e      	str	r6, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800197e:	6a1f      	ldr	r7, [r3, #32]
 8001980:	433d      	orrs	r5, r7
 8001982:	621d      	str	r5, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001984:	48ca      	ldr	r0, [pc, #808]	; (8001cb0 <main+0x3a0>)
 8001986:	23fc      	movs	r3, #252	; 0xfc
 8001988:	6941      	ldr	r1, [r0, #20]
 800198a:	03da      	lsls	r2, r3, #15
 800198c:	430a      	orrs	r2, r1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800198e:	2590      	movs	r5, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
 8001990:	24fc      	movs	r4, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
 8001992:	49ca      	ldr	r1, [pc, #808]	; (8001cbc <main+0x3ac>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001994:	2300      	movs	r3, #0
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001996:	6142      	str	r2, [r0, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001998:	05ee      	lsls	r6, r5, #23
  gpiop->OSPEEDR = config->ospeedr;
 800199a:	0627      	lsls	r7, r4, #24
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800199c:	4dc8      	ldr	r5, [pc, #800]	; (8001cc0 <main+0x3b0>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800199e:	22a0      	movs	r2, #160	; 0xa0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019a0:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80019a2:	0594      	lsls	r4, r2, #22
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80019a4:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80019a6:	60f1      	str	r1, [r6, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019a8:	4fc6      	ldr	r7, [pc, #792]	; (8001cc4 <main+0x3b4>)
  gpiop->OSPEEDR = config->ospeedr;
 80019aa:	21fc      	movs	r1, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80019ac:	6175      	str	r5, [r6, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80019ae:	008a      	lsls	r2, r1, #2
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80019b0:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80019b2:	21a8      	movs	r1, #168	; 0xa8
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80019b4:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80019b6:	6034      	str	r4, [r6, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80019b8:	4cc3      	ldr	r4, [pc, #780]	; (8001cc8 <main+0x3b8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019ba:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80019bc:	60ba      	str	r2, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80019be:	060a      	lsls	r2, r1, #24

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80019c0:	60fc      	str	r4, [r7, #12]
  gpiop->ODR     = config->odr;
 80019c2:	617d      	str	r5, [r7, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80019c4:	4cc1      	ldr	r4, [pc, #772]	; (8001ccc <main+0x3bc>)
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80019c6:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80019c8:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80019ca:	603a      	str	r2, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019cc:	4fc0      	ldr	r7, [pc, #768]	; (8001cd0 <main+0x3c0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80019ce:	49c1      	ldr	r1, [pc, #772]	; (8001cd4 <main+0x3c4>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019d0:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80019d2:	4ac1      	ldr	r2, [pc, #772]	; (8001cd8 <main+0x3c8>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80019d4:	60bc      	str	r4, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80019d6:	4cc1      	ldr	r4, [pc, #772]	; (8001cdc <main+0x3cc>)

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80019d8:	60f9      	str	r1, [r7, #12]
  gpiop->ODR     = config->odr;
 80019da:	617a      	str	r2, [r7, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80019dc:	49c0      	ldr	r1, [pc, #768]	; (8001ce0 <main+0x3d0>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80019de:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80019e0:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80019e2:	603c      	str	r4, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019e4:	4fbf      	ldr	r7, [pc, #764]	; (8001ce4 <main+0x3d4>)
 80019e6:	4ac0      	ldr	r2, [pc, #768]	; (8001ce8 <main+0x3d8>)
 80019e8:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80019ea:	4cc0      	ldr	r4, [pc, #768]	; (8001cec <main+0x3dc>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80019ec:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80019ee:	60f9      	str	r1, [r7, #12]
  gpiop->ODR     = config->odr;
 80019f0:	617d      	str	r5, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80019f2:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80019f4:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80019f6:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80019f8:	4fbd      	ldr	r7, [pc, #756]	; (8001cf0 <main+0x3e0>)
 80019fa:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80019fc:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80019fe:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8001a00:	6155      	str	r5, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8001a02:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8001a04:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001a06:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001a08:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001a0a:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001a0c:	60fc      	str	r4, [r7, #12]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8001a0e:	4cb9      	ldr	r4, [pc, #740]	; (8001cf4 <main+0x3e4>)
  gpiop->ODR     = config->odr;
 8001a10:	617d      	str	r5, [r7, #20]
 8001a12:	4db9      	ldr	r5, [pc, #740]	; (8001cf8 <main+0x3e8>)
 8001a14:	1c21      	adds	r1, r4, #0
  gpiop->AFRL    = config->afrl;
 8001a16:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8001a18:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001a1a:	603b      	str	r3, [r7, #0]
 8001a1c:	c120      	stmia	r1!, {r5}
 8001a1e:	46ab      	mov	fp, r5
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8001a20:	6061      	str	r1, [r4, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001a22:	2701      	movs	r7, #1
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8001a24:	22ca      	movs	r2, #202	; 0xca
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001a26:	1c25      	adds	r5, r4, #0
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001a28:	1c21      	adds	r1, r4, #0
 8001a2a:	3154      	adds	r1, #84	; 0x54
 8001a2c:	350c      	adds	r5, #12
 8001a2e:	7227      	strb	r7, [r4, #8]
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8001a30:	0057      	lsls	r7, r2, #1
 8001a32:	60e5      	str	r5, [r4, #12]
  tqp->p_prev = (thread_t *)tqp;
 8001a34:	6125      	str	r5, [r4, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001a36:	61a1      	str	r1, [r4, #24]
  iqp->q_rdptr   = bp;
 8001a38:	6261      	str	r1, [r4, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001a3a:	6221      	str	r1, [r4, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001a3c:	1c25      	adds	r5, r4, #0
  iqp->q_top     = bp + size;
 8001a3e:	19e1      	adds	r1, r4, r7
 8001a40:	3530      	adds	r5, #48	; 0x30
 8001a42:	61e1      	str	r1, [r4, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8001a44:	63e1      	str	r1, [r4, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8001a46:	64a1      	str	r1, [r4, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001a48:	6461      	str	r1, [r4, #68]	; 0x44
  oqp->q_top     = bp + size;
 8001a4a:	21b5      	movs	r1, #181	; 0xb5
 8001a4c:	6325      	str	r5, [r4, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8001a4e:	6365      	str	r5, [r4, #52]	; 0x34
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001a50:	22a0      	movs	r2, #160	; 0xa0
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001a52:	008d      	lsls	r5, r1, #2
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001a54:	0057      	lsls	r7, r2, #1
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001a56:	1962      	adds	r2, r4, r5
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001a58:	6163      	str	r3, [r4, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001a5a:	46ba      	mov	sl, r7
 8001a5c:	63a7      	str	r7, [r4, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001a5e:	6422      	str	r2, [r4, #64]	; 0x40
  oqp->q_notify  = onfy;
 8001a60:	4fa6      	ldr	r7, [pc, #664]	; (8001cfc <main+0x3ec>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8001a62:	21b5      	movs	r1, #181	; 0xb5
 8001a64:	4aa6      	ldr	r2, [pc, #664]	; (8001d00 <main+0x3f0>)
 8001a66:	008d      	lsls	r5, r1, #2
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001a68:	62a3      	str	r3, [r4, #40]	; 0x28
  SD1.clock = STM32_USART1CLK;
 8001a6a:	49a6      	ldr	r1, [pc, #664]	; (8001d04 <main+0x3f4>)
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8001a6c:	64e7      	str	r7, [r4, #76]	; 0x4c
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8001a6e:	62e4      	str	r4, [r4, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8001a70:	6524      	str	r4, [r4, #80]	; 0x50
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8001a72:	5162      	str	r2, [r4, r5]
  SD1.clock = STM32_USART1CLK;
 8001a74:	22b6      	movs	r2, #182	; 0xb6
 8001a76:	0097      	lsls	r7, r2, #2
 8001a78:	51e1      	str	r1, [r4, r7]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001a7a:	4aa3      	ldr	r2, [pc, #652]	; (8001d08 <main+0x3f8>)
 8001a7c:	4688      	mov	r8, r1
 8001a7e:	21c6      	movs	r1, #198	; 0xc6
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8001a80:	46a9      	mov	r9, r5
 8001a82:	008d      	lsls	r5, r1, #2
 8001a84:	5957      	ldr	r7, [r2, r5]
 8001a86:	0239      	lsls	r1, r7, #8
 8001a88:	27c0      	movs	r7, #192	; 0xc0
 8001a8a:	063f      	lsls	r7, r7, #24
 8001a8c:	0a09      	lsrs	r1, r1, #8
 8001a8e:	4339      	orrs	r1, r7
 8001a90:	5151      	str	r1, [r2, r5]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001a92:	2780      	movs	r7, #128	; 0x80
 8001a94:	25c0      	movs	r5, #192	; 0xc0
 8001a96:	0069      	lsls	r1, r5, #1
 8001a98:	053d      	lsls	r5, r7, #20
 8001a9a:	5055      	str	r5, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001a9c:	6015      	str	r5, [r2, #0]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8001a9e:	4d9b      	ldr	r5, [pc, #620]	; (8001d0c <main+0x3fc>)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001aa0:	468c      	mov	ip, r1
 8001aa2:	465f      	mov	r7, fp
 8001aa4:	1c29      	adds	r1, r5, #0
 8001aa6:	c180      	stmia	r1!, {r7}
 8001aa8:	6069      	str	r1, [r5, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001aaa:	1c2f      	adds	r7, r5, #0
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001aac:	2101      	movs	r1, #1
 8001aae:	7229      	strb	r1, [r5, #8]
 8001ab0:	370c      	adds	r7, #12
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001ab2:	1c29      	adds	r1, r5, #0
 8001ab4:	3154      	adds	r1, #84	; 0x54
 8001ab6:	60ef      	str	r7, [r5, #12]
  tqp->p_prev = (thread_t *)tqp;
 8001ab8:	612f      	str	r7, [r5, #16]
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8001aba:	27ca      	movs	r7, #202	; 0xca
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001abc:	61a9      	str	r1, [r5, #24]
  iqp->q_rdptr   = bp;
 8001abe:	6269      	str	r1, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001ac0:	6229      	str	r1, [r5, #32]
  iqp->q_top     = bp + size;
 8001ac2:	0079      	lsls	r1, r7, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001ac4:	2730      	movs	r7, #48	; 0x30
 8001ac6:	1869      	adds	r1, r5, r1
 8001ac8:	197f      	adds	r7, r7, r5
 8001aca:	61e9      	str	r1, [r5, #28]
 8001acc:	632f      	str	r7, [r5, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8001ace:	636f      	str	r7, [r5, #52]	; 0x34
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8001ad0:	63e9      	str	r1, [r5, #60]	; 0x3c
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001ad2:	4657      	mov	r7, sl
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
 8001ad4:	64a9      	str	r1, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001ad6:	6469      	str	r1, [r5, #68]	; 0x44
  oqp->q_top     = bp + size;
 8001ad8:	21b5      	movs	r1, #181	; 0xb5
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001ada:	616b      	str	r3, [r5, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001adc:	63af      	str	r7, [r5, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001ade:	008f      	lsls	r7, r1, #2
 8001ae0:	19e9      	adds	r1, r5, r7
  oqp->q_notify  = onfy;
 8001ae2:	4f8b      	ldr	r7, [pc, #556]	; (8001d10 <main+0x400>)
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001ae4:	6429      	str	r1, [r5, #64]	; 0x40
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001ae6:	498b      	ldr	r1, [pc, #556]	; (8001d14 <main+0x404>)
  oqp->q_notify  = onfy;
 8001ae8:	64ef      	str	r7, [r5, #76]	; 0x4c
 8001aea:	464f      	mov	r7, r9
 8001aec:	51e9      	str	r1, [r5, r7]
  SD2.clock = STM32_USART2CLK;
 8001aee:	21b6      	movs	r1, #182	; 0xb6
 8001af0:	4647      	mov	r7, r8
 8001af2:	0089      	lsls	r1, r1, #2
 8001af4:	506f      	str	r7, [r5, r1]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001af6:	27c7      	movs	r7, #199	; 0xc7
 8001af8:	00b9      	lsls	r1, r7, #2
 8001afa:	5857      	ldr	r7, [r2, r1]
 8001afc:	468b      	mov	fp, r1
 8001afe:	46ba      	mov	sl, r7
 8001b00:	4651      	mov	r1, sl
 8001b02:	27ff      	movs	r7, #255	; 0xff
 8001b04:	43b9      	bics	r1, r7
 8001b06:	4689      	mov	r9, r1
 8001b08:	464f      	mov	r7, r9
 8001b0a:	21c0      	movs	r1, #192	; 0xc0
 8001b0c:	430f      	orrs	r7, r1
 8001b0e:	4659      	mov	r1, fp
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001b10:	62ab      	str	r3, [r5, #40]	; 0x28
  iqp->q_link    = link;
 8001b12:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8001b14:	652d      	str	r5, [r5, #80]	; 0x50
 8001b16:	5057      	str	r7, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001b18:	2780      	movs	r7, #128	; 0x80
 8001b1a:	057f      	lsls	r7, r7, #21
 8001b1c:	4661      	mov	r1, ip
 8001b1e:	5057      	str	r7, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001b20:	6017      	str	r7, [r2, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001b22:	69c7      	ldr	r7, [r0, #28]
 8001b24:	2101      	movs	r1, #1
 8001b26:	430f      	orrs	r7, r1
 8001b28:	61c7      	str	r7, [r0, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001b2a:	487b      	ldr	r0, [pc, #492]	; (8001d18 <main+0x408>)
 8001b2c:	6887      	ldr	r7, [r0, #8]
 8001b2e:	430f      	orrs	r7, r1
 8001b30:	6087      	str	r7, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001b32:	4f7a      	ldr	r7, [pc, #488]	; (8001d1c <main+0x40c>)
 8001b34:	2080      	movs	r0, #128	; 0x80
 8001b36:	05c0      	lsls	r0, r0, #23
 8001b38:	6287      	str	r7, [r0, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001b3a:	2701      	movs	r7, #1
 8001b3c:	427f      	negs	r7, r7
 8001b3e:	62c7      	str	r7, [r0, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001b40:	6183      	str	r3, [r0, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001b42:	6343      	str	r3, [r0, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001b44:	60c3      	str	r3, [r0, #12]
  STM32_ST_TIM->CR2    = 0;
 8001b46:	6043      	str	r3, [r0, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001b48:	6141      	str	r1, [r0, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001b4a:	6001      	str	r1, [r0, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001b4c:	21c3      	movs	r1, #195	; 0xc3
 8001b4e:	0088      	lsls	r0, r1, #2
 8001b50:	5811      	ldr	r1, [r2, r0]
 8001b52:	4683      	mov	fp, r0
 8001b54:	0209      	lsls	r1, r1, #8
 8001b56:	0a08      	lsrs	r0, r1, #8
 8001b58:	4682      	mov	sl, r0
 8001b5a:	2180      	movs	r1, #128	; 0x80
 8001b5c:	0608      	lsls	r0, r1, #24
 8001b5e:	4651      	mov	r1, sl
 8001b60:	4308      	orrs	r0, r1
 8001b62:	4659      	mov	r1, fp
 8001b64:	5050      	str	r0, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001b66:	2080      	movs	r0, #128	; 0x80
 8001b68:	0200      	lsls	r0, r0, #8
 8001b6a:	4661      	mov	r1, ip
 8001b6c:	5050      	str	r0, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001b6e:	6010      	str	r0, [r2, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001b70:	4a6b      	ldr	r2, [pc, #428]	; (8001d20 <main+0x410>)
 8001b72:	6a10      	ldr	r0, [r2, #32]
 8001b74:	4684      	mov	ip, r0
 8001b76:	486b      	ldr	r0, [pc, #428]	; (8001d24 <main+0x414>)
 8001b78:	4661      	mov	r1, ip
 8001b7a:	4008      	ands	r0, r1
 8001b7c:	6210      	str	r0, [r2, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001b7e:	486a      	ldr	r0, [pc, #424]	; (8001d28 <main+0x418>)
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001b80:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001b82:	1c02      	adds	r2, r0, #0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001b84:	4f69      	ldr	r7, [pc, #420]	; (8001d2c <main+0x41c>)
 8001b86:	321c      	adds	r2, #28
 8001b88:	61c2      	str	r2, [r0, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001b8a:	6202      	str	r2, [r0, #32]
 8001b8c:	3707      	adds	r7, #7
 8001b8e:	2207      	movs	r2, #7
 8001b90:	4397      	bics	r7, r2
 8001b92:	46bb      	mov	fp, r7
 8001b94:	4f66      	ldr	r7, [pc, #408]	; (8001d30 <main+0x420>)
 8001b96:	4659      	mov	r1, fp
 8001b98:	6039      	str	r1, [r7, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001b9a:	4f66      	ldr	r7, [pc, #408]	; (8001d34 <main+0x424>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001b9c:	4966      	ldr	r1, [pc, #408]	; (8001d38 <main+0x428>)
 8001b9e:	4397      	bics	r7, r2
 8001ba0:	4a66      	ldr	r2, [pc, #408]	; (8001d3c <main+0x42c>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001ba2:	6083      	str	r3, [r0, #8]
 8001ba4:	6017      	str	r7, [r2, #0]
 8001ba6:	4f66      	ldr	r7, [pc, #408]	; (8001d40 <main+0x430>)
 8001ba8:	1c0a      	adds	r2, r1, #0
 8001baa:	3210      	adds	r2, #16
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8001bac:	6283      	str	r3, [r0, #40]	; 0x28
 8001bae:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001bb0:	6040      	str	r0, [r0, #4]
 8001bb2:	600f      	str	r7, [r1, #0]
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8001bb4:	1c07      	adds	r7, r0, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001bb6:	610a      	str	r2, [r1, #16]
  tqp->p_prev = (thread_t *)tqp;
 8001bb8:	614a      	str	r2, [r1, #20]
 8001bba:	3740      	adds	r7, #64	; 0x40
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001bbc:	2289      	movs	r2, #137	; 0x89
  default_heap.h_free.h.u.next = NULL;
 8001bbe:	608b      	str	r3, [r1, #8]
  default_heap.h_free.h.size = 0;
 8001bc0:	60cb      	str	r3, [r1, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8001bc2:	618b      	str	r3, [r1, #24]
 8001bc4:	63c7      	str	r7, [r0, #60]	; 0x3c
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8001bc6:	2140      	movs	r1, #64	; 0x40
 8001bc8:	00d7      	lsls	r7, r2, #3
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001bca:	4a5e      	ldr	r2, [pc, #376]	; (8001d44 <main+0x434>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001bcc:	51c1      	str	r1, [r0, r7]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001bce:	2790      	movs	r7, #144	; 0x90
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001bd0:	5483      	strb	r3, [r0, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001bd2:	00fa      	lsls	r2, r7, #3
 8001bd4:	5081      	str	r1, [r0, r2]
 8001bd6:	6381      	str	r1, [r0, #56]	; 0x38
  tp->p_mtxlist = NULL;
 8001bd8:	495b      	ldr	r1, [pc, #364]	; (8001d48 <main+0x438>)
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001bda:	278f      	movs	r7, #143	; 0x8f
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001bdc:	5043      	str	r3, [r0, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001bde:	00fa      	lsls	r2, r7, #3
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001be0:	495a      	ldr	r1, [pc, #360]	; (8001d4c <main+0x43c>)
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001be2:	5083      	str	r3, [r0, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001be4:	2701      	movs	r7, #1
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001be6:	228b      	movs	r2, #139	; 0x8b
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001be8:	5447      	strb	r7, [r0, r1]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001bea:	00d1      	lsls	r1, r2, #3
 8001bec:	5043      	str	r3, [r0, r1]
  REG_INSERT(tp);
 8001bee:	238a      	movs	r3, #138	; 0x8a
 8001bf0:	00df      	lsls	r7, r3, #3
 8001bf2:	4a57      	ldr	r2, [pc, #348]	; (8001d50 <main+0x440>)
 8001bf4:	2188      	movs	r1, #136	; 0x88
 8001bf6:	51c0      	str	r0, [r0, r7]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001bf8:	278d      	movs	r7, #141	; 0x8d
 8001bfa:	5080      	str	r0, [r0, r2]
 8001bfc:	00cb      	lsls	r3, r1, #3
 8001bfe:	00fa      	lsls	r2, r7, #3
 8001c00:	278d      	movs	r7, #141	; 0x8d
 8001c02:	18c1      	adds	r1, r0, r3
 8001c04:	1883      	adds	r3, r0, r2
 8001c06:	00fa      	lsls	r2, r7, #3
 8001c08:	5083      	str	r3, [r0, r2]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001c0a:	4b52      	ldr	r3, [pc, #328]	; (8001d54 <main+0x444>)
  tqp->p_prev = (thread_t *)tqp;
 8001c0c:	278e      	movs	r7, #142	; 0x8e
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001c0e:	18c2      	adds	r2, r0, r3
 8001c10:	50c2      	str	r2, [r0, r3]
 8001c12:	6101      	str	r1, [r0, #16]
  tqp->p_prev = (thread_t *)tqp;
 8001c14:	00fb      	lsls	r3, r7, #3
 8001c16:	6141      	str	r1, [r0, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8001c18:	6181      	str	r1, [r0, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8001c1a:	218c      	movs	r1, #140	; 0x8c
 8001c1c:	50c2      	str	r2, [r0, r3]
 8001c1e:	2701      	movs	r7, #1
 8001c20:	00ca      	lsls	r2, r1, #3
 8001c22:	5487      	strb	r7, [r0, r2]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8001c24:	494c      	ldr	r1, [pc, #304]	; (8001d58 <main+0x448>)
 8001c26:	4b4d      	ldr	r3, [pc, #308]	; (8001d5c <main+0x44c>)
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001c28:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8001c2a:	50c1      	str	r1, [r0, r3]
 8001c2c:	2a00      	cmp	r2, #0
 8001c2e:	d102      	bne.n	8001c36 <main+0x326>
 8001c30:	6b47      	ldr	r7, [r0, #52]	; 0x34
 8001c32:	2f00      	cmp	r7, #0
 8001c34:	d003      	beq.n	8001c3e <main+0x32e>
 8001c36:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001c38:	4f49      	ldr	r7, [pc, #292]	; (8001d60 <main+0x450>)
 8001c3a:	62c7      	str	r7, [r0, #44]	; 0x2c
 8001c3c:	e7fe      	b.n	8001c3c <main+0x32c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c3e:	b662      	cpsie	i
 8001c40:	4b48      	ldr	r3, [pc, #288]	; (8001d64 <main+0x454>)
 8001c42:	6981      	ldr	r1, [r0, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8001c44:	2291      	movs	r2, #145	; 0x91
 8001c46:	00d7      	lsls	r7, r2, #3
 8001c48:	618b      	str	r3, [r1, #24]
 8001c4a:	2201      	movs	r2, #1
 8001c4c:	21e0      	movs	r1, #224	; 0xe0
 8001c4e:	4b46      	ldr	r3, [pc, #280]	; (8001d68 <main+0x458>)
 8001c50:	19c0      	adds	r0, r0, r7
 8001c52:	f7ff fc9d 	bl	8001590 <chThdCreateStatic.constprop.15>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8001c56:	4945      	ldr	r1, [pc, #276]	; (8001d6c <main+0x45c>)
  chSysInit();

  /* Initialize connection to STN1110 on SD2
   */
  static SerialConfig stn_uart_cfg;
  stn_uart_cfg.speed=9600;
 8001c58:	4b45      	ldr	r3, [pc, #276]	; (8001d70 <main+0x460>)
 8001c5a:	6181      	str	r1, [r0, #24]
 8001c5c:	2096      	movs	r0, #150	; 0x96
 8001c5e:	0182      	lsls	r2, r0, #6
 8001c60:	601a      	str	r2, [r3, #0]

  /* USART2 TX.       */
  palSetPadMode(GPIOA, 2, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_HIGHEST | PAL_STM32_ALTERNATE(1));
 8001c62:	1c30      	adds	r0, r6, #0
 8001c64:	2104      	movs	r1, #4
 8001c66:	229a      	movs	r2, #154	; 0x9a
 8001c68:	f7ff f8fa 	bl	8000e60 <_pal_lld_setgroupmode>

  /* USART2 RX.       */
  palSetPadMode(GPIOA, 3, PAL_STM32_MODE_ALTERNATE | PAL_STM32_PUPDR_PULLUP | PAL_STM32_ALTERNATE(1));
 8001c6c:	1c30      	adds	r0, r6, #0
 8001c6e:	2108      	movs	r1, #8
 8001c70:	22a2      	movs	r2, #162	; 0xa2
 8001c72:	f7ff f8f5 	bl	8000e60 <_pal_lld_setgroupmode>

  sdStart(&SD2, NULL);
 8001c76:	1c28      	adds	r0, r5, #0

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8001c78:	2580      	movs	r5, #128	; 0x80
  palSetPadMode(GPIOA, 2, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_HIGHEST | PAL_STM32_ALTERNATE(1));

  /* USART2 RX.       */
  palSetPadMode(GPIOA, 3, PAL_STM32_MODE_ALTERNATE | PAL_STM32_PUPDR_PULLUP | PAL_STM32_ALTERNATE(1));

  sdStart(&SD2, NULL);
 8001c7a:	f7ff fd69 	bl	8001750 <sdStart.constprop.4>

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8001c7e:	1c30      	adds	r0, r6, #0
 8001c80:	00a9      	lsls	r1, r5, #2
 8001c82:	2282      	movs	r2, #130	; 0x82
 8001c84:	f7ff f8ec 	bl	8000e60 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 8001c88:	1c30      	adds	r0, r6, #0
 8001c8a:	2680      	movs	r6, #128	; 0x80
 8001c8c:	00f1      	lsls	r1, r6, #3
 8001c8e:	2282      	movs	r2, #130	; 0x82
 8001c90:	f7ff f8e6 	bl	8000e60 <_pal_lld_setgroupmode>
  sdStart(&SD1, NULL);
 8001c94:	1c20      	adds	r0, r4, #0


  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 8001c96:	24a8      	movs	r4, #168	; 0xa8
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
  sdStart(&SD1, NULL);
 8001c98:	f7ff fd5a 	bl	8001750 <sdStart.constprop.4>


  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 8001c9c:	4835      	ldr	r0, [pc, #212]	; (8001d74 <main+0x464>)
 8001c9e:	0061      	lsls	r1, r4, #1
 8001ca0:	2240      	movs	r2, #64	; 0x40
 8001ca2:	4b35      	ldr	r3, [pc, #212]	; (8001d78 <main+0x468>)
 8001ca4:	f7ff fc74 	bl	8001590 <chThdCreateStatic.constprop.15>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched with output on the serial
   * driver 1.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 8001ca8:	4834      	ldr	r0, [pc, #208]	; (8001d7c <main+0x46c>)
 8001caa:	f7ff fb89 	bl	80013c0 <chThdSleep>
 8001cae:	e7fb      	b.n	8001ca8 <main+0x398>
 8001cb0:	40021000 	.word	0x40021000
 8001cb4:	ffbfffff 	.word	0xffbfffff
 8001cb8:	40007000 	.word	0x40007000
 8001cbc:	64155554 	.word	0x64155554
 8001cc0:	0000ffff 	.word	0x0000ffff
 8001cc4:	48000400 	.word	0x48000400
 8001cc8:	01555555 	.word	0x01555555
 8001ccc:	f00ff003 	.word	0xf00ff003
 8001cd0:	48000800 	.word	0x48000800
 8001cd4:	05500554 	.word	0x05500554
 8001cd8:	0000fc3f 	.word	0x0000fc3f
 8001cdc:	00055001 	.word	0x00055001
 8001ce0:	55555555 	.word	0x55555555
 8001ce4:	48000c00 	.word	0x48000c00
 8001ce8:	48001000 	.word	0x48001000
 8001cec:	55555550 	.word	0x55555550
 8001cf0:	48001400 	.word	0x48001400
 8001cf4:	20000a00 	.word	0x20000a00
 8001cf8:	08002240 	.word	0x08002240
 8001cfc:	08000451 	.word	0x08000451
 8001d00:	40013800 	.word	0x40013800
 8001d04:	02dc6c00 	.word	0x02dc6c00
 8001d08:	e000e100 	.word	0xe000e100
 8001d0c:	20000cdc 	.word	0x20000cdc
 8001d10:	08000441 	.word	0x08000441
 8001d14:	40004400 	.word	0x40004400
 8001d18:	40015800 	.word	0x40015800
 8001d1c:	000012bf 	.word	0x000012bf
 8001d20:	e000ed00 	.word	0xe000ed00
 8001d24:	ff00ffff 	.word	0xff00ffff
 8001d28:	20000fc0 	.word	0x20000fc0
 8001d2c:	200016b0 	.word	0x200016b0
 8001d30:	20000fb8 	.word	0x20000fb8
 8001d34:	20004000 	.word	0x20004000
 8001d38:	20001540 	.word	0x20001540
 8001d3c:	20001528 	.word	0x20001528
 8001d40:	080016f1 	.word	0x080016f1
 8001d44:	00000461 	.word	0x00000461
 8001d48:	0000047c 	.word	0x0000047c
 8001d4c:	00000462 	.word	0x00000462
 8001d50:	00000454 	.word	0x00000454
 8001d54:	0000046c 	.word	0x0000046c
 8001d58:	20000400 	.word	0x20000400
 8001d5c:	0000045c 	.word	0x0000045c
 8001d60:	080022b8 	.word	0x080022b8
 8001d64:	080022e0 	.word	0x080022e0
 8001d68:	080004b1 	.word	0x080004b1
 8001d6c:	080022c0 	.word	0x080022c0
 8001d70:	2000152c 	.word	0x2000152c
 8001d74:	20001560 	.word	0x20001560
 8001d78:	08001841 	.word	0x08001841
 8001d7c:	00001388 	.word	0x00001388

08001d80 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001d80:	4827      	ldr	r0, [pc, #156]	; (8001e20 <__early_init+0xa0>)
 8001d82:	2301      	movs	r3, #1
 8001d84:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001d86:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001d88:	4313      	orrs	r3, r2
 8001d8a:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001d8c:	6803      	ldr	r3, [r0, #0]
 8001d8e:	4a24      	ldr	r2, [pc, #144]	; (8001e20 <__early_init+0xa0>)
 8001d90:	4219      	tst	r1, r3
 8001d92:	d0fb      	beq.n	8001d8c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001d94:	6850      	ldr	r0, [r2, #4]
 8001d96:	2103      	movs	r1, #3
 8001d98:	4388      	bics	r0, r1
 8001d9a:	6050      	str	r0, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001d9c:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001d9e:	1c10      	adds	r0, r2, #0

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001da0:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001da2:	210c      	movs	r1, #12
 8001da4:	6843      	ldr	r3, [r0, #4]
 8001da6:	4a1e      	ldr	r2, [pc, #120]	; (8001e20 <__early_init+0xa0>)
 8001da8:	400b      	ands	r3, r1
 8001daa:	d1fb      	bne.n	8001da4 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001dac:	6811      	ldr	r1, [r2, #0]
 8001dae:	20f9      	movs	r0, #249	; 0xf9
 8001db0:	4001      	ands	r1, r0
 8001db2:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001db4:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001db6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001db8:	2301      	movs	r3, #1
 8001dba:	430b      	orrs	r3, r1
 8001dbc:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8001dbe:	2002      	movs	r0, #2
 8001dc0:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001dc2:	4917      	ldr	r1, [pc, #92]	; (8001e20 <__early_init+0xa0>)
 8001dc4:	4218      	tst	r0, r3
 8001dc6:	d0fb      	beq.n	8001dc0 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001dc8:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8001dca:	2001      	movs	r0, #1
 8001dcc:	4310      	orrs	r0, r2
 8001dce:	6248      	str	r0, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001dd0:	2002      	movs	r0, #2
 8001dd2:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001dd4:	4a12      	ldr	r2, [pc, #72]	; (8001e20 <__early_init+0xa0>)
 8001dd6:	4218      	tst	r0, r3
 8001dd8:	d0fb      	beq.n	8001dd2 <__early_init+0x52>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001dda:	21a0      	movs	r1, #160	; 0xa0
 8001ddc:	0388      	lsls	r0, r1, #14
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8001dde:	2300      	movs	r3, #0
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001de0:	6050      	str	r0, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8001de2:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8001de4:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001de6:	6811      	ldr	r1, [r2, #0]
 8001de8:	2080      	movs	r0, #128	; 0x80
 8001dea:	0443      	lsls	r3, r0, #17
 8001dec:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001dee:	2180      	movs	r1, #128	; 0x80
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001df0:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001df2:	0488      	lsls	r0, r1, #18
 8001df4:	6813      	ldr	r3, [r2, #0]
 8001df6:	490a      	ldr	r1, [pc, #40]	; (8001e20 <__early_init+0xa0>)
 8001df8:	4203      	tst	r3, r0
 8001dfa:	d0fb      	beq.n	8001df4 <__early_init+0x74>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001dfc:	4809      	ldr	r0, [pc, #36]	; (8001e24 <__early_init+0xa4>)
 8001dfe:	2211      	movs	r2, #17
 8001e00:	6002      	str	r2, [r0, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001e02:	684a      	ldr	r2, [r1, #4]
 8001e04:	2302      	movs	r3, #2
 8001e06:	4313      	orrs	r3, r2
 8001e08:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001e0a:	200c      	movs	r0, #12
 8001e0c:	684b      	ldr	r3, [r1, #4]
 8001e0e:	4a04      	ldr	r2, [pc, #16]	; (8001e20 <__early_init+0xa0>)
 8001e10:	4003      	ands	r3, r0
 8001e12:	2b08      	cmp	r3, #8
 8001e14:	d1fa      	bne.n	8001e0c <__early_init+0x8c>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001e16:	6991      	ldr	r1, [r2, #24]
 8001e18:	2001      	movs	r0, #1
 8001e1a:	4308      	orrs	r0, r1
 8001e1c:	6190      	str	r0, [r2, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 8001e1e:	4770      	bx	lr
 8001e20:	40021000 	.word	0x40021000
 8001e24:	40022000 	.word	0x40022000
 8001e28:	46c0      	nop			; (mov r8, r8)
 8001e2a:	46c0      	nop			; (mov r8, r8)
 8001e2c:	46c0      	nop			; (mov r8, r8)
 8001e2e:	46c0      	nop			; (mov r8, r8)

08001e30 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001e30:	b538      	push	{r3, r4, r5, lr}
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8001e32:	4d14      	ldr	r5, [pc, #80]	; (8001e84 <chSchDoReschedule+0x54>)
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001e34:	2120      	movs	r1, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001e36:	682a      	ldr	r2, [r5, #0]
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8001e38:	69ac      	ldr	r4, [r5, #24]

  tqp->p_next = tp->p_next;
 8001e3a:	6813      	ldr	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001e3c:	2001      	movs	r0, #1
 8001e3e:	5450      	strb	r0, [r2, r1]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e40:	605d      	str	r5, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001e42:	61aa      	str	r2, [r5, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001e44:	2200      	movs	r2, #0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001e46:	602b      	str	r3, [r5, #0]
 8001e48:	5462      	strb	r2, [r4, r1]
 8001e4a:	68a0      	ldr	r0, [r4, #8]
 8001e4c:	e000      	b.n	8001e50 <chSchDoReschedule+0x20>
 8001e4e:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8001e50:	6899      	ldr	r1, [r3, #8]
 8001e52:	4281      	cmp	r1, r0
 8001e54:	d8fb      	bhi.n	8001e4e <chSchDoReschedule+0x1e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001e56:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001e58:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 8001e5a:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 8001e5c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 8001e5e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
 8001e60:	1c20      	adds	r0, r4, #0
 8001e62:	f7ff f87d 	bl	8000f60 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001e66:	f3ef 8309 	mrs	r3, PSP
 8001e6a:	69e0      	ldr	r0, [r4, #28]
 8001e6c:	3b24      	subs	r3, #36	; 0x24
 8001e6e:	4298      	cmp	r0, r3
 8001e70:	d804      	bhi.n	8001e7c <chSchDoReschedule+0x4c>
 8001e72:	69a8      	ldr	r0, [r5, #24]
 8001e74:	1c21      	adds	r1, r4, #0
 8001e76:	f7fe f9ab 	bl	80001d0 <_port_switch>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8001e7a:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e7c:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001e7e:	4c02      	ldr	r4, [pc, #8]	; (8001e88 <chSchDoReschedule+0x58>)
 8001e80:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001e82:	e7fe      	b.n	8001e82 <chSchDoReschedule+0x52>
 8001e84:	20000fc0 	.word	0x20000fc0
 8001e88:	08002098 	.word	0x08002098
 8001e8c:	46c0      	nop			; (mov r8, r8)
 8001e8e:	46c0      	nop			; (mov r8, r8)

08001e90 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001e90:	b570      	push	{r4, r5, r6, lr}
 8001e92:	1c06      	adds	r6, r0, #0
 8001e94:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001e96:	f7fe fb33 	bl	8000500 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001e9a:	4d0f      	ldr	r5, [pc, #60]	; (8001ed8 <chThdExit+0x48>)
 8001e9c:	69ac      	ldr	r4, [r5, #24]

  tp->p_u.exitcode = msg;
 8001e9e:	6266      	str	r6, [r4, #36]	; 0x24
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001ea0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001ea2:	1c26      	adds	r6, r4, #0
 8001ea4:	3628      	adds	r6, #40	; 0x28
 8001ea6:	42b0      	cmp	r0, r6
 8001ea8:	d006      	beq.n	8001eb8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001eaa:	6803      	ldr	r3, [r0, #0]
 8001eac:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001eae:	f7fe fdf7 	bl	8000aa0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001eb2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001eb4:	42b0      	cmp	r0, r6
 8001eb6:	d1f8      	bne.n	8001eaa <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001eb8:	2021      	movs	r0, #33	; 0x21
 8001eba:	5c21      	ldrb	r1, [r4, r0]
 8001ebc:	078a      	lsls	r2, r1, #30
 8001ebe:	d104      	bne.n	8001eca <chThdExit+0x3a>
    REG_REMOVE(tp);
 8001ec0:	6966      	ldr	r6, [r4, #20]
 8001ec2:	6922      	ldr	r2, [r4, #16]
 8001ec4:	6132      	str	r2, [r6, #16]
 8001ec6:	6924      	ldr	r4, [r4, #16]
 8001ec8:	6166      	str	r6, [r4, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001eca:	200f      	movs	r0, #15
 8001ecc:	f7ff f868 	bl	8000fa0 <chSchGoSleepS>
 8001ed0:	b672      	cpsid	i
 8001ed2:	4b02      	ldr	r3, [pc, #8]	; (8001edc <chThdExit+0x4c>)
 8001ed4:	62eb      	str	r3, [r5, #44]	; 0x2c
 8001ed6:	e7fe      	b.n	8001ed6 <chThdExit+0x46>
 8001ed8:	20000fc0 	.word	0x20000fc0
 8001edc:	080022d0 	.word	0x080022d0

08001ee0 <strlen>:
 8001ee0:	2300      	movs	r3, #0
 8001ee2:	5cc2      	ldrb	r2, [r0, r3]
 8001ee4:	3301      	adds	r3, #1
 8001ee6:	2a00      	cmp	r2, #0
 8001ee8:	d1fb      	bne.n	8001ee2 <strlen+0x2>
 8001eea:	1e58      	subs	r0, r3, #1
 8001eec:	4770      	bx	lr
 8001eee:	46c0      	nop			; (mov r8, r8)
 8001ef0:	0800090c 	.word	0x0800090c
 8001ef4:	080006cc 	.word	0x080006cc
 8001ef8:	080006cc 	.word	0x080006cc
 8001efc:	080006cc 	.word	0x080006cc
 8001f00:	080006cc 	.word	0x080006cc
 8001f04:	0800090c 	.word	0x0800090c
 8001f08:	080006cc 	.word	0x080006cc
 8001f0c:	080006cc 	.word	0x080006cc
 8001f10:	080006cc 	.word	0x080006cc
 8001f14:	080006cc 	.word	0x080006cc
 8001f18:	080006cc 	.word	0x080006cc
 8001f1c:	08000908 	.word	0x08000908
 8001f20:	080006cc 	.word	0x080006cc
 8001f24:	080006cc 	.word	0x080006cc
 8001f28:	080006cc 	.word	0x080006cc
 8001f2c:	080006cc 	.word	0x080006cc
 8001f30:	080006cc 	.word	0x080006cc
 8001f34:	08000904 	.word	0x08000904
 8001f38:	080006cc 	.word	0x080006cc
 8001f3c:	080006cc 	.word	0x080006cc
 8001f40:	080008ec 	.word	0x080008ec
 8001f44:	080006cc 	.word	0x080006cc
 8001f48:	080006cc 	.word	0x080006cc
 8001f4c:	080006cc 	.word	0x080006cc
 8001f50:	080006cc 	.word	0x080006cc
 8001f54:	080006cc 	.word	0x080006cc
 8001f58:	080006cc 	.word	0x080006cc
 8001f5c:	080006cc 	.word	0x080006cc
 8001f60:	080006cc 	.word	0x080006cc
 8001f64:	080006cc 	.word	0x080006cc
 8001f68:	080006cc 	.word	0x080006cc
 8001f6c:	080008d4 	.word	0x080008d4
 8001f70:	0800090c 	.word	0x0800090c
 8001f74:	080006cc 	.word	0x080006cc
 8001f78:	080006cc 	.word	0x080006cc
 8001f7c:	080006cc 	.word	0x080006cc
 8001f80:	080006cc 	.word	0x080006cc
 8001f84:	0800090c 	.word	0x0800090c
 8001f88:	080006cc 	.word	0x080006cc
 8001f8c:	080006cc 	.word	0x080006cc
 8001f90:	080006cc 	.word	0x080006cc
 8001f94:	080006cc 	.word	0x080006cc
 8001f98:	080006cc 	.word	0x080006cc
 8001f9c:	08000908 	.word	0x08000908
 8001fa0:	080006cc 	.word	0x080006cc
 8001fa4:	080006cc 	.word	0x080006cc
 8001fa8:	080006cc 	.word	0x080006cc
 8001fac:	08000882 	.word	0x08000882
 8001fb0:	080006cc 	.word	0x080006cc
 8001fb4:	08000904 	.word	0x08000904
 8001fb8:	080006cc 	.word	0x080006cc
 8001fbc:	080006cc 	.word	0x080006cc
 8001fc0:	080008ec 	.word	0x080008ec
	...
 8001fd0:	08000b3c 	.word	0x08000b3c
 8001fd4:	08000b30 	.word	0x08000b30
 8001fd8:	08000b30 	.word	0x08000b30
 8001fdc:	08000b44 	.word	0x08000b44
 8001fe0:	08000b26 	.word	0x08000b26
 8001fe4:	08000b1a 	.word	0x08000b1a
 8001fe8:	08000b30 	.word	0x08000b30
 8001fec:	08000b26 	.word	0x08000b26

08001ff0 <__func__.5749.4850.4533>:
 8001ff0:	63536863 61655268 00497964 00000000     chSchReadyI.....

08002000 <__func__.5232.5087.4525>:
 8002000:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 8002010:	00497478 00000000 00000000 00000000     xtI.............

08002020 <__func__.6269.7348.4534>:
 8002020:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08002030 <__func__.5752.4588.4528>:
 8002030:	54566863 65536f44 00004974 00000000     chVTDoSetI......
 8002040:	36235653 00000000 37235653 00000000     SV#6....SV#7....
 8002050:	38235653 00000000 39235653 00000000     SV#8....SV#9....
 8002060:	35235653 00000000 34235653 00000000     SV#5....SV#4....
 8002070:	65747942 65722073 25206461 000a0d69     Bytes read %i...
 8002080:	6c756e28 0000296c 31235653 00000030     (null)..SV#10...
 8002090:	31235653 00000031 63617473 766f206b     SV#11...stack ov
 80020a0:	6c667265 0000776f 00000000 00000000     erflow..........

080020b0 <__func__.5769.6221.4531>:
 80020b0:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 80020c0:	49736761 00000000 00000000 00000000     agsI............

080020d0 <__func__.5786.6219.4532>:
 80020d0:	76456863 67695374 496c616e 00000000     chEvtSignalI....

080020e0 <ram_areas.4018.4485>:
 80020e0:	080026f8 200016b0 200016b0 200016b0     .&..... ... ... 
 80020f0:	080026f8 00000000 00000000 00000000     .&..............
 8002100:	080026f8 00000000 00000000 00000000     .&..............
 8002110:	080026f8 00000000 00000000 00000000     .&..............
 8002120:	080026f8 00000000 00000000 00000000     .&..............
 8002130:	080026f8 00000000 00000000 00000000     .&..............
 8002140:	080026f8 00000000 00000000 00000000     .&..............
 8002150:	080026f8 00000000 00000000 00000000     .&..............

08002160 <__func__.5135.4318.4530>:
 8002160:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

08002170 <__func__.6262.7347.4529>:
 8002170:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08002180 <__func__.5046.6803.4369>:
 8002180:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08002190 <__func__.6307.7947.4377>:
 8002190:	74536473 00747261 00000000 00000000     sdStart.........

080021a0 <__func__.5761.5091.4374>:
 80021a0:	68546863 65724364 49657461 00000000     chThdCreateI....

080021b0 <__func__.5220.5089.4372>:
 80021b0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

080021c0 <__func__.5046.7946.4379>:
 80021c0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080021d0 <__func__.5046.5090.4371>:
 80021d0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080021e0 <__func__.5772.6804.4321>:
 80021e0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.
 80021f0:	66757473 00203a66 00000000 00000000     stuff: .........

08002200 <__func__.5808.6805.4373>:
 8002200:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

08002220 <__func__.5046.6877.4376>:
 8002220:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08002230 <__func__.5777.4851.4375>:
 8002230:	63536863 6b615768 53707565 00000000     chSchWakeupS....

08002240 <vmt.7998.4558>:
 8002240:	08001581 08001831 08001301 080013b1     ....1...........
 8002250:	080012f1 080013a1 08001571 08001821     ........q...!...
 8002260:	314e5453 5f303131 00005852 65736572     STN1110_RX..rese
 8002270:	6e697474 00000067 65746661 65722072     tting...after re
 8002280:	00746573 45205441 00000d30 53205441     set.AT E0...AT S
 8002290:	0d302050 00000000 43303130 0000000d     P 0.....010C....
 80022a0:	74696157 20676e69 20726f66 72205441     Waiting for AT r
 80022b0:	6f707365 0065736e 33235653 00000000     esponse.SV#3....
 80022c0:	656c6469 00000000 00000000 00000000     idle............

080022d0 <__func__.5805.5093.4559>:
 80022d0:	68546863 69784564 00005374 00000000     chThdExitS......

080022e0 <ch_debug.4515>:
 80022e0:	6e69616d 18441600 08480404 1814100c     main..D...H.....
 80022f0:	2221201c 00000000                       . !"....
