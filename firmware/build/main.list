
build/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000100 <Reset_Handler>:
 8000100:	b672      	cpsid	i
 8000102:	4824      	ldr	r0, [pc, #144]	; (8000194 <endfiniloop+0x6>)
 8000104:	f380 8808 	msr	MSP, r0
 8000108:	4823      	ldr	r0, [pc, #140]	; (8000198 <endfiniloop+0xa>)
 800010a:	f380 8809 	msr	PSP, r0
 800010e:	2002      	movs	r0, #2
 8000110:	f380 8814 	msr	CONTROL, r0
 8000114:	f3bf 8f6f 	isb	sy
 8000118:	f001 f9e2 	bl	80014e0 <__core_init>
 800011c:	f001 f8e0 	bl	80012e0 <__early_init>
 8000120:	481e      	ldr	r0, [pc, #120]	; (800019c <endfiniloop+0xe>)
 8000122:	491f      	ldr	r1, [pc, #124]	; (80001a0 <endfiniloop+0x12>)
 8000124:	4a1b      	ldr	r2, [pc, #108]	; (8000194 <endfiniloop+0x6>)

08000126 <msloop>:
 8000126:	4291      	cmp	r1, r2
 8000128:	da02      	bge.n	8000130 <endmsloop>
 800012a:	6008      	str	r0, [r1, #0]
 800012c:	3104      	adds	r1, #4
 800012e:	e7fa      	b.n	8000126 <msloop>

08000130 <endmsloop>:
 8000130:	491c      	ldr	r1, [pc, #112]	; (80001a4 <endfiniloop+0x16>)
 8000132:	4a19      	ldr	r2, [pc, #100]	; (8000198 <endfiniloop+0xa>)

08000134 <psloop>:
 8000134:	4291      	cmp	r1, r2
 8000136:	da02      	bge.n	800013e <endpsloop>
 8000138:	6008      	str	r0, [r1, #0]
 800013a:	3104      	adds	r1, #4
 800013c:	e7fa      	b.n	8000134 <psloop>

0800013e <endpsloop>:
 800013e:	491a      	ldr	r1, [pc, #104]	; (80001a8 <endfiniloop+0x1a>)
 8000140:	4a1a      	ldr	r2, [pc, #104]	; (80001ac <endfiniloop+0x1e>)
 8000142:	4b1b      	ldr	r3, [pc, #108]	; (80001b0 <endfiniloop+0x22>)

08000144 <dloop>:
 8000144:	429a      	cmp	r2, r3
 8000146:	da04      	bge.n	8000152 <enddloop>
 8000148:	6808      	ldr	r0, [r1, #0]
 800014a:	6010      	str	r0, [r2, #0]
 800014c:	3104      	adds	r1, #4
 800014e:	3204      	adds	r2, #4
 8000150:	e7f8      	b.n	8000144 <dloop>

08000152 <enddloop>:
 8000152:	2000      	movs	r0, #0
 8000154:	4917      	ldr	r1, [pc, #92]	; (80001b4 <endfiniloop+0x26>)
 8000156:	4a18      	ldr	r2, [pc, #96]	; (80001b8 <endfiniloop+0x2a>)

08000158 <bloop>:
 8000158:	4291      	cmp	r1, r2
 800015a:	da02      	bge.n	8000162 <endbloop>
 800015c:	6008      	str	r0, [r1, #0]
 800015e:	3104      	adds	r1, #4
 8000160:	e7fa      	b.n	8000158 <bloop>

08000162 <endbloop>:
 8000162:	f001 f95d 	bl	8001420 <__init_ram_areas>
 8000166:	f001 f9b3 	bl	80014d0 <__late_init>
 800016a:	4c14      	ldr	r4, [pc, #80]	; (80001bc <endfiniloop+0x2e>)
 800016c:	4d14      	ldr	r5, [pc, #80]	; (80001c0 <endfiniloop+0x32>)

0800016e <initloop>:
 800016e:	42ac      	cmp	r4, r5
 8000170:	da03      	bge.n	800017a <endinitloop>
 8000172:	6821      	ldr	r1, [r4, #0]
 8000174:	4788      	blx	r1
 8000176:	3404      	adds	r4, #4
 8000178:	e7f9      	b.n	800016e <initloop>

0800017a <endinitloop>:
 800017a:	f000 fe79 	bl	8000e70 <main>
 800017e:	4c11      	ldr	r4, [pc, #68]	; (80001c4 <endfiniloop+0x36>)
 8000180:	4d11      	ldr	r5, [pc, #68]	; (80001c8 <endfiniloop+0x3a>)

08000182 <finiloop>:
 8000182:	42ac      	cmp	r4, r5
 8000184:	da03      	bge.n	800018e <endfiniloop>
 8000186:	6821      	ldr	r1, [r4, #0]
 8000188:	4788      	blx	r1
 800018a:	3404      	adds	r4, #4
 800018c:	e7f9      	b.n	8000182 <finiloop>

0800018e <endfiniloop>:
 800018e:	490f      	ldr	r1, [pc, #60]	; (80001cc <endfiniloop+0x3e>)
 8000190:	4708      	bx	r1
 8000192:	0000      	.short	0x0000
 8000194:	20000200 	.word	0x20000200
 8000198:	20000400 	.word	0x20000400
 800019c:	55555555 	.word	0x55555555
 80001a0:	20000000 	.word	0x20000000
 80001a4:	20000200 	.word	0x20000200
 80001a8:	08001638 	.word	0x08001638
 80001ac:	20000400 	.word	0x20000400
 80001b0:	20000610 	.word	0x20000610
 80001b4:	20000610 	.word	0x20000610
 80001b8:	20000b18 	.word	0x20000b18
 80001bc:	08000100 	.word	0x08000100
 80001c0:	08000100 	.word	0x08000100
 80001c4:	08000100 	.word	0x08000100
 80001c8:	08000100 	.word	0x08000100
 80001cc:	080014c1 	.word	0x080014c1

080001d0 <_port_switch>:
 80001d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001d2:	4644      	mov	r4, r8
 80001d4:	464d      	mov	r5, r9
 80001d6:	4656      	mov	r6, sl
 80001d8:	465f      	mov	r7, fp
 80001da:	b4f0      	push	{r4, r5, r6, r7}
 80001dc:	466b      	mov	r3, sp
 80001de:	60cb      	str	r3, [r1, #12]
 80001e0:	68c3      	ldr	r3, [r0, #12]
 80001e2:	469d      	mov	sp, r3
 80001e4:	bcf0      	pop	{r4, r5, r6, r7}
 80001e6:	46a0      	mov	r8, r4
 80001e8:	46a9      	mov	r9, r5
 80001ea:	46b2      	mov	sl, r6
 80001ec:	46bb      	mov	fp, r7
 80001ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001f0 <_port_thread_start>:
 80001f0:	b662      	cpsie	i
 80001f2:	1c28      	adds	r0, r5, #0
 80001f4:	47a0      	blx	r4
 80001f6:	2000      	movs	r0, #0
 80001f8:	f001 f8ca 	bl	8001390 <chThdExit>

080001fc <_port_switch_from_isr>:
 80001fc:	f001 f8f0 	bl	80013e0 <chSchDoReschedule>

08000200 <_port_exit_from_isr>:
 8000200:	4a01      	ldr	r2, [pc, #4]	; (8000208 <_port_exit_from_isr+0x8>)
 8000202:	4b02      	ldr	r3, [pc, #8]	; (800020c <_port_exit_from_isr+0xc>)
 8000204:	6013      	str	r3, [r2, #0]
 8000206:	e7fe      	b.n	8000206 <_port_exit_from_isr+0x6>
 8000208:	e000ed04 	.word	0xe000ed04
 800020c:	80000000 	.word	0x80000000

08000210 <__aeabi_uidiv>:
 8000210:	2900      	cmp	r1, #0
 8000212:	d034      	beq.n	800027e <.udivsi3_skip_div0_test+0x6a>

08000214 <.udivsi3_skip_div0_test>:
 8000214:	2301      	movs	r3, #1
 8000216:	2200      	movs	r2, #0
 8000218:	b410      	push	{r4}
 800021a:	4288      	cmp	r0, r1
 800021c:	d32c      	bcc.n	8000278 <.udivsi3_skip_div0_test+0x64>
 800021e:	2401      	movs	r4, #1
 8000220:	0724      	lsls	r4, r4, #28
 8000222:	42a1      	cmp	r1, r4
 8000224:	d204      	bcs.n	8000230 <.udivsi3_skip_div0_test+0x1c>
 8000226:	4281      	cmp	r1, r0
 8000228:	d202      	bcs.n	8000230 <.udivsi3_skip_div0_test+0x1c>
 800022a:	0109      	lsls	r1, r1, #4
 800022c:	011b      	lsls	r3, r3, #4
 800022e:	e7f8      	b.n	8000222 <.udivsi3_skip_div0_test+0xe>
 8000230:	00e4      	lsls	r4, r4, #3
 8000232:	42a1      	cmp	r1, r4
 8000234:	d204      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x2c>
 8000236:	4281      	cmp	r1, r0
 8000238:	d202      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x2c>
 800023a:	0049      	lsls	r1, r1, #1
 800023c:	005b      	lsls	r3, r3, #1
 800023e:	e7f8      	b.n	8000232 <.udivsi3_skip_div0_test+0x1e>
 8000240:	4288      	cmp	r0, r1
 8000242:	d301      	bcc.n	8000248 <.udivsi3_skip_div0_test+0x34>
 8000244:	1a40      	subs	r0, r0, r1
 8000246:	431a      	orrs	r2, r3
 8000248:	084c      	lsrs	r4, r1, #1
 800024a:	42a0      	cmp	r0, r4
 800024c:	d302      	bcc.n	8000254 <.udivsi3_skip_div0_test+0x40>
 800024e:	1b00      	subs	r0, r0, r4
 8000250:	085c      	lsrs	r4, r3, #1
 8000252:	4322      	orrs	r2, r4
 8000254:	088c      	lsrs	r4, r1, #2
 8000256:	42a0      	cmp	r0, r4
 8000258:	d302      	bcc.n	8000260 <.udivsi3_skip_div0_test+0x4c>
 800025a:	1b00      	subs	r0, r0, r4
 800025c:	089c      	lsrs	r4, r3, #2
 800025e:	4322      	orrs	r2, r4
 8000260:	08cc      	lsrs	r4, r1, #3
 8000262:	42a0      	cmp	r0, r4
 8000264:	d302      	bcc.n	800026c <.udivsi3_skip_div0_test+0x58>
 8000266:	1b00      	subs	r0, r0, r4
 8000268:	08dc      	lsrs	r4, r3, #3
 800026a:	4322      	orrs	r2, r4
 800026c:	2800      	cmp	r0, #0
 800026e:	d003      	beq.n	8000278 <.udivsi3_skip_div0_test+0x64>
 8000270:	091b      	lsrs	r3, r3, #4
 8000272:	d001      	beq.n	8000278 <.udivsi3_skip_div0_test+0x64>
 8000274:	0909      	lsrs	r1, r1, #4
 8000276:	e7e3      	b.n	8000240 <.udivsi3_skip_div0_test+0x2c>
 8000278:	1c10      	adds	r0, r2, #0
 800027a:	bc10      	pop	{r4}
 800027c:	4770      	bx	lr
 800027e:	2800      	cmp	r0, #0
 8000280:	d001      	beq.n	8000286 <.udivsi3_skip_div0_test+0x72>
 8000282:	2000      	movs	r0, #0
 8000284:	43c0      	mvns	r0, r0
 8000286:	b407      	push	{r0, r1, r2}
 8000288:	4802      	ldr	r0, [pc, #8]	; (8000294 <.udivsi3_skip_div0_test+0x80>)
 800028a:	a102      	add	r1, pc, #8	; (adr r1, 8000294 <.udivsi3_skip_div0_test+0x80>)
 800028c:	1840      	adds	r0, r0, r1
 800028e:	9002      	str	r0, [sp, #8]
 8000290:	bd03      	pop	{r0, r1, pc}
 8000292:	46c0      	nop			; (mov r8, r8)
 8000294:	0000001d 	.word	0x0000001d

08000298 <__aeabi_uidivmod>:
 8000298:	2900      	cmp	r1, #0
 800029a:	d0f0      	beq.n	800027e <.udivsi3_skip_div0_test+0x6a>
 800029c:	b503      	push	{r0, r1, lr}
 800029e:	f7ff ffb9 	bl	8000214 <.udivsi3_skip_div0_test>
 80002a2:	bc0e      	pop	{r1, r2, r3}
 80002a4:	4342      	muls	r2, r0
 80002a6:	1a89      	subs	r1, r1, r2
 80002a8:	4718      	bx	r3
 80002aa:	46c0      	nop			; (mov r8, r8)
 80002ac:	0000      	movs	r0, r0
	...

080002b0 <__aeabi_idiv0>:
 80002b0:	4770      	bx	lr
 80002b2:	46c0      	nop			; (mov r8, r8)
	...

080002c0 <chCoreAllocAligned.4300>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80002c0:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80002c2:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80002c4:	4a09      	ldr	r2, [pc, #36]	; (80002ec <chCoreAllocAligned.4300+0x2c>)
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80002c6:	1e44      	subs	r4, r0, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80002c8:	6810      	ldr	r0, [r2, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80002ca:	424b      	negs	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80002cc:	3801      	subs	r0, #1
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80002ce:	1864      	adds	r4, r4, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80002d0:	1840      	adds	r0, r0, r1

  if (((size_t)endmem - (size_t)p) < size) {
 80002d2:	4907      	ldr	r1, [pc, #28]	; (80002f0 <chCoreAllocAligned.4300+0x30>)

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80002d4:	4018      	ands	r0, r3
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80002d6:	401c      	ands	r4, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 80002d8:	680b      	ldr	r3, [r1, #0]
 80002da:	1a19      	subs	r1, r3, r0
 80002dc:	428c      	cmp	r4, r1
 80002de:	d803      	bhi.n	80002e8 <chCoreAllocAligned.4300+0x28>
    return NULL;
  }
  nextmem = p + size;
 80002e0:	1904      	adds	r4, r0, r4
 80002e2:	6014      	str	r4, [r2, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80002e4:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 80002e6:	bd10      	pop	{r4, pc}

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 80002e8:	2000      	movs	r0, #0
 80002ea:	e7fb      	b.n	80002e4 <chCoreAllocAligned.4300+0x24>
 80002ec:	20000954 	.word	0x20000954
 80002f0:	200008d0 	.word	0x200008d0
 80002f4:	46c0      	nop			; (mov r8, r8)
 80002f6:	46c0      	nop			; (mov r8, r8)
 80002f8:	46c0      	nop			; (mov r8, r8)
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	46c0      	nop			; (mov r8, r8)
 80002fe:	46c0      	nop			; (mov r8, r8)

08000300 <notify1.7547.4338>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000300:	4b02      	ldr	r3, [pc, #8]	; (800030c <notify1.7547.4338+0xc>)
 8000302:	2280      	movs	r2, #128	; 0x80
 8000304:	6819      	ldr	r1, [r3, #0]
 8000306:	430a      	orrs	r2, r1
 8000308:	601a      	str	r2, [r3, #0]
}
 800030a:	4770      	bx	lr
 800030c:	40013800 	.word	0x40013800

08000310 <notify2.7544.4341>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000310:	4b02      	ldr	r3, [pc, #8]	; (800031c <notify2.7544.4341+0xc>)
 8000312:	2280      	movs	r2, #128	; 0x80
 8000314:	6819      	ldr	r1, [r3, #0]
 8000316:	430a      	orrs	r2, r1
 8000318:	601a      	str	r2, [r3, #0]
}
 800031a:	4770      	bx	lr
 800031c:	40004400 	.word	0x40004400

08000320 <wakeup.4507.4195>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000320:	b672      	cpsid	i
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8000322:	2320      	movs	r3, #32
 8000324:	5cc1      	ldrb	r1, [r0, r3]
 8000326:	2907      	cmp	r1, #7
 8000328:	d80c      	bhi.n	8000344 <wakeup.4507.4195+0x24>
 800032a:	4a12      	ldr	r2, [pc, #72]	; (8000374 <wakeup.4507.4195+0x54>)
 800032c:	008b      	lsls	r3, r1, #2
 800032e:	58d1      	ldr	r1, [r2, r3]
 8000330:	468f      	mov	pc, r1
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8000332:	6a43      	ldr	r3, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000334:	689a      	ldr	r2, [r3, #8]
 8000336:	3201      	adds	r2, #1
 8000338:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800033a:	6843      	ldr	r3, [r0, #4]
 800033c:	6801      	ldr	r1, [r0, #0]
 800033e:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000340:	6802      	ldr	r2, [r0, #0]
 8000342:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000344:	2201      	movs	r2, #1
 8000346:	4253      	negs	r3, r2
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000348:	2100      	movs	r1, #0
 800034a:	2220      	movs	r2, #32
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800034c:	6243      	str	r3, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800034e:	5481      	strb	r1, [r0, r2]
  cp = (thread_t *)&ch.rlist.queue;
 8000350:	4b09      	ldr	r3, [pc, #36]	; (8000378 <wakeup.4507.4195+0x58>)
 8000352:	6882      	ldr	r2, [r0, #8]
  do {
    cp = cp->queue.next;
 8000354:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000356:	6899      	ldr	r1, [r3, #8]
 8000358:	4291      	cmp	r1, r2
 800035a:	d2fb      	bcs.n	8000354 <wakeup.4507.4195+0x34>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800035c:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800035e:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000360:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000362:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000364:	6058      	str	r0, [r3, #4]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000366:	b662      	cpsie	i
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000368:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800036a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800036c:	2100      	movs	r1, #0
 800036e:	6019      	str	r1, [r3, #0]
 8000370:	e7e8      	b.n	8000344 <wakeup.4507.4195+0x24>
 8000372:	46c0      	nop			; (mov r8, r8)
 8000374:	08001500 	.word	0x08001500
 8000378:	20000958 	.word	0x20000958
 800037c:	46c0      	nop			; (mov r8, r8)
 800037e:	46c0      	nop			; (mov r8, r8)

08000380 <sd_lld_start.4554>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000380:	b570      	push	{r4, r5, r6, lr}
 8000382:	1c06      	adds	r6, r0, #0
 8000384:	1e0c      	subs	r4, r1, #0

  if (config == NULL)
 8000386:	d038      	beq.n	80003fa <sd_lld_start.4554+0x7a>
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000388:	7a33      	ldrb	r3, [r6, #8]
 800038a:	2b01      	cmp	r3, #1
 800038c:	d024      	beq.n	80003d8 <sd_lld_start.4554+0x58>
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800038e:	6821      	ldr	r1, [r4, #0]
 8000390:	6fb0      	ldr	r0, [r6, #120]	; 0x78
 8000392:	f7ff ff3d 	bl	8000210 <__aeabi_uidiv>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000396:	6f75      	ldr	r5, [r6, #116]	; 0x74
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000398:	68a1      	ldr	r1, [r4, #8]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800039a:	60e8      	str	r0, [r5, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800039c:	2040      	movs	r0, #64	; 0x40
 800039e:	4308      	orrs	r0, r1
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80003a0:	68e2      	ldr	r2, [r4, #12]
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80003a2:	6068      	str	r0, [r5, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80003a4:	6864      	ldr	r4, [r4, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80003a6:	4819      	ldr	r0, [pc, #100]	; (800040c <sd_lld_start.4554+0x8c>)
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80003a8:	2301      	movs	r3, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 80003aa:	2101      	movs	r1, #1
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80003ac:	4313      	orrs	r3, r2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80003ae:	4320      	orrs	r0, r4
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 80003b0:	424a      	negs	r2, r1
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80003b2:	60ab      	str	r3, [r5, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80003b4:	6028      	str	r0, [r5, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 80003b6:	622a      	str	r2, [r5, #32]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 80003b8:	0561      	lsls	r1, r4, #21
 80003ba:	d50a      	bpl.n	80003d2 <sd_lld_start.4554+0x52>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 80003bc:	4d14      	ldr	r5, [pc, #80]	; (8000410 <sd_lld_start.4554+0x90>)
 80003be:	402c      	ands	r4, r5
 80003c0:	d103      	bne.n	80003ca <sd_lld_start.4554+0x4a>
    case 0:
      sdp->rxmask = 0x7F;
 80003c2:	257f      	movs	r5, #127	; 0x7f
 80003c4:	237c      	movs	r3, #124	; 0x7c
 80003c6:	54f5      	strb	r5, [r6, r3]
 80003c8:	e005      	b.n	80003d6 <sd_lld_start.4554+0x56>
  u->ICR = 0xFFFFFFFFU;

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 80003ca:	2380      	movs	r3, #128	; 0x80
 80003cc:	0558      	lsls	r0, r3, #21
 80003ce:	4284      	cmp	r4, r0
 80003d0:	d00f      	beq.n	80003f2 <sd_lld_start.4554+0x72>
    default:
      sdp->rxmask = 0xFF;
    }
  }
  else {
    sdp->rxmask = 0xFF;
 80003d2:	247c      	movs	r4, #124	; 0x7c
 80003d4:	5532      	strb	r2, [r6, r4]
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
}
 80003d6:	bd70      	pop	{r4, r5, r6, pc}
  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 80003d8:	480e      	ldr	r0, [pc, #56]	; (8000414 <sd_lld_start.4554+0x94>)
 80003da:	4286      	cmp	r6, r0
 80003dc:	d00f      	beq.n	80003fe <sd_lld_start.4554+0x7e>
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 80003de:	490e      	ldr	r1, [pc, #56]	; (8000418 <sd_lld_start.4554+0x98>)
 80003e0:	428e      	cmp	r6, r1
 80003e2:	d1d4      	bne.n	800038e <sd_lld_start.4554+0xe>
      rccEnableUSART2(FALSE);
 80003e4:	4d0d      	ldr	r5, [pc, #52]	; (800041c <sd_lld_start.4554+0x9c>)
 80003e6:	2280      	movs	r2, #128	; 0x80
 80003e8:	69eb      	ldr	r3, [r5, #28]
 80003ea:	0290      	lsls	r0, r2, #10
 80003ec:	4318      	orrs	r0, r3
 80003ee:	61e8      	str	r0, [r5, #28]
 80003f0:	e7cd      	b.n	800038e <sd_lld_start.4554+0xe>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
    case 0:
      sdp->rxmask = 0x7F;
      break;
    case USART_CR1_M_1:
      sdp->rxmask = 0x3F;
 80003f2:	213f      	movs	r1, #63	; 0x3f
 80003f4:	227c      	movs	r2, #124	; 0x7c
 80003f6:	54b1      	strb	r1, [r6, r2]
 80003f8:	e7ed      	b.n	80003d6 <sd_lld_start.4554+0x56>
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 80003fa:	4c09      	ldr	r4, [pc, #36]	; (8000420 <sd_lld_start.4554+0xa0>)
 80003fc:	e7c4      	b.n	8000388 <sd_lld_start.4554+0x8>

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 80003fe:	4d07      	ldr	r5, [pc, #28]	; (800041c <sd_lld_start.4554+0x9c>)
 8000400:	2380      	movs	r3, #128	; 0x80
 8000402:	69a9      	ldr	r1, [r5, #24]
 8000404:	01da      	lsls	r2, r3, #7
 8000406:	430a      	orrs	r2, r1
 8000408:	61aa      	str	r2, [r5, #24]
 800040a:	e7c0      	b.n	800038e <sd_lld_start.4554+0xe>
 800040c:	0000012d 	.word	0x0000012d
 8000410:	10001000 	.word	0x10001000
 8000414:	20000610 	.word	0x20000610
 8000418:	200008d4 	.word	0x200008d4
 800041c:	40021000 	.word	0x40021000
 8000420:	08001570 	.word	0x08001570
 8000424:	46c0      	nop			; (mov r8, r8)
 8000426:	46c0      	nop			; (mov r8, r8)
 8000428:	46c0      	nop			; (mov r8, r8)
 800042a:	46c0      	nop			; (mov r8, r8)
 800042c:	46c0      	nop			; (mov r8, r8)
 800042e:	46c0      	nop			; (mov r8, r8)

08000430 <_pal_lld_setgroupmode.4562>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000430:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000432:	465f      	mov	r7, fp
 8000434:	4656      	mov	r6, sl
 8000436:	464d      	mov	r5, r9
 8000438:	4644      	mov	r4, r8
 800043a:	b4f0      	push	{r4, r5, r6, r7}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800043c:	2403      	movs	r4, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800043e:	0757      	lsls	r7, r2, #29
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000440:	06d6      	lsls	r6, r2, #27
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8000442:	0655      	lsls	r5, r2, #25
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000444:	4014      	ands	r4, r2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000446:	0552      	lsls	r2, r2, #21
 8000448:	0f13      	lsrs	r3, r2, #28
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800044a:	b083      	sub	sp, #12

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 800044c:	0fad      	lsrs	r5, r5, #30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800044e:	2201      	movs	r2, #1

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000450:	469b      	mov	fp, r3
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000452:	0fff      	lsrs	r7, r7, #31
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000454:	0fb6      	lsrs	r6, r6, #30
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000456:	2300      	movs	r3, #0
  while (true) {
    if ((mask & 1) != 0) {
 8000458:	4694      	mov	ip, r2
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 800045a:	9500      	str	r5, [sp, #0]
 800045c:	e00e      	b.n	800047c <_pal_lld_setgroupmode.4562+0x4c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800045e:	6a02      	ldr	r2, [r0, #32]
 8000460:	464d      	mov	r5, r9
 8000462:	43aa      	bics	r2, r5
 8000464:	4645      	mov	r5, r8
 8000466:	432a      	orrs	r2, r5
 8000468:	6202      	str	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 800046a:	0849      	lsrs	r1, r1, #1
    if (!mask)
 800046c:	d03d      	beq.n	80004ea <_pal_lld_setgroupmode.4562+0xba>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
 800046e:	9a00      	ldr	r2, [sp, #0]
      }
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
 8000470:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
    pupdr <<= 2;
 8000472:	0095      	lsls	r5, r2, #2
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8000474:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8000476:	9500      	str	r5, [sp, #0]
    moder <<= 2;
 8000478:	00a4      	lsls	r4, r4, #2
    bit++;
 800047a:	3301      	adds	r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800047c:	4665      	mov	r5, ip
 800047e:	420d      	tst	r5, r1
 8000480:	d0f3      	beq.n	800046a <_pal_lld_setgroupmode.4562+0x3a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000482:	2207      	movs	r2, #7
 8000484:	401a      	ands	r2, r3
 8000486:	0095      	lsls	r5, r2, #2
 8000488:	465a      	mov	r2, fp
 800048a:	40aa      	lsls	r2, r5
 800048c:	4690      	mov	r8, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800048e:	220f      	movs	r2, #15
 8000490:	40aa      	lsls	r2, r5
 8000492:	4691      	mov	r9, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000494:	6845      	ldr	r5, [r0, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8000496:	4662      	mov	r2, ip
 8000498:	409a      	lsls	r2, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800049a:	4395      	bics	r5, r2
 800049c:	433d      	orrs	r5, r7
 800049e:	6045      	str	r5, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80004a0:	6882      	ldr	r2, [r0, #8]
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80004a2:	005d      	lsls	r5, r3, #1
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80004a4:	4692      	mov	sl, r2
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 80004a6:	2203      	movs	r2, #3
 80004a8:	40aa      	lsls	r2, r5
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80004aa:	43d5      	mvns	r5, r2
 80004ac:	4652      	mov	r2, sl
 80004ae:	402a      	ands	r2, r5
 80004b0:	4332      	orrs	r2, r6
 80004b2:	6082      	str	r2, [r0, #8]
 80004b4:	9501      	str	r5, [sp, #4]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80004b6:	68c5      	ldr	r5, [r0, #12]
 80004b8:	1c2a      	adds	r2, r5, #0
 80004ba:	9d01      	ldr	r5, [sp, #4]
 80004bc:	402a      	ands	r2, r5
 80004be:	9d00      	ldr	r5, [sp, #0]
 80004c0:	432a      	orrs	r2, r5
 80004c2:	60c2      	str	r2, [r0, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80004c4:	2c02      	cmp	r4, #2
 80004c6:	d017      	beq.n	80004f8 <_pal_lld_setgroupmode.4562+0xc8>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80004c8:	6802      	ldr	r2, [r0, #0]
 80004ca:	4692      	mov	sl, r2
 80004cc:	9a01      	ldr	r2, [sp, #4]
 80004ce:	4655      	mov	r5, sl
 80004d0:	402a      	ands	r2, r5
 80004d2:	4322      	orrs	r2, r4
 80004d4:	6002      	str	r2, [r0, #0]
        if (bit < 8)
 80004d6:	2b07      	cmp	r3, #7
 80004d8:	d9c1      	bls.n	800045e <_pal_lld_setgroupmode.4562+0x2e>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80004da:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80004dc:	464d      	mov	r5, r9
 80004de:	43aa      	bics	r2, r5
 80004e0:	4645      	mov	r5, r8
 80004e2:	432a      	orrs	r2, r5
 80004e4:	6242      	str	r2, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
 80004e6:	0849      	lsrs	r1, r1, #1
    if (!mask)
 80004e8:	d1c1      	bne.n	800046e <_pal_lld_setgroupmode.4562+0x3e>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 80004ea:	b003      	add	sp, #12
 80004ec:	bc3c      	pop	{r2, r3, r4, r5}
 80004ee:	4690      	mov	r8, r2
 80004f0:	4699      	mov	r9, r3
 80004f2:	46a2      	mov	sl, r4
 80004f4:	46ab      	mov	fp, r5
 80004f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80004f8:	2b07      	cmp	r3, #7
 80004fa:	d80d      	bhi.n	8000518 <_pal_lld_setgroupmode.4562+0xe8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80004fc:	6a02      	ldr	r2, [r0, #32]
 80004fe:	1c15      	adds	r5, r2, #0
 8000500:	464a      	mov	r2, r9
 8000502:	4395      	bics	r5, r2
 8000504:	4642      	mov	r2, r8
 8000506:	4315      	orrs	r5, r2
 8000508:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 800050a:	6805      	ldr	r5, [r0, #0]
 800050c:	9a01      	ldr	r2, [sp, #4]
 800050e:	402a      	ands	r2, r5
 8000510:	2502      	movs	r5, #2
 8000512:	432a      	orrs	r2, r5
 8000514:	6002      	str	r2, [r0, #0]
 8000516:	e7a8      	b.n	800046a <_pal_lld_setgroupmode.4562+0x3a>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000518:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800051a:	464d      	mov	r5, r9
 800051c:	43aa      	bics	r2, r5
 800051e:	4645      	mov	r5, r8
 8000520:	432a      	orrs	r2, r5
 8000522:	6242      	str	r2, [r0, #36]	; 0x24
 8000524:	e7f1      	b.n	800050a <_pal_lld_setgroupmode.4562+0xda>
 8000526:	46c0      	nop			; (mov r8, r8)
 8000528:	46c0      	nop			; (mov r8, r8)
 800052a:	46c0      	nop			; (mov r8, r8)
 800052c:	46c0      	nop			; (mov r8, r8)
 800052e:	46c0      	nop			; (mov r8, r8)

08000530 <_port_irq_epilogue.4590>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000530:	300f      	adds	r0, #15
 8000532:	d011      	beq.n	8000558 <_port_irq_epilogue.4590+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000534:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000536:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800053a:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800053c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000540:	2280      	movs	r2, #128	; 0x80
 8000542:	0450      	lsls	r0, r2, #17
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000544:	4a06      	ldr	r2, [pc, #24]	; (8000560 <_port_irq_epilogue.4590+0x30>)
 8000546:	61d8      	str	r0, [r3, #28]
 8000548:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800054a:	6990      	ldr	r0, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800054c:	6889      	ldr	r1, [r1, #8]
 800054e:	6882      	ldr	r2, [r0, #8]
 8000550:	4291      	cmp	r1, r2
 8000552:	d802      	bhi.n	800055a <_port_irq_epilogue.4590+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000554:	4803      	ldr	r0, [pc, #12]	; (8000564 <_port_irq_epilogue.4590+0x34>)
 8000556:	6198      	str	r0, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000558:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800055a:	4903      	ldr	r1, [pc, #12]	; (8000568 <_port_irq_epilogue.4590+0x38>)
 800055c:	6199      	str	r1, [r3, #24]
 800055e:	e7fb      	b.n	8000558 <_port_irq_epilogue.4590+0x28>
 8000560:	20000958 	.word	0x20000958
 8000564:	08000200 	.word	0x08000200
 8000568:	080001fd 	.word	0x080001fd
 800056c:	46c0      	nop			; (mov r8, r8)
 800056e:	46c0      	nop			; (mov r8, r8)

08000570 <NMI_Handler.4599>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000570:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000574:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000576:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800057a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800057c:	4770      	bx	lr
 800057e:	46c0      	nop			; (mov r8, r8)

08000580 <chSchReadyI.4612>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000580:	2200      	movs	r2, #0
 8000582:	2320      	movs	r3, #32
 8000584:	54c2      	strb	r2, [r0, r3]
 8000586:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000588:	4b05      	ldr	r3, [pc, #20]	; (80005a0 <chSchReadyI.4612+0x20>)
  do {
    cp = cp->queue.next;
 800058a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800058c:	6899      	ldr	r1, [r3, #8]
 800058e:	4291      	cmp	r1, r2
 8000590:	d2fb      	bcs.n	800058a <chSchReadyI.4612+0xa>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000592:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000594:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000596:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000598:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800059a:	6058      	str	r0, [r3, #4]

  return tp;
}
 800059c:	4770      	bx	lr
 800059e:	46c0      	nop			; (mov r8, r8)
 80005a0:	20000958 	.word	0x20000958
 80005a4:	46c0      	nop			; (mov r8, r8)
 80005a6:	46c0      	nop			; (mov r8, r8)
 80005a8:	46c0      	nop			; (mov r8, r8)
 80005aa:	46c0      	nop			; (mov r8, r8)
 80005ac:	46c0      	nop			; (mov r8, r8)
 80005ae:	46c0      	nop			; (mov r8, r8)

080005b0 <chEvtBroadcastFlagsI.4601>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80005b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80005b2:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80005b4:	4647      	mov	r7, r8
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80005b6:	2200      	movs	r2, #0
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80005b8:	b480      	push	{r7}
 80005ba:	1c06      	adds	r6, r0, #0
 80005bc:	1c0d      	adds	r5, r1, #0
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80005be:	2720      	movs	r7, #32
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80005c0:	4690      	mov	r8, r2
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80005c2:	42a0      	cmp	r0, r4
 80005c4:	d103      	bne.n	80005ce <chEvtBroadcastFlagsI.4601+0x1e>
 80005c6:	e01f      	b.n	8000608 <chEvtBroadcastFlagsI.4601+0x58>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80005c8:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80005ca:	42a6      	cmp	r6, r4
 80005cc:	d01c      	beq.n	8000608 <chEvtBroadcastFlagsI.4601+0x58>
  /*lint -restore*/
    elp->flags |= flags;
 80005ce:	68e3      	ldr	r3, [r4, #12]
 80005d0:	432b      	orrs	r3, r5
 80005d2:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80005d4:	2d00      	cmp	r5, #0
 80005d6:	d002      	beq.n	80005de <chEvtBroadcastFlagsI.4601+0x2e>
 80005d8:	6920      	ldr	r0, [r4, #16]
 80005da:	4218      	tst	r0, r3
 80005dc:	d0f4      	beq.n	80005c8 <chEvtBroadcastFlagsI.4601+0x18>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 80005de:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 80005e0:	68a2      	ldr	r2, [r4, #8]
 80005e2:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80005e4:	4311      	orrs	r1, r2
 80005e6:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80005e8:	5dc3      	ldrb	r3, [r0, r7]
 80005ea:	2b0a      	cmp	r3, #10
 80005ec:	d00f      	beq.n	800060e <chEvtBroadcastFlagsI.4601+0x5e>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80005ee:	2b0b      	cmp	r3, #11
 80005f0:	d1ea      	bne.n	80005c8 <chEvtBroadcastFlagsI.4601+0x18>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80005f2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80005f4:	4011      	ands	r1, r2

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 80005f6:	428a      	cmp	r2, r1
 80005f8:	d1e6      	bne.n	80005c8 <chEvtBroadcastFlagsI.4601+0x18>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80005fa:	4641      	mov	r1, r8
 80005fc:	6241      	str	r1, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80005fe:	f7ff ffbf 	bl	8000580 <chSchReadyI.4612>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8000602:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000604:	42a6      	cmp	r6, r4
 8000606:	d1e2      	bne.n	80005ce <chEvtBroadcastFlagsI.4601+0x1e>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
 8000608:	bc04      	pop	{r2}
 800060a:	4690      	mov	r8, r2
 800060c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800060e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000610:	420b      	tst	r3, r1
 8000612:	d0d9      	beq.n	80005c8 <chEvtBroadcastFlagsI.4601+0x18>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000614:	4641      	mov	r1, r8
 8000616:	6241      	str	r1, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000618:	f7ff ffb2 	bl	8000580 <chSchReadyI.4612>
 800061c:	e7f1      	b.n	8000602 <chEvtBroadcastFlagsI.4601+0x52>
 800061e:	46c0      	nop			; (mov r8, r8)

08000620 <serve_interrupt.7558.4400>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000620:	b5f0      	push	{r4, r5, r6, r7, lr}
  USART_TypeDef *u = sdp->usart;
 8000622:	6f46      	ldr	r6, [r0, #116]	; 0x74
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000624:	4647      	mov	r7, r8
 8000626:	b480      	push	{r7}
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000628:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800062a:	69f5      	ldr	r5, [r6, #28]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800062c:	1c04      	adds	r4, r0, #0
  uint32_t cr1 = u->CR1;
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;
 800062e:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000630:	072a      	lsls	r2, r5, #28
 8000632:	d144      	bne.n	80006be <serve_interrupt.7558.4400+0x9e>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000634:	05ea      	lsls	r2, r5, #23
 8000636:	d43a      	bmi.n	80006ae <serve_interrupt.7558.4400+0x8e>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000638:	06ab      	lsls	r3, r5, #26
 800063a:	d413      	bmi.n	8000664 <serve_interrupt.7558.4400+0x44>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800063c:	2080      	movs	r0, #128	; 0x80
 800063e:	4238      	tst	r0, r7
 8000640:	d001      	beq.n	8000646 <serve_interrupt.7558.4400+0x26>
 8000642:	4228      	tst	r0, r5
 8000644:	d151      	bne.n	80006ea <serve_interrupt.7558.4400+0xca>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000646:	066b      	lsls	r3, r5, #25
 8000648:	d509      	bpl.n	800065e <serve_interrupt.7558.4400+0x3e>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800064a:	b672      	cpsid	i
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 800064c:	6c65      	ldr	r5, [r4, #68]	; 0x44
 800064e:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8000650:	4285      	cmp	r5, r0
 8000652:	d100      	bne.n	8000656 <serve_interrupt.7558.4400+0x36>
 8000654:	e06d      	b.n	8000732 <serve_interrupt.7558.4400+0x112>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000656:	2440      	movs	r4, #64	; 0x40
 8000658:	43a7      	bics	r7, r4
 800065a:	6037      	str	r7, [r6, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800065c:	b662      	cpsie	i
    osalSysUnlockFromISR();
  }
}
 800065e:	bc04      	pop	{r2}
 8000660:	4690      	mov	r8, r2
 8000662:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000664:	b672      	cpsid	i
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8000666:	227c      	movs	r2, #124	; 0x7c
 8000668:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
 800066a:	5ca3      	ldrb	r3, [r4, r2]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800066c:	6961      	ldr	r1, [r4, #20]
 800066e:	4003      	ands	r3, r0
 8000670:	4698      	mov	r8, r3
 8000672:	2900      	cmp	r1, #0
 8000674:	d066      	beq.n	8000744 <serve_interrupt.7558.4400+0x124>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8000676:	6a20      	ldr	r0, [r4, #32]
 8000678:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800067a:	4290      	cmp	r0, r2
 800067c:	d067      	beq.n	800074e <serve_interrupt.7558.4400+0x12e>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800067e:	6961      	ldr	r1, [r4, #20]
  *iqp->q_wrptr++ = b;
 8000680:	4642      	mov	r2, r8

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8000682:	3101      	adds	r1, #1
 8000684:	6161      	str	r1, [r4, #20]
  *iqp->q_wrptr++ = b;
 8000686:	7002      	strb	r2, [r0, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000688:	69e3      	ldr	r3, [r4, #28]
  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
 800068a:	3001      	adds	r0, #1
 800068c:	6220      	str	r0, [r4, #32]
  if (iqp->q_wrptr >= iqp->q_top) {
 800068e:	4298      	cmp	r0, r3
 8000690:	d24c      	bcs.n	800072c <serve_interrupt.7558.4400+0x10c>
    iqp->q_wrptr = iqp->q_buffer;
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8000692:	1c21      	adds	r1, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000694:	68e0      	ldr	r0, [r4, #12]
 8000696:	310c      	adds	r1, #12
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000698:	4281      	cmp	r1, r0
 800069a:	d006      	beq.n	80006aa <serve_interrupt.7558.4400+0x8a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800069c:	6802      	ldr	r2, [r0, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800069e:	2300      	movs	r3, #0
 80006a0:	60e2      	str	r2, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 80006a2:	6051      	str	r1, [r2, #4]
 80006a4:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80006a6:	f7ff ff6b 	bl	8000580 <chSchReadyI.4612>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006aa:	b662      	cpsie	i
 80006ac:	e7c6      	b.n	800063c <serve_interrupt.7558.4400+0x1c>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006ae:	b672      	cpsid	i
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80006b0:	2180      	movs	r1, #128	; 0x80
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80006b2:	1d20      	adds	r0, r4, #4
 80006b4:	0089      	lsls	r1, r1, #2
 80006b6:	f7ff ff7b 	bl	80005b0 <chEvtBroadcastFlagsI.4601>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006ba:	b662      	cpsie	i
 80006bc:	e7bc      	b.n	8000638 <serve_interrupt.7558.4400+0x18>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 80006be:	0729      	lsls	r1, r5, #28
    sts |= SD_OVERRUN_ERROR;
 80006c0:	0fc8      	lsrs	r0, r1, #31
 80006c2:	01c1      	lsls	r1, r0, #7
  if (isr & USART_ISR_PE)
 80006c4:	07eb      	lsls	r3, r5, #31
 80006c6:	d501      	bpl.n	80006cc <serve_interrupt.7558.4400+0xac>
    sts |= SD_PARITY_ERROR;
 80006c8:	2320      	movs	r3, #32
 80006ca:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 80006cc:	07aa      	lsls	r2, r5, #30
 80006ce:	d501      	bpl.n	80006d4 <serve_interrupt.7558.4400+0xb4>
    sts |= SD_FRAMING_ERROR;
 80006d0:	2240      	movs	r2, #64	; 0x40
 80006d2:	4311      	orrs	r1, r2
  if (isr & USART_ISR_NE)
 80006d4:	076b      	lsls	r3, r5, #29
 80006d6:	d502      	bpl.n	80006de <serve_interrupt.7558.4400+0xbe>
    sts |= SD_NOISE_ERROR;
 80006d8:	2080      	movs	r0, #128	; 0x80
 80006da:	0043      	lsls	r3, r0, #1
 80006dc:	4319      	orrs	r1, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006de:	b672      	cpsid	i
  osalSysLockFromISR();
  chnAddFlagsI(sdp, sts);
 80006e0:	1d20      	adds	r0, r4, #4
 80006e2:	f7ff ff65 	bl	80005b0 <chEvtBroadcastFlagsI.4601>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006e6:	b662      	cpsie	i
 80006e8:	e7a4      	b.n	8000634 <serve_interrupt.7558.4400+0x14>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006ea:	b672      	cpsid	i
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80006ec:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80006ee:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80006f0:	428a      	cmp	r2, r1
 80006f2:	d034      	beq.n	800075e <serve_interrupt.7558.4400+0x13e>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 80006f4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 80006f6:	6c23      	ldr	r3, [r4, #64]	; 0x40

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 80006f8:	3001      	adds	r0, #1
 80006fa:	63a0      	str	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 80006fc:	780a      	ldrb	r2, [r1, #0]
 80006fe:	3101      	adds	r1, #1
 8000700:	4690      	mov	r8, r2
 8000702:	64a1      	str	r1, [r4, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 8000704:	4299      	cmp	r1, r3
 8000706:	d301      	bcc.n	800070c <serve_interrupt.7558.4400+0xec>
    oqp->q_rdptr = oqp->q_buffer;
 8000708:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800070a:	64a1      	str	r1, [r4, #72]	; 0x48
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 800070c:	1c23      	adds	r3, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800070e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8000710:	3330      	adds	r3, #48	; 0x30
 8000712:	4283      	cmp	r3, r0
 8000714:	d006      	beq.n	8000724 <serve_interrupt.7558.4400+0x104>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000716:	6802      	ldr	r2, [r0, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000718:	2100      	movs	r1, #0
 800071a:	6322      	str	r2, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
 800071c:	6053      	str	r3, [r2, #4]
 800071e:	6241      	str	r1, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000720:	f7ff ff2e 	bl	8000580 <chSchReadyI.4612>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8000724:	4640      	mov	r0, r8
 8000726:	8530      	strh	r0, [r6, #40]	; 0x28
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000728:	b662      	cpsie	i
 800072a:	e78c      	b.n	8000646 <serve_interrupt.7558.4400+0x26>
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 800072c:	69a0      	ldr	r0, [r4, #24]
 800072e:	6220      	str	r0, [r4, #32]
 8000730:	e7af      	b.n	8000692 <serve_interrupt.7558.4400+0x72>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8000732:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000734:	2b00      	cmp	r3, #0
 8000736:	d100      	bne.n	800073a <serve_interrupt.7558.4400+0x11a>
 8000738:	e78d      	b.n	8000656 <serve_interrupt.7558.4400+0x36>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800073a:	1d20      	adds	r0, r4, #4
 800073c:	2110      	movs	r1, #16
 800073e:	f7ff ff37 	bl	80005b0 <chEvtBroadcastFlagsI.4601>
 8000742:	e788      	b.n	8000656 <serve_interrupt.7558.4400+0x36>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8000744:	1d20      	adds	r0, r4, #4
 8000746:	2104      	movs	r1, #4
 8000748:	f7ff ff32 	bl	80005b0 <chEvtBroadcastFlagsI.4601>
 800074c:	e793      	b.n	8000676 <serve_interrupt.7558.4400+0x56>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 800074e:	6963      	ldr	r3, [r4, #20]
 8000750:	2b00      	cmp	r3, #0
 8000752:	d094      	beq.n	800067e <serve_interrupt.7558.4400+0x5e>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8000754:	1d20      	adds	r0, r4, #4
 8000756:	2180      	movs	r1, #128	; 0x80
 8000758:	f7ff ff2a 	bl	80005b0 <chEvtBroadcastFlagsI.4601>
 800075c:	e7a5      	b.n	80006aa <serve_interrupt.7558.4400+0x8a>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 800075e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000760:	2b00      	cmp	r3, #0
 8000762:	d0c7      	beq.n	80006f4 <serve_interrupt.7558.4400+0xd4>
 8000764:	2108      	movs	r1, #8
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000766:	1d20      	adds	r0, r4, #4
 8000768:	f7ff ff22 	bl	80005b0 <chEvtBroadcastFlagsI.4601>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800076c:	23c0      	movs	r3, #192	; 0xc0
 800076e:	1c3a      	adds	r2, r7, #0
 8000770:	439a      	bics	r2, r3
 8000772:	2140      	movs	r1, #64	; 0x40
 8000774:	4311      	orrs	r1, r2
 8000776:	6031      	str	r1, [r6, #0]
 8000778:	e7d6      	b.n	8000728 <serve_interrupt.7558.4400+0x108>
 800077a:	46c0      	nop			; (mov r8, r8)
 800077c:	46c0      	nop			; (mov r8, r8)
 800077e:	46c0      	nop			; (mov r8, r8)

08000780 <_idle_thread.4272.4615>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000780:	e7fe      	b.n	8000780 <_idle_thread.4272.4615>
 8000782:	46c0      	nop			; (mov r8, r8)
 8000784:	46c0      	nop			; (mov r8, r8)
 8000786:	46c0      	nop			; (mov r8, r8)
 8000788:	46c0      	nop			; (mov r8, r8)
 800078a:	46c0      	nop			; (mov r8, r8)
 800078c:	46c0      	nop			; (mov r8, r8)
 800078e:	46c0      	nop			; (mov r8, r8)

08000790 <BusFault_Handler.4624>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000790:	e7fe      	b.n	8000790 <BusFault_Handler.4624>
 8000792:	46c0      	nop			; (mov r8, r8)
 8000794:	46c0      	nop			; (mov r8, r8)
 8000796:	46c0      	nop			; (mov r8, r8)
 8000798:	46c0      	nop			; (mov r8, r8)
 800079a:	46c0      	nop			; (mov r8, r8)
 800079c:	46c0      	nop			; (mov r8, r8)
 800079e:	46c0      	nop			; (mov r8, r8)

080007a0 <chSchWakeupS.constprop.11.4553>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80007a0:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 80007a2:	4d13      	ldr	r5, [pc, #76]	; (80007f0 <chSchWakeupS.constprop.11.4553+0x50>)

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80007a4:	6884      	ldr	r4, [r0, #8]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 80007a6:	69a9      	ldr	r1, [r5, #24]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80007a8:	2300      	movs	r3, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80007aa:	688a      	ldr	r2, [r1, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80007ac:	6243      	str	r3, [r0, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80007ae:	4294      	cmp	r4, r2
 80007b0:	d80b      	bhi.n	80007ca <chSchWakeupS.constprop.11.4553+0x2a>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80007b2:	2120      	movs	r1, #32
 80007b4:	5443      	strb	r3, [r0, r1]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 80007b6:	682d      	ldr	r5, [r5, #0]
  } while (cp->prio >= tp->prio);
 80007b8:	68aa      	ldr	r2, [r5, #8]
 80007ba:	4294      	cmp	r4, r2
 80007bc:	d9fb      	bls.n	80007b6 <chSchWakeupS.constprop.11.4553+0x16>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80007be:	686c      	ldr	r4, [r5, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80007c0:	6005      	str	r5, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 80007c2:	6044      	str	r4, [r0, #4]
  tp->queue.prev->queue.next = tp;
 80007c4:	6020      	str	r0, [r4, #0]
  cp->queue.prev             = tp;
 80007c6:	6068      	str	r0, [r5, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80007c8:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80007ca:	2420      	movs	r4, #32
 80007cc:	550b      	strb	r3, [r1, r4]
  cp = (thread_t *)&ch.rlist.queue;
 80007ce:	1c2b      	adds	r3, r5, #0
  do {
    cp = cp->queue.next;
 80007d0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80007d2:	689c      	ldr	r4, [r3, #8]
 80007d4:	42a2      	cmp	r2, r4
 80007d6:	d9fb      	bls.n	80007d0 <chSchWakeupS.constprop.11.4553+0x30>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80007d8:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80007da:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 80007dc:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 80007de:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 80007e0:	6059      	str	r1, [r3, #4]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80007e2:	61a8      	str	r0, [r5, #24]
    ntp->state = CH_STATE_CURRENT;
 80007e4:	2320      	movs	r3, #32
 80007e6:	2501      	movs	r5, #1
 80007e8:	54c5      	strb	r5, [r0, r3]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80007ea:	f7ff fcf1 	bl	80001d0 <_port_switch>
 80007ee:	e7eb      	b.n	80007c8 <chSchWakeupS.constprop.11.4553+0x28>
 80007f0:	20000958 	.word	0x20000958
 80007f4:	46c0      	nop			; (mov r8, r8)
 80007f6:	46c0      	nop			; (mov r8, r8)
 80007f8:	46c0      	nop			; (mov r8, r8)
 80007fa:	46c0      	nop			; (mov r8, r8)
 80007fc:	46c0      	nop			; (mov r8, r8)
 80007fe:	46c0      	nop			; (mov r8, r8)

08000800 <chThdCreateStatic.constprop.5.4548>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8000800:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000802:	b672      	cpsid	i
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8000804:	1c44      	adds	r4, r0, #1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000806:	1c02      	adds	r2, r0, #0
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8000808:	34ff      	adds	r4, #255	; 0xff
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800080a:	32dc      	adds	r2, #220	; 0xdc
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 800080c:	61e0      	str	r0, [r4, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800080e:	60e2      	str	r2, [r4, #12]
 8000810:	6111      	str	r1, [r2, #16]
 8000812:	4918      	ldr	r1, [pc, #96]	; (8000874 <chThdCreateStatic.constprop.5.4548+0x74>)
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000814:	2590      	movs	r5, #144	; 0x90
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000816:	6211      	str	r1, [r2, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000818:	0069      	lsls	r1, r5, #1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800081a:	2300      	movs	r3, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800081c:	1841      	adds	r1, r0, r1
 800081e:	2502      	movs	r5, #2
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000820:	6153      	str	r3, [r2, #20]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000822:	700d      	strb	r5, [r1, #0]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000824:	4914      	ldr	r1, [pc, #80]	; (8000878 <chThdCreateStatic.constprop.5.4548+0x78>)
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000826:	63a3      	str	r3, [r4, #56]	; 0x38
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000828:	1845      	adds	r5, r0, r1
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800082a:	6363      	str	r3, [r4, #52]	; 0x34
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 800082c:	702b      	strb	r3, [r5, #0]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800082e:	2280      	movs	r2, #128	; 0x80
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000830:	2391      	movs	r3, #145	; 0x91
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000832:	60a2      	str	r2, [r4, #8]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000834:	63e2      	str	r2, [r4, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000836:	005a      	lsls	r2, r3, #1
 8000838:	1881      	adds	r1, r0, r2
 800083a:	2501      	movs	r5, #1
 800083c:	700d      	strb	r5, [r1, #0]
  tp->name      = name;
  REG_INSERT(tp);
 800083e:	490f      	ldr	r1, [pc, #60]	; (800087c <chThdCreateStatic.constprop.5.4548+0x7c>)
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000840:	4b0f      	ldr	r3, [pc, #60]	; (8000880 <chThdCreateStatic.constprop.5.4548+0x80>)
  REG_INSERT(tp);
 8000842:	694a      	ldr	r2, [r1, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8000844:	2594      	movs	r5, #148	; 0x94
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000846:	6121      	str	r1, [r4, #16]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000848:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
 800084a:	6114      	str	r4, [r2, #16]
 800084c:	6162      	str	r2, [r4, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800084e:	006b      	lsls	r3, r5, #1
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000850:	2294      	movs	r2, #148	; 0x94
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000852:	614c      	str	r4, [r1, #20]
 8000854:	0055      	lsls	r5, r2, #1
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8000856:	18c1      	adds	r1, r0, r3
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8000858:	2396      	movs	r3, #150	; 0x96
 800085a:	5141      	str	r1, [r0, r5]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800085c:	2296      	movs	r2, #150	; 0x96
 800085e:	0059      	lsls	r1, r3, #1
 8000860:	1845      	adds	r5, r0, r1
 8000862:	0053      	lsls	r3, r2, #1
 8000864:	50c5      	str	r5, [r0, r3]
  tqp->prev = (thread_t *)tqp;
 8000866:	606d      	str	r5, [r5, #4]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000868:	1c20      	adds	r0, r4, #0
 800086a:	f7ff ff99 	bl	80007a0 <chSchWakeupS.constprop.11.4553>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800086e:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8000870:	1c20      	adds	r0, r4, #0
 8000872:	bd38      	pop	{r3, r4, r5, pc}
 8000874:	080001f1 	.word	0x080001f1
 8000878:	00000121 	.word	0x00000121
 800087c:	20000958 	.word	0x20000958
 8000880:	08001520 	.word	0x08001520
 8000884:	46c0      	nop			; (mov r8, r8)
 8000886:	46c0      	nop			; (mov r8, r8)
 8000888:	46c0      	nop			; (mov r8, r8)
 800088a:	46c0      	nop			; (mov r8, r8)
 800088c:	46c0      	nop			; (mov r8, r8)
 800088e:	46c0      	nop			; (mov r8, r8)

08000890 <chSchGoSleepS.4609>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000890:	4b07      	ldr	r3, [pc, #28]	; (80008b0 <chSchGoSleepS.4609+0x20>)

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000892:	2220      	movs	r2, #32
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000894:	6999      	ldr	r1, [r3, #24]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000896:	b510      	push	{r4, lr}
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000898:	5488      	strb	r0, [r1, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800089a:	6818      	ldr	r0, [r3, #0]

  tqp->next             = tp->queue.next;
 800089c:	6804      	ldr	r4, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800089e:	6063      	str	r3, [r4, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80008a0:	601c      	str	r4, [r3, #0]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80008a2:	6198      	str	r0, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80008a4:	2301      	movs	r3, #1
 80008a6:	5483      	strb	r3, [r0, r2]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80008a8:	f7ff fc92 	bl	80001d0 <_port_switch>
}
 80008ac:	bd10      	pop	{r4, pc}
 80008ae:	46c0      	nop			; (mov r8, r8)
 80008b0:	20000958 	.word	0x20000958
 80008b4:	46c0      	nop			; (mov r8, r8)
 80008b6:	46c0      	nop			; (mov r8, r8)
 80008b8:	46c0      	nop			; (mov r8, r8)
 80008ba:	46c0      	nop			; (mov r8, r8)
 80008bc:	46c0      	nop			; (mov r8, r8)
 80008be:	46c0      	nop			; (mov r8, r8)

080008c0 <chSchGoSleepTimeoutS.4521>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80008c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008c2:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80008c4:	1c4a      	adds	r2, r1, #1
 80008c6:	d046      	beq.n	8000956 <chSchGoSleepTimeoutS.4521+0x96>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80008c8:	4e3e      	ldr	r6, [pc, #248]	; (80009c4 <chSchGoSleepTimeoutS.4521+0x104>)

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 80008ca:	4a3f      	ldr	r2, [pc, #252]	; (80009c8 <chSchGoSleepTimeoutS.4521+0x108>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 80008cc:	69b3      	ldr	r3, [r6, #24]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80008ce:	2480      	movs	r4, #128	; 0x80
 80008d0:	ad01      	add	r5, sp, #4
 80008d2:	05e7      	lsls	r7, r4, #23
  vtp->func = vtfunc;
 80008d4:	60ea      	str	r2, [r5, #12]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 80008d6:	612b      	str	r3, [r5, #16]
 80008d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80008da:	2901      	cmp	r1, #1
 80008dc:	d95b      	bls.n	8000996 <chSchGoSleepTimeoutS.4521+0xd6>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80008de:	1c34      	adds	r4, r6, #0
 80008e0:	69f3      	ldr	r3, [r6, #28]
 80008e2:	341c      	adds	r4, #28
 80008e4:	42a3      	cmp	r3, r4
 80008e6:	d05a      	beq.n	800099e <chSchGoSleepTimeoutS.4521+0xde>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 80008e8:	6ab7      	ldr	r7, [r6, #40]	; 0x28
    if (delta < ch.vtlist.next->delta) {
 80008ea:	689c      	ldr	r4, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 80008ec:	1889      	adds	r1, r1, r2
 80008ee:	1bca      	subs	r2, r1, r7
    if (delta < ch.vtlist.next->delta) {
 80008f0:	42a2      	cmp	r2, r4
 80008f2:	d207      	bcs.n	8000904 <chSchGoSleepTimeoutS.4521+0x44>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80008f4:	2780      	movs	r7, #128	; 0x80
 80008f6:	05ff      	lsls	r7, r7, #23
 80008f8:	6379      	str	r1, [r7, #52]	; 0x34
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 80008fa:	4294      	cmp	r4, r2
 80008fc:	d204      	bcs.n	8000908 <chSchGoSleepTimeoutS.4521+0x48>
    delta -= p->delta;
    p = p->next;
 80008fe:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
 8000900:	1b12      	subs	r2, r2, r4
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8000902:	689c      	ldr	r4, [r3, #8]
 8000904:	4294      	cmp	r4, r2
 8000906:	d3fa      	bcc.n	80008fe <chSchGoSleepTimeoutS.4521+0x3e>
  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
  p->prev = vtp;
  vtp->delta = delta
 8000908:	60aa      	str	r2, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800090a:	6899      	ldr	r1, [r3, #8]
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800090c:	685c      	ldr	r4, [r3, #4]
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800090e:	1a8a      	subs	r2, r1, r2
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8000910:	9301      	str	r3, [sp, #4]
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8000912:	609a      	str	r2, [r3, #8]
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000914:	606c      	str	r4, [r5, #4]
  vtp->prev->next = vtp;
  p->prev = vtp;
 8000916:	605d      	str	r5, [r3, #4]
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
 8000918:	2301      	movs	r3, #1
 800091a:	425f      	negs	r7, r3
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 800091c:	6025      	str	r5, [r4, #0]
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
 800091e:	6277      	str	r7, [r6, #36]	; 0x24
    chSchGoSleepS(newstate);
 8000920:	f7ff ffb6 	bl	8000890 <chSchGoSleepS.4609>
    if (chVTIsArmedI(&vt)) {
 8000924:	68e8      	ldr	r0, [r5, #12]
 8000926:	2800      	cmp	r0, #0
 8000928:	d011      	beq.n	800094e <chSchGoSleepTimeoutS.4521+0x8e>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800092a:	69f1      	ldr	r1, [r6, #28]
 800092c:	42a9      	cmp	r1, r5
 800092e:	d016      	beq.n	800095e <chSchGoSleepTimeoutS.4521+0x9e>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000930:	686a      	ldr	r2, [r5, #4]
 8000932:	682c      	ldr	r4, [r5, #0]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000934:	1c37      	adds	r7, r6, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000936:	6014      	str	r4, [r2, #0]
    vtp->next->prev = vtp->prev;
 8000938:	6829      	ldr	r1, [r5, #0]
    vtp->func = NULL;
 800093a:	2000      	movs	r0, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800093c:	371c      	adds	r7, #28
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 800093e:	604a      	str	r2, [r1, #4]
    vtp->func = NULL;
 8000940:	60e8      	str	r0, [r5, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000942:	42b9      	cmp	r1, r7
 8000944:	d003      	beq.n	800094e <chSchGoSleepTimeoutS.4521+0x8e>
      vtp->next->delta += vtp->delta;
 8000946:	68ab      	ldr	r3, [r5, #8]
 8000948:	688d      	ldr	r5, [r1, #8]
 800094a:	18ea      	adds	r2, r5, r3
 800094c:	608a      	str	r2, [r1, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 800094e:	69b6      	ldr	r6, [r6, #24]
 8000950:	6a70      	ldr	r0, [r6, #36]	; 0x24
}
 8000952:	b007      	add	sp, #28
 8000954:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000956:	f7ff ff9b 	bl	8000890 <chSchGoSleepS.4609>
 800095a:	4e1a      	ldr	r6, [pc, #104]	; (80009c4 <chSchGoSleepTimeoutS.4521+0x104>)
 800095c:	e7f7      	b.n	800094e <chSchGoSleepTimeoutS.4521+0x8e>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800095e:	682f      	ldr	r7, [r5, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000960:	1c33      	adds	r3, r6, #0
 8000962:	331c      	adds	r3, #28
  vtp->func = NULL;
 8000964:	2200      	movs	r2, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000966:	61f7      	str	r7, [r6, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8000968:	60ea      	str	r2, [r5, #12]
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800096a:	607b      	str	r3, [r7, #4]
  vtp->func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800096c:	429f      	cmp	r7, r3
 800096e:	d025      	beq.n	80009bc <chSchGoSleepTimeoutS.4521+0xfc>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000970:	68ad      	ldr	r5, [r5, #8]
 8000972:	68bc      	ldr	r4, [r7, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000974:	2180      	movs	r1, #128	; 0x80
 8000976:	1928      	adds	r0, r5, r4
 8000978:	60b8      	str	r0, [r7, #8]
 800097a:	05cf      	lsls	r7, r1, #23
 800097c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800097e:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 8000980:	1a9d      	subs	r5, r3, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000982:	42a8      	cmp	r0, r5
 8000984:	d9e3      	bls.n	800094e <chSchGoSleepTimeoutS.4521+0x8e>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000986:	1b44      	subs	r4, r0, r5

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000988:	2c01      	cmp	r4, #1
 800098a:	d906      	bls.n	800099a <chSchGoSleepTimeoutS.4521+0xda>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800098c:	2080      	movs	r0, #128	; 0x80
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800098e:	18e1      	adds	r1, r4, r3
 8000990:	05c7      	lsls	r7, r0, #23
 8000992:	6379      	str	r1, [r7, #52]	; 0x34
 8000994:	e7db      	b.n	800094e <chSchGoSleepTimeoutS.4521+0x8e>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000996:	2102      	movs	r1, #2
 8000998:	e7a1      	b.n	80008de <chSchGoSleepTimeoutS.4521+0x1e>
  delta = ch.vtlist.next->delta - nowdelta;

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800099a:	2402      	movs	r4, #2
 800099c:	e7f6      	b.n	800098c <chSchGoSleepTimeoutS.4521+0xcc>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800099e:	2780      	movs	r7, #128	; 0x80
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80009a0:	62b2      	str	r2, [r6, #40]	; 0x28
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80009a2:	9301      	str	r3, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80009a4:	606b      	str	r3, [r5, #4]
      vtp->delta = delay;
 80009a6:	60a9      	str	r1, [r5, #8]
 80009a8:	05fb      	lsls	r3, r7, #23

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 80009aa:	1889      	adds	r1, r1, r2
  STM32_ST_TIM->SR     = 0;
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80009ac:	2402      	movs	r4, #2
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 80009ae:	2200      	movs	r2, #0
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 80009b0:	61f5      	str	r5, [r6, #28]
      ch.vtlist.prev = vtp;
 80009b2:	6235      	str	r5, [r6, #32]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80009b4:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80009b6:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80009b8:	60dc      	str	r4, [r3, #12]
 80009ba:	e7b1      	b.n	8000920 <chSchGoSleepTimeoutS.4521+0x60>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80009bc:	2380      	movs	r3, #128	; 0x80
 80009be:	05dd      	lsls	r5, r3, #23
 80009c0:	60ea      	str	r2, [r5, #12]
 80009c2:	e7c4      	b.n	800094e <chSchGoSleepTimeoutS.4521+0x8e>
 80009c4:	20000958 	.word	0x20000958
 80009c8:	08000321 	.word	0x08000321
 80009cc:	46c0      	nop			; (mov r8, r8)
 80009ce:	46c0      	nop			; (mov r8, r8)

080009d0 <chThdSleep.4442>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80009d0:	b508      	push	{r3, lr}
 80009d2:	1c01      	adds	r1, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009d4:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80009d6:	2008      	movs	r0, #8
 80009d8:	f7ff ff72 	bl	80008c0 <chSchGoSleepTimeoutS.4521>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009dc:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 80009de:	bd08      	pop	{r3, pc}

080009e0 <chThdEnqueueTimeoutS.4517>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80009e0:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 80009e2:	2900      	cmp	r1, #0
 80009e4:	d00a      	beq.n	80009fc <chThdEnqueueTimeoutS.4517+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80009e6:	4b07      	ldr	r3, [pc, #28]	; (8000a04 <chThdEnqueueTimeoutS.4517+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 80009e8:	6842      	ldr	r2, [r0, #4]
 80009ea:	699b      	ldr	r3, [r3, #24]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 80009ec:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 80009ee:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80009f0:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 80009f2:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80009f4:	2004      	movs	r0, #4
 80009f6:	f7ff ff63 	bl	80008c0 <chSchGoSleepTimeoutS.4521>
}
 80009fa:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 80009fc:	2001      	movs	r0, #1
 80009fe:	4240      	negs	r0, r0
 8000a00:	e7fb      	b.n	80009fa <chThdEnqueueTimeoutS.4517+0x1a>
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	20000958 	.word	0x20000958
 8000a08:	46c0      	nop			; (mov r8, r8)
 8000a0a:	46c0      	nop			; (mov r8, r8)
 8000a0c:	46c0      	nop			; (mov r8, r8)
 8000a0e:	46c0      	nop			; (mov r8, r8)

08000a10 <iqGetTimeout.4455>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000a10:	b538      	push	{r3, r4, r5, lr}
 8000a12:	1c04      	adds	r4, r0, #0
 8000a14:	1c0d      	adds	r5, r1, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a16:	b672      	cpsid	i
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8000a18:	68a3      	ldr	r3, [r4, #8]
 8000a1a:	2b00      	cmp	r3, #0
 8000a1c:	d107      	bne.n	8000a2e <iqGetTimeout.4455+0x1e>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 8000a1e:	1c20      	adds	r0, r4, #0
 8000a20:	1c29      	adds	r1, r5, #0
 8000a22:	f7ff ffdd 	bl	80009e0 <chThdEnqueueTimeoutS.4517>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000a26:	2800      	cmp	r0, #0
 8000a28:	daf6      	bge.n	8000a18 <iqGetTimeout.4455+0x8>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a2a:	b662      	cpsie	i
  }

  osalSysUnlock();

  return (msg_t)b;
}
 8000a2c:	bd38      	pop	{r3, r4, r5, pc}
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000a2e:	68a0      	ldr	r0, [r4, #8]
  b = *iqp->q_rdptr++;
 8000a30:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000a32:	3801      	subs	r0, #1
 8000a34:	60a0      	str	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000a36:	6922      	ldr	r2, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000a38:	780d      	ldrb	r5, [r1, #0]
 8000a3a:	3101      	adds	r1, #1
 8000a3c:	61a1      	str	r1, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000a3e:	4291      	cmp	r1, r2
 8000a40:	d301      	bcc.n	8000a46 <iqGetTimeout.4455+0x36>
    iqp->q_rdptr = iqp->q_buffer;
 8000a42:	68e3      	ldr	r3, [r4, #12]
 8000a44:	61a3      	str	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8000a46:	69e1      	ldr	r1, [r4, #28]
 8000a48:	2900      	cmp	r1, #0
 8000a4a:	d001      	beq.n	8000a50 <iqGetTimeout.4455+0x40>
    iqp->q_notify(iqp);
 8000a4c:	1c20      	adds	r0, r4, #0
 8000a4e:	4788      	blx	r1
 8000a50:	b662      	cpsie	i
  }

  osalSysUnlock();

  return (msg_t)b;
 8000a52:	1c28      	adds	r0, r5, #0
 8000a54:	e7ea      	b.n	8000a2c <iqGetTimeout.4455+0x1c>
 8000a56:	46c0      	nop			; (mov r8, r8)
 8000a58:	46c0      	nop			; (mov r8, r8)
 8000a5a:	46c0      	nop			; (mov r8, r8)
 8000a5c:	46c0      	nop			; (mov r8, r8)
 8000a5e:	46c0      	nop			; (mov r8, r8)

08000a60 <gett.7082.4448>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 8000a60:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000a62:	300c      	adds	r0, #12
 8000a64:	f7ff ffd4 	bl	8000a10 <iqGetTimeout.4455>
}
 8000a68:	bd08      	pop	{r3, pc}
 8000a6a:	46c0      	nop			; (mov r8, r8)
 8000a6c:	46c0      	nop			; (mov r8, r8)
 8000a6e:	46c0      	nop			; (mov r8, r8)

08000a70 <get.7086.4452>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 8000a70:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000a72:	2101      	movs	r1, #1
 8000a74:	300c      	adds	r0, #12
 8000a76:	4249      	negs	r1, r1
 8000a78:	f7ff ffca 	bl	8000a10 <iqGetTimeout.4455>
}
 8000a7c:	bd08      	pop	{r3, pc}
 8000a7e:	46c0      	nop			; (mov r8, r8)

08000a80 <iqReadTimeout.4473>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8000a80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a82:	4656      	mov	r6, sl
 8000a84:	464d      	mov	r5, r9
 8000a86:	4644      	mov	r4, r8
 8000a88:	465f      	mov	r7, fp
 8000a8a:	b4f0      	push	{r4, r5, r6, r7}
 8000a8c:	1c0e      	adds	r6, r1, #0
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8000a8e:	69c1      	ldr	r1, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8000a90:	b083      	sub	sp, #12
 8000a92:	1c04      	adds	r4, r0, #0
 8000a94:	1c15      	adds	r5, r2, #0
 8000a96:	4699      	mov	r9, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8000a98:	4688      	mov	r8, r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a9a:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000a9c:	2380      	movs	r3, #128	; 0x80
 8000a9e:	05d8      	lsls	r0, r3, #23
 8000aa0:	6a42      	ldr	r2, [r0, #36]	; 0x24
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000aa2:	2101      	movs	r1, #1
 8000aa4:	424b      	negs	r3, r1
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8000aa6:	444a      	add	r2, r9
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000aa8:	469a      	mov	sl, r3
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8000aaa:	9201      	str	r2, [sp, #4]
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8000aac:	2700      	movs	r7, #0
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000aae:	44ca      	add	sl, r9
 8000ab0:	4683      	mov	fp, r0
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8000ab2:	68a0      	ldr	r0, [r4, #8]
 8000ab4:	2800      	cmp	r0, #0
 8000ab6:	d01b      	beq.n	8000af0 <iqReadTimeout.4473+0x70>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8000ab8:	68a2      	ldr	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000aba:	69a3      	ldr	r3, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8000abc:	3a01      	subs	r2, #1
 8000abe:	60a2      	str	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000ac0:	7819      	ldrb	r1, [r3, #0]
 8000ac2:	3301      	adds	r3, #1
 8000ac4:	7031      	strb	r1, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8000ac6:	6920      	ldr	r0, [r4, #16]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8000ac8:	3601      	adds	r6, #1
 8000aca:	61a3      	str	r3, [r4, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 8000acc:	4283      	cmp	r3, r0
 8000ace:	d301      	bcc.n	8000ad4 <iqReadTimeout.4473+0x54>
      iqp->q_rdptr = iqp->q_buffer;
 8000ad0:	68e2      	ldr	r2, [r4, #12]
 8000ad2:	61a2      	str	r2, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8000ad4:	4643      	mov	r3, r8
 8000ad6:	2b00      	cmp	r3, #0
 8000ad8:	d001      	beq.n	8000ade <iqReadTimeout.4473+0x5e>
      nfy(iqp);
 8000ada:	1c20      	adds	r0, r4, #0
 8000adc:	47c0      	blx	r8
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ade:	b662      	cpsie	i

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 8000ae0:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 8000ae2:	3701      	adds	r7, #1
    if (--n == 0U) {
 8000ae4:	2d00      	cmp	r5, #0
 8000ae6:	d012      	beq.n	8000b0e <iqReadTimeout.4473+0x8e>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ae8:	b672      	cpsid	i
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8000aea:	68a0      	ldr	r0, [r4, #8]
 8000aec:	2800      	cmp	r0, #0
 8000aee:	d1e3      	bne.n	8000ab8 <iqReadTimeout.4473+0x38>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000af0:	4651      	mov	r1, sl
 8000af2:	1ccb      	adds	r3, r1, #3
 8000af4:	d813      	bhi.n	8000b1e <iqReadTimeout.4473+0x9e>
 8000af6:	4658      	mov	r0, fp
 8000af8:	6a42      	ldr	r2, [r0, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8000afa:	9b01      	ldr	r3, [sp, #4]
 8000afc:	1a99      	subs	r1, r3, r2

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8000afe:	4589      	cmp	r9, r1
 8000b00:	d304      	bcc.n	8000b0c <iqReadTimeout.4473+0x8c>
 8000b02:	1c20      	adds	r0, r4, #0
 8000b04:	f7ff ff6c 	bl	80009e0 <chThdEnqueueTimeoutS.4517>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8000b08:	2800      	cmp	r0, #0
 8000b0a:	d0d2      	beq.n	8000ab2 <iqReadTimeout.4473+0x32>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b0c:	b662      	cpsie	i
      return r;
    }

    osalSysLock();
  }
}
 8000b0e:	1c38      	adds	r0, r7, #0
 8000b10:	b003      	add	sp, #12
 8000b12:	bc3c      	pop	{r2, r3, r4, r5}
 8000b14:	4690      	mov	r8, r2
 8000b16:	4699      	mov	r9, r3
 8000b18:	46a2      	mov	sl, r4
 8000b1a:	46ab      	mov	fp, r5
 8000b1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b1e:	1c20      	adds	r0, r4, #0
 8000b20:	4649      	mov	r1, r9
 8000b22:	f7ff ff5d 	bl	80009e0 <chThdEnqueueTimeoutS.4517>
 8000b26:	e7ef      	b.n	8000b08 <iqReadTimeout.4473+0x88>
 8000b28:	46c0      	nop			; (mov r8, r8)
 8000b2a:	46c0      	nop			; (mov r8, r8)
 8000b2c:	46c0      	nop			; (mov r8, r8)
 8000b2e:	46c0      	nop			; (mov r8, r8)

08000b30 <readt.7059.4462>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8000b30:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000b32:	300c      	adds	r0, #12
 8000b34:	f7ff ffa4 	bl	8000a80 <iqReadTimeout.4473>
}
 8000b38:	bd08      	pop	{r3, pc}
 8000b3a:	46c0      	nop			; (mov r8, r8)
 8000b3c:	46c0      	nop			; (mov r8, r8)
 8000b3e:	46c0      	nop			; (mov r8, r8)

08000b40 <read.7066.4468>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8000b40:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000b42:	2301      	movs	r3, #1
 8000b44:	300c      	adds	r0, #12
 8000b46:	425b      	negs	r3, r3
 8000b48:	f7ff ff9a 	bl	8000a80 <iqReadTimeout.4473>
                       n, TIME_INFINITE);
}
 8000b4c:	bd08      	pop	{r3, pc}
 8000b4e:	46c0      	nop			; (mov r8, r8)

08000b50 <oqPutTimeout.4491>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000b50:	b570      	push	{r4, r5, r6, lr}
 8000b52:	1c04      	adds	r4, r0, #0
 8000b54:	1c0e      	adds	r6, r1, #0
 8000b56:	1c15      	adds	r5, r2, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b58:	b672      	cpsid	i

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8000b5a:	68a3      	ldr	r3, [r4, #8]
 8000b5c:	2b00      	cmp	r3, #0
 8000b5e:	d107      	bne.n	8000b70 <oqPutTimeout.4491+0x20>
 8000b60:	1c20      	adds	r0, r4, #0
 8000b62:	1c29      	adds	r1, r5, #0
 8000b64:	f7ff ff3c 	bl	80009e0 <chThdEnqueueTimeoutS.4517>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000b68:	2800      	cmp	r0, #0
 8000b6a:	daf6      	bge.n	8000b5a <oqPutTimeout.4491+0xa>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b6c:	b662      	cpsie	i
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000b6e:	bd70      	pop	{r4, r5, r6, pc}
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8000b70:	68a0      	ldr	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000b72:	6961      	ldr	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8000b74:	3801      	subs	r0, #1
 8000b76:	60a0      	str	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000b78:	700e      	strb	r6, [r1, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000b7a:	6922      	ldr	r2, [r4, #16]
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000b7c:	3101      	adds	r1, #1
 8000b7e:	6161      	str	r1, [r4, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000b80:	4291      	cmp	r1, r2
 8000b82:	d301      	bcc.n	8000b88 <oqPutTimeout.4491+0x38>
    oqp->q_wrptr = oqp->q_buffer;
 8000b84:	68e5      	ldr	r5, [r4, #12]
 8000b86:	6165      	str	r5, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000b88:	69e6      	ldr	r6, [r4, #28]
 8000b8a:	2e00      	cmp	r6, #0
 8000b8c:	d001      	beq.n	8000b92 <oqPutTimeout.4491+0x42>
    oqp->q_notify(oqp);
 8000b8e:	1c20      	adds	r0, r4, #0
 8000b90:	47b0      	blx	r6
 8000b92:	b662      	cpsie	i
 8000b94:	2000      	movs	r0, #0
 8000b96:	e7ea      	b.n	8000b6e <oqPutTimeout.4491+0x1e>
 8000b98:	46c0      	nop			; (mov r8, r8)
 8000b9a:	46c0      	nop			; (mov r8, r8)
 8000b9c:	46c0      	nop			; (mov r8, r8)
 8000b9e:	46c0      	nop			; (mov r8, r8)

08000ba0 <putt.7089.4479>:
static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8000ba0:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000ba2:	3030      	adds	r0, #48	; 0x30
 8000ba4:	f7ff ffd4 	bl	8000b50 <oqPutTimeout.4491>
}
 8000ba8:	bd08      	pop	{r3, pc}
 8000baa:	46c0      	nop			; (mov r8, r8)
 8000bac:	46c0      	nop			; (mov r8, r8)
 8000bae:	46c0      	nop			; (mov r8, r8)

08000bb0 <put.7094.4484>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8000bb0:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000bb2:	2201      	movs	r2, #1
 8000bb4:	3030      	adds	r0, #48	; 0x30
 8000bb6:	4252      	negs	r2, r2
 8000bb8:	f7ff ffca 	bl	8000b50 <oqPutTimeout.4491>
}
 8000bbc:	bd08      	pop	{r3, pc}
 8000bbe:	46c0      	nop			; (mov r8, r8)

08000bc0 <oqWriteTimeout.4511>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8000bc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000bc2:	4656      	mov	r6, sl
 8000bc4:	464d      	mov	r5, r9
 8000bc6:	4644      	mov	r4, r8
 8000bc8:	465f      	mov	r7, fp
 8000bca:	b4f0      	push	{r4, r5, r6, r7}
 8000bcc:	1c0e      	adds	r6, r1, #0
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8000bce:	69c1      	ldr	r1, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8000bd0:	b083      	sub	sp, #12
 8000bd2:	1c04      	adds	r4, r0, #0
 8000bd4:	1c15      	adds	r5, r2, #0
 8000bd6:	4699      	mov	r9, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8000bd8:	4688      	mov	r8, r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000bda:	b672      	cpsid	i
 8000bdc:	2380      	movs	r3, #128	; 0x80
 8000bde:	05d8      	lsls	r0, r3, #23
 8000be0:	6a42      	ldr	r2, [r0, #36]	; 0x24
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000be2:	2101      	movs	r1, #1
 8000be4:	424b      	negs	r3, r1
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8000be6:	444a      	add	r2, r9
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000be8:	469a      	mov	sl, r3
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8000bea:	9201      	str	r2, [sp, #4]
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8000bec:	2700      	movs	r7, #0
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000bee:	44ca      	add	sl, r9
 8000bf0:	4683      	mov	fp, r0
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8000bf2:	68a0      	ldr	r0, [r4, #8]
 8000bf4:	2800      	cmp	r0, #0
 8000bf6:	d01b      	beq.n	8000c30 <oqWriteTimeout.4511+0x70>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8000bf8:	68a2      	ldr	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000bfa:	6963      	ldr	r3, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8000bfc:	3a01      	subs	r2, #1
 8000bfe:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000c00:	7831      	ldrb	r1, [r6, #0]
 8000c02:	3601      	adds	r6, #1
 8000c04:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000c06:	6920      	ldr	r0, [r4, #16]
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000c08:	3301      	adds	r3, #1
 8000c0a:	6163      	str	r3, [r4, #20]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000c0c:	4283      	cmp	r3, r0
 8000c0e:	d301      	bcc.n	8000c14 <oqWriteTimeout.4511+0x54>
      oqp->q_wrptr = oqp->q_buffer;
 8000c10:	68e2      	ldr	r2, [r4, #12]
 8000c12:	6162      	str	r2, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8000c14:	4643      	mov	r3, r8
 8000c16:	2b00      	cmp	r3, #0
 8000c18:	d001      	beq.n	8000c1e <oqWriteTimeout.4511+0x5e>
      nfy(oqp);
 8000c1a:	1c20      	adds	r0, r4, #0
 8000c1c:	47c0      	blx	r8
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c1e:	b662      	cpsie	i

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 8000c20:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 8000c22:	3701      	adds	r7, #1
    if (--n == 0U) {
 8000c24:	2d00      	cmp	r5, #0
 8000c26:	d012      	beq.n	8000c4e <oqWriteTimeout.4511+0x8e>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c28:	b672      	cpsid	i
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8000c2a:	68a0      	ldr	r0, [r4, #8]
 8000c2c:	2800      	cmp	r0, #0
 8000c2e:	d1e3      	bne.n	8000bf8 <oqWriteTimeout.4511+0x38>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8000c30:	4651      	mov	r1, sl
 8000c32:	1ccb      	adds	r3, r1, #3
 8000c34:	d813      	bhi.n	8000c5e <oqWriteTimeout.4511+0x9e>
 8000c36:	4658      	mov	r0, fp
 8000c38:	6a42      	ldr	r2, [r0, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8000c3a:	9b01      	ldr	r3, [sp, #4]
 8000c3c:	1a99      	subs	r1, r3, r2

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8000c3e:	4589      	cmp	r9, r1
 8000c40:	d304      	bcc.n	8000c4c <oqWriteTimeout.4511+0x8c>
 8000c42:	1c20      	adds	r0, r4, #0
 8000c44:	f7ff fecc 	bl	80009e0 <chThdEnqueueTimeoutS.4517>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8000c48:	2800      	cmp	r0, #0
 8000c4a:	d0d2      	beq.n	8000bf2 <oqWriteTimeout.4511+0x32>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c4c:	b662      	cpsie	i
      return w;
    }

    osalSysLock();
  }
}
 8000c4e:	1c38      	adds	r0, r7, #0
 8000c50:	b003      	add	sp, #12
 8000c52:	bc3c      	pop	{r2, r3, r4, r5}
 8000c54:	4690      	mov	r8, r2
 8000c56:	4699      	mov	r9, r3
 8000c58:	46a2      	mov	sl, r4
 8000c5a:	46ab      	mov	fp, r5
 8000c5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c5e:	1c20      	adds	r0, r4, #0
 8000c60:	4649      	mov	r1, r9
 8000c62:	f7ff febd 	bl	80009e0 <chThdEnqueueTimeoutS.4517>
 8000c66:	e7ef      	b.n	8000c48 <oqWriteTimeout.4511+0x88>
 8000c68:	46c0      	nop			; (mov r8, r8)
 8000c6a:	46c0      	nop			; (mov r8, r8)
 8000c6c:	46c0      	nop			; (mov r8, r8)
 8000c6e:	46c0      	nop			; (mov r8, r8)

08000c70 <writet.7071.4500>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8000c70:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000c72:	3030      	adds	r0, #48	; 0x30
 8000c74:	f7ff ffa4 	bl	8000bc0 <oqWriteTimeout.4511>
}
 8000c78:	bd08      	pop	{r3, pc}
 8000c7a:	46c0      	nop			; (mov r8, r8)
 8000c7c:	46c0      	nop			; (mov r8, r8)
 8000c7e:	46c0      	nop			; (mov r8, r8)

08000c80 <write.7077.4506>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8000c80:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000c82:	2301      	movs	r3, #1
 8000c84:	3030      	adds	r0, #48	; 0x30
 8000c86:	425b      	negs	r3, r3
 8000c88:	f7ff ff9a 	bl	8000bc0 <oqWriteTimeout.4511>
                        n, TIME_INFINITE);
}
 8000c8c:	bd08      	pop	{r3, pc}
 8000c8e:	46c0      	nop			; (mov r8, r8)

08000c90 <VectorB0.4396>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000c90:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8000c92:	4804      	ldr	r0, [pc, #16]	; (8000ca4 <VectorB0.4396+0x14>)
 8000c94:	4674      	mov	r4, lr
 8000c96:	f7ff fcc3 	bl	8000620 <serve_interrupt.7558.4400>

  OSAL_IRQ_EPILOGUE();
 8000c9a:	1c20      	adds	r0, r4, #0
 8000c9c:	f7ff fc48 	bl	8000530 <_port_irq_epilogue.4590>
}
 8000ca0:	bd10      	pop	{r4, pc}
 8000ca2:	46c0      	nop			; (mov r8, r8)
 8000ca4:	200008d4 	.word	0x200008d4
 8000ca8:	46c0      	nop			; (mov r8, r8)
 8000caa:	46c0      	nop			; (mov r8, r8)
 8000cac:	46c0      	nop			; (mov r8, r8)
 8000cae:	46c0      	nop			; (mov r8, r8)

08000cb0 <VectorAC.4398>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000cb0:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);
 8000cb2:	4804      	ldr	r0, [pc, #16]	; (8000cc4 <VectorAC.4398+0x14>)
 8000cb4:	4674      	mov	r4, lr
 8000cb6:	f7ff fcb3 	bl	8000620 <serve_interrupt.7558.4400>

  OSAL_IRQ_EPILOGUE();
 8000cba:	1c20      	adds	r0, r4, #0
 8000cbc:	f7ff fc38 	bl	8000530 <_port_irq_epilogue.4590>
}
 8000cc0:	bd10      	pop	{r4, pc}
 8000cc2:	46c0      	nop			; (mov r8, r8)
 8000cc4:	20000610 	.word	0x20000610
 8000cc8:	46c0      	nop			; (mov r8, r8)
 8000cca:	46c0      	nop			; (mov r8, r8)
 8000ccc:	46c0      	nop			; (mov r8, r8)
 8000cce:	46c0      	nop			; (mov r8, r8)

08000cd0 <Vector7C.4431>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000cd2:	4646      	mov	r6, r8
 8000cd4:	464f      	mov	r7, r9
 8000cd6:	b4c0      	push	{r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000cd8:	2680      	movs	r6, #128	; 0x80
 8000cda:	05f6      	lsls	r6, r6, #23
 8000cdc:	6933      	ldr	r3, [r6, #16]
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8000cde:	46f0      	mov	r8, lr

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000ce0:	0798      	lsls	r0, r3, #30
 8000ce2:	d406      	bmi.n	8000cf2 <Vector7C.4431+0x22>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000ce4:	4640      	mov	r0, r8
 8000ce6:	f7ff fc23 	bl	8000530 <_port_irq_epilogue.4590>
}
 8000cea:	bc0c      	pop	{r2, r3}
 8000cec:	4690      	mov	r8, r2
 8000cee:	4699      	mov	r9, r3
 8000cf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8000cf2:	2000      	movs	r0, #0
 8000cf4:	6130      	str	r0, [r6, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cf6:	b672      	cpsid	i
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000cf8:	4c18      	ldr	r4, [pc, #96]	; (8000d5c <Vector7C.4431+0x8c>)
 8000cfa:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000cfc:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000cfe:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000d00:	689a      	ldr	r2, [r3, #8]
 8000d02:	1a45      	subs	r5, r0, r1
 8000d04:	4295      	cmp	r5, r2
 8000d06:	d318      	bcc.n	8000d3a <Vector7C.4431+0x6a>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000d08:	1c25      	adds	r5, r4, #0
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000d0a:	2700      	movs	r7, #0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000d0c:	351c      	adds	r5, #28
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000d0e:	46b9      	mov	r9, r7
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000d10:	681f      	ldr	r7, [r3, #0]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000d12:	188a      	adds	r2, r1, r2

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000d14:	4648      	mov	r0, r9
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000d16:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8000d18:	68d9      	ldr	r1, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000d1a:	607d      	str	r5, [r7, #4]
    ch.vtlist.next = vtp->next;
 8000d1c:	61e7      	str	r7, [r4, #28]
    fn = vtp->func;
    vtp->func = NULL;
 8000d1e:	60d8      	str	r0, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000d20:	42af      	cmp	r7, r5
 8000d22:	d017      	beq.n	8000d54 <Vector7C.4431+0x84>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d24:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8000d26:	6918      	ldr	r0, [r3, #16]
 8000d28:	4788      	blx	r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d2a:	b672      	cpsid	i
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8000d2c:	69e3      	ldr	r3, [r4, #28]
 8000d2e:	6a70      	ldr	r0, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000d30:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000d32:	689a      	ldr	r2, [r3, #8]
 8000d34:	1a47      	subs	r7, r0, r1
 8000d36:	42ba      	cmp	r2, r7
 8000d38:	d9ea      	bls.n	8000d10 <Vector7C.4431+0x40>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000d3a:	341c      	adds	r4, #28
 8000d3c:	42a3      	cmp	r3, r4
 8000d3e:	d007      	beq.n	8000d50 <Vector7C.4431+0x80>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8000d40:	188e      	adds	r6, r1, r2
 8000d42:	1a34      	subs	r4, r6, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000d44:	2c01      	cmp	r4, #1
 8000d46:	d907      	bls.n	8000d58 <Vector7C.4431+0x88>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000d48:	2380      	movs	r3, #128	; 0x80
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 8000d4a:	1825      	adds	r5, r4, r0
 8000d4c:	05d8      	lsls	r0, r3, #23
 8000d4e:	6345      	str	r5, [r0, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d50:	b662      	cpsie	i
 8000d52:	e7c7      	b.n	8000ce4 <Vector7C.4431+0x14>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000d54:	60f0      	str	r0, [r6, #12]
 8000d56:	e7e5      	b.n	8000d24 <Vector7C.4431+0x54>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000d58:	2402      	movs	r4, #2
 8000d5a:	e7f5      	b.n	8000d48 <Vector7C.4431+0x78>
 8000d5c:	20000958 	.word	0x20000958

08000d60 <debug_write.9962.4488>:
  *buf = 0;
  return n;
}
*/
static void debug_write(char *msg)
{
 8000d60:	b570      	push	{r4, r5, r6, lr}
 8000d62:	1c06      	adds	r6, r0, #0
    sdWrite(&SD1, (uint8_t*)msg, strlen(msg));
 8000d64:	f000 fbc4 	bl	80014f0 <strlen>
 8000d68:	4d0a      	ldr	r5, [pc, #40]	; (8000d94 <debug_write.9962.4488+0x34>)
 8000d6a:	2401      	movs	r4, #1
 8000d6c:	3530      	adds	r5, #48	; 0x30
 8000d6e:	4264      	negs	r4, r4
 8000d70:	1c31      	adds	r1, r6, #0
 8000d72:	1c23      	adds	r3, r4, #0
 8000d74:	1c02      	adds	r2, r0, #0
 8000d76:	1c28      	adds	r0, r5, #0
 8000d78:	f7ff ff22 	bl	8000bc0 <oqWriteTimeout.4511>
    sdPut(&SD1, '\r');
 8000d7c:	1c28      	adds	r0, r5, #0
 8000d7e:	1c22      	adds	r2, r4, #0
 8000d80:	210d      	movs	r1, #13
 8000d82:	f7ff fee5 	bl	8000b50 <oqPutTimeout.4491>
    sdPut(&SD1, '\n');
 8000d86:	1c28      	adds	r0, r5, #0
 8000d88:	210a      	movs	r1, #10
 8000d8a:	1c22      	adds	r2, r4, #0
 8000d8c:	f7ff fee0 	bl	8000b50 <oqPutTimeout.4491>
}
 8000d90:	bd70      	pop	{r4, r5, r6, pc}
 8000d92:	46c0      	nop			; (mov r8, r8)
 8000d94:	20000610 	.word	0x20000610
 8000d98:	46c0      	nop			; (mov r8, r8)
 8000d9a:	46c0      	nop			; (mov r8, r8)
 8000d9c:	46c0      	nop			; (mov r8, r8)
 8000d9e:	46c0      	nop			; (mov r8, r8)

08000da0 <CAN_rx.9956.4205>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8000da0:	4b0b      	ldr	r3, [pc, #44]	; (8000dd0 <CAN_rx.9956.4205+0x30>)

/**
 * CAN data receive thread
 */
static THD_WORKING_AREA(wa_CAN_rx, 128);
static THD_FUNCTION(CAN_rx, arg) {
 8000da2:	b570      	push	{r4, r5, r6, lr}
 8000da4:	6998      	ldr	r0, [r3, #24]
 8000da6:	4a0b      	ldr	r2, [pc, #44]	; (8000dd4 <CAN_rx.9956.4205+0x34>)

    (void)arg;
    chRegSetThreadName("CAN_RX");
    char * at_msg= "AT\r\n";
    while (true) {
        sdWrite(&SD2, (uint8_t*)at_msg, strlen(at_msg));
 8000da8:	4c0b      	ldr	r4, [pc, #44]	; (8000dd8 <CAN_rx.9956.4205+0x38>)
 8000daa:	4e0c      	ldr	r6, [pc, #48]	; (8000ddc <CAN_rx.9956.4205+0x3c>)
 8000dac:	4d0c      	ldr	r5, [pc, #48]	; (8000de0 <CAN_rx.9956.4205+0x40>)
 8000dae:	6182      	str	r2, [r0, #24]
 8000db0:	3430      	adds	r4, #48	; 0x30
 8000db2:	2301      	movs	r3, #1
 8000db4:	1c31      	adds	r1, r6, #0
 8000db6:	2204      	movs	r2, #4
 8000db8:	425b      	negs	r3, r3
 8000dba:	1c20      	adds	r0, r4, #0
 8000dbc:	f7ff ff00 	bl	8000bc0 <oqWriteTimeout.4511>

        chThdSleepMilliseconds(1000);
 8000dc0:	4808      	ldr	r0, [pc, #32]	; (8000de4 <CAN_rx.9956.4205+0x44>)
 8000dc2:	f7ff fe05 	bl	80009d0 <chThdSleep.4442>
        debug_write("sending AT");
 8000dc6:	1c28      	adds	r0, r5, #0
 8000dc8:	f7ff ffca 	bl	8000d60 <debug_write.9962.4488>
 8000dcc:	e7f1      	b.n	8000db2 <CAN_rx.9956.4205+0x12>
 8000dce:	46c0      	nop			; (mov r8, r8)
 8000dd0:	20000958 	.word	0x20000958
 8000dd4:	08001528 	.word	0x08001528
 8000dd8:	200008d4 	.word	0x200008d4
 8000ddc:	08001530 	.word	0x08001530
 8000de0:	08001538 	.word	0x08001538
 8000de4:	00002710 	.word	0x00002710
 8000de8:	46c0      	nop			; (mov r8, r8)
 8000dea:	46c0      	nop			; (mov r8, r8)
 8000dec:	46c0      	nop			; (mov r8, r8)
 8000dee:	46c0      	nop			; (mov r8, r8)

08000df0 <STN1110_rx.9959.4202>:
    sdPut(&SD1, '\r');
    sdPut(&SD1, '\n');
}

static THD_WORKING_AREA(wa_STN1110_rx, 128);
static THD_FUNCTION(STN1110_rx, arg) {
 8000df0:	b538      	push	{r3, r4, r5, lr}
 8000df2:	4b14      	ldr	r3, [pc, #80]	; (8000e44 <STN1110_rx.9959.4202+0x54>)
 8000df4:	4a14      	ldr	r2, [pc, #80]	; (8000e48 <STN1110_rx.9959.4202+0x58>)
 8000df6:	6998      	ldr	r0, [r3, #24]
  (void)arg;
  chRegSetThreadName("STN1110_RX");

  debug_write("resetting");
  palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8000df8:	4c14      	ldr	r4, [pc, #80]	; (8000e4c <STN1110_rx.9959.4202+0x5c>)
 8000dfa:	6182      	str	r2, [r0, #24]
static THD_WORKING_AREA(wa_STN1110_rx, 128);
static THD_FUNCTION(STN1110_rx, arg) {
  (void)arg;
  chRegSetThreadName("STN1110_RX");

  debug_write("resetting");
 8000dfc:	4814      	ldr	r0, [pc, #80]	; (8000e50 <STN1110_rx.9959.4202+0x60>)
 8000dfe:	f7ff ffaf 	bl	8000d60 <debug_write.9962.4488>
  palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
  palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8000e02:	2504      	movs	r5, #4
static THD_FUNCTION(STN1110_rx, arg) {
  (void)arg;
  chRegSetThreadName("STN1110_RX");

  debug_write("resetting");
  palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8000e04:	2201      	movs	r2, #1
 8000e06:	1c20      	adds	r0, r4, #0
 8000e08:	2104      	movs	r1, #4
 8000e0a:	f7ff fb11 	bl	8000430 <_pal_lld_setgroupmode.4562>
  palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8000e0e:	8365      	strh	r5, [r4, #26]
  chThdSleepMilliseconds(10);
 8000e10:	2064      	movs	r0, #100	; 0x64
 8000e12:	f7ff fddd 	bl	80009d0 <chThdSleep.4442>
  palSetPad(GPIOB, GPIOB_RESET_STN1110);
  chThdSleepMilliseconds(100);
 8000e16:	21fa      	movs	r1, #250	; 0xfa

  debug_write("resetting");
  palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
  palClearPad(GPIOB, GPIOB_RESET_STN1110);
  chThdSleepMilliseconds(10);
  palSetPad(GPIOB, GPIOB_RESET_STN1110);
 8000e18:	8325      	strh	r5, [r4, #24]
  chThdSleepMilliseconds(100);
 8000e1a:	0088      	lsls	r0, r1, #2
 8000e1c:	f7ff fdd8 	bl	80009d0 <chThdSleep.4442>
  debug_write("after reset");
 8000e20:	480c      	ldr	r0, [pc, #48]	; (8000e54 <STN1110_rx.9959.4202+0x64>)
 8000e22:	f7ff ff9d 	bl	8000d60 <debug_write.9962.4488>

  while (true) {
      /* Reset the STN1110 */
      sdReadTimeout(&SD1,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf),5000);
 8000e26:	4d0c      	ldr	r5, [pc, #48]	; (8000e58 <STN1110_rx.9959.4202+0x68>)
 8000e28:	4c0c      	ldr	r4, [pc, #48]	; (8000e5c <STN1110_rx.9959.4202+0x6c>)
 8000e2a:	350c      	adds	r5, #12
 8000e2c:	2380      	movs	r3, #128	; 0x80
 8000e2e:	009a      	lsls	r2, r3, #2
 8000e30:	1c28      	adds	r0, r5, #0
 8000e32:	1c21      	adds	r1, r4, #0
 8000e34:	4b0a      	ldr	r3, [pc, #40]	; (8000e60 <STN1110_rx.9959.4202+0x70>)
 8000e36:	f7ff fe23 	bl	8000a80 <iqReadTimeout.4473>
//sdGetLine(&SD1, (uint8_t*)stn_rx_buf);
      debug_write(stn_rx_buf);
 8000e3a:	1c20      	adds	r0, r4, #0
 8000e3c:	f7ff ff90 	bl	8000d60 <debug_write.9962.4488>
 8000e40:	e7f4      	b.n	8000e2c <STN1110_rx.9959.4202+0x3c>
 8000e42:	46c0      	nop			; (mov r8, r8)
 8000e44:	20000958 	.word	0x20000958
 8000e48:	08001544 	.word	0x08001544
 8000e4c:	48000400 	.word	0x48000400
 8000e50:	08001550 	.word	0x08001550
 8000e54:	0800155c 	.word	0x0800155c
 8000e58:	20000610 	.word	0x20000610
 8000e5c:	20000400 	.word	0x20000400
 8000e60:	00001388 	.word	0x00001388
 8000e64:	46c0      	nop			; (mov r8, r8)
 8000e66:	46c0      	nop			; (mov r8, r8)
 8000e68:	46c0      	nop			; (mov r8, r8)
 8000e6a:	46c0      	nop			; (mov r8, r8)
 8000e6c:	46c0      	nop			; (mov r8, r8)
 8000e6e:	46c0      	nop			; (mov r8, r8)

08000e70 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8000e70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000e72:	4be9      	ldr	r3, [pc, #932]	; (8001218 <main+0x3a8>)
 8000e74:	465f      	mov	r7, fp
 8000e76:	4656      	mov	r6, sl
 8000e78:	464d      	mov	r5, r9
 8000e7a:	4644      	mov	r4, r8
 8000e7c:	2101      	movs	r1, #1
 8000e7e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000e80:	b4f0      	push	{r4, r5, r6, r7}
 8000e82:	2200      	movs	r2, #0
 8000e84:	424c      	negs	r4, r1
 8000e86:	629c      	str	r4, [r3, #40]	; 0x28
 8000e88:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000e8a:	6918      	ldr	r0, [r3, #16]
 8000e8c:	611c      	str	r4, [r3, #16]
 8000e8e:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000e90:	68dd      	ldr	r5, [r3, #12]
 8000e92:	48e2      	ldr	r0, [pc, #904]	; (800121c <main+0x3ac>)

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000e94:	2780      	movs	r7, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000e96:	4305      	orrs	r5, r0
 8000e98:	60dd      	str	r5, [r3, #12]
 8000e9a:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000e9c:	69de      	ldr	r6, [r3, #28]
 8000e9e:	0579      	lsls	r1, r7, #21
 8000ea0:	4331      	orrs	r1, r6
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000ea2:	4ddf      	ldr	r5, [pc, #892]	; (8001220 <main+0x3b0>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000ea4:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000ea6:	682c      	ldr	r4, [r5, #0]
 8000ea8:	2080      	movs	r0, #128	; 0x80
 8000eaa:	0046      	lsls	r6, r0, #1
 8000eac:	4326      	orrs	r6, r4
 8000eae:	602e      	str	r6, [r5, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8000eb0:	6a1f      	ldr	r7, [r3, #32]
 8000eb2:	21c0      	movs	r1, #192	; 0xc0
 8000eb4:	008d      	lsls	r5, r1, #2
 8000eb6:	2480      	movs	r4, #128	; 0x80
 8000eb8:	402f      	ands	r7, r5
 8000eba:	00a0      	lsls	r0, r4, #2
 8000ebc:	4287      	cmp	r7, r0
 8000ebe:	d003      	beq.n	8000ec8 <main+0x58>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000ec0:	2680      	movs	r6, #128	; 0x80
 8000ec2:	0277      	lsls	r7, r6, #9
 8000ec4:	621f      	str	r7, [r3, #32]
    RCC->BDCR = 0;
 8000ec6:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000ec8:	4bd3      	ldr	r3, [pc, #844]	; (8001218 <main+0x3a8>)
 8000eca:	2280      	movs	r2, #128	; 0x80
 8000ecc:	6a19      	ldr	r1, [r3, #32]
 8000ece:	0215      	lsls	r5, r2, #8
 8000ed0:	4229      	tst	r1, r5
 8000ed2:	d107      	bne.n	8000ee4 <main+0x74>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000ed4:	6a1c      	ldr	r4, [r3, #32]
 8000ed6:	2080      	movs	r0, #128	; 0x80
 8000ed8:	0086      	lsls	r6, r0, #2
 8000eda:	4326      	orrs	r6, r4
 8000edc:	621e      	str	r6, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000ede:	6a1f      	ldr	r7, [r3, #32]
 8000ee0:	433d      	orrs	r5, r7
 8000ee2:	621d      	str	r5, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000ee4:	49cc      	ldr	r1, [pc, #816]	; (8001218 <main+0x3a8>)
 8000ee6:	23fc      	movs	r3, #252	; 0xfc
 8000ee8:	694a      	ldr	r2, [r1, #20]
 8000eea:	03dd      	lsls	r5, r3, #15
 8000eec:	4315      	orrs	r5, r2
 8000eee:	614d      	str	r5, [r1, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ef0:	2490      	movs	r4, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000ef2:	4dcc      	ldr	r5, [pc, #816]	; (8001224 <main+0x3b4>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000ef4:	20fc      	movs	r0, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
 8000ef6:	49cc      	ldr	r1, [pc, #816]	; (8001228 <main+0x3b8>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000ef8:	22a0      	movs	r2, #160	; 0xa0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000efa:	2300      	movs	r3, #0
 8000efc:	05e6      	lsls	r6, r4, #23
  gpiop->OSPEEDR = config->ospeedr;
 8000efe:	0607      	lsls	r7, r0, #24
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000f00:	0594      	lsls	r4, r2, #22
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f02:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000f04:	20fc      	movs	r0, #252	; 0xfc
 8000f06:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8000f08:	4ac8      	ldr	r2, [pc, #800]	; (800122c <main+0x3bc>)
 8000f0a:	60f1      	str	r1, [r6, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f0c:	4fc8      	ldr	r7, [pc, #800]	; (8001230 <main+0x3c0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000f0e:	6175      	str	r5, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8000f10:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8000f12:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000f14:	6034      	str	r4, [r6, #0]
 8000f16:	24a8      	movs	r4, #168	; 0xa8
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000f18:	0081      	lsls	r1, r0, #2
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000f1a:	0620      	lsls	r0, r4, #24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f1c:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000f1e:	4cc5      	ldr	r4, [pc, #788]	; (8001234 <main+0x3c4>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000f20:	60b9      	str	r1, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8000f22:	60fa      	str	r2, [r7, #12]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000f24:	49c4      	ldr	r1, [pc, #784]	; (8001238 <main+0x3c8>)
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000f26:	617d      	str	r5, [r7, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000f28:	4ac4      	ldr	r2, [pc, #784]	; (800123c <main+0x3cc>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000f2a:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8000f2c:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000f2e:	6038      	str	r0, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f30:	4fc3      	ldr	r7, [pc, #780]	; (8001240 <main+0x3d0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000f32:	48c4      	ldr	r0, [pc, #784]	; (8001244 <main+0x3d4>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f34:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000f36:	60b9      	str	r1, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8000f38:	60fa      	str	r2, [r7, #12]
 8000f3a:	49c3      	ldr	r1, [pc, #780]	; (8001248 <main+0x3d8>)
  gpiop->ODR     = config->odr;
 8000f3c:	617c      	str	r4, [r7, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f3e:	4ac3      	ldr	r2, [pc, #780]	; (800124c <main+0x3dc>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000f40:	623b      	str	r3, [r7, #32]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f42:	4cc3      	ldr	r4, [pc, #780]	; (8001250 <main+0x3e0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8000f44:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000f46:	6038      	str	r0, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f48:	4fc2      	ldr	r7, [pc, #776]	; (8001254 <main+0x3e4>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000f4a:	48c3      	ldr	r0, [pc, #780]	; (8001258 <main+0x3e8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f4c:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000f4e:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8000f50:	60f9      	str	r1, [r7, #12]
  gpiop->ODR     = config->odr;
 8000f52:	617d      	str	r5, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8000f54:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8000f56:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000f58:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f5a:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000f5c:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000f5e:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8000f60:	6155      	str	r5, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000f62:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000f64:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000f66:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000f68:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000f6a:	60a3      	str	r3, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8000f6c:	60e0      	str	r0, [r4, #12]
  gpiop->ODR     = config->odr;
 8000f6e:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8000f70:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8000f72:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000f74:	6023      	str	r3, [r4, #0]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8000f76:	4cb9      	ldr	r4, [pc, #740]	; (800125c <main+0x3ec>)
 8000f78:	4db9      	ldr	r5, [pc, #740]	; (8001260 <main+0x3f0>)
 8000f7a:	1c27      	adds	r7, r4, #0
 8000f7c:	c720      	stmia	r7!, {r5}
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000f7e:	2201      	movs	r2, #1
 8000f80:	4693      	mov	fp, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000f82:	6067      	str	r7, [r4, #4]
 8000f84:	7222      	strb	r2, [r4, #8]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000f86:	1c27      	adds	r7, r4, #0
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8000f88:	1c22      	adds	r2, r4, #0
 8000f8a:	3264      	adds	r2, #100	; 0x64
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000f8c:	3754      	adds	r7, #84	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000f8e:	1c21      	adds	r1, r4, #0
 8000f90:	61a7      	str	r7, [r4, #24]
  iqp->q_rdptr   = bp;
 8000f92:	6267      	str	r7, [r4, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8000f94:	6227      	str	r7, [r4, #32]
  iqp->q_top     = bp + size;
 8000f96:	61e2      	str	r2, [r4, #28]
 8000f98:	3130      	adds	r1, #48	; 0x30
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000f9a:	2010      	movs	r0, #16
  oqp->q_buffer  = bp;
 8000f9c:	63e2      	str	r2, [r4, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8000f9e:	64a2      	str	r2, [r4, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8000fa0:	6462      	str	r2, [r4, #68]	; 0x44
  oqp->q_top     = bp + size;
 8000fa2:	1c27      	adds	r7, r4, #0
  oqp->q_notify  = onfy;
 8000fa4:	4aaf      	ldr	r2, [pc, #700]	; (8001264 <main+0x3f4>)
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8000fa6:	46aa      	mov	sl, r5
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000fa8:	6163      	str	r3, [r4, #20]
 8000faa:	6321      	str	r1, [r4, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8000fac:	6361      	str	r1, [r4, #52]	; 0x34
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000fae:	4684      	mov	ip, r0
 8000fb0:	63a0      	str	r0, [r4, #56]	; 0x38
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000fb2:	1c25      	adds	r5, r4, #0
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
  SD1.clock = STM32_USART1CLK;
 8000fb4:	48ac      	ldr	r0, [pc, #688]	; (8001268 <main+0x3f8>)
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000fb6:	3774      	adds	r7, #116	; 0x74
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8000fb8:	49ac      	ldr	r1, [pc, #688]	; (800126c <main+0x3fc>)
 8000fba:	350c      	adds	r5, #12
 8000fbc:	6427      	str	r7, [r4, #64]	; 0x40
  oqp->q_notify  = onfy;
 8000fbe:	64e2      	str	r2, [r4, #76]	; 0x4c
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000fc0:	27c6      	movs	r7, #198	; 0xc6
 8000fc2:	4aab      	ldr	r2, [pc, #684]	; (8001270 <main+0x400>)
 8000fc4:	60e5      	str	r5, [r4, #12]
  tqp->prev = (thread_t *)tqp;
 8000fc6:	6125      	str	r5, [r4, #16]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8000fc8:	62a3      	str	r3, [r4, #40]	; 0x28
  iqp->q_link    = link;
 8000fca:	62e4      	str	r4, [r4, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000fcc:	6524      	str	r4, [r4, #80]	; 0x50
  SD1.clock = STM32_USART1CLK;
 8000fce:	67a0      	str	r0, [r4, #120]	; 0x78
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8000fd0:	6761      	str	r1, [r4, #116]	; 0x74
 8000fd2:	00b9      	lsls	r1, r7, #2
  SD1.clock = STM32_USART1CLK;
 8000fd4:	4681      	mov	r9, r0
 8000fd6:	5850      	ldr	r0, [r2, r1]
 8000fd8:	27c0      	movs	r7, #192	; 0xc0
 8000fda:	0205      	lsls	r5, r0, #8
 8000fdc:	0a28      	lsrs	r0, r5, #8
 8000fde:	063f      	lsls	r7, r7, #24
 8000fe0:	4338      	orrs	r0, r7
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000fe2:	2580      	movs	r5, #128	; 0x80
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000fe4:	5050      	str	r0, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000fe6:	052f      	lsls	r7, r5, #20
 8000fe8:	21c0      	movs	r1, #192	; 0xc0
 8000fea:	4da2      	ldr	r5, [pc, #648]	; (8001274 <main+0x404>)
 8000fec:	0048      	lsls	r0, r1, #1
 8000fee:	5017      	str	r7, [r2, r0]
 8000ff0:	4680      	mov	r8, r0
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000ff2:	6017      	str	r7, [r2, #0]
 8000ff4:	1c28      	adds	r0, r5, #0
 8000ff6:	4657      	mov	r7, sl
 8000ff8:	c080      	stmia	r0!, {r7}
 8000ffa:	6068      	str	r0, [r5, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000ffc:	1c28      	adds	r0, r5, #0
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000ffe:	4659      	mov	r1, fp
 8001000:	300c      	adds	r0, #12
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001002:	1c2f      	adds	r7, r5, #0
 8001004:	7229      	strb	r1, [r5, #8]
 8001006:	60e8      	str	r0, [r5, #12]
  tqp->prev = (thread_t *)tqp;
 8001008:	6128      	str	r0, [r5, #16]
 800100a:	3754      	adds	r7, #84	; 0x54
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800100c:	1c28      	adds	r0, r5, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800100e:	2130      	movs	r1, #48	; 0x30
 8001010:	3064      	adds	r0, #100	; 0x64
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001012:	61af      	str	r7, [r5, #24]
  iqp->q_rdptr   = bp;
 8001014:	626f      	str	r7, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001016:	622f      	str	r7, [r5, #32]
 8001018:	194f      	adds	r7, r1, r5
  iqp->q_top     = bp + size;
 800101a:	61e8      	str	r0, [r5, #28]
 800101c:	632f      	str	r7, [r5, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 800101e:	636f      	str	r7, [r5, #52]	; 0x34
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8001020:	63e8      	str	r0, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8001022:	64a8      	str	r0, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001024:	6468      	str	r0, [r5, #68]	; 0x44
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8001026:	4f94      	ldr	r7, [pc, #592]	; (8001278 <main+0x408>)
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001028:	1c28      	adds	r0, r5, #0
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800102a:	4661      	mov	r1, ip
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800102c:	3074      	adds	r0, #116	; 0x74
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800102e:	616b      	str	r3, [r5, #20]
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001030:	6428      	str	r0, [r5, #64]	; 0x40
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001032:	63a9      	str	r1, [r5, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8001034:	64ef      	str	r7, [r5, #76]	; 0x4c
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
  SD2.clock = STM32_USART2CLK;
 8001036:	4648      	mov	r0, r9
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001038:	4990      	ldr	r1, [pc, #576]	; (800127c <main+0x40c>)
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800103a:	27c7      	movs	r7, #199	; 0xc7
  SD2.clock = STM32_USART2CLK;
 800103c:	67a8      	str	r0, [r5, #120]	; 0x78
 800103e:	00b8      	lsls	r0, r7, #2
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001040:	6769      	str	r1, [r5, #116]	; 0x74
 8001042:	5811      	ldr	r1, [r2, r0]
 8001044:	27ff      	movs	r7, #255	; 0xff
 8001046:	43b9      	bics	r1, r7
 8001048:	4689      	mov	r9, r1
 800104a:	464f      	mov	r7, r9
 800104c:	21c0      	movs	r1, #192	; 0xc0
 800104e:	430f      	orrs	r7, r1
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001050:	62ab      	str	r3, [r5, #40]	; 0x28
  iqp->q_link    = link;
 8001052:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8001054:	652d      	str	r5, [r5, #80]	; 0x50
 8001056:	5017      	str	r7, [r2, r0]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001058:	2080      	movs	r0, #128	; 0x80
 800105a:	4647      	mov	r7, r8
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800105c:	468c      	mov	ip, r1
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800105e:	0541      	lsls	r1, r0, #21

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001060:	486d      	ldr	r0, [pc, #436]	; (8001218 <main+0x3a8>)
 8001062:	51d1      	str	r1, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001064:	6011      	str	r1, [r2, #0]
 8001066:	69c1      	ldr	r1, [r0, #28]
 8001068:	465f      	mov	r7, fp
 800106a:	4339      	orrs	r1, r7
 800106c:	61c1      	str	r1, [r0, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800106e:	4984      	ldr	r1, [pc, #528]	; (8001280 <main+0x410>)
 8001070:	4658      	mov	r0, fp
 8001072:	688f      	ldr	r7, [r1, #8]
 8001074:	4307      	orrs	r7, r0
 8001076:	608f      	str	r7, [r1, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001078:	4f82      	ldr	r7, [pc, #520]	; (8001284 <main+0x414>)
 800107a:	2180      	movs	r1, #128	; 0x80
 800107c:	05c9      	lsls	r1, r1, #23
 800107e:	628f      	str	r7, [r1, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001080:	2701      	movs	r7, #1
 8001082:	4278      	negs	r0, r7
 8001084:	62c8      	str	r0, [r1, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001086:	618b      	str	r3, [r1, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001088:	634b      	str	r3, [r1, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800108a:	60cb      	str	r3, [r1, #12]
  STM32_ST_TIM->CR2    = 0;
 800108c:	604b      	str	r3, [r1, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800108e:	614f      	str	r7, [r1, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001090:	600f      	str	r7, [r1, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001092:	21c3      	movs	r1, #195	; 0xc3
 8001094:	008f      	lsls	r7, r1, #2
 8001096:	59d1      	ldr	r1, [r2, r7]
 8001098:	0209      	lsls	r1, r1, #8
 800109a:	0a0f      	lsrs	r7, r1, #8
 800109c:	46ba      	mov	sl, r7
 800109e:	2180      	movs	r1, #128	; 0x80
 80010a0:	4657      	mov	r7, sl
 80010a2:	0609      	lsls	r1, r1, #24
 80010a4:	4339      	orrs	r1, r7
 80010a6:	27c3      	movs	r7, #195	; 0xc3
 80010a8:	00bf      	lsls	r7, r7, #2
 80010aa:	51d1      	str	r1, [r2, r7]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80010ac:	2180      	movs	r1, #128	; 0x80
 80010ae:	0209      	lsls	r1, r1, #8
 80010b0:	4647      	mov	r7, r8
 80010b2:	51d1      	str	r1, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80010b4:	6011      	str	r1, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80010b6:	4a74      	ldr	r2, [pc, #464]	; (8001288 <main+0x418>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 80010b8:	4f74      	ldr	r7, [pc, #464]	; (800128c <main+0x41c>)
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 80010ba:	6250      	str	r0, [r2, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 80010bc:	1c11      	adds	r1, r2, #0
 80010be:	4874      	ldr	r0, [pc, #464]	; (8001290 <main+0x420>)
 80010c0:	311c      	adds	r1, #28
 80010c2:	61d1      	str	r1, [r2, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 80010c4:	6211      	str	r1, [r2, #32]
 80010c6:	6038      	str	r0, [r7, #0]
  endmem  = __heap_end__;
 80010c8:	4972      	ldr	r1, [pc, #456]	; (8001294 <main+0x424>)
 80010ca:	4873      	ldr	r0, [pc, #460]	; (8001298 <main+0x428>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 80010cc:	4f73      	ldr	r7, [pc, #460]	; (800129c <main+0x42c>)
 80010ce:	6008      	str	r0, [r1, #0]
 80010d0:	4873      	ldr	r0, [pc, #460]	; (80012a0 <main+0x430>)
 80010d2:	6012      	str	r2, [r2, #0]
 80010d4:	1c01      	adds	r1, r0, #0
 80010d6:	3110      	adds	r1, #16
  tqp->prev = (thread_t *)tqp;
 80010d8:	6052      	str	r2, [r2, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 80010da:	6093      	str	r3, [r2, #8]
  ch.vtlist.delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 80010dc:	6293      	str	r3, [r2, #40]	; 0x28
 80010de:	6007      	str	r7, [r0, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80010e0:	6101      	str	r1, [r0, #16]
  tqp->prev = (thread_t *)tqp;
 80010e2:	6141      	str	r1, [r0, #20]
  H_NEXT(&default_heap.header) = NULL;
 80010e4:	6083      	str	r3, [r0, #8]
  H_PAGES(&default_heap.header) = 0;
 80010e6:	60c3      	str	r3, [r0, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 80010e8:	6183      	str	r3, [r0, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 80010ea:	2080      	movs	r0, #128	; 0x80
 80010ec:	6390      	str	r0, [r2, #56]	; 0x38
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 80010ee:	66d0      	str	r0, [r2, #108]	; 0x6c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 80010f0:	4682      	mov	sl, r0
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80010f2:	2151      	movs	r1, #81	; 0x51
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 80010f4:	486b      	ldr	r0, [pc, #428]	; (80012a4 <main+0x434>)
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80010f6:	5453      	strb	r3, [r2, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80010f8:	2752      	movs	r7, #82	; 0x52
 80010fa:	4659      	mov	r1, fp
 80010fc:	55d1      	strb	r1, [r2, r7]
  tp->name      = name;
 80010fe:	6490      	str	r0, [r2, #72]	; 0x48
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001100:	2758      	movs	r7, #88	; 0x58
  REG_INSERT(tp);
 8001102:	1c10      	adds	r0, r2, #0
 8001104:	3030      	adds	r0, #48	; 0x30
 8001106:	18b9      	adds	r1, r7, r2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001108:	275c      	movs	r7, #92	; 0x5c
 800110a:	6110      	str	r0, [r2, #16]
 800110c:	6150      	str	r0, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800110e:	6591      	str	r1, [r2, #88]	; 0x58
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001110:	6190      	str	r0, [r2, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001112:	18b9      	adds	r1, r7, r2
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8001114:	4658      	mov	r0, fp
 8001116:	2750      	movs	r7, #80	; 0x50
 8001118:	55d0      	strb	r0, [r2, r7]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800111a:	4863      	ldr	r0, [pc, #396]	; (80012a8 <main+0x438>)
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800111c:	6653      	str	r3, [r2, #100]	; 0x64
 800111e:	65d1      	str	r1, [r2, #92]	; 0x5c
  tqp->prev = (thread_t *)tqp;
 8001120:	6611      	str	r1, [r2, #96]	; 0x60
 8001122:	4f62      	ldr	r7, [pc, #392]	; (80012ac <main+0x43c>)
 8001124:	6a01      	ldr	r1, [r0, #32]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001126:	6693      	str	r3, [r2, #104]	; 0x68
 8001128:	4039      	ands	r1, r7
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800112a:	6412      	str	r2, [r2, #64]	; 0x40
 800112c:	6452      	str	r2, [r2, #68]	; 0x44
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 800112e:	64d3      	str	r3, [r2, #76]	; 0x4c
 8001130:	6201      	str	r1, [r0, #32]
 8001132:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001134:	b672      	cpsid	i
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001136:	495e      	ldr	r1, [pc, #376]	; (80012b0 <main+0x440>)
 8001138:	20ac      	movs	r0, #172	; 0xac
 800113a:	5009      	str	r1, [r1, r0]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800113c:	206c      	movs	r0, #108	; 0x6c
 800113e:	1840      	adds	r0, r0, r1
 8001140:	279c      	movs	r7, #156	; 0x9c
 8001142:	51c8      	str	r0, [r1, r7]
 8001144:	485b      	ldr	r0, [pc, #364]	; (80012b4 <main+0x444>)
 8001146:	4f5c      	ldr	r7, [pc, #368]	; (80012b8 <main+0x448>)
 8001148:	67c8      	str	r0, [r1, #124]	; 0x7c
 800114a:	4650      	mov	r0, sl
 800114c:	46ba      	mov	sl, r7
 800114e:	500b      	str	r3, [r1, r0]
 8001150:	278c      	movs	r7, #140	; 0x8c
 8001152:	4650      	mov	r0, sl
 8001154:	51c8      	str	r0, [r1, r7]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001156:	4658      	mov	r0, fp
 8001158:	2798      	movs	r7, #152	; 0x98
 800115a:	51c8      	str	r0, [r1, r7]
  tp->state     = CH_STATE_WTSTART;
 800115c:	20b0      	movs	r0, #176	; 0xb0
 800115e:	2702      	movs	r7, #2
 8001160:	4680      	mov	r8, r0
 8001162:	46b9      	mov	r9, r7
 8001164:	1c38      	adds	r0, r7, #0
 8001166:	4647      	mov	r7, r8
 8001168:	55c8      	strb	r0, [r1, r7]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800116a:	20b1      	movs	r0, #177	; 0xb1
 800116c:	540b      	strb	r3, [r1, r0]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800116e:	465f      	mov	r7, fp
 8001170:	20cc      	movs	r0, #204	; 0xcc
 8001172:	500f      	str	r7, [r1, r0]
  tp->mtxlist   = NULL;
 8001174:	27c8      	movs	r7, #200	; 0xc8
 8001176:	51cb      	str	r3, [r1, r7]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001178:	27c4      	movs	r7, #196	; 0xc4
 800117a:	51cb      	str	r3, [r1, r7]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800117c:	484f      	ldr	r0, [pc, #316]	; (80012bc <main+0x44c>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800117e:	465f      	mov	r7, fp
 8001180:	23b2      	movs	r3, #178	; 0xb2
 8001182:	54cf      	strb	r7, [r1, r3]
  tp->name      = name;
 8001184:	23a8      	movs	r3, #168	; 0xa8
 8001186:	50c8      	str	r0, [r1, r3]
  REG_INSERT(tp);
 8001188:	6953      	ldr	r3, [r2, #20]
 800118a:	20a4      	movs	r0, #164	; 0xa4
 800118c:	500b      	str	r3, [r1, r0]
 800118e:	1c08      	adds	r0, r1, #0
 8001190:	3090      	adds	r0, #144	; 0x90
 8001192:	27a0      	movs	r7, #160	; 0xa0
 8001194:	51ca      	str	r2, [r1, r7]
 8001196:	6118      	str	r0, [r3, #16]
 8001198:	6150      	str	r0, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800119a:	1c0a      	adds	r2, r1, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800119c:	1c0b      	adds	r3, r1, #0
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800119e:	32b8      	adds	r2, #184	; 0xb8
 80011a0:	27b8      	movs	r7, #184	; 0xb8
 80011a2:	51ca      	str	r2, [r1, r7]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80011a4:	33bc      	adds	r3, #188	; 0xbc
 80011a6:	22bc      	movs	r2, #188	; 0xbc
  tqp->prev = (thread_t *)tqp;
 80011a8:	4667      	mov	r7, ip
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80011aa:	508b      	str	r3, [r1, r2]
  tqp->prev = (thread_t *)tqp;
 80011ac:	51cb      	str	r3, [r1, r7]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 80011ae:	f7ff faf7 	bl	80007a0 <chSchWakeupS.constprop.11.4553>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011b2:	b662      	cpsie	i
  /* Initialize connection to STN1110 on SD2
   */
  static SerialConfig stn_uart_cfg = {9600};
  //stn_uart_cfg.speed=9600;

  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(1));       /* USART2 TX.       */
 80011b4:	2104      	movs	r1, #4
 80011b6:	1c30      	adds	r0, r6, #0
 80011b8:	2282      	movs	r2, #130	; 0x82
 80011ba:	f7ff f939 	bl	8000430 <_pal_lld_setgroupmode.4562>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(1));       /* USART2 RX.       */
 80011be:	1c30      	adds	r0, r6, #0
 80011c0:	2108      	movs	r1, #8
 80011c2:	2282      	movs	r2, #130	; 0x82
 80011c4:	f7ff f934 	bl	8000430 <_pal_lld_setgroupmode.4562>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011c8:	b672      	cpsid	i
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80011ca:	493d      	ldr	r1, [pc, #244]	; (80012c0 <main+0x450>)
 80011cc:	1c28      	adds	r0, r5, #0
 80011ce:	f7ff f8d7 	bl	8000380 <sd_lld_start.4554>
  sdp->state = SD_READY;
 80011d2:	4649      	mov	r1, r9
 80011d4:	7229      	strb	r1, [r5, #8]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011d6:	b662      	cpsie	i

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 80011d8:	2580      	movs	r5, #128	; 0x80
 80011da:	1c30      	adds	r0, r6, #0
 80011dc:	00a9      	lsls	r1, r5, #2
 80011de:	2282      	movs	r2, #130	; 0x82
 80011e0:	f7ff f926 	bl	8000430 <_pal_lld_setgroupmode.4562>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 80011e4:	1c30      	adds	r0, r6, #0
 80011e6:	2680      	movs	r6, #128	; 0x80
 80011e8:	00f1      	lsls	r1, r6, #3
 80011ea:	2282      	movs	r2, #130	; 0x82
 80011ec:	f7ff f920 	bl	8000430 <_pal_lld_setgroupmode.4562>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011f0:	b672      	cpsid	i
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80011f2:	2100      	movs	r1, #0
 80011f4:	1c20      	adds	r0, r4, #0
 80011f6:	f7ff f8c3 	bl	8000380 <sd_lld_start.4554>
  sdp->state = SD_READY;
 80011fa:	4648      	mov	r0, r9
 80011fc:	7220      	strb	r0, [r4, #8]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011fe:	b662      	cpsie	i


  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 8001200:	4930      	ldr	r1, [pc, #192]	; (80012c4 <main+0x454>)
 8001202:	4831      	ldr	r0, [pc, #196]	; (80012c8 <main+0x458>)
 8001204:	f7ff fafc 	bl	8000800 <chThdCreateStatic.constprop.5.4548>
  chThdCreateStatic(wa_CAN_rx, sizeof(wa_CAN_rx), NORMALPRIO, CAN_rx, NULL);
 8001208:	4830      	ldr	r0, [pc, #192]	; (80012cc <main+0x45c>)
 800120a:	4931      	ldr	r1, [pc, #196]	; (80012d0 <main+0x460>)
 800120c:	f7ff faf8 	bl	8000800 <chThdCreateStatic.constprop.5.4548>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched with output on the serial
   * driver 1.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 8001210:	4830      	ldr	r0, [pc, #192]	; (80012d4 <main+0x464>)
 8001212:	f7ff fbdd 	bl	80009d0 <chThdSleep.4442>
 8001216:	e7fb      	b.n	8001210 <main+0x3a0>
 8001218:	40021000 	.word	0x40021000
 800121c:	ffbfffff 	.word	0xffbfffff
 8001220:	40007000 	.word	0x40007000
 8001224:	0000ffff 	.word	0x0000ffff
 8001228:	64155554 	.word	0x64155554
 800122c:	01555555 	.word	0x01555555
 8001230:	48000400 	.word	0x48000400
 8001234:	0000fc3f 	.word	0x0000fc3f
 8001238:	f00ff003 	.word	0xf00ff003
 800123c:	05500554 	.word	0x05500554
 8001240:	48000800 	.word	0x48000800
 8001244:	00055001 	.word	0x00055001
 8001248:	55555555 	.word	0x55555555
 800124c:	48001000 	.word	0x48001000
 8001250:	48001400 	.word	0x48001400
 8001254:	48000c00 	.word	0x48000c00
 8001258:	55555550 	.word	0x55555550
 800125c:	20000610 	.word	0x20000610
 8001260:	08001618 	.word	0x08001618
 8001264:	08000301 	.word	0x08000301
 8001268:	02dc6c00 	.word	0x02dc6c00
 800126c:	40013800 	.word	0x40013800
 8001270:	e000e100 	.word	0xe000e100
 8001274:	200008d4 	.word	0x200008d4
 8001278:	08000311 	.word	0x08000311
 800127c:	40004400 	.word	0x40004400
 8001280:	40015800 	.word	0x40015800
 8001284:	000012bf 	.word	0x000012bf
 8001288:	20000958 	.word	0x20000958
 800128c:	20000954 	.word	0x20000954
 8001290:	20000b18 	.word	0x20000b18
 8001294:	200008d0 	.word	0x200008d0
 8001298:	20004000 	.word	0x20004000
 800129c:	080002c1 	.word	0x080002c1
 80012a0:	200008b0 	.word	0x200008b0
 80012a4:	08001600 	.word	0x08001600
 80012a8:	e000ed00 	.word	0xe000ed00
 80012ac:	ff00ffff 	.word	0xff00ffff
 80012b0:	20000690 	.word	0x20000690
 80012b4:	08000781 	.word	0x08000781
 80012b8:	080001f1 	.word	0x080001f1
 80012bc:	08001568 	.word	0x08001568
 80012c0:	20000600 	.word	0x20000600
 80012c4:	08000df1 	.word	0x08000df1
 80012c8:	20000768 	.word	0x20000768
 80012cc:	200009d0 	.word	0x200009d0
 80012d0:	08000da1 	.word	0x08000da1
 80012d4:	00001388 	.word	0x00001388
 80012d8:	46c0      	nop			; (mov r8, r8)
 80012da:	46c0      	nop			; (mov r8, r8)
 80012dc:	46c0      	nop			; (mov r8, r8)
 80012de:	46c0      	nop			; (mov r8, r8)

080012e0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80012e0:	4827      	ldr	r0, [pc, #156]	; (8001380 <__early_init+0xa0>)
 80012e2:	2301      	movs	r3, #1
 80012e4:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80012e6:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80012e8:	4313      	orrs	r3, r2
 80012ea:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80012ec:	6803      	ldr	r3, [r0, #0]
 80012ee:	4a24      	ldr	r2, [pc, #144]	; (8001380 <__early_init+0xa0>)
 80012f0:	4219      	tst	r1, r3
 80012f2:	d0fb      	beq.n	80012ec <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80012f4:	6850      	ldr	r0, [r2, #4]
 80012f6:	2103      	movs	r1, #3
 80012f8:	4388      	bics	r0, r1
 80012fa:	6050      	str	r0, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80012fc:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80012fe:	1c10      	adds	r0, r2, #0

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001300:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001302:	210c      	movs	r1, #12
 8001304:	6843      	ldr	r3, [r0, #4]
 8001306:	4a1e      	ldr	r2, [pc, #120]	; (8001380 <__early_init+0xa0>)
 8001308:	400b      	ands	r3, r1
 800130a:	d1fb      	bne.n	8001304 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800130c:	6811      	ldr	r1, [r2, #0]
 800130e:	20f9      	movs	r0, #249	; 0xf9
 8001310:	4001      	ands	r1, r0
 8001312:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001314:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001316:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001318:	2301      	movs	r3, #1
 800131a:	430b      	orrs	r3, r1
 800131c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800131e:	2002      	movs	r0, #2
 8001320:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001322:	4917      	ldr	r1, [pc, #92]	; (8001380 <__early_init+0xa0>)
 8001324:	4218      	tst	r0, r3
 8001326:	d0fb      	beq.n	8001320 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001328:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 800132a:	2001      	movs	r0, #1
 800132c:	4310      	orrs	r0, r2
 800132e:	6248      	str	r0, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001330:	2002      	movs	r0, #2
 8001332:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001334:	4a12      	ldr	r2, [pc, #72]	; (8001380 <__early_init+0xa0>)
 8001336:	4218      	tst	r0, r3
 8001338:	d0fb      	beq.n	8001332 <__early_init+0x52>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800133a:	21a0      	movs	r1, #160	; 0xa0
 800133c:	0388      	lsls	r0, r1, #14
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 800133e:	2300      	movs	r3, #0
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001340:	6050      	str	r0, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8001342:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8001344:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001346:	6811      	ldr	r1, [r2, #0]
 8001348:	2080      	movs	r0, #128	; 0x80
 800134a:	0443      	lsls	r3, r0, #17
 800134c:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800134e:	2180      	movs	r1, #128	; 0x80
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001350:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001352:	0488      	lsls	r0, r1, #18
 8001354:	6813      	ldr	r3, [r2, #0]
 8001356:	490a      	ldr	r1, [pc, #40]	; (8001380 <__early_init+0xa0>)
 8001358:	4203      	tst	r3, r0
 800135a:	d0fb      	beq.n	8001354 <__early_init+0x74>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800135c:	4809      	ldr	r0, [pc, #36]	; (8001384 <__early_init+0xa4>)
 800135e:	2211      	movs	r2, #17
 8001360:	6002      	str	r2, [r0, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001362:	684a      	ldr	r2, [r1, #4]
 8001364:	2302      	movs	r3, #2
 8001366:	4313      	orrs	r3, r2
 8001368:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800136a:	200c      	movs	r0, #12
 800136c:	684b      	ldr	r3, [r1, #4]
 800136e:	4a04      	ldr	r2, [pc, #16]	; (8001380 <__early_init+0xa0>)
 8001370:	4003      	ands	r3, r0
 8001372:	2b08      	cmp	r3, #8
 8001374:	d1fa      	bne.n	800136c <__early_init+0x8c>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001376:	6991      	ldr	r1, [r2, #24]
 8001378:	2001      	movs	r0, #1
 800137a:	4308      	orrs	r0, r1
 800137c:	6190      	str	r0, [r2, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 800137e:	4770      	bx	lr
 8001380:	40021000 	.word	0x40021000
 8001384:	40022000 	.word	0x40022000
 8001388:	46c0      	nop			; (mov r8, r8)
 800138a:	46c0      	nop			; (mov r8, r8)
 800138c:	46c0      	nop			; (mov r8, r8)
 800138e:	46c0      	nop			; (mov r8, r8)

08001390 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001390:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001392:	b672      	cpsid	i
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001394:	4b0f      	ldr	r3, [pc, #60]	; (80013d4 <chThdExit+0x44>)
 8001396:	699c      	ldr	r4, [r3, #24]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8001398:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800139a:	1c25      	adds	r5, r4, #0
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800139c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800139e:	3528      	adds	r5, #40	; 0x28
 80013a0:	42a8      	cmp	r0, r5
 80013a2:	d006      	beq.n	80013b2 <chThdExit+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80013a4:	6802      	ldr	r2, [r0, #0]
 80013a6:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 80013a8:	f7ff f8ea 	bl	8000580 <chSchReadyI.4612>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80013ac:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80013ae:	42a8      	cmp	r0, r5
 80013b0:	d1f8      	bne.n	80013a4 <chThdExit+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80013b2:	2022      	movs	r0, #34	; 0x22
 80013b4:	5c21      	ldrb	r1, [r4, r0]
 80013b6:	2900      	cmp	r1, #0
 80013b8:	d108      	bne.n	80013cc <chThdExit+0x3c>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80013ba:	2321      	movs	r3, #33	; 0x21
 80013bc:	5ce5      	ldrb	r5, [r4, r3]

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80013be:	07aa      	lsls	r2, r5, #30
 80013c0:	d104      	bne.n	80013cc <chThdExit+0x3c>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 80013c2:	6960      	ldr	r0, [r4, #20]
 80013c4:	6922      	ldr	r2, [r4, #16]
 80013c6:	6102      	str	r2, [r0, #16]
 80013c8:	6924      	ldr	r4, [r4, #16]
 80013ca:	6160      	str	r0, [r4, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80013cc:	200f      	movs	r0, #15
 80013ce:	f7ff fa5f 	bl	8000890 <chSchGoSleepS.4609>
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 80013d2:	bd38      	pop	{r3, r4, r5, pc}
 80013d4:	20000958 	.word	0x20000958
 80013d8:	46c0      	nop			; (mov r8, r8)
 80013da:	46c0      	nop			; (mov r8, r8)
 80013dc:	46c0      	nop			; (mov r8, r8)
 80013de:	46c0      	nop			; (mov r8, r8)

080013e0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 80013e0:	4a0d      	ldr	r2, [pc, #52]	; (8001418 <chSchDoReschedule+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80013e2:	b510      	push	{r4, lr}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80013e4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp = currp;
 80013e6:	6991      	ldr	r1, [r2, #24]

  tqp->next             = tp->queue.next;
 80013e8:	6803      	ldr	r3, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80013ea:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80013ec:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80013ee:	6013      	str	r3, [r2, #0]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80013f0:	6190      	str	r0, [r2, #24]
  currp->state = CH_STATE_CURRENT;
 80013f2:	2220      	movs	r2, #32
 80013f4:	5484      	strb	r4, [r0, r2]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80013f6:	2400      	movs	r4, #0
 80013f8:	548c      	strb	r4, [r1, r2]
 80013fa:	688a      	ldr	r2, [r1, #8]
 80013fc:	e000      	b.n	8001400 <chSchDoReschedule+0x20>
 80013fe:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8001400:	689c      	ldr	r4, [r3, #8]
 8001402:	4294      	cmp	r4, r2
 8001404:	d8fb      	bhi.n	80013fe <chSchDoReschedule+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001406:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001408:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 800140a:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 800140c:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 800140e:	6059      	str	r1, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001410:	f7fe fede 	bl	80001d0 <_port_switch>
}
 8001414:	bd10      	pop	{r4, pc}
 8001416:	46c0      	nop			; (mov r8, r8)
 8001418:	20000958 	.word	0x20000958
 800141c:	46c0      	nop			; (mov r8, r8)
 800141e:	46c0      	nop			; (mov r8, r8)

08001420 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001420:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001422:	4647      	mov	r7, r8
 8001424:	b480      	push	{r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001426:	4825      	ldr	r0, [pc, #148]	; (80014bc <__init_ram_areas+0x9c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001428:	2380      	movs	r3, #128	; 0x80
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800142a:	4684      	mov	ip, r0
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800142c:	4698      	mov	r8, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800142e:	2400      	movs	r4, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001430:	44e0      	add	r8, ip
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8001432:	4662      	mov	r2, ip
    uint32_t *p = rap->init_area;
 8001434:	6856      	ldr	r6, [r2, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001436:	6895      	ldr	r5, [r2, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8001438:	6811      	ldr	r1, [r2, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800143a:	42ae      	cmp	r6, r5
 800143c:	d220      	bcs.n	8001480 <__init_ram_areas+0x60>
 800143e:	43f7      	mvns	r7, r6
 8001440:	19e8      	adds	r0, r5, r7
      *p = *tp;
 8001442:	1c0a      	adds	r2, r1, #0
 8001444:	0743      	lsls	r3, r0, #29
 8001446:	ca01      	ldmia	r2!, {r0}
 8001448:	0fdf      	lsrs	r7, r3, #31
 800144a:	1c33      	adds	r3, r6, #0
 800144c:	c301      	stmia	r3!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800144e:	42ab      	cmp	r3, r5
 8001450:	d210      	bcs.n	8001474 <__init_ram_areas+0x54>
 8001452:	2f00      	cmp	r7, #0
 8001454:	d004      	beq.n	8001460 <__init_ram_areas+0x40>
      *p = *tp;
 8001456:	6849      	ldr	r1, [r1, #4]
 8001458:	3204      	adds	r2, #4
 800145a:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800145c:	42ab      	cmp	r3, r5
 800145e:	d209      	bcs.n	8001474 <__init_ram_areas+0x54>
      *p = *tp;
 8001460:	1c10      	adds	r0, r2, #0
 8001462:	c880      	ldmia	r0!, {r7}
 8001464:	1c19      	adds	r1, r3, #0
 8001466:	c180      	stmia	r1!, {r7}
 8001468:	6852      	ldr	r2, [r2, #4]
 800146a:	605a      	str	r2, [r3, #4]
      p++;
 800146c:	1d0b      	adds	r3, r1, #4
 800146e:	1d02      	adds	r2, r0, #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001470:	42ab      	cmp	r3, r5
 8001472:	d3f5      	bcc.n	8001460 <__init_ram_areas+0x40>
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001474:	43f3      	mvns	r3, r6
 8001476:	195d      	adds	r5, r3, r5
 8001478:	08a8      	lsrs	r0, r5, #2
 800147a:	3001      	adds	r0, #1
 800147c:	0087      	lsls	r7, r0, #2
 800147e:	19f6      	adds	r6, r6, r7
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001480:	4661      	mov	r1, ip
 8001482:	68cd      	ldr	r5, [r1, #12]
 8001484:	42ae      	cmp	r6, r5
 8001486:	d211      	bcs.n	80014ac <__init_ram_areas+0x8c>
 8001488:	43f2      	mvns	r2, r6
 800148a:	18ab      	adds	r3, r5, r2
 800148c:	0758      	lsls	r0, r3, #29
      *p = 0;
 800148e:	c610      	stmia	r6!, {r4}
 8001490:	0fc7      	lsrs	r7, r0, #31
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001492:	42ae      	cmp	r6, r5
 8001494:	d20a      	bcs.n	80014ac <__init_ram_areas+0x8c>
 8001496:	2f00      	cmp	r7, #0
 8001498:	d002      	beq.n	80014a0 <__init_ram_areas+0x80>
      *p = 0;
 800149a:	c610      	stmia	r6!, {r4}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800149c:	42ae      	cmp	r6, r5
 800149e:	d205      	bcs.n	80014ac <__init_ram_areas+0x8c>
      *p = 0;
 80014a0:	1c31      	adds	r1, r6, #0
 80014a2:	c110      	stmia	r1!, {r4}
 80014a4:	6074      	str	r4, [r6, #4]
      p++;
 80014a6:	1d0e      	adds	r6, r1, #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80014a8:	42ae      	cmp	r6, r5
 80014aa:	d3f9      	bcc.n	80014a0 <__init_ram_areas+0x80>
      *p = 0;
      p++;
    }
    rap++;
 80014ac:	2510      	movs	r5, #16
 80014ae:	44ac      	add	ip, r5
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80014b0:	45c4      	cmp	ip, r8
 80014b2:	d3be      	bcc.n	8001432 <__init_ram_areas+0x12>
#endif
}
 80014b4:	bc04      	pop	{r2}
 80014b6:	4690      	mov	r8, r2
 80014b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80014ba:	46c0      	nop			; (mov r8, r8)
 80014bc:	08001580 	.word	0x08001580

080014c0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80014c0:	e7fe      	b.n	80014c0 <__default_exit>
 80014c2:	46c0      	nop			; (mov r8, r8)
 80014c4:	46c0      	nop			; (mov r8, r8)
 80014c6:	46c0      	nop			; (mov r8, r8)
 80014c8:	46c0      	nop			; (mov r8, r8)
 80014ca:	46c0      	nop			; (mov r8, r8)
 80014cc:	46c0      	nop			; (mov r8, r8)
 80014ce:	46c0      	nop			; (mov r8, r8)

080014d0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80014d0:	4770      	bx	lr
 80014d2:	46c0      	nop			; (mov r8, r8)
 80014d4:	46c0      	nop			; (mov r8, r8)
 80014d6:	46c0      	nop			; (mov r8, r8)
 80014d8:	46c0      	nop			; (mov r8, r8)
 80014da:	46c0      	nop			; (mov r8, r8)
 80014dc:	46c0      	nop			; (mov r8, r8)
 80014de:	46c0      	nop			; (mov r8, r8)

080014e0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80014e0:	4770      	bx	lr
 80014e2:	46c0      	nop			; (mov r8, r8)
 80014e4:	46c0      	nop			; (mov r8, r8)
 80014e6:	46c0      	nop			; (mov r8, r8)
 80014e8:	46c0      	nop			; (mov r8, r8)
 80014ea:	46c0      	nop			; (mov r8, r8)
 80014ec:	46c0      	nop			; (mov r8, r8)
 80014ee:	46c0      	nop			; (mov r8, r8)

080014f0 <strlen>:
 80014f0:	2300      	movs	r3, #0
 80014f2:	5cc2      	ldrb	r2, [r0, r3]
 80014f4:	3301      	adds	r3, #1
 80014f6:	2a00      	cmp	r2, #0
 80014f8:	d1fb      	bne.n	80014f2 <strlen+0x2>
 80014fa:	1e58      	subs	r0, r3, #1
 80014fc:	4770      	bx	lr
 80014fe:	46c0      	nop			; (mov r8, r8)
