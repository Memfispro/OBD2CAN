
build/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000100 <Reset_Handler>:
 8000100:	b672      	cpsid	i
 8000102:	4822      	ldr	r0, [pc, #136]	; (800018c <endfiniloop+0x4>)
 8000104:	f380 8809 	msr	PSP, r0
 8000108:	2002      	movs	r0, #2
 800010a:	f380 8814 	msr	CONTROL, r0
 800010e:	f3bf 8f6f 	isb	sy
 8000112:	f000 fe05 	bl	8000d20 <__core_init>
 8000116:	f001 ff0b 	bl	8001f30 <__early_init>
 800011a:	481d      	ldr	r0, [pc, #116]	; (8000190 <endfiniloop+0x8>)
 800011c:	491d      	ldr	r1, [pc, #116]	; (8000194 <endfiniloop+0xc>)
 800011e:	4a1e      	ldr	r2, [pc, #120]	; (8000198 <endfiniloop+0x10>)

08000120 <msloop>:
 8000120:	4291      	cmp	r1, r2
 8000122:	da02      	bge.n	800012a <endmsloop>
 8000124:	6008      	str	r0, [r1, #0]
 8000126:	3104      	adds	r1, #4
 8000128:	e7fa      	b.n	8000120 <msloop>

0800012a <endmsloop>:
 800012a:	491c      	ldr	r1, [pc, #112]	; (800019c <endfiniloop+0x14>)
 800012c:	4a17      	ldr	r2, [pc, #92]	; (800018c <endfiniloop+0x4>)

0800012e <psloop>:
 800012e:	4291      	cmp	r1, r2
 8000130:	da02      	bge.n	8000138 <endpsloop>
 8000132:	6008      	str	r0, [r1, #0]
 8000134:	3104      	adds	r1, #4
 8000136:	e7fa      	b.n	800012e <psloop>

08000138 <endpsloop>:
 8000138:	4919      	ldr	r1, [pc, #100]	; (80001a0 <endfiniloop+0x18>)
 800013a:	4a1a      	ldr	r2, [pc, #104]	; (80001a4 <endfiniloop+0x1c>)
 800013c:	4b1a      	ldr	r3, [pc, #104]	; (80001a8 <endfiniloop+0x20>)

0800013e <dloop>:
 800013e:	429a      	cmp	r2, r3
 8000140:	da04      	bge.n	800014c <enddloop>
 8000142:	6808      	ldr	r0, [r1, #0]
 8000144:	6010      	str	r0, [r2, #0]
 8000146:	3104      	adds	r1, #4
 8000148:	3204      	adds	r2, #4
 800014a:	e7f8      	b.n	800013e <dloop>

0800014c <enddloop>:
 800014c:	2000      	movs	r0, #0
 800014e:	4917      	ldr	r1, [pc, #92]	; (80001ac <endfiniloop+0x24>)
 8000150:	4a17      	ldr	r2, [pc, #92]	; (80001b0 <endfiniloop+0x28>)

08000152 <bloop>:
 8000152:	4291      	cmp	r1, r2
 8000154:	da02      	bge.n	800015c <endbloop>
 8000156:	6008      	str	r0, [r1, #0]
 8000158:	3104      	adds	r1, #4
 800015a:	e7fa      	b.n	8000152 <bloop>

0800015c <endbloop>:
 800015c:	f000 fd80 	bl	8000c60 <__init_ram_areas>
 8000160:	f000 fdd6 	bl	8000d10 <__late_init>
 8000164:	4c13      	ldr	r4, [pc, #76]	; (80001b4 <endfiniloop+0x2c>)
 8000166:	4d14      	ldr	r5, [pc, #80]	; (80001b8 <endfiniloop+0x30>)

08000168 <initloop>:
 8000168:	42ac      	cmp	r4, r5
 800016a:	da03      	bge.n	8000174 <endinitloop>
 800016c:	6821      	ldr	r1, [r4, #0]
 800016e:	4788      	blx	r1
 8000170:	3404      	adds	r4, #4
 8000172:	e7f9      	b.n	8000168 <initloop>

08000174 <endinitloop>:
 8000174:	f001 ff34 	bl	8001fe0 <main>
 8000178:	4c10      	ldr	r4, [pc, #64]	; (80001bc <endfiniloop+0x34>)
 800017a:	4d11      	ldr	r5, [pc, #68]	; (80001c0 <endfiniloop+0x38>)

0800017c <finiloop>:
 800017c:	42ac      	cmp	r4, r5
 800017e:	da03      	bge.n	8000188 <endfiniloop>
 8000180:	6821      	ldr	r1, [r4, #0]
 8000182:	4788      	blx	r1
 8000184:	3404      	adds	r4, #4
 8000186:	e7f9      	b.n	800017c <finiloop>

08000188 <endfiniloop>:
 8000188:	490e      	ldr	r1, [pc, #56]	; (80001c4 <endfiniloop+0x3c>)
 800018a:	4708      	bx	r1
 800018c:	20000600 	.word	0x20000600
 8000190:	55555555 	.word	0x55555555
 8000194:	20000000 	.word	0x20000000
 8000198:	20000400 	.word	0x20000400
 800019c:	20000400 	.word	0x20000400
 80001a0:	08002ab0 	.word	0x08002ab0
 80001a4:	20000600 	.word	0x20000600
 80001a8:	20000a00 	.word	0x20000a00
 80001ac:	20000a00 	.word	0x20000a00
 80001b0:	20001a80 	.word	0x20001a80
 80001b4:	08000100 	.word	0x08000100
 80001b8:	08000100 	.word	0x08000100
 80001bc:	08000100 	.word	0x08000100
 80001c0:	08000100 	.word	0x08000100
 80001c4:	08000d01 	.word	0x08000d01
	...

080001d0 <_port_switch>:
 80001d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001d2:	4644      	mov	r4, r8
 80001d4:	464d      	mov	r5, r9
 80001d6:	4656      	mov	r6, sl
 80001d8:	465f      	mov	r7, fp
 80001da:	b4f0      	push	{r4, r5, r6, r7}
 80001dc:	466b      	mov	r3, sp
 80001de:	60cb      	str	r3, [r1, #12]
 80001e0:	68c3      	ldr	r3, [r0, #12]
 80001e2:	469d      	mov	sp, r3
 80001e4:	bcf0      	pop	{r4, r5, r6, r7}
 80001e6:	46a0      	mov	r8, r4
 80001e8:	46a9      	mov	r9, r5
 80001ea:	46b2      	mov	sl, r6
 80001ec:	46bb      	mov	fp, r7
 80001ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001f0 <_port_thread_start>:
 80001f0:	f000 fa76 	bl	80006e0 <_dbg_check_unlock>
 80001f4:	b662      	cpsie	i
 80001f6:	1c28      	adds	r0, r5, #0
 80001f8:	47a0      	blx	r4
 80001fa:	2000      	movs	r0, #0
 80001fc:	f001 fb68 	bl	80018d0 <chThdExit>

08000200 <_port_switch_from_isr>:
 8000200:	f000 fa86 	bl	8000710 <_dbg_check_lock>
 8000204:	f001 fb34 	bl	8001870 <chSchDoReschedule>
 8000208:	f000 fa6a 	bl	80006e0 <_dbg_check_unlock>

0800020c <_port_exit_from_isr>:
 800020c:	4a01      	ldr	r2, [pc, #4]	; (8000214 <_port_exit_from_isr+0x8>)
 800020e:	4b02      	ldr	r3, [pc, #8]	; (8000218 <_port_exit_from_isr+0xc>)
 8000210:	6013      	str	r3, [r2, #0]
 8000212:	e7fe      	b.n	8000212 <_port_exit_from_isr+0x6>
 8000214:	e000ed04 	.word	0xe000ed04
 8000218:	80000000 	.word	0x80000000
 800021c:	00000000 	.word	0x00000000

08000220 <__aeabi_uidiv>:
 8000220:	2900      	cmp	r1, #0
 8000222:	d034      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>

08000224 <.udivsi3_skip_div0_test>:
 8000224:	2301      	movs	r3, #1
 8000226:	2200      	movs	r2, #0
 8000228:	b410      	push	{r4}
 800022a:	4288      	cmp	r0, r1
 800022c:	d32c      	bcc.n	8000288 <.udivsi3_skip_div0_test+0x64>
 800022e:	2401      	movs	r4, #1
 8000230:	0724      	lsls	r4, r4, #28
 8000232:	42a1      	cmp	r1, r4
 8000234:	d204      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 8000236:	4281      	cmp	r1, r0
 8000238:	d202      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 800023a:	0109      	lsls	r1, r1, #4
 800023c:	011b      	lsls	r3, r3, #4
 800023e:	e7f8      	b.n	8000232 <.udivsi3_skip_div0_test+0xe>
 8000240:	00e4      	lsls	r4, r4, #3
 8000242:	42a1      	cmp	r1, r4
 8000244:	d204      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000246:	4281      	cmp	r1, r0
 8000248:	d202      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 800024a:	0049      	lsls	r1, r1, #1
 800024c:	005b      	lsls	r3, r3, #1
 800024e:	e7f8      	b.n	8000242 <.udivsi3_skip_div0_test+0x1e>
 8000250:	4288      	cmp	r0, r1
 8000252:	d301      	bcc.n	8000258 <.udivsi3_skip_div0_test+0x34>
 8000254:	1a40      	subs	r0, r0, r1
 8000256:	431a      	orrs	r2, r3
 8000258:	084c      	lsrs	r4, r1, #1
 800025a:	42a0      	cmp	r0, r4
 800025c:	d302      	bcc.n	8000264 <.udivsi3_skip_div0_test+0x40>
 800025e:	1b00      	subs	r0, r0, r4
 8000260:	085c      	lsrs	r4, r3, #1
 8000262:	4322      	orrs	r2, r4
 8000264:	088c      	lsrs	r4, r1, #2
 8000266:	42a0      	cmp	r0, r4
 8000268:	d302      	bcc.n	8000270 <.udivsi3_skip_div0_test+0x4c>
 800026a:	1b00      	subs	r0, r0, r4
 800026c:	089c      	lsrs	r4, r3, #2
 800026e:	4322      	orrs	r2, r4
 8000270:	08cc      	lsrs	r4, r1, #3
 8000272:	42a0      	cmp	r0, r4
 8000274:	d302      	bcc.n	800027c <.udivsi3_skip_div0_test+0x58>
 8000276:	1b00      	subs	r0, r0, r4
 8000278:	08dc      	lsrs	r4, r3, #3
 800027a:	4322      	orrs	r2, r4
 800027c:	2800      	cmp	r0, #0
 800027e:	d003      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000280:	091b      	lsrs	r3, r3, #4
 8000282:	d001      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000284:	0909      	lsrs	r1, r1, #4
 8000286:	e7e3      	b.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000288:	1c10      	adds	r0, r2, #0
 800028a:	bc10      	pop	{r4}
 800028c:	4770      	bx	lr
 800028e:	2800      	cmp	r0, #0
 8000290:	d001      	beq.n	8000296 <.udivsi3_skip_div0_test+0x72>
 8000292:	2000      	movs	r0, #0
 8000294:	43c0      	mvns	r0, r0
 8000296:	b407      	push	{r0, r1, r2}
 8000298:	4802      	ldr	r0, [pc, #8]	; (80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029a:	a102      	add	r1, pc, #8	; (adr r1, 80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029c:	1840      	adds	r0, r0, r1
 800029e:	9002      	str	r0, [sp, #8]
 80002a0:	bd03      	pop	{r0, r1, pc}
 80002a2:	46c0      	nop			; (mov r8, r8)
 80002a4:	0000001d 	.word	0x0000001d

080002a8 <__aeabi_uidivmod>:
 80002a8:	2900      	cmp	r1, #0
 80002aa:	d0f0      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>
 80002ac:	b503      	push	{r0, r1, lr}
 80002ae:	f7ff ffb9 	bl	8000224 <.udivsi3_skip_div0_test>
 80002b2:	bc0e      	pop	{r1, r2, r3}
 80002b4:	4342      	muls	r2, r0
 80002b6:	1a89      	subs	r1, r1, r2
 80002b8:	4718      	bx	r3
 80002ba:	46c0      	nop			; (mov r8, r8)
 80002bc:	0000      	movs	r0, r0
	...

080002c0 <__aeabi_idiv0>:
 80002c0:	4770      	bx	lr
 80002c2:	46c0      	nop			; (mov r8, r8)
	...

080002d0 <chThdDequeueAllI.constprop.32.4421>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80002d0:	b570      	push	{r4, r5, r6, lr}
 80002d2:	1c04      	adds	r4, r0, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80002d4:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 80002d6:	4284      	cmp	r4, r0
 80002d8:	d01f      	beq.n	800031a <chThdDequeueAllI.constprop.32.4421+0x4a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80002da:	6802      	ldr	r2, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80002dc:	2120      	movs	r1, #32
 80002de:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80002e0:	6054      	str	r4, [r2, #4]
 80002e2:	5c43      	ldrb	r3, [r0, r1]
 80002e4:	2b04      	cmp	r3, #4
 80002e6:	d004      	beq.n	80002f2 <chThdDequeueAllI.constprop.32.4421+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80002e8:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80002ea:	480c      	ldr	r0, [pc, #48]	; (800031c <chThdDequeueAllI.constprop.32.4421+0x4c>)
 80002ec:	4c0c      	ldr	r4, [pc, #48]	; (8000320 <chThdDequeueAllI.constprop.32.4421+0x50>)
 80002ee:	62e0      	str	r0, [r4, #44]	; 0x2c
 80002f0:	e7fe      	b.n	80002f0 <chThdDequeueAllI.constprop.32.4421+0x20>

  tp->p_u.rdymsg = msg;
 80002f2:	2600      	movs	r6, #0
 80002f4:	6246      	str	r6, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80002f6:	f000 ffc3 	bl	8001280 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80002fa:	6820      	ldr	r0, [r4, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80002fc:	2520      	movs	r5, #32
 80002fe:	4284      	cmp	r4, r0
 8000300:	d00b      	beq.n	800031a <chThdDequeueAllI.constprop.32.4421+0x4a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000302:	6802      	ldr	r2, [r0, #0]
 8000304:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000306:	6054      	str	r4, [r2, #4]
 8000308:	5d41      	ldrb	r1, [r0, r5]
 800030a:	2904      	cmp	r1, #4
 800030c:	d1ec      	bne.n	80002e8 <chThdDequeueAllI.constprop.32.4421+0x18>

  tp->p_u.rdymsg = msg;
 800030e:	6246      	str	r6, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000310:	f000 ffb6 	bl	8001280 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000314:	6820      	ldr	r0, [r4, #0]
 8000316:	4284      	cmp	r4, r0
 8000318:	d1f3      	bne.n	8000302 <chThdDequeueAllI.constprop.32.4421+0x32>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800031a:	bd70      	pop	{r4, r5, r6, pc}
 800031c:	08002710 	.word	0x08002710
 8000320:	20001118 	.word	0x20001118
 8000324:	46c0      	nop			; (mov r8, r8)
 8000326:	46c0      	nop			; (mov r8, r8)
 8000328:	46c0      	nop			; (mov r8, r8)
 800032a:	46c0      	nop			; (mov r8, r8)
 800032c:	46c0      	nop			; (mov r8, r8)
 800032e:	46c0      	nop			; (mov r8, r8)

08000330 <serve_interrupt.9026.4349>:
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000330:	23b5      	movs	r3, #181	; 0xb5
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000332:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000334:	1c04      	adds	r4, r0, #0
  USART_TypeDef *u = sdp->usart;
 8000336:	0098      	lsls	r0, r3, #2
 8000338:	5826      	ldr	r6, [r4, r0]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800033a:	4647      	mov	r7, r8
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 800033c:	6832      	ldr	r2, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800033e:	69f5      	ldr	r5, [r6, #28]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000340:	b480      	push	{r7}
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000342:	4690      	mov	r8, r2
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;
 8000344:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000346:	072b      	lsls	r3, r5, #28
 8000348:	d14b      	bne.n	80003e2 <serve_interrupt.9026.4349+0xb2>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800034a:	05eb      	lsls	r3, r5, #23
 800034c:	d465      	bmi.n	800041a <serve_interrupt.9026.4349+0xea>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 800034e:	06aa      	lsls	r2, r5, #26
 8000350:	d500      	bpl.n	8000354 <serve_interrupt.9026.4349+0x24>
 8000352:	e070      	b.n	8000436 <serve_interrupt.9026.4349+0x106>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000354:	2080      	movs	r0, #128	; 0x80
 8000356:	4643      	mov	r3, r8
 8000358:	4218      	tst	r0, r3
 800035a:	d001      	beq.n	8000360 <serve_interrupt.9026.4349+0x30>
 800035c:	4228      	tst	r0, r5
 800035e:	d104      	bne.n	800036a <serve_interrupt.9026.4349+0x3a>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000360:	066a      	lsls	r2, r5, #25
 8000362:	d42c      	bmi.n	80003be <serve_interrupt.9026.4349+0x8e>
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    osalSysUnlockFromISR();
  }
}
 8000364:	bc04      	pop	{r2}
 8000366:	4690      	mov	r8, r2
 8000368:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800036a:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800036c:	f000 ff18 	bl	80011a0 <_dbg_check_lock_from_isr>
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
  uint8_t b;

  chDbgCheckClassI();
 8000370:	f000 ff76 	bl	8001260 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000374:	f000 ff74 	bl	8001260 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000378:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800037a:	6c67      	ldr	r7, [r4, #68]	; 0x44
 800037c:	428f      	cmp	r7, r1
 800037e:	d100      	bne.n	8000382 <serve_interrupt.9026.4349+0x52>
 8000380:	e095      	b.n	80004ae <serve_interrupt.9026.4349+0x17e>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000382:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000384:	6c23      	ldr	r3, [r4, #64]	; 0x40

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000386:	3001      	adds	r0, #1
 8000388:	63a0      	str	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 800038a:	780f      	ldrb	r7, [r1, #0]
 800038c:	3101      	adds	r1, #1
 800038e:	64a1      	str	r1, [r4, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 8000390:	4299      	cmp	r1, r3
 8000392:	d301      	bcc.n	8000398 <serve_interrupt.9026.4349+0x68>
    oqp->q_rdptr = oqp->q_buffer;
 8000394:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8000396:	64a1      	str	r1, [r4, #72]	; 0x48
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8000398:	1c22      	adds	r2, r4, #0
 800039a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800039c:	3230      	adds	r2, #48	; 0x30
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 800039e:	4282      	cmp	r2, r0
 80003a0:	d100      	bne.n	80003a4 <serve_interrupt.9026.4349+0x74>
 80003a2:	e0ab      	b.n	80004fc <serve_interrupt.9026.4349+0x1cc>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80003a4:	6803      	ldr	r3, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80003a6:	2120      	movs	r1, #32
 80003a8:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->p_next->p_prev = (thread_t *)tqp;
 80003aa:	605a      	str	r2, [r3, #4]
 80003ac:	5c42      	ldrb	r2, [r0, r1]
 80003ae:	2a04      	cmp	r2, #4
 80003b0:	d100      	bne.n	80003b4 <serve_interrupt.9026.4349+0x84>
 80003b2:	e09f      	b.n	80004f4 <serve_interrupt.9026.4349+0x1c4>
 80003b4:	b672      	cpsid	i
 80003b6:	4852      	ldr	r0, [pc, #328]	; (8000500 <serve_interrupt.9026.4349+0x1d0>)
 80003b8:	4f52      	ldr	r7, [pc, #328]	; (8000504 <serve_interrupt.9026.4349+0x1d4>)
 80003ba:	62f8      	str	r0, [r7, #44]	; 0x2c
 80003bc:	e7fe      	b.n	80003bc <serve_interrupt.9026.4349+0x8c>
 80003be:	b672      	cpsid	i
 80003c0:	f000 feee 	bl	80011a0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80003c4:	f000 ff4c 	bl	8001260 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80003c8:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80003ca:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80003cc:	4285      	cmp	r5, r0
 80003ce:	d100      	bne.n	80003d2 <serve_interrupt.9026.4349+0xa2>
 80003d0:	e087      	b.n	80004e2 <serve_interrupt.9026.4349+0x1b2>
  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80003d2:	2440      	movs	r4, #64	; 0x40
 80003d4:	4641      	mov	r1, r8
 80003d6:	43a1      	bics	r1, r4
 80003d8:	6031      	str	r1, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80003da:	f000 fef9 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003de:	b662      	cpsie	i
 80003e0:	e7c0      	b.n	8000364 <serve_interrupt.9026.4349+0x34>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 80003e2:	072f      	lsls	r7, r5, #28
    sts |= SD_OVERRUN_ERROR;
 80003e4:	0ff9      	lsrs	r1, r7, #31
 80003e6:	01cf      	lsls	r7, r1, #7
  if (isr & USART_ISR_PE)
 80003e8:	07ea      	lsls	r2, r5, #31
 80003ea:	d501      	bpl.n	80003f0 <serve_interrupt.9026.4349+0xc0>
    sts |= SD_PARITY_ERROR;
 80003ec:	2320      	movs	r3, #32
 80003ee:	431f      	orrs	r7, r3
  if (isr & USART_ISR_FE)
 80003f0:	07ab      	lsls	r3, r5, #30
 80003f2:	d501      	bpl.n	80003f8 <serve_interrupt.9026.4349+0xc8>
    sts |= SD_FRAMING_ERROR;
 80003f4:	2040      	movs	r0, #64	; 0x40
 80003f6:	4307      	orrs	r7, r0
  if (isr & USART_ISR_NE)
 80003f8:	076a      	lsls	r2, r5, #29
 80003fa:	d502      	bpl.n	8000402 <serve_interrupt.9026.4349+0xd2>
    sts |= SD_NOISE_ERROR;
 80003fc:	2280      	movs	r2, #128	; 0x80
 80003fe:	0051      	lsls	r1, r2, #1
 8000400:	430f      	orrs	r7, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000402:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000404:	f000 fecc 	bl	80011a0 <_dbg_check_lock_from_isr>
  osalSysLockFromISR();
  chnAddFlagsI(sdp, sts);
 8000408:	1d20      	adds	r0, r4, #4
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800040a:	1c39      	adds	r1, r7, #0
 800040c:	f000 ff98 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000410:	f000 fede 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000414:	b662      	cpsie	i
  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000416:	05eb      	lsls	r3, r5, #23
 8000418:	d599      	bpl.n	800034e <serve_interrupt.9026.4349+0x1e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800041a:	b672      	cpsid	i
 800041c:	2780      	movs	r7, #128	; 0x80
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800041e:	f000 febf 	bl	80011a0 <_dbg_check_lock_from_isr>
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000422:	1d20      	adds	r0, r4, #4
 8000424:	00b9      	lsls	r1, r7, #2
 8000426:	f000 ff8b 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800042a:	f000 fed1 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800042e:	b662      	cpsie	i
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000430:	06aa      	lsls	r2, r5, #26
 8000432:	d400      	bmi.n	8000436 <serve_interrupt.9026.4349+0x106>
 8000434:	e78e      	b.n	8000354 <serve_interrupt.9026.4349+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000436:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000438:	f000 feb2 	bl	80011a0 <_dbg_check_lock_from_isr>
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800043c:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
 800043e:	b2df      	uxtb	r7, r3
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8000440:	f000 ff0e 	bl	8001260 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000444:	f000 ff0c 	bl	8001260 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8000448:	6960      	ldr	r0, [r4, #20]
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800044a:	2800      	cmp	r0, #0
 800044c:	d103      	bne.n	8000456 <serve_interrupt.9026.4349+0x126>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800044e:	1d20      	adds	r0, r4, #4
 8000450:	2104      	movs	r1, #4
 8000452:	f000 ff75 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();
 8000456:	f000 ff03 	bl	8001260 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 800045a:	f000 ff01 	bl	8001260 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800045e:	6a21      	ldr	r1, [r4, #32]
 8000460:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000462:	4291      	cmp	r1, r2
 8000464:	d035      	beq.n	80004d2 <serve_interrupt.9026.4349+0x1a2>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000466:	6960      	ldr	r0, [r4, #20]
 8000468:	3001      	adds	r0, #1
 800046a:	6160      	str	r0, [r4, #20]
  *iqp->q_wrptr++ = b;
 800046c:	700f      	strb	r7, [r1, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 800046e:	69e7      	ldr	r7, [r4, #28]
  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
 8000470:	3101      	adds	r1, #1
 8000472:	6221      	str	r1, [r4, #32]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000474:	42b9      	cmp	r1, r7
 8000476:	d301      	bcc.n	800047c <serve_interrupt.9026.4349+0x14c>
    iqp->q_wrptr = iqp->q_buffer;
 8000478:	69a1      	ldr	r1, [r4, #24]
 800047a:	6221      	str	r1, [r4, #32]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800047c:	1c22      	adds	r2, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800047e:	68e0      	ldr	r0, [r4, #12]
 8000480:	320c      	adds	r2, #12
 8000482:	4282      	cmp	r2, r0
 8000484:	d00f      	beq.n	80004a6 <serve_interrupt.9026.4349+0x176>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000486:	6803      	ldr	r3, [r0, #0]
 8000488:	2720      	movs	r7, #32
 800048a:	60e3      	str	r3, [r4, #12]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800048c:	605a      	str	r2, [r3, #4]
 800048e:	5dc1      	ldrb	r1, [r0, r7]
 8000490:	2904      	cmp	r1, #4
 8000492:	d004      	beq.n	800049e <serve_interrupt.9026.4349+0x16e>
 8000494:	b672      	cpsid	i
 8000496:	4c1a      	ldr	r4, [pc, #104]	; (8000500 <serve_interrupt.9026.4349+0x1d0>)
 8000498:	4d1a      	ldr	r5, [pc, #104]	; (8000504 <serve_interrupt.9026.4349+0x1d4>)
 800049a:	62ec      	str	r4, [r5, #44]	; 0x2c
 800049c:	e7fe      	b.n	800049c <serve_interrupt.9026.4349+0x16c>

  tp->p_u.rdymsg = msg;
 800049e:	2200      	movs	r2, #0
 80004a0:	6242      	str	r2, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80004a2:	f000 feed 	bl	8001280 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80004a6:	f000 fe93 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80004aa:	b662      	cpsie	i
 80004ac:	e752      	b.n	8000354 <serve_interrupt.9026.4349+0x24>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80004ae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80004b0:	2a00      	cmp	r2, #0
 80004b2:	d100      	bne.n	80004b6 <serve_interrupt.9026.4349+0x186>
 80004b4:	e765      	b.n	8000382 <serve_interrupt.9026.4349+0x52>
 80004b6:	2108      	movs	r1, #8
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80004b8:	1d20      	adds	r0, r4, #4
 80004ba:	f000 ff41 	bl	8001340 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80004be:	21c0      	movs	r1, #192	; 0xc0
 80004c0:	4642      	mov	r2, r8
 80004c2:	438a      	bics	r2, r1
 80004c4:	2340      	movs	r3, #64	; 0x40
 80004c6:	4313      	orrs	r3, r2
 80004c8:	6033      	str	r3, [r6, #0]
 80004ca:	f000 fe81 	bl	80011d0 <_dbg_check_unlock_from_isr>
 80004ce:	b662      	cpsie	i
 80004d0:	e746      	b.n	8000360 <serve_interrupt.9026.4349+0x30>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80004d2:	6963      	ldr	r3, [r4, #20]
 80004d4:	2b00      	cmp	r3, #0
 80004d6:	d0c6      	beq.n	8000466 <serve_interrupt.9026.4349+0x136>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80004d8:	1d20      	adds	r0, r4, #4
 80004da:	2180      	movs	r1, #128	; 0x80
 80004dc:	f000 ff30 	bl	8001340 <chEvtBroadcastFlagsI>
 80004e0:	e7e1      	b.n	80004a6 <serve_interrupt.9026.4349+0x176>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80004e2:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 80004e4:	2f00      	cmp	r7, #0
 80004e6:	d100      	bne.n	80004ea <serve_interrupt.9026.4349+0x1ba>
 80004e8:	e773      	b.n	80003d2 <serve_interrupt.9026.4349+0xa2>

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 80004ea:	1d20      	adds	r0, r4, #4
 80004ec:	2110      	movs	r1, #16
 80004ee:	f000 ff27 	bl	8001340 <chEvtBroadcastFlagsI>
 80004f2:	e76e      	b.n	80003d2 <serve_interrupt.9026.4349+0xa2>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80004f4:	2300      	movs	r3, #0
 80004f6:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80004f8:	f000 fec2 	bl	8001280 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 80004fc:	8537      	strh	r7, [r6, #40]	; 0x28
 80004fe:	e7e4      	b.n	80004ca <serve_interrupt.9026.4349+0x19a>
 8000500:	08002710 	.word	0x08002710
 8000504:	20001118 	.word	0x20001118
 8000508:	46c0      	nop			; (mov r8, r8)
 800050a:	46c0      	nop			; (mov r8, r8)
 800050c:	46c0      	nop			; (mov r8, r8)
 800050e:	46c0      	nop			; (mov r8, r8)

08000510 <VectorB0.4345>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000510:	b510      	push	{r4, lr}
 8000512:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000514:	f000 fe74 	bl	8001200 <_dbg_check_enter_isr>

  serve_interrupt(&SD2);
 8000518:	4804      	ldr	r0, [pc, #16]	; (800052c <VectorB0.4345+0x1c>)
 800051a:	f7ff ff09 	bl	8000330 <serve_interrupt.9026.4349>

  OSAL_IRQ_EPILOGUE();
 800051e:	f000 fe87 	bl	8001230 <_dbg_check_leave_isr>
 8000522:	1c20      	adds	r0, r4, #0
 8000524:	f000 fffc 	bl	8001520 <_port_irq_epilogue>
}
 8000528:	bd10      	pop	{r4, pc}
 800052a:	46c0      	nop			; (mov r8, r8)
 800052c:	20000e34 	.word	0x20000e34

08000530 <VectorAC.4347>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000530:	b510      	push	{r4, lr}
 8000532:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000534:	f000 fe64 	bl	8001200 <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
 8000538:	4804      	ldr	r0, [pc, #16]	; (800054c <VectorAC.4347+0x1c>)
 800053a:	f7ff fef9 	bl	8000330 <serve_interrupt.9026.4349>

  OSAL_IRQ_EPILOGUE();
 800053e:	f000 fe77 	bl	8001230 <_dbg_check_leave_isr>
 8000542:	1c20      	adds	r0, r4, #0
 8000544:	f000 ffec 	bl	8001520 <_port_irq_epilogue>
}
 8000548:	bd10      	pop	{r4, pc}
 800054a:	46c0      	nop			; (mov r8, r8)
 800054c:	20000b58 	.word	0x20000b58

08000550 <VectorB8.4394>:
/**
 * @brief   CAN1 unified interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_UNIFIED_HANDLER) {
 8000550:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000552:	4647      	mov	r7, r8
 8000554:	b480      	push	{r7}

  OSAL_IRQ_PROLOGUE();
 8000556:	4677      	mov	r7, lr
 8000558:	f000 fe52 	bl	8001200 <_dbg_check_enter_isr>
static void can_lld_tx_handler(CANDriver *canp) {
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 800055c:	4e5c      	ldr	r6, [pc, #368]	; (80006d0 <VectorB8.4394+0x180>)
  canp->can->TSR = tsr;

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;
 800055e:	2400      	movs	r4, #0
static void can_lld_tx_handler(CANDriver *canp) {
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 8000560:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8000562:	6893      	ldr	r3, [r2, #8]
  canp->can->TSR = tsr;
 8000564:	6093      	str	r3, [r2, #8]

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
 8000566:	07da      	lsls	r2, r3, #31
 8000568:	d504      	bpl.n	8000574 <VectorB8.4394+0x24>
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
 800056a:	200c      	movs	r0, #12
      flags |= CAN_MAILBOX_TO_MASK(1U) << 16U;
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(1U);
 800056c:	2401      	movs	r4, #1
  /* Flags to be signaled through the TX event source.*/
  flags = 0U;

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
 800056e:	4218      	tst	r0, r3
 8000570:	d000      	beq.n	8000574 <VectorB8.4394+0x24>
 8000572:	e068      	b.n	8000646 <VectorB8.4394+0xf6>
      flags |= CAN_MAILBOX_TO_MASK(1U);
    }
  }

  /* Checking mailbox 1.*/
  if ((tsr & CAN_TSR_RQCP1) != 0U) {
 8000574:	05da      	lsls	r2, r3, #23
 8000576:	d506      	bpl.n	8000586 <VectorB8.4394+0x36>
    if ((tsr & (CAN_TSR_ALST1 | CAN_TSR_TERR1)) != 0U) {
 8000578:	21c0      	movs	r1, #192	; 0xc0
 800057a:	010d      	lsls	r5, r1, #4
 800057c:	422b      	tst	r3, r5
 800057e:	d05f      	beq.n	8000640 <VectorB8.4394+0xf0>
      flags |= CAN_MAILBOX_TO_MASK(2U) << 16U;
 8000580:	2080      	movs	r0, #128	; 0x80
 8000582:	0281      	lsls	r1, r0, #10
 8000584:	430c      	orrs	r4, r1
      flags |= CAN_MAILBOX_TO_MASK(2U);
    }
  }

  /* Checking mailbox 2.*/
  if ((tsr & CAN_TSR_RQCP2) != 0U) {
 8000586:	03da      	lsls	r2, r3, #15
 8000588:	d505      	bpl.n	8000596 <VectorB8.4394+0x46>
    if ((tsr & (CAN_TSR_ALST2 | CAN_TSR_TERR2)) != 0U) {
 800058a:	25c0      	movs	r5, #192	; 0xc0
 800058c:	032a      	lsls	r2, r5, #12
 800058e:	4213      	tst	r3, r2
 8000590:	d15c      	bne.n	800064c <VectorB8.4394+0xfc>
      flags |= CAN_MAILBOX_TO_MASK(3U) << 16U;
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(3U);
 8000592:	2304      	movs	r3, #4
 8000594:	431c      	orrs	r4, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000596:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000598:	f000 fe02 	bl	80011a0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800059c:	4d4d      	ldr	r5, [pc, #308]	; (80006d4 <VectorB8.4394+0x184>)
 800059e:	1c28      	adds	r0, r5, #0
 80005a0:	f7ff fe96 	bl	80002d0 <chThdDequeueAllI.constprop.32.4421>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80005a4:	1c28      	adds	r0, r5, #0
 80005a6:	3014      	adds	r0, #20
 80005a8:	1c21      	adds	r1, r4, #0
 80005aa:	f000 fec9 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80005ae:	f000 fe0f 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005b2:	b662      	cpsie	i
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 80005b4:	2408      	movs	r4, #8
 80005b6:	4262      	negs	r2, r4
 80005b8:	1953      	adds	r3, r2, r5
 80005ba:	4698      	mov	r8, r3
 80005bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005be:	68dc      	ldr	r4, [r3, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 80005c0:	07a2      	lsls	r2, r4, #30
 80005c2:	d147      	bne.n	8000654 <VectorB8.4394+0x104>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1U));
    osalSysUnlockFromISR();
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 80005c4:	2210      	movs	r2, #16
 80005c6:	4222      	tst	r2, r4
 80005c8:	d00c      	beq.n	80005e4 <VectorB8.4394+0x94>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 80005ca:	60da      	str	r2, [r3, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005cc:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80005ce:	f000 fde7 	bl	80011a0 <_dbg_check_lock_from_isr>
 80005d2:	4c41      	ldr	r4, [pc, #260]	; (80006d8 <VectorB8.4394+0x188>)
 80005d4:	2110      	movs	r1, #16
 80005d6:	1c20      	adds	r0, r4, #0
 80005d8:	f000 feb2 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80005dc:	f000 fdf8 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005e0:	b662      	cpsie	i
 80005e2:	68e3      	ldr	r3, [r4, #12]
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 80005e4:	691c      	ldr	r4, [r3, #16]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 80005e6:	07a2      	lsls	r2, r4, #30
 80005e8:	d15c      	bne.n	80006a4 <VectorB8.4394+0x154>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2U));
    osalSysUnlockFromISR();
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 80005ea:	2210      	movs	r2, #16
 80005ec:	4222      	tst	r2, r4
 80005ee:	d00c      	beq.n	800060a <VectorB8.4394+0xba>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 80005f0:	611a      	str	r2, [r3, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005f2:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80005f4:	f000 fdd4 	bl	80011a0 <_dbg_check_lock_from_isr>
 80005f8:	4c37      	ldr	r4, [pc, #220]	; (80006d8 <VectorB8.4394+0x188>)
 80005fa:	2110      	movs	r1, #16
 80005fc:	1c20      	adds	r0, r4, #0
 80005fe:	f000 fe9f 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000602:	f000 fde5 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000606:	b662      	cpsie	i
 8000608:	68e3      	ldr	r3, [r4, #12]
 */
static void can_lld_sce_handler(CANDriver *canp) {
  uint32_t msr;

  /* Clearing IRQ sources.*/
  msr = canp->can->MSR;
 800060a:	685d      	ldr	r5, [r3, #4]
  canp->can->MSR = msr;
 800060c:	605d      	str	r5, [r3, #4]

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 800060e:	072a      	lsls	r2, r5, #28
 8000610:	d436      	bmi.n	8000680 <VectorB8.4394+0x130>
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
    osalSysUnlockFromISR();
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 8000612:	076b      	lsls	r3, r5, #29
 8000614:	d50c      	bpl.n	8000630 <VectorB8.4394+0xe0>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 8000616:	6af4      	ldr	r4, [r6, #44]	; 0x2c
 8000618:	69a5      	ldr	r5, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800061a:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800061c:	f000 fdc0 	bl	80011a0 <_dbg_check_lock_from_isr>
 8000620:	1c30      	adds	r0, r6, #0
 8000622:	3020      	adds	r0, #32

    osalSysLockFromISR();
    /* The content of the ESR register is copied unchanged in the upper
       half word of the listener flags mask.*/
    osalEventBroadcastFlagsI(&canp->error_event,
                             flags | (eventflags_t)(esr << 16U));
 8000624:	0429      	lsls	r1, r5, #16
 8000626:	f000 fe8b 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800062a:	f000 fdd1 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800062e:	b662      	cpsie	i
  can_lld_tx_handler(&CAND1);
  can_lld_rx0_handler(&CAND1);
  can_lld_rx1_handler(&CAND1);
  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8000630:	f000 fdfe 	bl	8001230 <_dbg_check_leave_isr>
 8000634:	1c38      	adds	r0, r7, #0
 8000636:	f000 ff73 	bl	8001520 <_port_irq_epilogue>
}
 800063a:	bc04      	pop	{r2}
 800063c:	4690      	mov	r8, r2
 800063e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((tsr & CAN_TSR_RQCP1) != 0U) {
    if ((tsr & (CAN_TSR_ALST1 | CAN_TSR_TERR1)) != 0U) {
      flags |= CAN_MAILBOX_TO_MASK(2U) << 16U;
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(2U);
 8000640:	2202      	movs	r2, #2
 8000642:	4314      	orrs	r4, r2
 8000644:	e79f      	b.n	8000586 <VectorB8.4394+0x36>
  flags = 0U;

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
      flags |= CAN_MAILBOX_TO_MASK(1U) << 16U;
 8000646:	2480      	movs	r4, #128	; 0x80
 8000648:	0264      	lsls	r4, r4, #9
 800064a:	e793      	b.n	8000574 <VectorB8.4394+0x24>
  }

  /* Checking mailbox 2.*/
  if ((tsr & CAN_TSR_RQCP2) != 0U) {
    if ((tsr & (CAN_TSR_ALST2 | CAN_TSR_TERR2)) != 0U) {
      flags |= CAN_MAILBOX_TO_MASK(3U) << 16U;
 800064c:	2080      	movs	r0, #128	; 0x80
 800064e:	02c1      	lsls	r1, r0, #11
 8000650:	430c      	orrs	r4, r1
 8000652:	e7a0      	b.n	8000596 <VectorB8.4394+0x46>
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 8000654:	6958      	ldr	r0, [r3, #20]
 8000656:	2102      	movs	r1, #2
 8000658:	4388      	bics	r0, r1
 800065a:	6158      	str	r0, [r3, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800065c:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800065e:	f000 fd9f 	bl	80011a0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8000662:	1c28      	adds	r0, r5, #0
 8000664:	3008      	adds	r0, #8
 8000666:	f7ff fe33 	bl	80002d0 <chThdDequeueAllI.constprop.32.4421>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800066a:	1c28      	adds	r0, r5, #0
 800066c:	3010      	adds	r0, #16
 800066e:	2101      	movs	r1, #1
 8000670:	f000 fe66 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000674:	f000 fdac 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000678:	b662      	cpsie	i
 800067a:	4645      	mov	r5, r8
 800067c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800067e:	e7a1      	b.n	80005c4 <VectorB8.4394+0x74>

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 8000680:	681a      	ldr	r2, [r3, #0]
 8000682:	2102      	movs	r1, #2
  canp->can->MSR = msr;

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 8000684:	2003      	movs	r0, #3
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 8000686:	438a      	bics	r2, r1
  canp->can->MSR = msr;

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 8000688:	7030      	strb	r0, [r6, #0]
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 800068a:	601a      	str	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800068c:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800068e:	f000 fd87 	bl	80011a0 <_dbg_check_lock_from_isr>
 8000692:	1c30      	adds	r0, r6, #0
 8000694:	3028      	adds	r0, #40	; 0x28
 8000696:	2100      	movs	r1, #0
 8000698:	f000 fe52 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800069c:	f000 fd98 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006a0:	b662      	cpsie	i
 80006a2:	e7b6      	b.n	8000612 <VectorB8.4394+0xc2>
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 80006a4:	6958      	ldr	r0, [r3, #20]
 80006a6:	2110      	movs	r1, #16
 80006a8:	4388      	bics	r0, r1
 80006aa:	6158      	str	r0, [r3, #20]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006ac:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80006ae:	f000 fd77 	bl	80011a0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 80006b2:	4d0a      	ldr	r5, [pc, #40]	; (80006dc <VectorB8.4394+0x18c>)
 80006b4:	1c28      	adds	r0, r5, #0
 80006b6:	f7ff fe0b 	bl	80002d0 <chThdDequeueAllI.constprop.32.4421>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80006ba:	1c28      	adds	r0, r5, #0
 80006bc:	3008      	adds	r0, #8
 80006be:	2102      	movs	r1, #2
 80006c0:	f000 fe3e 	bl	8001340 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80006c4:	f000 fd84 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006c8:	b662      	cpsie	i
 80006ca:	69eb      	ldr	r3, [r5, #28]
 80006cc:	e78d      	b.n	80005ea <VectorB8.4394+0x9a>
 80006ce:	46c0      	nop			; (mov r8, r8)
 80006d0:	20001680 	.word	0x20001680
 80006d4:	20001688 	.word	0x20001688
 80006d8:	200016a0 	.word	0x200016a0
 80006dc:	20001690 	.word	0x20001690

080006e0 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80006e0:	4b06      	ldr	r3, [pc, #24]	; (80006fc <_dbg_check_unlock+0x1c>)
 80006e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80006e4:	2a00      	cmp	r2, #0
 80006e6:	d104      	bne.n	80006f2 <_dbg_check_unlock+0x12>
 80006e8:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80006ea:	2900      	cmp	r1, #0
 80006ec:	dd01      	ble.n	80006f2 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80006ee:	635a      	str	r2, [r3, #52]	; 0x34
}
 80006f0:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006f2:	b672      	cpsid	i
 80006f4:	4802      	ldr	r0, [pc, #8]	; (8000700 <_dbg_check_unlock+0x20>)
 80006f6:	62d8      	str	r0, [r3, #44]	; 0x2c
 80006f8:	e7fe      	b.n	80006f8 <_dbg_check_unlock+0x18>
 80006fa:	46c0      	nop			; (mov r8, r8)
 80006fc:	20001118 	.word	0x20001118
 8000700:	080026d0 	.word	0x080026d0
 8000704:	46c0      	nop			; (mov r8, r8)
 8000706:	46c0      	nop			; (mov r8, r8)
 8000708:	46c0      	nop			; (mov r8, r8)
 800070a:	46c0      	nop			; (mov r8, r8)
 800070c:	46c0      	nop			; (mov r8, r8)
 800070e:	46c0      	nop			; (mov r8, r8)

08000710 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000710:	4b06      	ldr	r3, [pc, #24]	; (800072c <_dbg_check_lock+0x1c>)
 8000712:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000714:	2a00      	cmp	r2, #0
 8000716:	d102      	bne.n	800071e <_dbg_check_lock+0xe>
 8000718:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800071a:	2800      	cmp	r0, #0
 800071c:	d003      	beq.n	8000726 <_dbg_check_lock+0x16>
 800071e:	b672      	cpsid	i
 8000720:	4a03      	ldr	r2, [pc, #12]	; (8000730 <_dbg_check_lock+0x20>)
 8000722:	62da      	str	r2, [r3, #44]	; 0x2c
 8000724:	e7fe      	b.n	8000724 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000726:	2101      	movs	r1, #1
 8000728:	6359      	str	r1, [r3, #52]	; 0x34
}
 800072a:	4770      	bx	lr
 800072c:	20001118 	.word	0x20001118
 8000730:	080026d8 	.word	0x080026d8
 8000734:	46c0      	nop			; (mov r8, r8)
 8000736:	46c0      	nop			; (mov r8, r8)
 8000738:	46c0      	nop			; (mov r8, r8)
 800073a:	46c0      	nop			; (mov r8, r8)
 800073c:	46c0      	nop			; (mov r8, r8)
 800073e:	46c0      	nop			; (mov r8, r8)

08000740 <chOQPutTimeout.4234>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000742:	1c04      	adds	r4, r0, #0
 8000744:	1c0f      	adds	r7, r1, #0
 8000746:	1c16      	adds	r6, r2, #0
 8000748:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800074a:	f7ff ffe1 	bl	8000710 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800074e:	f000 fd87 	bl	8001260 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8000752:	68a3      	ldr	r3, [r4, #8]

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8000754:	2b00      	cmp	r3, #0
 8000756:	d113      	bne.n	8000780 <chOQPutTimeout.4234+0x40>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000758:	1c20      	adds	r0, r4, #0
 800075a:	1c31      	adds	r1, r6, #0
 800075c:	f001 f868 	bl	8001830 <chThdEnqueueTimeoutS>
 8000760:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 8000762:	daf4      	bge.n	800074e <chOQPutTimeout.4234+0xe>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000764:	f7ff ffbc 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000768:	4b19      	ldr	r3, [pc, #100]	; (80007d0 <chOQPutTimeout.4234+0x90>)
 800076a:	6818      	ldr	r0, [r3, #0]
 800076c:	4298      	cmp	r0, r3
 800076e:	d004      	beq.n	800077a <chOQPutTimeout.4234+0x3a>
 8000770:	6999      	ldr	r1, [r3, #24]
 8000772:	6882      	ldr	r2, [r0, #8]
 8000774:	688c      	ldr	r4, [r1, #8]
 8000776:	4294      	cmp	r4, r2
 8000778:	d321      	bcc.n	80007be <chOQPutTimeout.4234+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800077a:	b662      	cpsie	i
    oqp->q_notify(oqp);
  }
  chSysUnlock();

  return Q_OK;
}
 800077c:	1c28      	adds	r0, r5, #0
 800077e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000780:	68a0      	ldr	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000782:	6961      	ldr	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000784:	3801      	subs	r0, #1
 8000786:	60a0      	str	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000788:	700f      	strb	r7, [r1, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800078a:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 800078c:	3101      	adds	r1, #1
 800078e:	6161      	str	r1, [r4, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000790:	4291      	cmp	r1, r2
 8000792:	d301      	bcc.n	8000798 <chOQPutTimeout.4234+0x58>
    oqp->q_wrptr = oqp->q_buffer;
 8000794:	68e5      	ldr	r5, [r4, #12]
 8000796:	6165      	str	r5, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8000798:	69e6      	ldr	r6, [r4, #28]
 800079a:	2e00      	cmp	r6, #0
 800079c:	d001      	beq.n	80007a2 <chOQPutTimeout.4234+0x62>
    oqp->q_notify(oqp);
 800079e:	1c20      	adds	r0, r4, #0
 80007a0:	47b0      	blx	r6
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80007a2:	f7ff ff9d 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80007a6:	4c0a      	ldr	r4, [pc, #40]	; (80007d0 <chOQPutTimeout.4234+0x90>)
 80007a8:	6827      	ldr	r7, [r4, #0]
 80007aa:	42a7      	cmp	r7, r4
 80007ac:	d004      	beq.n	80007b8 <chOQPutTimeout.4234+0x78>
 80007ae:	69a3      	ldr	r3, [r4, #24]
 80007b0:	68b9      	ldr	r1, [r7, #8]
 80007b2:	6898      	ldr	r0, [r3, #8]
 80007b4:	4288      	cmp	r0, r1
 80007b6:	d306      	bcc.n	80007c6 <chOQPutTimeout.4234+0x86>
 80007b8:	b662      	cpsie	i
 80007ba:	2500      	movs	r5, #0
 80007bc:	e7de      	b.n	800077c <chOQPutTimeout.4234+0x3c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007be:	b672      	cpsid	i
 80007c0:	4d04      	ldr	r5, [pc, #16]	; (80007d4 <chOQPutTimeout.4234+0x94>)
 80007c2:	62dd      	str	r5, [r3, #44]	; 0x2c
 80007c4:	e7fe      	b.n	80007c4 <chOQPutTimeout.4234+0x84>
 80007c6:	b672      	cpsid	i
 80007c8:	4a02      	ldr	r2, [pc, #8]	; (80007d4 <chOQPutTimeout.4234+0x94>)
 80007ca:	62e2      	str	r2, [r4, #44]	; 0x2c
 80007cc:	e7fe      	b.n	80007cc <chOQPutTimeout.4234+0x8c>
 80007ce:	46c0      	nop			; (mov r8, r8)
 80007d0:	20001118 	.word	0x20001118
 80007d4:	08002a00 	.word	0x08002a00
 80007d8:	46c0      	nop			; (mov r8, r8)
 80007da:	46c0      	nop			; (mov r8, r8)
 80007dc:	46c0      	nop			; (mov r8, r8)
 80007de:	46c0      	nop			; (mov r8, r8)

080007e0 <putt.8202>:
static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80007e0:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80007e2:	3030      	adds	r0, #48	; 0x30
 80007e4:	f7ff ffac 	bl	8000740 <chOQPutTimeout.4234>
}
 80007e8:	bd08      	pop	{r3, pc}
 80007ea:	46c0      	nop			; (mov r8, r8)
 80007ec:	46c0      	nop			; (mov r8, r8)
 80007ee:	46c0      	nop			; (mov r8, r8)

080007f0 <put.8207>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 80007f0:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80007f2:	2201      	movs	r2, #1
 80007f4:	3030      	adds	r0, #48	; 0x30
 80007f6:	4252      	negs	r2, r2
 80007f8:	f7ff ffa2 	bl	8000740 <chOQPutTimeout.4234>
}
 80007fc:	bd08      	pop	{r3, pc}
 80007fe:	46c0      	nop			; (mov r8, r8)

08000800 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000800:	b510      	push	{r4, lr}
 8000802:	1c04      	adds	r4, r0, #0
 8000804:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000806:	f7ff ff83 	bl	8000710 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800080a:	2c00      	cmp	r4, #0
 800080c:	d010      	beq.n	8000830 <chThdSleep+0x30>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800080e:	1c21      	adds	r1, r4, #0
 8000810:	2008      	movs	r0, #8
 8000812:	f000 ff5d 	bl	80016d0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000816:	f7ff ff63 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800081a:	4b0a      	ldr	r3, [pc, #40]	; (8000844 <chThdSleep+0x44>)
 800081c:	681a      	ldr	r2, [r3, #0]
 800081e:	429a      	cmp	r2, r3
 8000820:	d004      	beq.n	800082c <chThdSleep+0x2c>
 8000822:	6999      	ldr	r1, [r3, #24]
 8000824:	6894      	ldr	r4, [r2, #8]
 8000826:	6888      	ldr	r0, [r1, #8]
 8000828:	42a0      	cmp	r0, r4
 800082a:	d306      	bcc.n	800083a <chThdSleep+0x3a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800082c:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 800082e:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000830:	b672      	cpsid	i
 8000832:	4905      	ldr	r1, [pc, #20]	; (8000848 <chThdSleep+0x48>)
 8000834:	4b03      	ldr	r3, [pc, #12]	; (8000844 <chThdSleep+0x44>)
 8000836:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000838:	e7fe      	b.n	8000838 <chThdSleep+0x38>
 800083a:	b672      	cpsid	i
 800083c:	4a03      	ldr	r2, [pc, #12]	; (800084c <chThdSleep+0x4c>)
 800083e:	62da      	str	r2, [r3, #44]	; 0x2c
 8000840:	e7fe      	b.n	8000840 <chThdSleep+0x40>
 8000842:	46c0      	nop			; (mov r8, r8)
 8000844:	20001118 	.word	0x20001118
 8000848:	080026c0 	.word	0x080026c0
 800084c:	08002730 	.word	0x08002730

08000850 <chOQWriteTimeout.4275>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000850:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000852:	4645      	mov	r5, r8
 8000854:	4688      	mov	r8, r1
  qnotify_t nfy = oqp->q_notify;
 8000856:	69c1      	ldr	r1, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000858:	4657      	mov	r7, sl
 800085a:	464e      	mov	r6, r9
 800085c:	b4e0      	push	{r5, r6, r7}
 800085e:	1c04      	adds	r4, r0, #0
 8000860:	1c16      	adds	r6, r2, #0
 8000862:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8000864:	4689      	mov	r9, r1
 8000866:	b672      	cpsid	i
  size_t w = 0;

  chDbgCheck(n > 0U);
 8000868:	2a00      	cmp	r2, #0
 800086a:	d04f      	beq.n	800090c <chOQWriteTimeout.4275+0xbc>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800086c:	f7ff ff50 	bl	8000710 <_dbg_check_lock>
 8000870:	4d2a      	ldr	r5, [pc, #168]	; (800091c <chOQWriteTimeout.4275+0xcc>)
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8000872:	2700      	movs	r7, #0
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000874:	f000 fcf4 	bl	8001260 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8000878:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800087a:	2b00      	cmp	r3, #0
 800087c:	d02b      	beq.n	80008d6 <chOQWriteTimeout.4275+0x86>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800087e:	68a0      	ldr	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000880:	4642      	mov	r2, r8
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000882:	3801      	subs	r0, #1
 8000884:	60a0      	str	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000886:	6963      	ldr	r3, [r4, #20]
 8000888:	7811      	ldrb	r1, [r2, #0]
 800088a:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800088c:	6920      	ldr	r0, [r4, #16]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800088e:	3301      	adds	r3, #1
 8000890:	6163      	str	r3, [r4, #20]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000892:	4283      	cmp	r3, r0
 8000894:	d301      	bcc.n	800089a <chOQWriteTimeout.4275+0x4a>
      oqp->q_wrptr = oqp->q_buffer;
 8000896:	68e3      	ldr	r3, [r4, #12]
 8000898:	6163      	str	r3, [r4, #20]
    }

    if (nfy != NULL) {
 800089a:	464a      	mov	r2, r9
 800089c:	2a00      	cmp	r2, #0
 800089e:	d001      	beq.n	80008a4 <chOQWriteTimeout.4275+0x54>
      nfy(oqp);
 80008a0:	1c20      	adds	r0, r4, #0
 80008a2:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80008a4:	f7ff ff1c 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80008a8:	6828      	ldr	r0, [r5, #0]
 80008aa:	42a8      	cmp	r0, r5
 80008ac:	d004      	beq.n	80008b8 <chOQWriteTimeout.4275+0x68>
 80008ae:	69a9      	ldr	r1, [r5, #24]
 80008b0:	6883      	ldr	r3, [r0, #8]
 80008b2:	688a      	ldr	r2, [r1, #8]
 80008b4:	429a      	cmp	r2, r3
 80008b6:	d325      	bcc.n	8000904 <chOQWriteTimeout.4275+0xb4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008b8:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 80008ba:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 80008bc:	3701      	adds	r7, #1
    if (--n == 0U) {
 80008be:	2e00      	cmp	r6, #0
 80008c0:	d01a      	beq.n	80008f8 <chOQWriteTimeout.4275+0xa8>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80008c2:	2001      	movs	r0, #1
 80008c4:	4480      	add	r8, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008c6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80008c8:	f7ff ff22 	bl	8000710 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80008cc:	f000 fcc8 	bl	8001260 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 80008d0:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80008d2:	2b00      	cmp	r3, #0
 80008d4:	d1d3      	bne.n	800087e <chOQWriteTimeout.4275+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80008d6:	1c20      	adds	r0, r4, #0
 80008d8:	4651      	mov	r1, sl
 80008da:	f000 ffa9 	bl	8001830 <chThdEnqueueTimeoutS>
 80008de:	2800      	cmp	r0, #0
 80008e0:	d0c8      	beq.n	8000874 <chOQWriteTimeout.4275+0x24>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80008e2:	f7ff fefd 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80008e6:	6829      	ldr	r1, [r5, #0]
 80008e8:	42a9      	cmp	r1, r5
 80008ea:	d004      	beq.n	80008f6 <chOQWriteTimeout.4275+0xa6>
 80008ec:	69aa      	ldr	r2, [r5, #24]
 80008ee:	688b      	ldr	r3, [r1, #8]
 80008f0:	6890      	ldr	r0, [r2, #8]
 80008f2:	4298      	cmp	r0, r3
 80008f4:	d30e      	bcc.n	8000914 <chOQWriteTimeout.4275+0xc4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008f6:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80008f8:	1c38      	adds	r0, r7, #0
 80008fa:	bc1c      	pop	{r2, r3, r4}
 80008fc:	4690      	mov	r8, r2
 80008fe:	4699      	mov	r9, r3
 8000900:	46a2      	mov	sl, r4
 8000902:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000904:	b672      	cpsid	i
 8000906:	4c06      	ldr	r4, [pc, #24]	; (8000920 <chOQWriteTimeout.4275+0xd0>)
 8000908:	62ec      	str	r4, [r5, #44]	; 0x2c
 800090a:	e7fe      	b.n	800090a <chOQWriteTimeout.4275+0xba>
 800090c:	4d05      	ldr	r5, [pc, #20]	; (8000924 <chOQWriteTimeout.4275+0xd4>)
 800090e:	4e03      	ldr	r6, [pc, #12]	; (800091c <chOQWriteTimeout.4275+0xcc>)
 8000910:	62f5      	str	r5, [r6, #44]	; 0x2c
 8000912:	e7fe      	b.n	8000912 <chOQWriteTimeout.4275+0xc2>
 8000914:	b672      	cpsid	i
 8000916:	4c02      	ldr	r4, [pc, #8]	; (8000920 <chOQWriteTimeout.4275+0xd0>)
 8000918:	62ec      	str	r4, [r5, #44]	; 0x2c
 800091a:	e7fe      	b.n	800091a <chOQWriteTimeout.4275+0xca>
 800091c:	20001118 	.word	0x20001118
 8000920:	08002a00 	.word	0x08002a00
 8000924:	08002740 	.word	0x08002740
 8000928:	46c0      	nop			; (mov r8, r8)
 800092a:	46c0      	nop			; (mov r8, r8)
 800092c:	46c0      	nop			; (mov r8, r8)
 800092e:	46c0      	nop			; (mov r8, r8)

08000930 <debug_write.9476>:
};

char stn_rx_buf[1024] = "booo\r\n";

static void debug_write(char *msg)
{
 8000930:	b570      	push	{r4, r5, r6, lr}
    sdWrite(&SD1, (uint8_t*)"stuff: ", 7);
 8000932:	4d0f      	ldr	r5, [pc, #60]	; (8000970 <debug_write.9476+0x40>)
 8000934:	2401      	movs	r4, #1
 8000936:	4264      	negs	r4, r4
};

char stn_rx_buf[1024] = "booo\r\n";

static void debug_write(char *msg)
{
 8000938:	1c06      	adds	r6, r0, #0
    sdWrite(&SD1, (uint8_t*)"stuff: ", 7);
 800093a:	1c23      	adds	r3, r4, #0
 800093c:	1c28      	adds	r0, r5, #0
 800093e:	490d      	ldr	r1, [pc, #52]	; (8000974 <debug_write.9476+0x44>)
 8000940:	2207      	movs	r2, #7
 8000942:	f7ff ff85 	bl	8000850 <chOQWriteTimeout.4275>
    sdWrite(&SD1, (uint8_t*)msg, strlen(msg));
 8000946:	1c30      	adds	r0, r6, #0
 8000948:	f001 fe52 	bl	80025f0 <strlen>
 800094c:	1c31      	adds	r1, r6, #0
 800094e:	1c23      	adds	r3, r4, #0
 8000950:	1c02      	adds	r2, r0, #0
 8000952:	1c28      	adds	r0, r5, #0
 8000954:	f7ff ff7c 	bl	8000850 <chOQWriteTimeout.4275>
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8000958:	1c28      	adds	r0, r5, #0
 800095a:	1c22      	adds	r2, r4, #0
 800095c:	210d      	movs	r1, #13
 800095e:	f7ff feef 	bl	8000740 <chOQPutTimeout.4234>
 8000962:	1c28      	adds	r0, r5, #0
 8000964:	210a      	movs	r1, #10
 8000966:	1c22      	adds	r2, r4, #0
 8000968:	f7ff feea 	bl	8000740 <chOQPutTimeout.4234>
    sdPut(&SD1, '\r');
    sdPut(&SD1, '\n');
}
 800096c:	bd70      	pop	{r4, r5, r6, pc}
 800096e:	46c0      	nop			; (mov r8, r8)
 8000970:	20000b88 	.word	0x20000b88
 8000974:	080026e0 	.word	0x080026e0
 8000978:	46c0      	nop			; (mov r8, r8)
 800097a:	46c0      	nop			; (mov r8, r8)
 800097c:	46c0      	nop			; (mov r8, r8)
 800097e:	46c0      	nop			; (mov r8, r8)

08000980 <send_at.9469>:
    chThdSleepMilliseconds(1000);
    debug_write("after reset");
}

static void send_at(char *at_cmd)
{
 8000980:	b510      	push	{r4, lr}
 8000982:	1c04      	adds	r4, r0, #0
    sdWrite(&SD2, (uint8_t*)at_cmd, strlen(at_cmd));
 8000984:	f001 fe34 	bl	80025f0 <strlen>
 8000988:	2301      	movs	r3, #1
 800098a:	1c02      	adds	r2, r0, #0
 800098c:	1c21      	adds	r1, r4, #0
 800098e:	425b      	negs	r3, r3
 8000990:	4803      	ldr	r0, [pc, #12]	; (80009a0 <send_at.9469+0x20>)
 8000992:	f7ff ff5d 	bl	8000850 <chOQWriteTimeout.4275>
    chThdSleepMilliseconds(1000);
 8000996:	4803      	ldr	r0, [pc, #12]	; (80009a4 <send_at.9469+0x24>)
 8000998:	f7ff ff32 	bl	8000800 <chThdSleep>
}
 800099c:	bd10      	pop	{r4, pc}
 800099e:	46c0      	nop			; (mov r8, r8)
 80009a0:	20000e64 	.word	0x20000e64
 80009a4:	00002710 	.word	0x00002710
 80009a8:	46c0      	nop			; (mov r8, r8)
 80009aa:	46c0      	nop			; (mov r8, r8)
 80009ac:	46c0      	nop			; (mov r8, r8)
 80009ae:	46c0      	nop			; (mov r8, r8)

080009b0 <writet.8184>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 80009b0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80009b2:	3030      	adds	r0, #48	; 0x30
 80009b4:	f7ff ff4c 	bl	8000850 <chOQWriteTimeout.4275>
}
 80009b8:	bd08      	pop	{r3, pc}
 80009ba:	46c0      	nop			; (mov r8, r8)
 80009bc:	46c0      	nop			; (mov r8, r8)
 80009be:	46c0      	nop			; (mov r8, r8)

080009c0 <write.8190>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80009c0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80009c2:	2301      	movs	r3, #1
 80009c4:	3030      	adds	r0, #48	; 0x30
 80009c6:	425b      	negs	r3, r3
 80009c8:	f7ff ff42 	bl	8000850 <chOQWriteTimeout.4275>
                        n, TIME_INFINITE);
}
 80009cc:	bd08      	pop	{r3, pc}
 80009ce:	46c0      	nop			; (mov r8, r8)

080009d0 <chThdCreateStatic.constprop.38>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 80009d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80009d2:	464f      	mov	r7, r9
 80009d4:	4646      	mov	r6, r8
 80009d6:	b4c0      	push	{r6, r7}
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80009d8:	1c06      	adds	r6, r0, #0
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 80009da:	1c04      	adds	r4, r0, #0
 80009dc:	4688      	mov	r8, r1
 80009de:	1c17      	adds	r7, r2, #0
 80009e0:	4699      	mov	r9, r3
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80009e2:	3648      	adds	r6, #72	; 0x48
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80009e4:	25ff      	movs	r5, #255	; 0xff
 80009e6:	7005      	strb	r5, [r0, #0]
 80009e8:	7045      	strb	r5, [r0, #1]
 80009ea:	3002      	adds	r0, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80009ec:	4286      	cmp	r6, r0
 80009ee:	d1fa      	bne.n	80009e6 <chThdCreateStatic.constprop.38+0x16>
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 80009f0:	4642      	mov	r2, r8
 80009f2:	18a3      	adds	r3, r4, r2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80009f4:	429e      	cmp	r6, r3
 80009f6:	d213      	bcs.n	8000a20 <chThdCreateStatic.constprop.38+0x50>
 80009f8:	43f1      	mvns	r1, r6
 80009fa:	185a      	adds	r2, r3, r1
    *startp++ = v;
 80009fc:	2555      	movs	r5, #85	; 0x55
 80009fe:	2001      	movs	r0, #1
 8000a00:	1c71      	adds	r1, r6, #1
 8000a02:	4002      	ands	r2, r0
 8000a04:	7035      	strb	r5, [r6, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000a06:	4299      	cmp	r1, r3
 8000a08:	d00a      	beq.n	8000a20 <chThdCreateStatic.constprop.38+0x50>
 8000a0a:	2a00      	cmp	r2, #0
 8000a0c:	d003      	beq.n	8000a16 <chThdCreateStatic.constprop.38+0x46>
    *startp++ = v;
 8000a0e:	700d      	strb	r5, [r1, #0]
 8000a10:	3101      	adds	r1, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000a12:	4299      	cmp	r1, r3
 8000a14:	d004      	beq.n	8000a20 <chThdCreateStatic.constprop.38+0x50>
    *startp++ = v;
 8000a16:	700d      	strb	r5, [r1, #0]
 8000a18:	704d      	strb	r5, [r1, #1]
 8000a1a:	3102      	adds	r1, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000a1c:	4299      	cmp	r1, r3
 8000a1e:	d1fa      	bne.n	8000a16 <chThdCreateStatic.constprop.38+0x46>
 8000a20:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000a22:	f7ff fe75 	bl	8000710 <_dbg_check_lock>
                       tprio_t prio, tfunc_t pf, void *arg) {
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
 8000a26:	f000 fc1b 	bl	8001260 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8000a2a:	2c00      	cmp	r4, #0
 8000a2c:	d05c      	beq.n	8000ae8 <chThdCreateStatic.constprop.38+0x118>
 8000a2e:	4643      	mov	r3, r8
 8000a30:	2bcf      	cmp	r3, #207	; 0xcf
 8000a32:	d959      	bls.n	8000ae8 <chThdCreateStatic.constprop.38+0x118>
 8000a34:	2f7f      	cmp	r7, #127	; 0x7f
 8000a36:	d857      	bhi.n	8000ae8 <chThdCreateStatic.constprop.38+0x118>
 8000a38:	464d      	mov	r5, r9
 8000a3a:	2d00      	cmp	r5, #0
 8000a3c:	d054      	beq.n	8000ae8 <chThdCreateStatic.constprop.38+0x118>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000a3e:	4642      	mov	r2, r8
 8000a40:	3a24      	subs	r2, #36	; 0x24
 8000a42:	18a0      	adds	r0, r4, r2
 8000a44:	60e0      	str	r0, [r4, #12]
 8000a46:	6105      	str	r5, [r0, #16]
 8000a48:	4d32      	ldr	r5, [pc, #200]	; (8000b14 <chThdCreateStatic.constprop.38+0x144>)
 8000a4a:	2300      	movs	r3, #0
 8000a4c:	6143      	str	r3, [r0, #20]
 8000a4e:	6205      	str	r5, [r0, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000a50:	2220      	movs	r2, #32
 8000a52:	2002      	movs	r0, #2
 8000a54:	54a0      	strb	r0, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000a56:	2501      	movs	r5, #1
 8000a58:	2022      	movs	r0, #34	; 0x22
 8000a5a:	5425      	strb	r5, [r4, r0]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a5c:	4d2e      	ldr	r5, [pc, #184]	; (8000b18 <chThdCreateStatic.constprop.38+0x148>)
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000a5e:	2121      	movs	r1, #33	; 0x21
 8000a60:	5463      	strb	r3, [r4, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000a62:	63e3      	str	r3, [r4, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8000a64:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8000a66:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8000a68:	1c22      	adds	r2, r4, #0
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a6a:	696b      	ldr	r3, [r5, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8000a6c:	3228      	adds	r2, #40	; 0x28
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a6e:	6125      	str	r5, [r4, #16]
 8000a70:	611c      	str	r4, [r3, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000a72:	62a2      	str	r2, [r4, #40]	; 0x28
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8000a74:	3204      	adds	r2, #4
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000a76:	60a7      	str	r7, [r4, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a78:	6163      	str	r3, [r4, #20]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8000a7a:	61e6      	str	r6, [r4, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8000a7c:	6427      	str	r7, [r4, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000a7e:	62e2      	str	r2, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 8000a80:	6322      	str	r2, [r4, #48]	; 0x30
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000a82:	616c      	str	r4, [r5, #20]
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {

  chDbgCheckClassS();
 8000a84:	f000 fcbc 	bl	8001400 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000a88:	69a8      	ldr	r0, [r5, #24]
 8000a8a:	682e      	ldr	r6, [r5, #0]
 8000a8c:	6881      	ldr	r1, [r0, #8]
 8000a8e:	42ae      	cmp	r6, r5
 8000a90:	d002      	beq.n	8000a98 <chThdCreateStatic.constprop.38+0xc8>
 8000a92:	68b3      	ldr	r3, [r6, #8]
 8000a94:	4299      	cmp	r1, r3
 8000a96:	d330      	bcc.n	8000afa <chThdCreateStatic.constprop.38+0x12a>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000a98:	2200      	movs	r2, #0
 8000a9a:	6262      	str	r2, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000a9c:	428f      	cmp	r7, r1
 8000a9e:	d930      	bls.n	8000b02 <chThdCreateStatic.constprop.38+0x132>
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000aa0:	f000 fbee 	bl	8001280 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000aa4:	2620      	movs	r6, #32
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000aa6:	1c07      	adds	r7, r0, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000aa8:	2001      	movs	r0, #1
 8000aaa:	55a0      	strb	r0, [r4, r6]
    chSysSwitch(ntp, otp);
 8000aac:	1c38      	adds	r0, r7, #0
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8000aae:	61ac      	str	r4, [r5, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000ab0:	f000 fdc6 	bl	8001640 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000ab4:	f3ef 8109 	mrs	r1, PSP
 8000ab8:	69fb      	ldr	r3, [r7, #28]
 8000aba:	3924      	subs	r1, #36	; 0x24
 8000abc:	428b      	cmp	r3, r1
 8000abe:	d818      	bhi.n	8000af2 <chThdCreateStatic.constprop.38+0x122>
 8000ac0:	1c20      	adds	r0, r4, #0
 8000ac2:	1c39      	adds	r1, r7, #0
 8000ac4:	f7ff fb84 	bl	80001d0 <_port_switch>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000ac8:	f7ff fe0a 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000acc:	682f      	ldr	r7, [r5, #0]
 8000ace:	42af      	cmp	r7, r5
 8000ad0:	d004      	beq.n	8000adc <chThdCreateStatic.constprop.38+0x10c>
 8000ad2:	69aa      	ldr	r2, [r5, #24]
 8000ad4:	68be      	ldr	r6, [r7, #8]
 8000ad6:	6890      	ldr	r0, [r2, #8]
 8000ad8:	42b0      	cmp	r0, r6
 8000ada:	d316      	bcc.n	8000b0a <chThdCreateStatic.constprop.38+0x13a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000adc:	b662      	cpsie	i
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
  chSysUnlock();

  return tp;
}
 8000ade:	1c20      	adds	r0, r4, #0
 8000ae0:	bc0c      	pop	{r2, r3}
 8000ae2:	4690      	mov	r8, r2
 8000ae4:	4699      	mov	r9, r3
 8000ae6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ae8:	b672      	cpsid	i
 8000aea:	4d0c      	ldr	r5, [pc, #48]	; (8000b1c <chThdCreateStatic.constprop.38+0x14c>)
 8000aec:	4c0a      	ldr	r4, [pc, #40]	; (8000b18 <chThdCreateStatic.constprop.38+0x148>)
 8000aee:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000af0:	e7fe      	b.n	8000af0 <chThdCreateStatic.constprop.38+0x120>
 8000af2:	b672      	cpsid	i
 8000af4:	4c0a      	ldr	r4, [pc, #40]	; (8000b20 <chThdCreateStatic.constprop.38+0x150>)
 8000af6:	62ec      	str	r4, [r5, #44]	; 0x2c
 8000af8:	e7fe      	b.n	8000af8 <chThdCreateStatic.constprop.38+0x128>
 8000afa:	b672      	cpsid	i
 8000afc:	4b09      	ldr	r3, [pc, #36]	; (8000b24 <chThdCreateStatic.constprop.38+0x154>)
 8000afe:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000b00:	e7fe      	b.n	8000b00 <chThdCreateStatic.constprop.38+0x130>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
 8000b02:	1c20      	adds	r0, r4, #0
 8000b04:	f000 fbbc 	bl	8001280 <chSchReadyI>
 8000b08:	e7de      	b.n	8000ac8 <chThdCreateStatic.constprop.38+0xf8>
 8000b0a:	b672      	cpsid	i
 8000b0c:	4906      	ldr	r1, [pc, #24]	; (8000b28 <chThdCreateStatic.constprop.38+0x158>)
 8000b0e:	62e9      	str	r1, [r5, #44]	; 0x2c
 8000b10:	e7fe      	b.n	8000b10 <chThdCreateStatic.constprop.38+0x140>
 8000b12:	46c0      	nop			; (mov r8, r8)
 8000b14:	080001f1 	.word	0x080001f1
 8000b18:	20001118 	.word	0x20001118
 8000b1c:	08002620 	.word	0x08002620
 8000b20:	080026e8 	.word	0x080026e8
 8000b24:	08002630 	.word	0x08002630
 8000b28:	08002730 	.word	0x08002730
 8000b2c:	46c0      	nop			; (mov r8, r8)
 8000b2e:	46c0      	nop			; (mov r8, r8)

08000b30 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8000b30:	b510      	push	{r4, lr}
 8000b32:	1c04      	adds	r4, r0, #0
 8000b34:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000b36:	f7ff fdeb 	bl	8000710 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();
 8000b3a:	f000 fb91 	bl	8001260 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000b3e:	4910      	ldr	r1, [pc, #64]	; (8000b80 <chCoreAlloc+0x50>)
 8000b40:	4810      	ldr	r0, [pc, #64]	; (8000b84 <chCoreAlloc+0x54>)
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000b42:	1de2      	adds	r2, r4, #7
 8000b44:	2307      	movs	r3, #7
 8000b46:	439a      	bics	r2, r3
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000b48:	6804      	ldr	r4, [r0, #0]
 8000b4a:	680b      	ldr	r3, [r1, #0]
 8000b4c:	1b19      	subs	r1, r3, r4
 8000b4e:	428a      	cmp	r2, r1
 8000b50:	d813      	bhi.n	8000b7a <chCoreAlloc+0x4a>
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8000b52:	18a2      	adds	r2, r4, r2
 8000b54:	6002      	str	r2, [r0, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000b56:	f7ff fdc3 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000b5a:	480b      	ldr	r0, [pc, #44]	; (8000b88 <chCoreAlloc+0x58>)
 8000b5c:	6803      	ldr	r3, [r0, #0]
 8000b5e:	4283      	cmp	r3, r0
 8000b60:	d004      	beq.n	8000b6c <chCoreAlloc+0x3c>
 8000b62:	6981      	ldr	r1, [r0, #24]
 8000b64:	689a      	ldr	r2, [r3, #8]
 8000b66:	6889      	ldr	r1, [r1, #8]
 8000b68:	4291      	cmp	r1, r2
 8000b6a:	d302      	bcc.n	8000b72 <chCoreAlloc+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b6c:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8000b6e:	1c20      	adds	r0, r4, #0
 8000b70:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b72:	b672      	cpsid	i
 8000b74:	4c05      	ldr	r4, [pc, #20]	; (8000b8c <chCoreAlloc+0x5c>)
 8000b76:	62c4      	str	r4, [r0, #44]	; 0x2c
 8000b78:	e7fe      	b.n	8000b78 <chCoreAlloc+0x48>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8000b7a:	2400      	movs	r4, #0
 8000b7c:	e7eb      	b.n	8000b56 <chCoreAlloc+0x26>
 8000b7e:	46c0      	nop			; (mov r8, r8)
 8000b80:	20000a00 	.word	0x20000a00
 8000b84:	20001110 	.word	0x20001110
 8000b88:	20001118 	.word	0x20001118
 8000b8c:	08002700 	.word	0x08002700

08000b90 <sdStart.constprop.10>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8000b90:	b538      	push	{r3, r4, r5, lr}
 8000b92:	1c04      	adds	r4, r0, #0
 8000b94:	b672      	cpsid	i

  osalDbgCheck(sdp != NULL);
 8000b96:	2800      	cmp	r0, #0
 8000b98:	d03c      	beq.n	8000c14 <sdStart.constprop.10+0x84>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000b9a:	f7ff fdb9 	bl	8000710 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8000b9e:	7a23      	ldrb	r3, [r4, #8]
 8000ba0:	1e5a      	subs	r2, r3, #1
 8000ba2:	2a01      	cmp	r2, #1
 8000ba4:	d904      	bls.n	8000bb0 <sdStart.constprop.10+0x20>
 8000ba6:	b672      	cpsid	i
 8000ba8:	4c22      	ldr	r4, [pc, #136]	; (8000c34 <sdStart.constprop.10+0xa4>)
 8000baa:	4b23      	ldr	r3, [pc, #140]	; (8000c38 <sdStart.constprop.10+0xa8>)
 8000bac:	62dc      	str	r4, [r3, #44]	; 0x2c
 8000bae:	e7fe      	b.n	8000bae <sdStart.constprop.10+0x1e>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000bb0:	2b01      	cmp	r3, #1
 8000bb2:	d022      	beq.n	8000bfa <sdStart.constprop.10+0x6a>
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000bb4:	21b6      	movs	r1, #182	; 0xb6
 8000bb6:	008b      	lsls	r3, r1, #2
 8000bb8:	2296      	movs	r2, #150	; 0x96
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000bba:	20b5      	movs	r0, #181	; 0xb5
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000bbc:	0191      	lsls	r1, r2, #6
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000bbe:	0085      	lsls	r5, r0, #2
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000bc0:	58e0      	ldr	r0, [r4, r3]
 8000bc2:	f7ff fb2d 	bl	8000220 <__aeabi_uidiv>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000bc6:	5965      	ldr	r5, [r4, r5]
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000bc8:	4b1c      	ldr	r3, [pc, #112]	; (8000c3c <sdStart.constprop.10+0xac>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000bca:	60e8      	str	r0, [r5, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000bcc:	481c      	ldr	r0, [pc, #112]	; (8000c40 <sdStart.constprop.10+0xb0>)
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000bce:	2201      	movs	r2, #1
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000bd0:	6068      	str	r0, [r5, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000bd2:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000bd4:	4250      	negs	r0, r2
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000bd6:	60a9      	str	r1, [r5, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000bd8:	602b      	str	r3, [r5, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000bda:	6228      	str	r0, [r5, #32]
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8000bdc:	2502      	movs	r5, #2
 8000bde:	7225      	strb	r5, [r4, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000be0:	f7ff fd7e 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000be4:	4c14      	ldr	r4, [pc, #80]	; (8000c38 <sdStart.constprop.10+0xa8>)
 8000be6:	6823      	ldr	r3, [r4, #0]
 8000be8:	42a3      	cmp	r3, r4
 8000bea:	d004      	beq.n	8000bf6 <sdStart.constprop.10+0x66>
 8000bec:	69a1      	ldr	r1, [r4, #24]
 8000bee:	689a      	ldr	r2, [r3, #8]
 8000bf0:	6888      	ldr	r0, [r1, #8]
 8000bf2:	4290      	cmp	r0, r2
 8000bf4:	d312      	bcc.n	8000c1c <sdStart.constprop.10+0x8c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000bf6:	b662      	cpsie	i
  osalSysUnlock();
}
 8000bf8:	bd38      	pop	{r3, r4, r5, pc}
  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8000bfa:	4812      	ldr	r0, [pc, #72]	; (8000c44 <sdStart.constprop.10+0xb4>)
 8000bfc:	4284      	cmp	r4, r0
 8000bfe:	d011      	beq.n	8000c24 <sdStart.constprop.10+0x94>
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8000c00:	4911      	ldr	r1, [pc, #68]	; (8000c48 <sdStart.constprop.10+0xb8>)
 8000c02:	428c      	cmp	r4, r1
 8000c04:	d1d6      	bne.n	8000bb4 <sdStart.constprop.10+0x24>
      rccEnableUSART2(FALSE);
 8000c06:	4d11      	ldr	r5, [pc, #68]	; (8000c4c <sdStart.constprop.10+0xbc>)
 8000c08:	2280      	movs	r2, #128	; 0x80
 8000c0a:	69eb      	ldr	r3, [r5, #28]
 8000c0c:	0290      	lsls	r0, r2, #10
 8000c0e:	4318      	orrs	r0, r3
 8000c10:	61e8      	str	r0, [r5, #28]
 8000c12:	e7cf      	b.n	8000bb4 <sdStart.constprop.10+0x24>
 8000c14:	4907      	ldr	r1, [pc, #28]	; (8000c34 <sdStart.constprop.10+0xa4>)
 8000c16:	4808      	ldr	r0, [pc, #32]	; (8000c38 <sdStart.constprop.10+0xa8>)
 8000c18:	62c1      	str	r1, [r0, #44]	; 0x2c
 8000c1a:	e7fe      	b.n	8000c1a <sdStart.constprop.10+0x8a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c1c:	b672      	cpsid	i
 8000c1e:	4d0c      	ldr	r5, [pc, #48]	; (8000c50 <sdStart.constprop.10+0xc0>)
 8000c20:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000c22:	e7fe      	b.n	8000c22 <sdStart.constprop.10+0x92>
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 8000c24:	4d09      	ldr	r5, [pc, #36]	; (8000c4c <sdStart.constprop.10+0xbc>)
 8000c26:	2380      	movs	r3, #128	; 0x80
 8000c28:	69a9      	ldr	r1, [r5, #24]
 8000c2a:	01da      	lsls	r2, r3, #7
 8000c2c:	430a      	orrs	r2, r1
 8000c2e:	61aa      	str	r2, [r5, #24]
 8000c30:	e7c0      	b.n	8000bb4 <sdStart.constprop.10+0x24>
 8000c32:	46c0      	nop			; (mov r8, r8)
 8000c34:	08002610 	.word	0x08002610
 8000c38:	20001118 	.word	0x20001118
 8000c3c:	0000012d 	.word	0x0000012d
 8000c40:	00004040 	.word	0x00004040
 8000c44:	20000b58 	.word	0x20000b58
 8000c48:	20000e34 	.word	0x20000e34
 8000c4c:	40021000 	.word	0x40021000
 8000c50:	08002600 	.word	0x08002600
 8000c54:	46c0      	nop			; (mov r8, r8)
 8000c56:	46c0      	nop			; (mov r8, r8)
 8000c58:	46c0      	nop			; (mov r8, r8)
 8000c5a:	46c0      	nop			; (mov r8, r8)
 8000c5c:	46c0      	nop			; (mov r8, r8)
 8000c5e:	46c0      	nop			; (mov r8, r8)

08000c60 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000c60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000c62:	4647      	mov	r7, r8
 8000c64:	b480      	push	{r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000c66:	4825      	ldr	r0, [pc, #148]	; (8000cfc <__init_ram_areas+0x9c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000c68:	2380      	movs	r3, #128	; 0x80
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000c6a:	4684      	mov	ip, r0
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000c6c:	4698      	mov	r8, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8000c6e:	2400      	movs	r4, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000c70:	44e0      	add	r8, ip
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8000c72:	4662      	mov	r2, ip
    uint32_t *p = rap->init_area;
 8000c74:	6856      	ldr	r6, [r2, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000c76:	6895      	ldr	r5, [r2, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8000c78:	6811      	ldr	r1, [r2, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000c7a:	42ae      	cmp	r6, r5
 8000c7c:	d220      	bcs.n	8000cc0 <__init_ram_areas+0x60>
 8000c7e:	43f7      	mvns	r7, r6
 8000c80:	19e8      	adds	r0, r5, r7
      *p = *tp;
 8000c82:	1c0a      	adds	r2, r1, #0
 8000c84:	0743      	lsls	r3, r0, #29
 8000c86:	ca01      	ldmia	r2!, {r0}
 8000c88:	0fdf      	lsrs	r7, r3, #31
 8000c8a:	1c33      	adds	r3, r6, #0
 8000c8c:	c301      	stmia	r3!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000c8e:	42ab      	cmp	r3, r5
 8000c90:	d210      	bcs.n	8000cb4 <__init_ram_areas+0x54>
 8000c92:	2f00      	cmp	r7, #0
 8000c94:	d004      	beq.n	8000ca0 <__init_ram_areas+0x40>
      *p = *tp;
 8000c96:	6849      	ldr	r1, [r1, #4]
 8000c98:	3204      	adds	r2, #4
 8000c9a:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000c9c:	42ab      	cmp	r3, r5
 8000c9e:	d209      	bcs.n	8000cb4 <__init_ram_areas+0x54>
      *p = *tp;
 8000ca0:	1c10      	adds	r0, r2, #0
 8000ca2:	c880      	ldmia	r0!, {r7}
 8000ca4:	1c19      	adds	r1, r3, #0
 8000ca6:	c180      	stmia	r1!, {r7}
 8000ca8:	6852      	ldr	r2, [r2, #4]
 8000caa:	605a      	str	r2, [r3, #4]
      p++;
 8000cac:	1d0b      	adds	r3, r1, #4
 8000cae:	1d02      	adds	r2, r0, #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000cb0:	42ab      	cmp	r3, r5
 8000cb2:	d3f5      	bcc.n	8000ca0 <__init_ram_areas+0x40>
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000cb4:	43f3      	mvns	r3, r6
 8000cb6:	195d      	adds	r5, r3, r5
 8000cb8:	08a8      	lsrs	r0, r5, #2
 8000cba:	3001      	adds	r0, #1
 8000cbc:	0087      	lsls	r7, r0, #2
 8000cbe:	19f6      	adds	r6, r6, r7
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000cc0:	4661      	mov	r1, ip
 8000cc2:	68cd      	ldr	r5, [r1, #12]
 8000cc4:	42ae      	cmp	r6, r5
 8000cc6:	d211      	bcs.n	8000cec <__init_ram_areas+0x8c>
 8000cc8:	43f2      	mvns	r2, r6
 8000cca:	18ab      	adds	r3, r5, r2
 8000ccc:	0758      	lsls	r0, r3, #29
      *p = 0;
 8000cce:	c610      	stmia	r6!, {r4}
 8000cd0:	0fc7      	lsrs	r7, r0, #31
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000cd2:	42ae      	cmp	r6, r5
 8000cd4:	d20a      	bcs.n	8000cec <__init_ram_areas+0x8c>
 8000cd6:	2f00      	cmp	r7, #0
 8000cd8:	d002      	beq.n	8000ce0 <__init_ram_areas+0x80>
      *p = 0;
 8000cda:	c610      	stmia	r6!, {r4}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000cdc:	42ae      	cmp	r6, r5
 8000cde:	d205      	bcs.n	8000cec <__init_ram_areas+0x8c>
      *p = 0;
 8000ce0:	1c31      	adds	r1, r6, #0
 8000ce2:	c110      	stmia	r1!, {r4}
 8000ce4:	6074      	str	r4, [r6, #4]
      p++;
 8000ce6:	1d0e      	adds	r6, r1, #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000ce8:	42ae      	cmp	r6, r5
 8000cea:	d3f9      	bcc.n	8000ce0 <__init_ram_areas+0x80>
      *p = 0;
      p++;
    }
    rap++;
 8000cec:	2510      	movs	r5, #16
 8000cee:	44ac      	add	ip, r5
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000cf0:	45c4      	cmp	ip, r8
 8000cf2:	d3be      	bcc.n	8000c72 <__init_ram_areas+0x12>
#endif
}
 8000cf4:	bc04      	pop	{r2}
 8000cf6:	4690      	mov	r8, r2
 8000cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cfa:	46c0      	nop			; (mov r8, r8)
 8000cfc:	08002640 	.word	0x08002640

08000d00 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8000d00:	e7fe      	b.n	8000d00 <__default_exit>
 8000d02:	46c0      	nop			; (mov r8, r8)
 8000d04:	46c0      	nop			; (mov r8, r8)
 8000d06:	46c0      	nop			; (mov r8, r8)
 8000d08:	46c0      	nop			; (mov r8, r8)
 8000d0a:	46c0      	nop			; (mov r8, r8)
 8000d0c:	46c0      	nop			; (mov r8, r8)
 8000d0e:	46c0      	nop			; (mov r8, r8)

08000d10 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000d10:	4770      	bx	lr
 8000d12:	46c0      	nop			; (mov r8, r8)
 8000d14:	46c0      	nop			; (mov r8, r8)
 8000d16:	46c0      	nop			; (mov r8, r8)
 8000d18:	46c0      	nop			; (mov r8, r8)
 8000d1a:	46c0      	nop			; (mov r8, r8)
 8000d1c:	46c0      	nop			; (mov r8, r8)
 8000d1e:	46c0      	nop			; (mov r8, r8)

08000d20 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000d20:	4770      	bx	lr
 8000d22:	46c0      	nop			; (mov r8, r8)
 8000d24:	46c0      	nop			; (mov r8, r8)
 8000d26:	46c0      	nop			; (mov r8, r8)
 8000d28:	46c0      	nop			; (mov r8, r8)
 8000d2a:	46c0      	nop			; (mov r8, r8)
 8000d2c:	46c0      	nop			; (mov r8, r8)
 8000d2e:	46c0      	nop			; (mov r8, r8)

08000d30 <stSetAlarm.4275>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000d30:	2380      	movs	r3, #128	; 0x80
 8000d32:	05db      	lsls	r3, r3, #23
 8000d34:	68da      	ldr	r2, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000d36:	0791      	lsls	r1, r2, #30
 8000d38:	d501      	bpl.n	8000d3e <stSetAlarm.4275+0xe>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000d3a:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
 8000d3c:	4770      	bx	lr
 8000d3e:	b672      	cpsid	i
 8000d40:	4801      	ldr	r0, [pc, #4]	; (8000d48 <stSetAlarm.4275+0x18>)
 8000d42:	4902      	ldr	r1, [pc, #8]	; (8000d4c <stSetAlarm.4275+0x1c>)
 8000d44:	62c8      	str	r0, [r1, #44]	; 0x2c
 8000d46:	e7fe      	b.n	8000d46 <stSetAlarm.4275+0x16>
 8000d48:	08002890 	.word	0x08002890
 8000d4c:	20001118 	.word	0x20001118

08000d50 <long_to_string_with_divisor.9101.constprop.5.4284>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8000d50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d52:	4657      	mov	r7, sl
 8000d54:	464e      	mov	r6, r9
 8000d56:	4645      	mov	r5, r8
 8000d58:	b4e0      	push	{r5, r6, r7}
 8000d5a:	1c0e      	adds	r6, r1, #0
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8000d5c:	210b      	movs	r1, #11
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8000d5e:	4681      	mov	r9, r0
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8000d60:	468a      	mov	sl, r1
 8000d62:	44ca      	add	sl, r9
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8000d64:	4690      	mov	r8, r2
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8000d66:	1c37      	adds	r7, r6, #0
 8000d68:	4654      	mov	r4, sl
  do {
    i = (int)(l % radix);
 8000d6a:	1c30      	adds	r0, r6, #0
 8000d6c:	4641      	mov	r1, r8
 8000d6e:	f7ff fa9b 	bl	80002a8 <__aeabi_uidivmod>
    i += '0';
 8000d72:	1c0b      	adds	r3, r1, #0
 8000d74:	3330      	adds	r3, #48	; 0x30
    if (i > '9')
 8000d76:	2b39      	cmp	r3, #57	; 0x39
 8000d78:	dd00      	ble.n	8000d7c <long_to_string_with_divisor.9101.constprop.5.4284+0x2c>
      i += 'A' - '0' - 10;
 8000d7a:	3307      	adds	r3, #7
    *--q = i;
 8000d7c:	b2dd      	uxtb	r5, r3
 8000d7e:	3c01      	subs	r4, #1
    l /= radix;
 8000d80:	1c30      	adds	r0, r6, #0
 8000d82:	4641      	mov	r1, r8
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8000d84:	7025      	strb	r5, [r4, #0]
    l /= radix;
 8000d86:	f7ff fa4b 	bl	8000220 <__aeabi_uidiv>
  } while ((ll /= radix) != 0);
 8000d8a:	4641      	mov	r1, r8
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8000d8c:	1c06      	adds	r6, r0, #0
  } while ((ll /= radix) != 0);
 8000d8e:	1c38      	adds	r0, r7, #0
 8000d90:	f7ff fa46 	bl	8000220 <__aeabi_uidiv>
 8000d94:	1e07      	subs	r7, r0, #0
 8000d96:	d1e8      	bne.n	8000d6a <long_to_string_with_divisor.9101.constprop.5.4284+0x1a>

  i = (int)(p + MAX_FILLER - q);
 8000d98:	4652      	mov	r2, sl
 8000d9a:	1b10      	subs	r0, r2, r4
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8000d9c:	4649      	mov	r1, r9
 8000d9e:	1c63      	adds	r3, r4, #1
 8000da0:	1808      	adds	r0, r1, r0
 8000da2:	43cc      	mvns	r4, r1
 8000da4:	1906      	adds	r6, r0, r4
 8000da6:	07f4      	lsls	r4, r6, #31
 8000da8:	d50b      	bpl.n	8000dc2 <long_to_string_with_divisor.9101.constprop.5.4284+0x72>
    l /= radix;
  } while ((ll /= radix) != 0);

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8000daa:	700d      	strb	r5, [r1, #0]
 8000dac:	2501      	movs	r5, #1
 8000dae:	44a9      	add	r9, r5
 8000db0:	781d      	ldrb	r5, [r3, #0]
 8000db2:	3301      	adds	r3, #1
 8000db4:	e005      	b.n	8000dc2 <long_to_string_with_divisor.9101.constprop.5.4284+0x72>
 8000db6:	7819      	ldrb	r1, [r3, #0]
 8000db8:	3601      	adds	r6, #1
 8000dba:	7051      	strb	r1, [r2, #1]
 8000dbc:	785d      	ldrb	r5, [r3, #1]
 8000dbe:	46b1      	mov	r9, r6
 8000dc0:	3302      	adds	r3, #2
 8000dc2:	464e      	mov	r6, r9
 8000dc4:	464a      	mov	r2, r9
 8000dc6:	3601      	adds	r6, #1
 8000dc8:	7015      	strb	r5, [r2, #0]
  while (--i);
 8000dca:	42b0      	cmp	r0, r6
 8000dcc:	d1f3      	bne.n	8000db6 <long_to_string_with_divisor.9101.constprop.5.4284+0x66>

  return p;
}
 8000dce:	bc1c      	pop	{r2, r3, r4}
 8000dd0:	4690      	mov	r8, r2
 8000dd2:	4699      	mov	r9, r3
 8000dd4:	46a2      	mov	sl, r4
 8000dd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000dd8:	46c0      	nop			; (mov r8, r8)
 8000dda:	46c0      	nop			; (mov r8, r8)
 8000ddc:	46c0      	nop			; (mov r8, r8)
 8000dde:	46c0      	nop			; (mov r8, r8)

08000de0 <notify2.9008>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000de0:	4b02      	ldr	r3, [pc, #8]	; (8000dec <notify2.9008+0xc>)
 8000de2:	2280      	movs	r2, #128	; 0x80
 8000de4:	6819      	ldr	r1, [r3, #0]
 8000de6:	430a      	orrs	r2, r1
 8000de8:	601a      	str	r2, [r3, #0]
}
 8000dea:	4770      	bx	lr
 8000dec:	40004400 	.word	0x40004400

08000df0 <notify1.9011>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000df0:	4b02      	ldr	r3, [pc, #8]	; (8000dfc <notify1.9011+0xc>)
 8000df2:	2280      	movs	r2, #128	; 0x80
 8000df4:	6819      	ldr	r1, [r3, #0]
 8000df6:	430a      	orrs	r2, r1
 8000df8:	601a      	str	r2, [r3, #0]
}
 8000dfa:	4770      	bx	lr
 8000dfc:	40013800 	.word	0x40013800

08000e00 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e00:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000e04:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000e06:	f383 8809 	msr	PSP, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e0a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8000e0c:	4770      	bx	lr
 8000e0e:	46c0      	nop			; (mov r8, r8)

08000e10 <_idle_thread.4252>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000e10:	e7fe      	b.n	8000e10 <_idle_thread.4252>
 8000e12:	46c0      	nop			; (mov r8, r8)
 8000e14:	46c0      	nop			; (mov r8, r8)
 8000e16:	46c0      	nop			; (mov r8, r8)
 8000e18:	46c0      	nop			; (mov r8, r8)
 8000e1a:	46c0      	nop			; (mov r8, r8)
 8000e1c:	46c0      	nop			; (mov r8, r8)
 8000e1e:	46c0      	nop			; (mov r8, r8)

08000e20 <chprintf.constprop.3>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000e20:	b40e      	push	{r1, r2, r3}
 8000e22:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e24:	465f      	mov	r7, fp
 8000e26:	464d      	mov	r5, r9
 8000e28:	4644      	mov	r4, r8
 8000e2a:	4656      	mov	r6, sl
 8000e2c:	b4f0      	push	{r4, r5, r6, r7}
 8000e2e:	b08a      	sub	sp, #40	; 0x28
 8000e30:	ab13      	add	r3, sp, #76	; 0x4c
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8000e32:	4669      	mov	r1, sp
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000e34:	cb10      	ldmia	r3!, {r4}
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8000e36:	a807      	add	r0, sp, #28
 8000e38:	311d      	adds	r1, #29
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8000e3a:	2200      	movs	r2, #0
 8000e3c:	1a0d      	subs	r5, r1, r0
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000e3e:	9306      	str	r3, [sp, #24]
 8000e40:	1c1f      	adds	r7, r3, #0
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8000e42:	9203      	str	r2, [sp, #12]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8000e44:	9002      	str	r0, [sp, #8]
 8000e46:	9101      	str	r1, [sp, #4]
 8000e48:	9505      	str	r5, [sp, #20]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8000e4a:	7821      	ldrb	r1, [r4, #0]
 8000e4c:	1c65      	adds	r5, r4, #1
    if (c == 0)
 8000e4e:	2900      	cmp	r1, #0
 8000e50:	d00d      	beq.n	8000e6e <chprintf.constprop.3+0x4e>
      return n;
    if (c != '%') {
 8000e52:	2925      	cmp	r1, #37	; 0x25
 8000e54:	d016      	beq.n	8000e84 <chprintf.constprop.3+0x64>
      streamPut(chp, (uint8_t)c);
 8000e56:	48c8      	ldr	r0, [pc, #800]	; (8001178 <chprintf.constprop.3+0x358>)
 8000e58:	6804      	ldr	r4, [r0, #0]
 8000e5a:	68a2      	ldr	r2, [r4, #8]
 8000e5c:	4790      	blx	r2
      n++;
 8000e5e:	9903      	ldr	r1, [sp, #12]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8000e60:	1c2c      	adds	r4, r5, #0
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8000e62:	3101      	adds	r1, #1
 8000e64:	9103      	str	r1, [sp, #12]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8000e66:	7821      	ldrb	r1, [r4, #0]
 8000e68:	1c65      	adds	r5, r4, #1
    if (c == 0)
 8000e6a:	2900      	cmp	r1, #0
 8000e6c:	d1f1      	bne.n	8000e52 <chprintf.constprop.3+0x32>
  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8000e6e:	9803      	ldr	r0, [sp, #12]
 8000e70:	b00a      	add	sp, #40	; 0x28
 8000e72:	bc3c      	pop	{r2, r3, r4, r5}
 8000e74:	4690      	mov	r8, r2
 8000e76:	4699      	mov	r9, r3
 8000e78:	46a2      	mov	sl, r4
 8000e7a:	46ab      	mov	fp, r5
 8000e7c:	bcf0      	pop	{r4, r5, r6, r7}
 8000e7e:	bc08      	pop	{r3}
 8000e80:	b003      	add	sp, #12
 8000e82:	4718      	bx	r3
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8000e84:	7863      	ldrb	r3, [r4, #1]
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8000e86:	2600      	movs	r6, #0
 8000e88:	46b1      	mov	r9, r6
    if (*fmt == '-') {
 8000e8a:	2b2d      	cmp	r3, #45	; 0x2d
 8000e8c:	d100      	bne.n	8000e90 <chprintf.constprop.3+0x70>
 8000e8e:	e151      	b.n	8001134 <chprintf.constprop.3+0x314>
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8000e90:	2220      	movs	r2, #32
 8000e92:	4690      	mov	r8, r2
    if (*fmt == '0') {
 8000e94:	2b30      	cmp	r3, #48	; 0x30
 8000e96:	d100      	bne.n	8000e9a <chprintf.constprop.3+0x7a>
 8000e98:	e147      	b.n	800112a <chprintf.constprop.3+0x30a>
      fmt++;
      filler = '0';
 8000e9a:	1c2c      	adds	r4, r5, #0
    }
    width = 0;
 8000e9c:	2600      	movs	r6, #0
 8000e9e:	e006      	b.n	8000eae <chprintf.constprop.3+0x8e>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8000ea0:	7838      	ldrb	r0, [r7, #0]
 8000ea2:	3704      	adds	r7, #4
      else
        break;
      width = width * 10 + c;
 8000ea4:	00b2      	lsls	r2, r6, #2
 8000ea6:	1996      	adds	r6, r2, r6
 8000ea8:	0073      	lsls	r3, r6, #1
 8000eaa:	181e      	adds	r6, r3, r0
 8000eac:	7823      	ldrb	r3, [r4, #0]
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8000eae:	1c19      	adds	r1, r3, #0
 8000eb0:	3930      	subs	r1, #48	; 0x30
 8000eb2:	b2c8      	uxtb	r0, r1
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8000eb4:	3401      	adds	r4, #1
      if (c >= '0' && c <= '9')
 8000eb6:	2809      	cmp	r0, #9
 8000eb8:	d9f4      	bls.n	8000ea4 <chprintf.constprop.3+0x84>
        c -= '0';
      else if (c == '*')
 8000eba:	2b2a      	cmp	r3, #42	; 0x2a
 8000ebc:	d0f0      	beq.n	8000ea0 <chprintf.constprop.3+0x80>
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
 8000ebe:	2100      	movs	r1, #0
    if (c == '.') {
 8000ec0:	2b2e      	cmp	r3, #46	; 0x2e
 8000ec2:	d100      	bne.n	8000ec6 <chprintf.constprop.3+0xa6>
 8000ec4:	e0c9      	b.n	800105a <chprintf.constprop.3+0x23a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8000ec6:	2b6c      	cmp	r3, #108	; 0x6c
 8000ec8:	d100      	bne.n	8000ecc <chprintf.constprop.3+0xac>
 8000eca:	e0d2      	b.n	8001072 <chprintf.constprop.3+0x252>
 8000ecc:	2b4c      	cmp	r3, #76	; 0x4c
 8000ece:	d100      	bne.n	8000ed2 <chprintf.constprop.3+0xb2>
 8000ed0:	e0cf      	b.n	8001072 <chprintf.constprop.3+0x252>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8000ed2:	1c18      	adds	r0, r3, #0
 8000ed4:	3844      	subs	r0, #68	; 0x44
 8000ed6:	b2c5      	uxtb	r5, r0
 8000ed8:	2d34      	cmp	r5, #52	; 0x34
 8000eda:	d800      	bhi.n	8000ede <chprintf.constprop.3+0xbe>
 8000edc:	e0d5      	b.n	800108a <chprintf.constprop.3+0x26a>
 8000ede:	9905      	ldr	r1, [sp, #20]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8000ee0:	466a      	mov	r2, sp
 8000ee2:	1c0d      	adds	r5, r1, #0
 8000ee4:	3d01      	subs	r5, #1
 8000ee6:	9504      	str	r5, [sp, #16]
 8000ee8:	7713      	strb	r3, [r2, #28]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8000eea:	ad07      	add	r5, sp, #28
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8000eec:	1a76      	subs	r6, r6, r1
 8000eee:	43f3      	mvns	r3, r6
 8000ef0:	17d9      	asrs	r1, r3, #31
 8000ef2:	400e      	ands	r6, r1
      width = 0;
    if (left_align == FALSE)
 8000ef4:	4648      	mov	r0, r9
 8000ef6:	46b3      	mov	fp, r6
 8000ef8:	2800      	cmp	r0, #0
 8000efa:	d140      	bne.n	8000f7e <chprintf.constprop.3+0x15e>
      width = -width;
 8000efc:	4276      	negs	r6, r6
 8000efe:	46b3      	mov	fp, r6
    if (width < 0) {
 8000f00:	2e00      	cmp	r6, #0
 8000f02:	d03c      	beq.n	8000f7e <chprintf.constprop.3+0x15e>
      if (*s == '-' && filler == '0') {
 8000f04:	782b      	ldrb	r3, [r5, #0]
 8000f06:	2b2d      	cmp	r3, #45	; 0x2d
 8000f08:	d100      	bne.n	8000f0c <chprintf.constprop.3+0xec>
 8000f0a:	e118      	b.n	800113e <chprintf.constprop.3+0x31e>
 8000f0c:	4e9a      	ldr	r6, [pc, #616]	; (8001178 <chprintf.constprop.3+0x358>)
 8000f0e:	465a      	mov	r2, fp
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000f10:	6833      	ldr	r3, [r6, #0]
 8000f12:	2001      	movs	r0, #1
 8000f14:	4390      	bics	r0, r2
 8000f16:	4641      	mov	r1, r8
 8000f18:	4682      	mov	sl, r0
 8000f1a:	689a      	ldr	r2, [r3, #8]
 8000f1c:	1c30      	adds	r0, r6, #0
 8000f1e:	4790      	blx	r2
        n++;
      } while (++width != 0);
 8000f20:	2101      	movs	r1, #1
 8000f22:	4689      	mov	r9, r1
 8000f24:	44d9      	add	r9, fp
 8000f26:	4648      	mov	r0, r9
 8000f28:	2800      	cmp	r0, #0
 8000f2a:	d022      	beq.n	8000f72 <chprintf.constprop.3+0x152>
 8000f2c:	4653      	mov	r3, sl
 8000f2e:	2b00      	cmp	r3, #0
 8000f30:	d009      	beq.n	8000f46 <chprintf.constprop.3+0x126>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000f32:	6832      	ldr	r2, [r6, #0]
 8000f34:	4641      	mov	r1, r8
 8000f36:	6893      	ldr	r3, [r2, #8]
 8000f38:	1c30      	adds	r0, r6, #0
 8000f3a:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8000f3c:	2101      	movs	r1, #1
 8000f3e:	4489      	add	r9, r1
 8000f40:	4648      	mov	r0, r9
 8000f42:	2800      	cmp	r0, #0
 8000f44:	d015      	beq.n	8000f72 <chprintf.constprop.3+0x152>
 8000f46:	4643      	mov	r3, r8
 8000f48:	46a2      	mov	sl, r4
 8000f4a:	46a8      	mov	r8, r5
 8000f4c:	464c      	mov	r4, r9
 8000f4e:	1c1d      	adds	r5, r3, #0
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000f50:	6832      	ldr	r2, [r6, #0]
 8000f52:	1c29      	adds	r1, r5, #0
 8000f54:	6893      	ldr	r3, [r2, #8]
 8000f56:	1c30      	adds	r0, r6, #0
 8000f58:	4798      	blx	r3
 8000f5a:	6831      	ldr	r1, [r6, #0]
 8000f5c:	1c30      	adds	r0, r6, #0
 8000f5e:	688a      	ldr	r2, [r1, #8]
        n++;
      } while (++width != 0);
 8000f60:	3402      	adds	r4, #2
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000f62:	1c29      	adds	r1, r5, #0
 8000f64:	4790      	blx	r2
        n++;
      } while (++width != 0);
 8000f66:	2c00      	cmp	r4, #0
 8000f68:	d1f2      	bne.n	8000f50 <chprintf.constprop.3+0x130>
 8000f6a:	1c2e      	adds	r6, r5, #0
 8000f6c:	4654      	mov	r4, sl
 8000f6e:	4645      	mov	r5, r8
 8000f70:	46b0      	mov	r8, r6
 8000f72:	9803      	ldr	r0, [sp, #12]
 8000f74:	465b      	mov	r3, fp
 8000f76:	1ac1      	subs	r1, r0, r3
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000f78:	2200      	movs	r2, #0
 8000f7a:	9103      	str	r1, [sp, #12]
 8000f7c:	4693      	mov	fp, r2
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8000f7e:	9e04      	ldr	r6, [sp, #16]
 8000f80:	2e00      	cmp	r6, #0
 8000f82:	db31      	blt.n	8000fe8 <chprintf.constprop.3+0x1c8>
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000f84:	1c30      	adds	r0, r6, #0
 8000f86:	3001      	adds	r0, #1
 8000f88:	4e7b      	ldr	r6, [pc, #492]	; (8001178 <chprintf.constprop.3+0x358>)
 8000f8a:	1943      	adds	r3, r0, r5
 8000f8c:	469a      	mov	sl, r3
 8000f8e:	43e9      	mvns	r1, r5
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8000f90:	6830      	ldr	r0, [r6, #0]
 8000f92:	4451      	add	r1, sl
 8000f94:	2201      	movs	r2, #1
 8000f96:	400a      	ands	r2, r1
 8000f98:	6883      	ldr	r3, [r0, #8]
 8000f9a:	7829      	ldrb	r1, [r5, #0]
 8000f9c:	1c30      	adds	r0, r6, #0
 8000f9e:	3501      	adds	r5, #1
 8000fa0:	4691      	mov	r9, r2
 8000fa2:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8000fa4:	4555      	cmp	r5, sl
 8000fa6:	d01a      	beq.n	8000fde <chprintf.constprop.3+0x1be>
 8000fa8:	4649      	mov	r1, r9
 8000faa:	2900      	cmp	r1, #0
 8000fac:	d007      	beq.n	8000fbe <chprintf.constprop.3+0x19e>
      streamPut(chp, (uint8_t)*s++);
 8000fae:	6832      	ldr	r2, [r6, #0]
 8000fb0:	7829      	ldrb	r1, [r5, #0]
 8000fb2:	6893      	ldr	r3, [r2, #8]
 8000fb4:	3501      	adds	r5, #1
 8000fb6:	1c30      	adds	r0, r6, #0
 8000fb8:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8000fba:	4555      	cmp	r5, sl
 8000fbc:	d00f      	beq.n	8000fde <chprintf.constprop.3+0x1be>
 8000fbe:	46a1      	mov	r9, r4
 8000fc0:	4654      	mov	r4, sl
      streamPut(chp, (uint8_t)*s++);
 8000fc2:	6830      	ldr	r0, [r6, #0]
 8000fc4:	7829      	ldrb	r1, [r5, #0]
 8000fc6:	6882      	ldr	r2, [r0, #8]
 8000fc8:	1c30      	adds	r0, r6, #0
 8000fca:	4790      	blx	r2
 8000fcc:	6833      	ldr	r3, [r6, #0]
 8000fce:	7869      	ldrb	r1, [r5, #1]
 8000fd0:	689a      	ldr	r2, [r3, #8]
 8000fd2:	3502      	adds	r5, #2
 8000fd4:	1c30      	adds	r0, r6, #0
 8000fd6:	4790      	blx	r2
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8000fd8:	42a5      	cmp	r5, r4
 8000fda:	d1f2      	bne.n	8000fc2 <chprintf.constprop.3+0x1a2>
 8000fdc:	464c      	mov	r4, r9
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000fde:	9d03      	ldr	r5, [sp, #12]
 8000fe0:	9e04      	ldr	r6, [sp, #16]
 8000fe2:	3501      	adds	r5, #1
 8000fe4:	19a9      	adds	r1, r5, r6
 8000fe6:	9103      	str	r1, [sp, #12]
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8000fe8:	4658      	mov	r0, fp
 8000fea:	2800      	cmp	r0, #0
 8000fec:	d100      	bne.n	8000ff0 <chprintf.constprop.3+0x1d0>
 8000fee:	e72c      	b.n	8000e4a <chprintf.constprop.3+0x2a>
 8000ff0:	4d61      	ldr	r5, [pc, #388]	; (8001178 <chprintf.constprop.3+0x358>)
 8000ff2:	465e      	mov	r6, fp
 8000ff4:	3e01      	subs	r6, #1
 8000ff6:	2301      	movs	r3, #1
      streamPut(chp, (uint8_t)filler);
 8000ff8:	682a      	ldr	r2, [r5, #0]
 8000ffa:	4033      	ands	r3, r6
 8000ffc:	469a      	mov	sl, r3
 8000ffe:	1c28      	adds	r0, r5, #0
 8001000:	6893      	ldr	r3, [r2, #8]
 8001002:	4641      	mov	r1, r8
 8001004:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001006:	2e00      	cmp	r6, #0
 8001008:	d01c      	beq.n	8001044 <chprintf.constprop.3+0x224>
 800100a:	4651      	mov	r1, sl
 800100c:	2900      	cmp	r1, #0
 800100e:	d008      	beq.n	8001022 <chprintf.constprop.3+0x202>
      streamPut(chp, (uint8_t)filler);
 8001010:	682e      	ldr	r6, [r5, #0]
 8001012:	1c28      	adds	r0, r5, #0
 8001014:	68b2      	ldr	r2, [r6, #8]
      n++;
      width--;
 8001016:	465e      	mov	r6, fp
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8001018:	4641      	mov	r1, r8
      n++;
      width--;
 800101a:	3e02      	subs	r6, #2
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 800101c:	4790      	blx	r2
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800101e:	2e00      	cmp	r6, #0
 8001020:	d010      	beq.n	8001044 <chprintf.constprop.3+0x224>
 8001022:	1c20      	adds	r0, r4, #0
 8001024:	4644      	mov	r4, r8
 8001026:	4680      	mov	r8, r0
      streamPut(chp, (uint8_t)filler);
 8001028:	682b      	ldr	r3, [r5, #0]
 800102a:	1c21      	adds	r1, r4, #0
 800102c:	689a      	ldr	r2, [r3, #8]
 800102e:	1c28      	adds	r0, r5, #0
 8001030:	4790      	blx	r2
 8001032:	6829      	ldr	r1, [r5, #0]
 8001034:	1c28      	adds	r0, r5, #0
 8001036:	688b      	ldr	r3, [r1, #8]
      n++;
      width--;
 8001038:	3e02      	subs	r6, #2
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 800103a:	1c21      	adds	r1, r4, #0
 800103c:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800103e:	2e00      	cmp	r6, #0
 8001040:	d1f2      	bne.n	8001028 <chprintf.constprop.3+0x208>
 8001042:	4644      	mov	r4, r8
 8001044:	9d03      	ldr	r5, [sp, #12]
 8001046:	1c2e      	adds	r6, r5, #0
 8001048:	445e      	add	r6, fp
 800104a:	9603      	str	r6, [sp, #12]
 800104c:	e6fd      	b.n	8000e4a <chprintf.constprop.3+0x2a>
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 800104e:	783a      	ldrb	r2, [r7, #0]
 8001050:	3704      	adds	r7, #4
        else
          break;
        precision *= 10;
 8001052:	008b      	lsls	r3, r1, #2
 8001054:	1859      	adds	r1, r3, r1
 8001056:	004d      	lsls	r5, r1, #1
        precision += c;
 8001058:	18a9      	adds	r1, r5, r2
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800105a:	7823      	ldrb	r3, [r4, #0]
 800105c:	3401      	adds	r4, #1
        if (c >= '0' && c <= '9')
 800105e:	1c1d      	adds	r5, r3, #0
 8001060:	3d30      	subs	r5, #48	; 0x30
 8001062:	b2ea      	uxtb	r2, r5
 8001064:	2a09      	cmp	r2, #9
 8001066:	d9f4      	bls.n	8001052 <chprintf.constprop.3+0x232>
          c -= '0';
        else if (c == '*')
 8001068:	2b2a      	cmp	r3, #42	; 0x2a
 800106a:	d0f0      	beq.n	800104e <chprintf.constprop.3+0x22e>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800106c:	2b6c      	cmp	r3, #108	; 0x6c
 800106e:	d000      	beq.n	8001072 <chprintf.constprop.3+0x252>
 8001070:	e72c      	b.n	8000ecc <chprintf.constprop.3+0xac>
      is_long = TRUE;
      if (*fmt)
 8001072:	7822      	ldrb	r2, [r4, #0]
 8001074:	2a00      	cmp	r2, #0
 8001076:	d100      	bne.n	800107a <chprintf.constprop.3+0x25a>
 8001078:	e72b      	b.n	8000ed2 <chprintf.constprop.3+0xb2>
        c = *fmt++;
 800107a:	1c13      	adds	r3, r2, #0
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800107c:	1c18      	adds	r0, r3, #0
 800107e:	3844      	subs	r0, #68	; 0x44
 8001080:	b2c5      	uxtb	r5, r0
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8001082:	3401      	adds	r4, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001084:	2d34      	cmp	r5, #52	; 0x34
 8001086:	d900      	bls.n	800108a <chprintf.constprop.3+0x26a>
 8001088:	e729      	b.n	8000ede <chprintf.constprop.3+0xbe>
 800108a:	483c      	ldr	r0, [pc, #240]	; (800117c <chprintf.constprop.3+0x35c>)
 800108c:	00aa      	lsls	r2, r5, #2
 800108e:	5885      	ldr	r5, [r0, r2]
 8001090:	46af      	mov	pc, r5
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001092:	683d      	ldr	r5, [r7, #0]
 8001094:	1d38      	adds	r0, r7, #4
 8001096:	2d00      	cmp	r5, #0
 8001098:	d06c      	beq.n	8001174 <chprintf.constprop.3+0x354>
        s = "(null)";
      if (precision == 0)
 800109a:	2900      	cmp	r1, #0
 800109c:	d061      	beq.n	8001162 <chprintf.constprop.3+0x342>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800109e:	782f      	ldrb	r7, [r5, #0]
 80010a0:	2f00      	cmp	r7, #0
 80010a2:	d071      	beq.n	8001188 <chprintf.constprop.3+0x368>
 80010a4:	43ef      	mvns	r7, r5
 80010a6:	2201      	movs	r2, #1
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80010a8:	1869      	adds	r1, r5, r1
 80010aa:	19cb      	adds	r3, r1, r7
 80010ac:	1c17      	adds	r7, r2, #0
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80010ae:	786a      	ldrb	r2, [r5, #1]
 80010b0:	401f      	ands	r7, r3
 80010b2:	1c6b      	adds	r3, r5, #1
 80010b4:	2a00      	cmp	r2, #0
 80010b6:	d00e      	beq.n	80010d6 <chprintf.constprop.3+0x2b6>
 80010b8:	428b      	cmp	r3, r1
 80010ba:	d00c      	beq.n	80010d6 <chprintf.constprop.3+0x2b6>
 80010bc:	2f00      	cmp	r7, #0
 80010be:	d002      	beq.n	80010c6 <chprintf.constprop.3+0x2a6>
 80010c0:	e005      	b.n	80010ce <chprintf.constprop.3+0x2ae>
 80010c2:	428b      	cmp	r3, r1
 80010c4:	d007      	beq.n	80010d6 <chprintf.constprop.3+0x2b6>
 80010c6:	3301      	adds	r3, #1
 80010c8:	781a      	ldrb	r2, [r3, #0]
 80010ca:	2a00      	cmp	r2, #0
 80010cc:	d003      	beq.n	80010d6 <chprintf.constprop.3+0x2b6>
 80010ce:	3301      	adds	r3, #1
 80010d0:	781f      	ldrb	r7, [r3, #0]
 80010d2:	2f00      	cmp	r7, #0
 80010d4:	d1f5      	bne.n	80010c2 <chprintf.constprop.3+0x2a2>
 80010d6:	1b59      	subs	r1, r3, r5
 80010d8:	1e4f      	subs	r7, r1, #1
 80010da:	9704      	str	r7, [sp, #16]
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80010dc:	1c07      	adds	r7, r0, #0
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80010de:	2020      	movs	r0, #32
 80010e0:	4680      	mov	r8, r0
 80010e2:	e703      	b.n	8000eec <chprintf.constprop.3+0xcc>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 80010e4:	683d      	ldr	r5, [r7, #0]
 80010e6:	4669      	mov	r1, sp
 80010e8:	770d      	strb	r5, [r1, #28]
 80010ea:	9905      	ldr	r1, [sp, #20]
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 80010ec:	2220      	movs	r2, #32
 80010ee:	1c0b      	adds	r3, r1, #0
 80010f0:	3b01      	subs	r3, #1
 80010f2:	9304      	str	r3, [sp, #16]
      *p++ = va_arg(ap, int);
 80010f4:	3704      	adds	r7, #4
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 80010f6:	4690      	mov	r8, r2
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80010f8:	ad07      	add	r5, sp, #28
 80010fa:	e6f7      	b.n	8000eec <chprintf.constprop.3+0xcc>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80010fc:	2210      	movs	r2, #16
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 80010fe:	6839      	ldr	r1, [r7, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001100:	a807      	add	r0, sp, #28
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 8001102:	3704      	adds	r7, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001104:	f7ff fe24 	bl	8000d50 <long_to_string_with_divisor.9101.constprop.5.4284>
 8001108:	9902      	ldr	r1, [sp, #8]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800110a:	ad07      	add	r5, sp, #28
 800110c:	1a41      	subs	r1, r0, r1
 800110e:	1e48      	subs	r0, r1, #1
 8001110:	9004      	str	r0, [sp, #16]
 8001112:	e6eb      	b.n	8000eec <chprintf.constprop.3+0xcc>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001114:	220a      	movs	r2, #10
 8001116:	e7f2      	b.n	80010fe <chprintf.constprop.3+0x2de>
 8001118:	2208      	movs	r2, #8
 800111a:	e7f0      	b.n	80010fe <chprintf.constprop.3+0x2de>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 800111c:	6839      	ldr	r1, [r7, #0]
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800111e:	a807      	add	r0, sp, #28
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 8001120:	3704      	adds	r7, #4
      else
        l = va_arg(ap, int);
      if (l < 0) {
 8001122:	2900      	cmp	r1, #0
 8001124:	db1f      	blt.n	8001166 <chprintf.constprop.3+0x346>
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001126:	220a      	movs	r2, #10
 8001128:	e7ec      	b.n	8001104 <chprintf.constprop.3+0x2e4>
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
 800112a:	2030      	movs	r0, #48	; 0x30
 800112c:	786b      	ldrb	r3, [r5, #1]
 800112e:	4680      	mov	r8, r0
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
 8001130:	3501      	adds	r5, #1
 8001132:	e6b2      	b.n	8000e9a <chprintf.constprop.3+0x7a>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
 8001134:	1ca5      	adds	r5, r4, #2
 8001136:	78a3      	ldrb	r3, [r4, #2]
      left_align = TRUE;
 8001138:	2401      	movs	r4, #1
 800113a:	46a1      	mov	r9, r4
 800113c:	e6a8      	b.n	8000e90 <chprintf.constprop.3+0x70>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 800113e:	4641      	mov	r1, r8
 8001140:	2930      	cmp	r1, #48	; 0x30
 8001142:	d000      	beq.n	8001146 <chprintf.constprop.3+0x326>
 8001144:	e6e2      	b.n	8000f0c <chprintf.constprop.3+0xec>
        streamPut(chp, (uint8_t)*s++);
 8001146:	4e0c      	ldr	r6, [pc, #48]	; (8001178 <chprintf.constprop.3+0x358>)
 8001148:	212d      	movs	r1, #45	; 0x2d
 800114a:	6830      	ldr	r0, [r6, #0]
 800114c:	3501      	adds	r5, #1
 800114e:	6882      	ldr	r2, [r0, #8]
 8001150:	1c30      	adds	r0, r6, #0
 8001152:	4790      	blx	r2
        n++;
 8001154:	9b03      	ldr	r3, [sp, #12]
 8001156:	9904      	ldr	r1, [sp, #16]
 8001158:	3301      	adds	r3, #1
 800115a:	3901      	subs	r1, #1
 800115c:	9303      	str	r3, [sp, #12]
 800115e:	9104      	str	r1, [sp, #16]
 8001160:	e6d5      	b.n	8000f0e <chprintf.constprop.3+0xee>
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
 8001162:	4907      	ldr	r1, [pc, #28]	; (8001180 <chprintf.constprop.3+0x360>)
 8001164:	e79b      	b.n	800109e <chprintf.constprop.3+0x27e>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8001166:	252d      	movs	r5, #45	; 0x2d
 8001168:	466b      	mov	r3, sp
 800116a:	771d      	strb	r5, [r3, #28]
        l = -l;
 800116c:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 800116e:	3001      	adds	r0, #1
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001170:	220a      	movs	r2, #10
 8001172:	e7c7      	b.n	8001104 <chprintf.constprop.3+0x2e4>
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
 8001174:	4d03      	ldr	r5, [pc, #12]	; (8001184 <chprintf.constprop.3+0x364>)
 8001176:	e790      	b.n	800109a <chprintf.constprop.3+0x27a>
 8001178:	20000b58 	.word	0x20000b58
 800117c:	08002760 	.word	0x08002760
 8001180:	00007fff 	.word	0x00007fff
 8001184:	080028a0 	.word	0x080028a0
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001188:	2301      	movs	r3, #1
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 800118a:	1c07      	adds	r7, r0, #0
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800118c:	425a      	negs	r2, r3
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800118e:	2020      	movs	r0, #32
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001190:	9204      	str	r2, [sp, #16]
 8001192:	2100      	movs	r1, #0
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001194:	4680      	mov	r8, r0
 8001196:	e6a9      	b.n	8000eec <chprintf.constprop.3+0xcc>
 8001198:	46c0      	nop			; (mov r8, r8)
 800119a:	46c0      	nop			; (mov r8, r8)
 800119c:	46c0      	nop			; (mov r8, r8)
 800119e:	46c0      	nop			; (mov r8, r8)

080011a0 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80011a0:	4b06      	ldr	r3, [pc, #24]	; (80011bc <_dbg_check_lock_from_isr+0x1c>)
 80011a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011a4:	2a00      	cmp	r2, #0
 80011a6:	dd02      	ble.n	80011ae <_dbg_check_lock_from_isr+0xe>
 80011a8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80011aa:	2800      	cmp	r0, #0
 80011ac:	d003      	beq.n	80011b6 <_dbg_check_lock_from_isr+0x16>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011ae:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80011b0:	4a03      	ldr	r2, [pc, #12]	; (80011c0 <_dbg_check_lock_from_isr+0x20>)
 80011b2:	62da      	str	r2, [r3, #44]	; 0x2c
 80011b4:	e7fe      	b.n	80011b4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80011b6:	2101      	movs	r1, #1
 80011b8:	6359      	str	r1, [r3, #52]	; 0x34
}
 80011ba:	4770      	bx	lr
 80011bc:	20001118 	.word	0x20001118
 80011c0:	080028a8 	.word	0x080028a8
 80011c4:	46c0      	nop			; (mov r8, r8)
 80011c6:	46c0      	nop			; (mov r8, r8)
 80011c8:	46c0      	nop			; (mov r8, r8)
 80011ca:	46c0      	nop			; (mov r8, r8)
 80011cc:	46c0      	nop			; (mov r8, r8)
 80011ce:	46c0      	nop			; (mov r8, r8)

080011d0 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80011d0:	4b06      	ldr	r3, [pc, #24]	; (80011ec <_dbg_check_unlock_from_isr+0x1c>)
 80011d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011d4:	2a00      	cmp	r2, #0
 80011d6:	dd05      	ble.n	80011e4 <_dbg_check_unlock_from_isr+0x14>
 80011d8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80011da:	2800      	cmp	r0, #0
 80011dc:	dd02      	ble.n	80011e4 <_dbg_check_unlock_from_isr+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 80011de:	2100      	movs	r1, #0
 80011e0:	6359      	str	r1, [r3, #52]	; 0x34
}
 80011e2:	4770      	bx	lr
 80011e4:	b672      	cpsid	i
 80011e6:	4a02      	ldr	r2, [pc, #8]	; (80011f0 <_dbg_check_unlock_from_isr+0x20>)
 80011e8:	62da      	str	r2, [r3, #44]	; 0x2c
 80011ea:	e7fe      	b.n	80011ea <_dbg_check_unlock_from_isr+0x1a>
 80011ec:	20001118 	.word	0x20001118
 80011f0:	080028b0 	.word	0x080028b0
 80011f4:	46c0      	nop			; (mov r8, r8)
 80011f6:	46c0      	nop			; (mov r8, r8)
 80011f8:	46c0      	nop			; (mov r8, r8)
 80011fa:	46c0      	nop			; (mov r8, r8)
 80011fc:	46c0      	nop			; (mov r8, r8)
 80011fe:	46c0      	nop			; (mov r8, r8)

08001200 <_dbg_check_enter_isr>:
 8001200:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001202:	4b07      	ldr	r3, [pc, #28]	; (8001220 <_dbg_check_enter_isr+0x20>)
 8001204:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001206:	2a00      	cmp	r2, #0
 8001208:	db02      	blt.n	8001210 <_dbg_check_enter_isr+0x10>
 800120a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800120c:	2900      	cmp	r1, #0
 800120e:	d003      	beq.n	8001218 <_dbg_check_enter_isr+0x18>
 8001210:	b672      	cpsid	i
 8001212:	4804      	ldr	r0, [pc, #16]	; (8001224 <_dbg_check_enter_isr+0x24>)
 8001214:	62d8      	str	r0, [r3, #44]	; 0x2c
 8001216:	e7fe      	b.n	8001216 <_dbg_check_enter_isr+0x16>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 8001218:	3201      	adds	r2, #1
 800121a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800121c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800121e:	4770      	bx	lr
 8001220:	20001118 	.word	0x20001118
 8001224:	080028b8 	.word	0x080028b8
 8001228:	46c0      	nop			; (mov r8, r8)
 800122a:	46c0      	nop			; (mov r8, r8)
 800122c:	46c0      	nop			; (mov r8, r8)
 800122e:	46c0      	nop			; (mov r8, r8)

08001230 <_dbg_check_leave_isr>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001230:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001232:	4b07      	ldr	r3, [pc, #28]	; (8001250 <_dbg_check_leave_isr+0x20>)
 8001234:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001236:	2a00      	cmp	r2, #0
 8001238:	dd02      	ble.n	8001240 <_dbg_check_leave_isr+0x10>
 800123a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800123c:	2900      	cmp	r1, #0
 800123e:	d003      	beq.n	8001248 <_dbg_check_leave_isr+0x18>
 8001240:	b672      	cpsid	i
 8001242:	4804      	ldr	r0, [pc, #16]	; (8001254 <_dbg_check_leave_isr+0x24>)
 8001244:	62d8      	str	r0, [r3, #44]	; 0x2c
 8001246:	e7fe      	b.n	8001246 <_dbg_check_leave_isr+0x16>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8001248:	3a01      	subs	r2, #1
 800124a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800124c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800124e:	4770      	bx	lr
 8001250:	20001118 	.word	0x20001118
 8001254:	080028c0 	.word	0x080028c0
 8001258:	46c0      	nop			; (mov r8, r8)
 800125a:	46c0      	nop			; (mov r8, r8)
 800125c:	46c0      	nop			; (mov r8, r8)
 800125e:	46c0      	nop			; (mov r8, r8)

08001260 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001260:	4b05      	ldr	r3, [pc, #20]	; (8001278 <chDbgCheckClassI+0x18>)
 8001262:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001264:	2a00      	cmp	r2, #0
 8001266:	db03      	blt.n	8001270 <chDbgCheckClassI+0x10>
 8001268:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800126a:	2800      	cmp	r0, #0
 800126c:	dd00      	ble.n	8001270 <chDbgCheckClassI+0x10>
    chSysHalt("SV#10");
  }
}
 800126e:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001270:	b672      	cpsid	i
 8001272:	4902      	ldr	r1, [pc, #8]	; (800127c <chDbgCheckClassI+0x1c>)
 8001274:	62d9      	str	r1, [r3, #44]	; 0x2c
 8001276:	e7fe      	b.n	8001276 <chDbgCheckClassI+0x16>
 8001278:	20001118 	.word	0x20001118
 800127c:	080028c8 	.word	0x080028c8

08001280 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001280:	b510      	push	{r4, lr}
 8001282:	1c04      	adds	r4, r0, #0
  thread_t *cp;

  chDbgCheckClassI();
 8001284:	f7ff ffec 	bl	8001260 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001288:	2c00      	cmp	r4, #0
 800128a:	d019      	beq.n	80012c0 <chSchReadyI+0x40>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800128c:	2320      	movs	r3, #32
 800128e:	5ce2      	ldrb	r2, [r4, r3]
 8001290:	2a00      	cmp	r2, #0
 8001292:	d010      	beq.n	80012b6 <chSchReadyI+0x36>
 8001294:	2a0f      	cmp	r2, #15
 8001296:	d00e      	beq.n	80012b6 <chSchReadyI+0x36>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001298:	2000      	movs	r0, #0
 800129a:	54e0      	strb	r0, [r4, r3]
 800129c:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 800129e:	4b0b      	ldr	r3, [pc, #44]	; (80012cc <chSchReadyI+0x4c>)
  do {
    cp = cp->p_next;
 80012a0:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80012a2:	6899      	ldr	r1, [r3, #8]
 80012a4:	4291      	cmp	r1, r2
 80012a6:	d2fb      	bcs.n	80012a0 <chSchReadyI+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80012a8:	6858      	ldr	r0, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80012aa:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 80012ac:	6060      	str	r0, [r4, #4]
  tp->p_prev->p_next = tp;
 80012ae:	6004      	str	r4, [r0, #0]
  cp->p_prev = tp;
 80012b0:	605c      	str	r4, [r3, #4]

  return tp;
}
 80012b2:	1c20      	adds	r0, r4, #0
 80012b4:	bd10      	pop	{r4, pc}
 80012b6:	b672      	cpsid	i
 80012b8:	4c05      	ldr	r4, [pc, #20]	; (80012d0 <chSchReadyI+0x50>)
 80012ba:	4a04      	ldr	r2, [pc, #16]	; (80012cc <chSchReadyI+0x4c>)
 80012bc:	62d4      	str	r4, [r2, #44]	; 0x2c
 80012be:	e7fe      	b.n	80012be <chSchReadyI+0x3e>
 80012c0:	b672      	cpsid	i
 80012c2:	4903      	ldr	r1, [pc, #12]	; (80012d0 <chSchReadyI+0x50>)
 80012c4:	4b01      	ldr	r3, [pc, #4]	; (80012cc <chSchReadyI+0x4c>)
 80012c6:	62d9      	str	r1, [r3, #44]	; 0x2c
 80012c8:	e7fe      	b.n	80012c8 <chSchReadyI+0x48>
 80012ca:	46c0      	nop			; (mov r8, r8)
 80012cc:	20001118 	.word	0x20001118
 80012d0:	08002870 	.word	0x08002870
 80012d4:	46c0      	nop			; (mov r8, r8)
 80012d6:	46c0      	nop			; (mov r8, r8)
 80012d8:	46c0      	nop			; (mov r8, r8)
 80012da:	46c0      	nop			; (mov r8, r8)
 80012dc:	46c0      	nop			; (mov r8, r8)
 80012de:	46c0      	nop			; (mov r8, r8)

080012e0 <wakeup.4792.4152>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80012e0:	b538      	push	{r3, r4, r5, lr}
 80012e2:	1c04      	adds	r4, r0, #0
 80012e4:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80012e6:	f7ff ff5b 	bl	80011a0 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80012ea:	2320      	movs	r3, #32
 80012ec:	5ce0      	ldrb	r0, [r4, r3]
 80012ee:	2807      	cmp	r0, #7
 80012f0:	d80e      	bhi.n	8001310 <wakeup.4792.4152+0x30>
 80012f2:	4a11      	ldr	r2, [pc, #68]	; (8001338 <wakeup.4792.4152+0x58>)
 80012f4:	0081      	lsls	r1, r0, #2
 80012f6:	5855      	ldr	r5, [r2, r1]
 80012f8:	46af      	mov	pc, r5
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80012fa:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 80012fc:	f7ff ffb0 	bl	8001260 <chDbgCheckClassI>

  sp->s_cnt++;
 8001300:	68ab      	ldr	r3, [r5, #8]
 8001302:	3301      	adds	r3, #1
 8001304:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001306:	6860      	ldr	r0, [r4, #4]
 8001308:	6821      	ldr	r1, [r4, #0]
 800130a:	6001      	str	r1, [r0, #0]
  tp->p_next->p_prev = tp->p_prev;
 800130c:	6822      	ldr	r2, [r4, #0]
 800130e:	6050      	str	r0, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001310:	2001      	movs	r0, #1
 8001312:	4241      	negs	r1, r0
 8001314:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001316:	1c20      	adds	r0, r4, #0
 8001318:	f7ff ffb2 	bl	8001280 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800131c:	f7ff ff58 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001320:	b662      	cpsie	i
  chSysUnlockFromISR();
}
 8001322:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001324:	6a65      	ldr	r5, [r4, #36]	; 0x24
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001326:	2001      	movs	r0, #1
 8001328:	4241      	negs	r1, r0
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 800132a:	2300      	movs	r3, #0
 800132c:	602b      	str	r3, [r5, #0]
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
 800132e:	1c20      	adds	r0, r4, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001330:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001332:	f7ff ffa5 	bl	8001280 <chSchReadyI>
 8001336:	e7f1      	b.n	800131c <wakeup.4792.4152+0x3c>
 8001338:	08002840 	.word	0x08002840
 800133c:	46c0      	nop			; (mov r8, r8)
 800133e:	46c0      	nop			; (mov r8, r8)

08001340 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001340:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001342:	4657      	mov	r7, sl
 8001344:	464e      	mov	r6, r9
 8001346:	4645      	mov	r5, r8
 8001348:	b4e0      	push	{r5, r6, r7}
 800134a:	1c06      	adds	r6, r0, #0
 800134c:	1c0f      	adds	r7, r1, #0
  event_listener_t *elp;

  chDbgCheckClassI();
 800134e:	f7ff ff87 	bl	8001260 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8001352:	2e00      	cmp	r6, #0
 8001354:	d042      	beq.n	80013dc <chEvtBroadcastFlagsI+0x9c>

  elp = esp->es_next;
 8001356:	6834      	ldr	r4, [r6, #0]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001358:	2120      	movs	r1, #32
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800135a:	2200      	movs	r2, #0
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800135c:	4689      	mov	r9, r1
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800135e:	4690      	mov	r8, r2
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001360:	42a6      	cmp	r6, r4
 8001362:	d103      	bne.n	800136c <chEvtBroadcastFlagsI+0x2c>
 8001364:	e027      	b.n	80013b6 <chEvtBroadcastFlagsI+0x76>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8001366:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001368:	42a6      	cmp	r6, r4
 800136a:	d024      	beq.n	80013b6 <chEvtBroadcastFlagsI+0x76>
  /*lint -restore*/
    elp->el_flags |= flags;
 800136c:	68e3      	ldr	r3, [r4, #12]
 800136e:	433b      	orrs	r3, r7
 8001370:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001372:	2f00      	cmp	r7, #0
 8001374:	d002      	beq.n	800137c <chEvtBroadcastFlagsI+0x3c>
 8001376:	6920      	ldr	r0, [r4, #16]
 8001378:	4218      	tst	r0, r3
 800137a:	d0f4      	beq.n	8001366 <chEvtBroadcastFlagsI+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 800137c:	6865      	ldr	r5, [r4, #4]
 800137e:	68a1      	ldr	r1, [r4, #8]
 8001380:	468a      	mov	sl, r1
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 8001382:	f7ff ff6d 	bl	8001260 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001386:	2d00      	cmp	r5, #0
 8001388:	d023      	beq.n	80013d2 <chEvtBroadcastFlagsI+0x92>

  tp->p_epending |= events;
 800138a:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800138c:	4653      	mov	r3, sl
 800138e:	4313      	orrs	r3, r2
 8001390:	63ab      	str	r3, [r5, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001392:	4648      	mov	r0, r9
 8001394:	5c29      	ldrb	r1, [r5, r0]
 8001396:	290a      	cmp	r1, #10
 8001398:	d012      	beq.n	80013c0 <chEvtBroadcastFlagsI+0x80>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800139a:	290b      	cmp	r1, #11
 800139c:	d1e3      	bne.n	8001366 <chEvtBroadcastFlagsI+0x26>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 800139e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80013a0:	4013      	ands	r3, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 80013a2:	429a      	cmp	r2, r3
 80013a4:	d1df      	bne.n	8001366 <chEvtBroadcastFlagsI+0x26>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80013a6:	4643      	mov	r3, r8
 80013a8:	626b      	str	r3, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80013aa:	1c28      	adds	r0, r5, #0
 80013ac:	f7ff ff68 	bl	8001280 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 80013b0:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80013b2:	42a6      	cmp	r6, r4
 80013b4:	d1da      	bne.n	800136c <chEvtBroadcastFlagsI+0x2c>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80013b6:	bc1c      	pop	{r2, r3, r4}
 80013b8:	4690      	mov	r8, r2
 80013ba:	4699      	mov	r9, r3
 80013bc:	46a2      	mov	sl, r4
 80013be:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80013c0:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80013c2:	4218      	tst	r0, r3
 80013c4:	d0cf      	beq.n	8001366 <chEvtBroadcastFlagsI+0x26>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80013c6:	4643      	mov	r3, r8
 80013c8:	626b      	str	r3, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80013ca:	1c28      	adds	r0, r5, #0
 80013cc:	f7ff ff58 	bl	8001280 <chSchReadyI>
 80013d0:	e7ee      	b.n	80013b0 <chEvtBroadcastFlagsI+0x70>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013d2:	b672      	cpsid	i
 80013d4:	4e04      	ldr	r6, [pc, #16]	; (80013e8 <chEvtBroadcastFlagsI+0xa8>)
 80013d6:	4f05      	ldr	r7, [pc, #20]	; (80013ec <chEvtBroadcastFlagsI+0xac>)
 80013d8:	62fe      	str	r6, [r7, #44]	; 0x2c
 80013da:	e7fe      	b.n	80013da <chEvtBroadcastFlagsI+0x9a>
 80013dc:	b672      	cpsid	i
 80013de:	4d04      	ldr	r5, [pc, #16]	; (80013f0 <chEvtBroadcastFlagsI+0xb0>)
 80013e0:	4902      	ldr	r1, [pc, #8]	; (80013ec <chEvtBroadcastFlagsI+0xac>)
 80013e2:	62cd      	str	r5, [r1, #44]	; 0x2c
 80013e4:	e7fe      	b.n	80013e4 <chEvtBroadcastFlagsI+0xa4>
 80013e6:	46c0      	nop			; (mov r8, r8)
 80013e8:	08002910 	.word	0x08002910
 80013ec:	20001118 	.word	0x20001118
 80013f0:	080028f0 	.word	0x080028f0
 80013f4:	46c0      	nop			; (mov r8, r8)
 80013f6:	46c0      	nop			; (mov r8, r8)
 80013f8:	46c0      	nop			; (mov r8, r8)
 80013fa:	46c0      	nop			; (mov r8, r8)
 80013fc:	46c0      	nop			; (mov r8, r8)
 80013fe:	46c0      	nop			; (mov r8, r8)

08001400 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001400:	4b05      	ldr	r3, [pc, #20]	; (8001418 <chDbgCheckClassS+0x18>)
 8001402:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001404:	2a00      	cmp	r2, #0
 8001406:	d103      	bne.n	8001410 <chDbgCheckClassS+0x10>
 8001408:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800140a:	2800      	cmp	r0, #0
 800140c:	dd00      	ble.n	8001410 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 800140e:	4770      	bx	lr
 8001410:	b672      	cpsid	i
 8001412:	4902      	ldr	r1, [pc, #8]	; (800141c <chDbgCheckClassS+0x1c>)
 8001414:	62d9      	str	r1, [r3, #44]	; 0x2c
 8001416:	e7fe      	b.n	8001416 <chDbgCheckClassS+0x16>
 8001418:	20001118 	.word	0x20001118
 800141c:	080028d0 	.word	0x080028d0

08001420 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001420:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001422:	465f      	mov	r7, fp
 8001424:	4656      	mov	r6, sl
 8001426:	464d      	mov	r5, r9
 8001428:	4644      	mov	r4, r8
 800142a:	b4f0      	push	{r4, r5, r6, r7}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800142c:	2403      	movs	r4, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800142e:	0757      	lsls	r7, r2, #29
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001430:	06d6      	lsls	r6, r2, #27
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001432:	0655      	lsls	r5, r2, #25
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001434:	4014      	ands	r4, r2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001436:	0552      	lsls	r2, r2, #21
 8001438:	0f13      	lsrs	r3, r2, #28
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800143a:	b083      	sub	sp, #12

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 800143c:	0fad      	lsrs	r5, r5, #30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800143e:	2201      	movs	r2, #1

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001440:	469b      	mov	fp, r3
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001442:	0fff      	lsrs	r7, r7, #31
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001444:	0fb6      	lsrs	r6, r6, #30
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8001446:	2300      	movs	r3, #0
  while (true) {
    if ((mask & 1) != 0) {
 8001448:	4694      	mov	ip, r2
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 800144a:	9500      	str	r5, [sp, #0]
 800144c:	e00e      	b.n	800146c <_pal_lld_setgroupmode+0x4c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800144e:	6a02      	ldr	r2, [r0, #32]
 8001450:	464d      	mov	r5, r9
 8001452:	43aa      	bics	r2, r5
 8001454:	4645      	mov	r5, r8
 8001456:	432a      	orrs	r2, r5
 8001458:	6202      	str	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 800145a:	0849      	lsrs	r1, r1, #1
    if (!mask)
 800145c:	d03d      	beq.n	80014da <_pal_lld_setgroupmode+0xba>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
 800145e:	9a00      	ldr	r2, [sp, #0]
      }
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
 8001460:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
    pupdr <<= 2;
 8001462:	0095      	lsls	r5, r2, #2
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8001464:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8001466:	9500      	str	r5, [sp, #0]
    moder <<= 2;
 8001468:	00a4      	lsls	r4, r4, #2
    bit++;
 800146a:	3301      	adds	r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800146c:	4665      	mov	r5, ip
 800146e:	420d      	tst	r5, r1
 8001470:	d0f3      	beq.n	800145a <_pal_lld_setgroupmode+0x3a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001472:	2207      	movs	r2, #7
 8001474:	401a      	ands	r2, r3
 8001476:	0095      	lsls	r5, r2, #2
 8001478:	465a      	mov	r2, fp
 800147a:	40aa      	lsls	r2, r5
 800147c:	4690      	mov	r8, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800147e:	220f      	movs	r2, #15
 8001480:	40aa      	lsls	r2, r5
 8001482:	4691      	mov	r9, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001484:	6845      	ldr	r5, [r0, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8001486:	4662      	mov	r2, ip
 8001488:	409a      	lsls	r2, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800148a:	4395      	bics	r5, r2
 800148c:	433d      	orrs	r5, r7
 800148e:	6045      	str	r5, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001490:	6882      	ldr	r2, [r0, #8]
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8001492:	005d      	lsls	r5, r3, #1
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001494:	4692      	mov	sl, r2
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8001496:	2203      	movs	r2, #3
 8001498:	40aa      	lsls	r2, r5
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800149a:	43d5      	mvns	r5, r2
 800149c:	4652      	mov	r2, sl
 800149e:	402a      	ands	r2, r5
 80014a0:	4332      	orrs	r2, r6
 80014a2:	6082      	str	r2, [r0, #8]
 80014a4:	9501      	str	r5, [sp, #4]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80014a6:	68c5      	ldr	r5, [r0, #12]
 80014a8:	1c2a      	adds	r2, r5, #0
 80014aa:	9d01      	ldr	r5, [sp, #4]
 80014ac:	402a      	ands	r2, r5
 80014ae:	9d00      	ldr	r5, [sp, #0]
 80014b0:	432a      	orrs	r2, r5
 80014b2:	60c2      	str	r2, [r0, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80014b4:	2c02      	cmp	r4, #2
 80014b6:	d017      	beq.n	80014e8 <_pal_lld_setgroupmode+0xc8>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80014b8:	6802      	ldr	r2, [r0, #0]
 80014ba:	4692      	mov	sl, r2
 80014bc:	9a01      	ldr	r2, [sp, #4]
 80014be:	4655      	mov	r5, sl
 80014c0:	402a      	ands	r2, r5
 80014c2:	4322      	orrs	r2, r4
 80014c4:	6002      	str	r2, [r0, #0]
        if (bit < 8)
 80014c6:	2b07      	cmp	r3, #7
 80014c8:	d9c1      	bls.n	800144e <_pal_lld_setgroupmode+0x2e>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80014ca:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80014cc:	464d      	mov	r5, r9
 80014ce:	43aa      	bics	r2, r5
 80014d0:	4645      	mov	r5, r8
 80014d2:	432a      	orrs	r2, r5
 80014d4:	6242      	str	r2, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
 80014d6:	0849      	lsrs	r1, r1, #1
    if (!mask)
 80014d8:	d1c1      	bne.n	800145e <_pal_lld_setgroupmode+0x3e>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 80014da:	b003      	add	sp, #12
 80014dc:	bc3c      	pop	{r2, r3, r4, r5}
 80014de:	4690      	mov	r8, r2
 80014e0:	4699      	mov	r9, r3
 80014e2:	46a2      	mov	sl, r4
 80014e4:	46ab      	mov	fp, r5
 80014e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80014e8:	2b07      	cmp	r3, #7
 80014ea:	d80d      	bhi.n	8001508 <_pal_lld_setgroupmode+0xe8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80014ec:	6a02      	ldr	r2, [r0, #32]
 80014ee:	1c15      	adds	r5, r2, #0
 80014f0:	464a      	mov	r2, r9
 80014f2:	4395      	bics	r5, r2
 80014f4:	4642      	mov	r2, r8
 80014f6:	4315      	orrs	r5, r2
 80014f8:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80014fa:	6805      	ldr	r5, [r0, #0]
 80014fc:	9a01      	ldr	r2, [sp, #4]
 80014fe:	402a      	ands	r2, r5
 8001500:	2502      	movs	r5, #2
 8001502:	432a      	orrs	r2, r5
 8001504:	6002      	str	r2, [r0, #0]
 8001506:	e7a8      	b.n	800145a <_pal_lld_setgroupmode+0x3a>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001508:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800150a:	464d      	mov	r5, r9
 800150c:	43aa      	bics	r2, r5
 800150e:	4645      	mov	r5, r8
 8001510:	432a      	orrs	r2, r5
 8001512:	6242      	str	r2, [r0, #36]	; 0x24
 8001514:	e7f1      	b.n	80014fa <_pal_lld_setgroupmode+0xda>
 8001516:	46c0      	nop			; (mov r8, r8)
 8001518:	46c0      	nop			; (mov r8, r8)
 800151a:	46c0      	nop			; (mov r8, r8)
 800151c:	46c0      	nop			; (mov r8, r8)
 800151e:	46c0      	nop			; (mov r8, r8)

08001520 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001520:	300f      	adds	r0, #15
 8001522:	d011      	beq.n	8001548 <_port_irq_epilogue+0x28>
 8001524:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001526:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800152a:	3b20      	subs	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800152c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001530:	2280      	movs	r2, #128	; 0x80
 8001532:	0450      	lsls	r0, r2, #17
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001534:	4a06      	ldr	r2, [pc, #24]	; (8001550 <_port_irq_epilogue+0x30>)
 8001536:	61d8      	str	r0, [r3, #28]
 8001538:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800153a:	6990      	ldr	r0, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800153c:	6889      	ldr	r1, [r1, #8]
 800153e:	6882      	ldr	r2, [r0, #8]
 8001540:	4291      	cmp	r1, r2
 8001542:	d802      	bhi.n	800154a <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001544:	4803      	ldr	r0, [pc, #12]	; (8001554 <_port_irq_epilogue+0x34>)
 8001546:	6198      	str	r0, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8001548:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800154a:	4903      	ldr	r1, [pc, #12]	; (8001558 <_port_irq_epilogue+0x38>)
 800154c:	6199      	str	r1, [r3, #24]
 800154e:	e7fb      	b.n	8001548 <_port_irq_epilogue+0x28>
 8001550:	20001118 	.word	0x20001118
 8001554:	0800020c 	.word	0x0800020c
 8001558:	08000201 	.word	0x08000201
 800155c:	46c0      	nop			; (mov r8, r8)
 800155e:	46c0      	nop			; (mov r8, r8)

08001560 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001560:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001562:	464e      	mov	r6, r9
 8001564:	4657      	mov	r7, sl
 8001566:	4645      	mov	r5, r8
 8001568:	b4e0      	push	{r5, r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800156a:	2680      	movs	r6, #128	; 0x80
 800156c:	05f6      	lsls	r6, r6, #23
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800156e:	46f1      	mov	r9, lr
 8001570:	f7ff fe46 	bl	8001200 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001574:	6933      	ldr	r3, [r6, #16]
 8001576:	079a      	lsls	r2, r3, #30
 8001578:	d409      	bmi.n	800158e <Vector7C+0x2e>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800157a:	f7ff fe59 	bl	8001230 <_dbg_check_leave_isr>
 800157e:	4648      	mov	r0, r9
 8001580:	f7ff ffce 	bl	8001520 <_port_irq_epilogue>
}
 8001584:	bc1c      	pop	{r2, r3, r4}
 8001586:	4690      	mov	r8, r2
 8001588:	4699      	mov	r9, r3
 800158a:	46a2      	mov	sl, r4
 800158c:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 800158e:	2000      	movs	r0, #0
 8001590:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001592:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8001594:	f7ff fe04 	bl	80011a0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 8001598:	f7ff fe62 	bl	8001260 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 800159c:	f7ff fe60 	bl	8001260 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80015a0:	4c22      	ldr	r4, [pc, #136]	; (800162c <Vector7C+0xcc>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80015a2:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80015a4:	69e5      	ldr	r5, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80015a6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80015a8:	68aa      	ldr	r2, [r5, #8]
 80015aa:	1a5f      	subs	r7, r3, r1
 80015ac:	4297      	cmp	r7, r2
 80015ae:	d31d      	bcc.n	80015ec <Vector7C+0x8c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80015b0:	231c      	movs	r3, #28
 80015b2:	1918      	adds	r0, r3, r4
 80015b4:	4680      	mov	r8, r0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80015b6:	2700      	movs	r7, #0
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80015b8:	188a      	adds	r2, r1, r2

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80015ba:	68e8      	ldr	r0, [r5, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80015bc:	6829      	ldr	r1, [r5, #0]
 80015be:	4643      	mov	r3, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80015c0:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80015c2:	4682      	mov	sl, r0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80015c4:	604b      	str	r3, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80015c6:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80015c8:	60ef      	str	r7, [r5, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80015ca:	4541      	cmp	r1, r8
 80015cc:	d02b      	beq.n	8001626 <Vector7C+0xc6>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80015ce:	f7ff fdff 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80015d2:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 80015d4:	6928      	ldr	r0, [r5, #16]
 80015d6:	47d0      	blx	sl
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80015d8:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80015da:	f7ff fde1 	bl	80011a0 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80015de:	69e5      	ldr	r5, [r4, #28]
 80015e0:	6a73      	ldr	r3, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80015e2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80015e4:	68aa      	ldr	r2, [r5, #8]
 80015e6:	1a58      	subs	r0, r3, r1
 80015e8:	4282      	cmp	r2, r0
 80015ea:	d9e5      	bls.n	80015b8 <Vector7C+0x58>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80015ec:	4e10      	ldr	r6, [pc, #64]	; (8001630 <Vector7C+0xd0>)
 80015ee:	42b5      	cmp	r5, r6
 80015f0:	d013      	beq.n	800161a <Vector7C+0xba>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80015f2:	188f      	adds	r7, r1, r2
 80015f4:	1afd      	subs	r5, r7, r3
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80015f6:	2d01      	cmp	r5, #1
 80015f8:	d913      	bls.n	8001622 <Vector7C+0xc2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 80015fa:	18ee      	adds	r6, r5, r3
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80015fc:	1c30      	adds	r0, r6, #0
 80015fe:	f7ff fb97 	bl	8000d30 <stSetAlarm.4275>
 8001602:	2380      	movs	r3, #128	; 0x80
 8001604:	05da      	lsls	r2, r3, #23

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 8001606:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001608:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800160a:	1a75      	subs	r5, r6, r1
 800160c:	1a47      	subs	r7, r0, r1
 800160e:	42af      	cmp	r7, r5
 8001610:	d903      	bls.n	800161a <Vector7C+0xba>
 8001612:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001614:	4e07      	ldr	r6, [pc, #28]	; (8001634 <Vector7C+0xd4>)
 8001616:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001618:	e7fe      	b.n	8001618 <Vector7C+0xb8>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800161a:	f7ff fdd9 	bl	80011d0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800161e:	b662      	cpsie	i
 8001620:	e7ab      	b.n	800157a <Vector7C+0x1a>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001622:	2502      	movs	r5, #2
 8001624:	e7e9      	b.n	80015fa <Vector7C+0x9a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001626:	60f7      	str	r7, [r6, #12]
 8001628:	e7d1      	b.n	80015ce <Vector7C+0x6e>
 800162a:	46c0      	nop			; (mov r8, r8)
 800162c:	20001118 	.word	0x20001118
 8001630:	20001134 	.word	0x20001134
 8001634:	08002860 	.word	0x08002860
 8001638:	46c0      	nop			; (mov r8, r8)
 800163a:	46c0      	nop			; (mov r8, r8)
 800163c:	46c0      	nop			; (mov r8, r8)
 800163e:	46c0      	nop			; (mov r8, r8)

08001640 <_dbg_trace>:
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8001640:	4a0b      	ldr	r2, [pc, #44]	; (8001670 <_dbg_trace+0x30>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001642:	2180      	movs	r1, #128	; 0x80
 8001644:	05c9      	lsls	r1, r1, #23
 8001646:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8001648:	6a49      	ldr	r1, [r1, #36]	; 0x24
 800164a:	6019      	str	r1, [r3, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 800164c:	6991      	ldr	r1, [r2, #24]
 800164e:	6059      	str	r1, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8001650:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8001652:	6099      	str	r1, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8001654:	2120      	movs	r1, #32
 8001656:	5c40      	ldrb	r0, [r0, r1]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8001658:	2188      	movs	r1, #136	; 0x88
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 800165a:	7318      	strb	r0, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 800165c:	00c8      	lsls	r0, r1, #3
 800165e:	3310      	adds	r3, #16
 8001660:	1811      	adds	r1, r2, r0
 8001662:	428b      	cmp	r3, r1
 8001664:	d301      	bcc.n	800166a <_dbg_trace+0x2a>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8001666:	1c13      	adds	r3, r2, #0
 8001668:	3340      	adds	r3, #64	; 0x40
 800166a:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800166c:	4770      	bx	lr
 800166e:	46c0      	nop			; (mov r8, r8)
 8001670:	20001118 	.word	0x20001118
 8001674:	46c0      	nop			; (mov r8, r8)
 8001676:	46c0      	nop			; (mov r8, r8)
 8001678:	46c0      	nop			; (mov r8, r8)
 800167a:	46c0      	nop			; (mov r8, r8)
 800167c:	46c0      	nop			; (mov r8, r8)
 800167e:	46c0      	nop			; (mov r8, r8)

08001680 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001680:	b570      	push	{r4, r5, r6, lr}
 8001682:	1c06      	adds	r6, r0, #0
  thread_t *otp;

  chDbgCheckClassS();
 8001684:	f7ff febc 	bl	8001400 <chDbgCheckClassS>

  otp = currp;
 8001688:	4c0e      	ldr	r4, [pc, #56]	; (80016c4 <chSchGoSleepS+0x44>)
  otp->p_state = newstate;
 800168a:	2220      	movs	r2, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800168c:	6823      	ldr	r3, [r4, #0]
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 800168e:	69a5      	ldr	r5, [r4, #24]

  tqp->p_next = tp->p_next;
 8001690:	6819      	ldr	r1, [r3, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001692:	2001      	movs	r0, #1
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 8001694:	54ae      	strb	r6, [r5, r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001696:	604c      	str	r4, [r1, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001698:	5498      	strb	r0, [r3, r2]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800169a:	6021      	str	r1, [r4, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800169c:	61a3      	str	r3, [r4, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800169e:	1c28      	adds	r0, r5, #0
 80016a0:	f7ff ffce 	bl	8001640 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80016a4:	f3ef 8609 	mrs	r6, PSP
 80016a8:	69ea      	ldr	r2, [r5, #28]
 80016aa:	3e24      	subs	r6, #36	; 0x24
 80016ac:	42b2      	cmp	r2, r6
 80016ae:	d804      	bhi.n	80016ba <chSchGoSleepS+0x3a>
 80016b0:	1c29      	adds	r1, r5, #0
 80016b2:	69a0      	ldr	r0, [r4, #24]
 80016b4:	f7fe fd8c 	bl	80001d0 <_port_switch>
}
 80016b8:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016ba:	b672      	cpsid	i
 80016bc:	4d02      	ldr	r5, [pc, #8]	; (80016c8 <chSchGoSleepS+0x48>)
 80016be:	62e5      	str	r5, [r4, #44]	; 0x2c
 80016c0:	e7fe      	b.n	80016c0 <chSchGoSleepS+0x40>
 80016c2:	46c0      	nop			; (mov r8, r8)
 80016c4:	20001118 	.word	0x20001118
 80016c8:	080026e8 	.word	0x080026e8
 80016cc:	46c0      	nop			; (mov r8, r8)
 80016ce:	46c0      	nop			; (mov r8, r8)

080016d0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80016d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80016d2:	4647      	mov	r7, r8
 80016d4:	b480      	push	{r7}
 80016d6:	1c0e      	adds	r6, r1, #0
 80016d8:	b086      	sub	sp, #24
 80016da:	1c07      	adds	r7, r0, #0

  chDbgCheckClassS();
 80016dc:	f7ff fe90 	bl	8001400 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 80016e0:	1c71      	adds	r1, r6, #1
 80016e2:	d053      	beq.n	800178c <chSchGoSleepTimeoutS+0xbc>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80016e4:	4d4c      	ldr	r5, [pc, #304]	; (8001818 <chSchGoSleepTimeoutS+0x148>)
 80016e6:	69aa      	ldr	r2, [r5, #24]
 80016e8:	4690      	mov	r8, r2
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 80016ea:	f7ff fdb9 	bl	8001260 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 80016ee:	2e00      	cmp	r6, #0
 80016f0:	d103      	bne.n	80016fa <chSchGoSleepTimeoutS+0x2a>
 80016f2:	b672      	cpsid	i
 80016f4:	4b49      	ldr	r3, [pc, #292]	; (800181c <chSchGoSleepTimeoutS+0x14c>)
 80016f6:	62eb      	str	r3, [r5, #44]	; 0x2c
 80016f8:	e7fe      	b.n	80016f8 <chSchGoSleepTimeoutS+0x28>

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80016fa:	4849      	ldr	r0, [pc, #292]	; (8001820 <chSchGoSleepTimeoutS+0x150>)
 80016fc:	2180      	movs	r1, #128	; 0x80
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80016fe:	ac01      	add	r4, sp, #4
 8001700:	4643      	mov	r3, r8
 8001702:	05ca      	lsls	r2, r1, #23
  vtp->vt_func = vtfunc;
 8001704:	60e0      	str	r0, [r4, #12]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001706:	6123      	str	r3, [r4, #16]
 8001708:	6a50      	ldr	r0, [r2, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800170a:	2e01      	cmp	r6, #1
 800170c:	d943      	bls.n	8001796 <chSchGoSleepTimeoutS+0xc6>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800170e:	1c29      	adds	r1, r5, #0
 8001710:	69eb      	ldr	r3, [r5, #28]
 8001712:	311c      	adds	r1, #28
 8001714:	428b      	cmp	r3, r1
 8001716:	d044      	beq.n	80017a2 <chSchGoSleepTimeoutS+0xd2>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001718:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800171a:	6899      	ldr	r1, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800171c:	1830      	adds	r0, r6, r0
 800171e:	1a86      	subs	r6, r0, r2
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001720:	428e      	cmp	r6, r1
 8001722:	d203      	bcs.n	800172c <chSchGoSleepTimeoutS+0x5c>
 8001724:	e06e      	b.n	8001804 <chSchGoSleepTimeoutS+0x134>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
    p = p->vt_next;
 8001726:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001728:	1a76      	subs	r6, r6, r1
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800172a:	6899      	ldr	r1, [r3, #8]
 800172c:	42b1      	cmp	r1, r6
 800172e:	d3fa      	bcc.n	8001726 <chSchGoSleepTimeoutS+0x56>
  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
  vtp->vt_delta = delta
 8001730:	60a6      	str	r6, [r4, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001732:	6899      	ldr	r1, [r3, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001734:	6858      	ldr	r0, [r3, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001736:	1b8e      	subs	r6, r1, r6
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001738:	9301      	str	r3, [sp, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800173a:	609e      	str	r6, [r3, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800173c:	6060      	str	r0, [r4, #4]
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
 800173e:	605c      	str	r4, [r3, #4]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001740:	2301      	movs	r3, #1
 8001742:	425a      	negs	r2, r3
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8001744:	6004      	str	r4, [r0, #0]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001746:	626a      	str	r2, [r5, #36]	; 0x24
    chSchGoSleepS(newstate);
 8001748:	1c38      	adds	r0, r7, #0
 800174a:	f7ff ff99 	bl	8001680 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800174e:	f7ff fd87 	bl	8001260 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8001752:	68e7      	ldr	r7, [r4, #12]
 8001754:	2f00      	cmp	r7, #0
 8001756:	d013      	beq.n	8001780 <chSchGoSleepTimeoutS+0xb0>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8001758:	f7ff fd82 	bl	8001260 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 800175c:	69ea      	ldr	r2, [r5, #28]
 800175e:	42a2      	cmp	r2, r4
 8001760:	d030      	beq.n	80017c4 <chSchGoSleepTimeoutS+0xf4>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001762:	6860      	ldr	r0, [r4, #4]
 8001764:	6826      	ldr	r6, [r4, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001766:	1c2f      	adds	r7, r5, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001768:	6006      	str	r6, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800176a:	6823      	ldr	r3, [r4, #0]
    vtp->vt_func = NULL;
 800176c:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800176e:	371c      	adds	r7, #28
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001770:	6058      	str	r0, [r3, #4]
    vtp->vt_func = NULL;
 8001772:	60e1      	str	r1, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001774:	42bb      	cmp	r3, r7
 8001776:	d003      	beq.n	8001780 <chSchGoSleepTimeoutS+0xb0>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8001778:	68a4      	ldr	r4, [r4, #8]
 800177a:	689a      	ldr	r2, [r3, #8]
 800177c:	1910      	adds	r0, r2, r4
 800177e:	6098      	str	r0, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8001780:	69ad      	ldr	r5, [r5, #24]
 8001782:	6a68      	ldr	r0, [r5, #36]	; 0x24
}
 8001784:	b006      	add	sp, #24
 8001786:	bc04      	pop	{r2}
 8001788:	4690      	mov	r8, r2
 800178a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800178c:	1c38      	adds	r0, r7, #0
 800178e:	f7ff ff77 	bl	8001680 <chSchGoSleepS>
 8001792:	4d21      	ldr	r5, [pc, #132]	; (8001818 <chSchGoSleepTimeoutS+0x148>)
 8001794:	e7f4      	b.n	8001780 <chSchGoSleepTimeoutS+0xb0>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001796:	1c29      	adds	r1, r5, #0
 8001798:	69eb      	ldr	r3, [r5, #28]
 800179a:	311c      	adds	r1, #28
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800179c:	2602      	movs	r6, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800179e:	428b      	cmp	r3, r1
 80017a0:	d1ba      	bne.n	8001718 <chSchGoSleepTimeoutS+0x48>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 80017a2:	62a8      	str	r0, [r5, #40]	; 0x28
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 80017a4:	1832      	adds	r2, r6, r0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80017a6:	2080      	movs	r0, #128	; 0x80
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;
 80017a8:	60a6      	str	r6, [r4, #8]
 80017aa:	05c6      	lsls	r6, r0, #23
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 80017ac:	9301      	str	r3, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80017ae:	6063      	str	r3, [r4, #4]
 80017b0:	68f3      	ldr	r3, [r6, #12]
 80017b2:	2102      	movs	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 80017b4:	61ec      	str	r4, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 80017b6:	622c      	str	r4, [r5, #32]
 80017b8:	400b      	ands	r3, r1
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80017ba:	d128      	bne.n	800180e <chSchGoSleepTimeoutS+0x13e>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80017bc:	6372      	str	r2, [r6, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80017be:	6133      	str	r3, [r6, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80017c0:	60f1      	str	r1, [r6, #12]
 80017c2:	e7c1      	b.n	8001748 <chSchGoSleepTimeoutS+0x78>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80017c4:	6820      	ldr	r0, [r4, #0]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80017c6:	1c2e      	adds	r6, r5, #0
 80017c8:	361c      	adds	r6, #28
  vtp->vt_func = NULL;
 80017ca:	2100      	movs	r1, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80017cc:	61e8      	str	r0, [r5, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80017ce:	60e1      	str	r1, [r4, #12]
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80017d0:	6046      	str	r6, [r0, #4]
  vtp->vt_func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80017d2:	42b0      	cmp	r0, r6
 80017d4:	d012      	beq.n	80017fc <chSchGoSleepTimeoutS+0x12c>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80017d6:	68a4      	ldr	r4, [r4, #8]
 80017d8:	6883      	ldr	r3, [r0, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80017da:	2280      	movs	r2, #128	; 0x80
 80017dc:	18e7      	adds	r7, r4, r3
 80017de:	6087      	str	r7, [r0, #8]
 80017e0:	05d0      	lsls	r0, r2, #23
 80017e2:	6a46      	ldr	r6, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80017e4:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80017e6:	1a74      	subs	r4, r6, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80017e8:	42a7      	cmp	r7, r4
 80017ea:	d9c9      	bls.n	8001780 <chSchGoSleepTimeoutS+0xb0>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80017ec:	1b3b      	subs	r3, r7, r4

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80017ee:	2b01      	cmp	r3, #1
 80017f0:	d800      	bhi.n	80017f4 <chSchGoSleepTimeoutS+0x124>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80017f2:	2302      	movs	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80017f4:	1998      	adds	r0, r3, r6
 80017f6:	f7ff fa9b 	bl	8000d30 <stSetAlarm.4275>
 80017fa:	e7c1      	b.n	8001780 <chSchGoSleepTimeoutS+0xb0>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80017fc:	2780      	movs	r7, #128	; 0x80
 80017fe:	05fa      	lsls	r2, r7, #23
 8001800:	60d1      	str	r1, [r2, #12]
 8001802:	e7bd      	b.n	8001780 <chSchGoSleepTimeoutS+0xb0>
 8001804:	f7ff fa94 	bl	8000d30 <stSetAlarm.4275>
 8001808:	69eb      	ldr	r3, [r5, #28]
 800180a:	6899      	ldr	r1, [r3, #8]
 800180c:	e78e      	b.n	800172c <chSchGoSleepTimeoutS+0x5c>
 800180e:	b672      	cpsid	i
 8001810:	4e04      	ldr	r6, [pc, #16]	; (8001824 <chSchGoSleepTimeoutS+0x154>)
 8001812:	62ee      	str	r6, [r5, #44]	; 0x2c
 8001814:	e7fe      	b.n	8001814 <chSchGoSleepTimeoutS+0x144>
 8001816:	46c0      	nop			; (mov r8, r8)
 8001818:	20001118 	.word	0x20001118
 800181c:	080028e0 	.word	0x080028e0
 8001820:	080012e1 	.word	0x080012e1
 8001824:	08002880 	.word	0x08002880
 8001828:	46c0      	nop			; (mov r8, r8)
 800182a:	46c0      	nop			; (mov r8, r8)
 800182c:	46c0      	nop			; (mov r8, r8)
 800182e:	46c0      	nop			; (mov r8, r8)

08001830 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001830:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8001832:	2900      	cmp	r1, #0
 8001834:	d00a      	beq.n	800184c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001836:	4b07      	ldr	r3, [pc, #28]	; (8001854 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001838:	6842      	ldr	r2, [r0, #4]
 800183a:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800183c:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800183e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001840:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8001842:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001844:	2004      	movs	r0, #4
 8001846:	f7ff ff43 	bl	80016d0 <chSchGoSleepTimeoutS>
}
 800184a:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 800184c:	2001      	movs	r0, #1
 800184e:	4240      	negs	r0, r0
 8001850:	e7fb      	b.n	800184a <chThdEnqueueTimeoutS+0x1a>
 8001852:	46c0      	nop			; (mov r8, r8)
 8001854:	20001118 	.word	0x20001118
 8001858:	46c0      	nop			; (mov r8, r8)
 800185a:	46c0      	nop			; (mov r8, r8)
 800185c:	46c0      	nop			; (mov r8, r8)
 800185e:	46c0      	nop			; (mov r8, r8)

08001860 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001860:	e7fe      	b.n	8001860 <BusFault_Handler>
 8001862:	46c0      	nop			; (mov r8, r8)
 8001864:	46c0      	nop			; (mov r8, r8)
 8001866:	46c0      	nop			; (mov r8, r8)
 8001868:	46c0      	nop			; (mov r8, r8)
 800186a:	46c0      	nop			; (mov r8, r8)
 800186c:	46c0      	nop			; (mov r8, r8)
 800186e:	46c0      	nop			; (mov r8, r8)

08001870 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001870:	b538      	push	{r3, r4, r5, lr}
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8001872:	4d14      	ldr	r5, [pc, #80]	; (80018c4 <chSchDoReschedule+0x54>)
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001874:	2120      	movs	r1, #32
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001876:	682a      	ldr	r2, [r5, #0]
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8001878:	69ac      	ldr	r4, [r5, #24]

  tqp->p_next = tp->p_next;
 800187a:	6813      	ldr	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800187c:	2001      	movs	r0, #1
 800187e:	5450      	strb	r0, [r2, r1]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001880:	605d      	str	r5, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001882:	61aa      	str	r2, [r5, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001884:	2200      	movs	r2, #0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001886:	602b      	str	r3, [r5, #0]
 8001888:	5462      	strb	r2, [r4, r1]
 800188a:	68a0      	ldr	r0, [r4, #8]
 800188c:	e000      	b.n	8001890 <chSchDoReschedule+0x20>
 800188e:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8001890:	6899      	ldr	r1, [r3, #8]
 8001892:	4281      	cmp	r1, r0
 8001894:	d8fb      	bhi.n	800188e <chSchDoReschedule+0x1e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001896:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001898:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 800189a:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 800189c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 800189e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
 80018a0:	1c20      	adds	r0, r4, #0
 80018a2:	f7ff fecd 	bl	8001640 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80018a6:	f3ef 8309 	mrs	r3, PSP
 80018aa:	69e0      	ldr	r0, [r4, #28]
 80018ac:	3b24      	subs	r3, #36	; 0x24
 80018ae:	4298      	cmp	r0, r3
 80018b0:	d804      	bhi.n	80018bc <chSchDoReschedule+0x4c>
 80018b2:	69a8      	ldr	r0, [r5, #24]
 80018b4:	1c21      	adds	r1, r4, #0
 80018b6:	f7fe fc8b 	bl	80001d0 <_port_switch>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 80018ba:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80018bc:	b672      	cpsid	i
 80018be:	4c02      	ldr	r4, [pc, #8]	; (80018c8 <chSchDoReschedule+0x58>)
 80018c0:	62ec      	str	r4, [r5, #44]	; 0x2c
 80018c2:	e7fe      	b.n	80018c2 <chSchDoReschedule+0x52>
 80018c4:	20001118 	.word	0x20001118
 80018c8:	080026e8 	.word	0x080026e8
 80018cc:	46c0      	nop			; (mov r8, r8)
 80018ce:	46c0      	nop			; (mov r8, r8)

080018d0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80018d0:	b570      	push	{r4, r5, r6, lr}
 80018d2:	1c06      	adds	r6, r0, #0
 80018d4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80018d6:	f7fe ff1b 	bl	8000710 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80018da:	4d0f      	ldr	r5, [pc, #60]	; (8001918 <chThdExit+0x48>)
 80018dc:	69ac      	ldr	r4, [r5, #24]

  tp->p_u.exitcode = msg;
 80018de:	6266      	str	r6, [r4, #36]	; 0x24
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80018e0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80018e2:	1c26      	adds	r6, r4, #0
 80018e4:	3628      	adds	r6, #40	; 0x28
 80018e6:	42b0      	cmp	r0, r6
 80018e8:	d006      	beq.n	80018f8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 80018ea:	6803      	ldr	r3, [r0, #0]
 80018ec:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80018ee:	f7ff fcc7 	bl	8001280 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80018f2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80018f4:	42b0      	cmp	r0, r6
 80018f6:	d1f8      	bne.n	80018ea <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80018f8:	2021      	movs	r0, #33	; 0x21
 80018fa:	5c21      	ldrb	r1, [r4, r0]
 80018fc:	078a      	lsls	r2, r1, #30
 80018fe:	d104      	bne.n	800190a <chThdExit+0x3a>
    REG_REMOVE(tp);
 8001900:	6966      	ldr	r6, [r4, #20]
 8001902:	6922      	ldr	r2, [r4, #16]
 8001904:	6132      	str	r2, [r6, #16]
 8001906:	6924      	ldr	r4, [r4, #16]
 8001908:	6166      	str	r6, [r4, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800190a:	200f      	movs	r0, #15
 800190c:	f7ff feb8 	bl	8001680 <chSchGoSleepS>
 8001910:	b672      	cpsid	i
 8001912:	4b02      	ldr	r3, [pc, #8]	; (800191c <chThdExit+0x4c>)
 8001914:	62eb      	str	r3, [r5, #44]	; 0x2c
 8001916:	e7fe      	b.n	8001916 <chThdExit+0x46>
 8001918:	20001118 	.word	0x20001118
 800191c:	08002940 	.word	0x08002940

08001920 <chIQReadTimeout.4247>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001920:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001922:	464e      	mov	r6, r9
 8001924:	4645      	mov	r5, r8
 8001926:	4657      	mov	r7, sl
 8001928:	b4e0      	push	{r5, r6, r7}
 800192a:	1c15      	adds	r5, r2, #0
  qnotify_t nfy = iqp->q_notify;
 800192c:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800192e:	1c04      	adds	r4, r0, #0
 8001930:	1c0e      	adds	r6, r1, #0
 8001932:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8001934:	4690      	mov	r8, r2
 8001936:	b672      	cpsid	i
  size_t r = 0;

  chDbgCheck(n > 0U);
 8001938:	2d00      	cmp	r5, #0
 800193a:	d04b      	beq.n	80019d4 <chIQReadTimeout.4247+0xb4>
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
 800193c:	3d01      	subs	r5, #1
 800193e:	f7fe fee7 	bl	8000710 <_dbg_check_lock>
 8001942:	19a8      	adds	r0, r5, r6
 8001944:	4d27      	ldr	r5, [pc, #156]	; (80019e4 <chIQReadTimeout.4247+0xc4>)
 8001946:	4682      	mov	sl, r0
                       size_t n, systime_t timeout) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8001948:	2700      	movs	r7, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 800194a:	4643      	mov	r3, r8
 800194c:	2b00      	cmp	r3, #0
 800194e:	d001      	beq.n	8001954 <chIQReadTimeout.4247+0x34>
      nfy(iqp);
 8001950:	1c20      	adds	r0, r4, #0
 8001952:	47c0      	blx	r8
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001954:	f7ff fc84 	bl	8001260 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8001958:	68a1      	ldr	r1, [r4, #8]
    }

    while (chIQIsEmptyI(iqp)) {
 800195a:	2900      	cmp	r1, #0
 800195c:	d11a      	bne.n	8001994 <chIQReadTimeout.4247+0x74>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800195e:	1c20      	adds	r0, r4, #0
 8001960:	4649      	mov	r1, r9
 8001962:	f7ff ff65 	bl	8001830 <chThdEnqueueTimeoutS>
 8001966:	2800      	cmp	r0, #0
 8001968:	d0f4      	beq.n	8001954 <chIQReadTimeout.4247+0x34>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800196a:	f7fe feb9 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800196e:	6828      	ldr	r0, [r5, #0]
 8001970:	42a8      	cmp	r0, r5
 8001972:	d004      	beq.n	800197e <chIQReadTimeout.4247+0x5e>
 8001974:	69ab      	ldr	r3, [r5, #24]
 8001976:	6882      	ldr	r2, [r0, #8]
 8001978:	6899      	ldr	r1, [r3, #8]
 800197a:	4291      	cmp	r1, r2
 800197c:	d306      	bcc.n	800198c <chIQReadTimeout.4247+0x6c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800197e:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 8001980:	1c38      	adds	r0, r7, #0
 8001982:	bc1c      	pop	{r2, r3, r4}
 8001984:	4690      	mov	r8, r2
 8001986:	4699      	mov	r9, r3
 8001988:	46a2      	mov	sl, r4
 800198a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800198c:	b672      	cpsid	i
 800198e:	4c16      	ldr	r4, [pc, #88]	; (80019e8 <chIQReadTimeout.4247+0xc8>)
 8001990:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001992:	e7fe      	b.n	8001992 <chIQReadTimeout.4247+0x72>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001994:	68a2      	ldr	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001996:	69a0      	ldr	r0, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001998:	3a01      	subs	r2, #1
 800199a:	60a2      	str	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800199c:	7803      	ldrb	r3, [r0, #0]
 800199e:	3001      	adds	r0, #1
 80019a0:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 80019a2:	6921      	ldr	r1, [r4, #16]
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80019a4:	61a0      	str	r0, [r4, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 80019a6:	4288      	cmp	r0, r1
 80019a8:	d301      	bcc.n	80019ae <chIQReadTimeout.4247+0x8e>
      iqp->q_rdptr = iqp->q_buffer;
 80019aa:	68e2      	ldr	r2, [r4, #12]
 80019ac:	61a2      	str	r2, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80019ae:	f7fe fe97 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80019b2:	6828      	ldr	r0, [r5, #0]
 80019b4:	42a8      	cmp	r0, r5
 80019b6:	d004      	beq.n	80019c2 <chIQReadTimeout.4247+0xa2>
 80019b8:	69ab      	ldr	r3, [r5, #24]
 80019ba:	6882      	ldr	r2, [r0, #8]
 80019bc:	6899      	ldr	r1, [r3, #8]
 80019be:	4291      	cmp	r1, r2
 80019c0:	d30c      	bcc.n	80019dc <chIQReadTimeout.4247+0xbc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80019c2:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 80019c4:	3701      	adds	r7, #1
    if (--n == 0U) {
 80019c6:	4556      	cmp	r6, sl
 80019c8:	d0da      	beq.n	8001980 <chIQReadTimeout.4247+0x60>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80019ca:	3601      	adds	r6, #1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80019cc:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80019ce:	f7fe fe9f 	bl	8000710 <_dbg_check_lock>
 80019d2:	e7ba      	b.n	800194a <chIQReadTimeout.4247+0x2a>
 80019d4:	4d05      	ldr	r5, [pc, #20]	; (80019ec <chIQReadTimeout.4247+0xcc>)
 80019d6:	4e03      	ldr	r6, [pc, #12]	; (80019e4 <chIQReadTimeout.4247+0xc4>)
 80019d8:	62f5      	str	r5, [r6, #44]	; 0x2c
 80019da:	e7fe      	b.n	80019da <chIQReadTimeout.4247+0xba>
 80019dc:	b672      	cpsid	i
 80019de:	4c02      	ldr	r4, [pc, #8]	; (80019e8 <chIQReadTimeout.4247+0xc8>)
 80019e0:	62ec      	str	r4, [r5, #44]	; 0x2c
 80019e2:	e7fe      	b.n	80019e2 <chIQReadTimeout.4247+0xc2>
 80019e4:	20001118 	.word	0x20001118
 80019e8:	08002a00 	.word	0x08002a00
 80019ec:	08002920 	.word	0x08002920

080019f0 <readt.8173>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 80019f0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80019f2:	300c      	adds	r0, #12
 80019f4:	f7ff ff94 	bl	8001920 <chIQReadTimeout.4247>
}
 80019f8:	bd08      	pop	{r3, pc}
 80019fa:	46c0      	nop			; (mov r8, r8)
 80019fc:	46c0      	nop			; (mov r8, r8)
 80019fe:	46c0      	nop			; (mov r8, r8)

08001a00 <read.8179>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8001a00:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001a02:	2301      	movs	r3, #1
 8001a04:	300c      	adds	r0, #12
 8001a06:	425b      	negs	r3, r3
 8001a08:	f7ff ff8a 	bl	8001920 <chIQReadTimeout.4247>
                       n, TIME_INFINITE);
}
 8001a0c:	bd08      	pop	{r3, pc}
 8001a0e:	46c0      	nop			; (mov r8, r8)

08001a10 <STN1110_rx.9466>:

static THD_WORKING_AREA(wa_STN1110_rx, 128);
static THD_FUNCTION(STN1110_rx, arg) {
 8001a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001a12:	4b25      	ldr	r3, [pc, #148]	; (8001aa8 <STN1110_rx.9466+0x98>)
 8001a14:	4a25      	ldr	r2, [pc, #148]	; (8001aac <STN1110_rx.9466+0x9c>)
 8001a16:	6998      	ldr	r0, [r3, #24]
 8001a18:	4657      	mov	r7, sl
 8001a1a:	464e      	mov	r6, r9
 8001a1c:	4645      	mov	r5, r8
 8001a1e:	b4e0      	push	{r5, r6, r7}
 8001a20:	6182      	str	r2, [r0, #24]
    sdPut(&SD1, '\n');
}

static void reset_stn1110(void)
{
    debug_write("resetting");
 8001a22:	4823      	ldr	r0, [pc, #140]	; (8001ab0 <STN1110_rx.9466+0xa0>)
 8001a24:	f7fe ff84 	bl	8000930 <debug_write.9476>
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8001a28:	4c22      	ldr	r4, [pc, #136]	; (8001ab4 <STN1110_rx.9466+0xa4>)
    debug_write("resetting");

    /* set STN1110 NVM reset to disbled (normal running mode)
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);
 8001a2a:	2190      	movs	r1, #144	; 0x90
 8001a2c:	05c8      	lsls	r0, r1, #23
 8001a2e:	2220      	movs	r2, #32
 8001a30:	2102      	movs	r1, #2
 8001a32:	f7ff fcf5 	bl	8001420 <_pal_lld_setgroupmode>

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001a36:	2504      	movs	r5, #4
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8001a38:	2104      	movs	r1, #4
 8001a3a:	2201      	movs	r2, #1
 8001a3c:	1c20      	adds	r0, r4, #0
 8001a3e:	f7ff fcef 	bl	8001420 <_pal_lld_setgroupmode>
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001a42:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(10);
 8001a44:	2064      	movs	r0, #100	; 0x64
 8001a46:	f7fe fedb 	bl	8000800 <chThdSleep>
    palSetPad(GPIOB, GPIOB_RESET_STN1110);
 8001a4a:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(1000);
 8001a4c:	481a      	ldr	r0, [pc, #104]	; (8001ab8 <STN1110_rx.9466+0xa8>)
 8001a4e:	f7fe fed7 	bl	8000800 <chThdSleep>
    debug_write("after reset");
 8001a52:	481a      	ldr	r0, [pc, #104]	; (8001abc <STN1110_rx.9466+0xac>)
 8001a54:	f7fe ff6c 	bl	8000930 <debug_write.9476>
static THD_FUNCTION(STN1110_rx, arg) {
  (void)arg;
  chRegSetThreadName("STN1110_RX");

  reset_stn1110();
  send_at("AT E0\r");
 8001a58:	4819      	ldr	r0, [pc, #100]	; (8001ac0 <STN1110_rx.9466+0xb0>)
 8001a5a:	f7fe ff91 	bl	8000980 <send_at.9469>
  send_at("AT SP 0\r");
 8001a5e:	4819      	ldr	r0, [pc, #100]	; (8001ac4 <STN1110_rx.9466+0xb4>)
 8001a60:	f7fe ff8e 	bl	8000980 <send_at.9469>
 8001a64:	4e18      	ldr	r6, [pc, #96]	; (8001ac8 <STN1110_rx.9466+0xb8>)
 8001a66:	4f19      	ldr	r7, [pc, #100]	; (8001acc <STN1110_rx.9466+0xbc>)
 8001a68:	4b19      	ldr	r3, [pc, #100]	; (8001ad0 <STN1110_rx.9466+0xc0>)
 8001a6a:	46b2      	mov	sl, r6
 8001a6c:	46b9      	mov	r9, r7
 8001a6e:	4c19      	ldr	r4, [pc, #100]	; (8001ad4 <STN1110_rx.9466+0xc4>)
 8001a70:	4f19      	ldr	r7, [pc, #100]	; (8001ad8 <STN1110_rx.9466+0xc8>)
 8001a72:	4e1a      	ldr	r6, [pc, #104]	; (8001adc <STN1110_rx.9466+0xcc>)
 8001a74:	4698      	mov	r8, r3
  while (true) {
      /* Reset the STN1110 */
      send_at("010C\r");
      debug_write("Waiting for AT response");
      int bytes_read = sdReadTimeout(&SD2,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf), 50000);
      stn_rx_buf[bytes_read] = '\0';
 8001a76:	2500      	movs	r5, #0
  send_at("AT E0\r");
  send_at("AT SP 0\r");

  while (true) {
      /* Reset the STN1110 */
      send_at("010C\r");
 8001a78:	4650      	mov	r0, sl
 8001a7a:	f7fe ff81 	bl	8000980 <send_at.9469>
      debug_write("Waiting for AT response");
 8001a7e:	4648      	mov	r0, r9
 8001a80:	f7fe ff56 	bl	8000930 <debug_write.9476>
      int bytes_read = sdReadTimeout(&SD2,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf), 50000);
 8001a84:	2280      	movs	r2, #128	; 0x80
 8001a86:	1c21      	adds	r1, r4, #0
 8001a88:	4b15      	ldr	r3, [pc, #84]	; (8001ae0 <STN1110_rx.9466+0xd0>)
 8001a8a:	4640      	mov	r0, r8
 8001a8c:	00d2      	lsls	r2, r2, #3
 8001a8e:	f7ff ff47 	bl	8001920 <chIQReadTimeout.4247>
      stn_rx_buf[bytes_read] = '\0';
      chprintf(&SD1, "Bytes read %i\r\n", bytes_read);
 8001a92:	1c31      	adds	r1, r6, #0

  while (true) {
      /* Reset the STN1110 */
      send_at("010C\r");
      debug_write("Waiting for AT response");
      int bytes_read = sdReadTimeout(&SD2,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf), 50000);
 8001a94:	1c02      	adds	r2, r0, #0
      stn_rx_buf[bytes_read] = '\0';
 8001a96:	5425      	strb	r5, [r4, r0]
      chprintf(&SD1, "Bytes read %i\r\n", bytes_read);
 8001a98:	1c38      	adds	r0, r7, #0
 8001a9a:	f7ff f9c1 	bl	8000e20 <chprintf.constprop.3>
      debug_write(stn_rx_buf);
 8001a9e:	1c20      	adds	r0, r4, #0
 8001aa0:	f7fe ff46 	bl	8000930 <debug_write.9476>
 8001aa4:	e7e8      	b.n	8001a78 <STN1110_rx.9466+0x68>
 8001aa6:	46c0      	nop			; (mov r8, r8)
 8001aa8:	20001118 	.word	0x20001118
 8001aac:	08002950 	.word	0x08002950
 8001ab0:	0800295c 	.word	0x0800295c
 8001ab4:	48000400 	.word	0x48000400
 8001ab8:	00002710 	.word	0x00002710
 8001abc:	08002968 	.word	0x08002968
 8001ac0:	08002974 	.word	0x08002974
 8001ac4:	0800297c 	.word	0x0800297c
 8001ac8:	08002988 	.word	0x08002988
 8001acc:	08002990 	.word	0x08002990
 8001ad0:	20000e40 	.word	0x20000e40
 8001ad4:	20000600 	.word	0x20000600
 8001ad8:	20000b58 	.word	0x20000b58
 8001adc:	080029a8 	.word	0x080029a8
 8001ae0:	0000c350 	.word	0x0000c350
 8001ae4:	46c0      	nop			; (mov r8, r8)
 8001ae6:	46c0      	nop			; (mov r8, r8)
 8001ae8:	46c0      	nop			; (mov r8, r8)
 8001aea:	46c0      	nop			; (mov r8, r8)
 8001aec:	46c0      	nop			; (mov r8, r8)
 8001aee:	46c0      	nop			; (mov r8, r8)

08001af0 <can_rx.9463>:

/*
 * Receiver thread.
 */
static THD_WORKING_AREA(can_rx_wa, 256);
static THD_FUNCTION(can_rx, p) {
 8001af0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001af2:	4644      	mov	r4, r8
 8001af4:	465f      	mov	r7, fp
 8001af6:	4656      	mov	r6, sl
 8001af8:	464d      	mov	r5, r9
 8001afa:	b4f0      	push	{r4, r5, r6, r7}
  event_listener_t el;
  CANRxFrame rxmsg;

  chprintf(&SD1, "freq %i\r\n", STM32_HCLK);
 8001afc:	4983      	ldr	r1, [pc, #524]	; (8001d0c <can_rx.9463+0x21c>)

/*
 * Receiver thread.
 */
static THD_WORKING_AREA(can_rx_wa, 256);
static THD_FUNCTION(can_rx, p) {
 8001afe:	b087      	sub	sp, #28
  event_listener_t el;
  CANRxFrame rxmsg;

  chprintf(&SD1, "freq %i\r\n", STM32_HCLK);
 8001b00:	4a83      	ldr	r2, [pc, #524]	; (8001d10 <can_rx.9463+0x220>)
 8001b02:	4884      	ldr	r0, [pc, #528]	; (8001d14 <can_rx.9463+0x224>)
 8001b04:	f7ff f98c 	bl	8000e20 <chprintf.constprop.3>

  debug_write("CAN Rx starting");
 8001b08:	4883      	ldr	r0, [pc, #524]	; (8001d18 <can_rx.9463+0x228>)
 8001b0a:	f7fe ff11 	bl	8000930 <debug_write.9476>
 8001b0e:	4c83      	ldr	r4, [pc, #524]	; (8001d1c <can_rx.9463+0x22c>)
 8001b10:	4a83      	ldr	r2, [pc, #524]	; (8001d20 <can_rx.9463+0x230>)
 8001b12:	69a3      	ldr	r3, [r4, #24]
 8001b14:	619a      	str	r2, [r3, #24]
 8001b16:	b672      	cpsid	i
 8001b18:	f7fe fdfa 	bl	8000710 <_dbg_check_lock>
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001b1c:	4981      	ldr	r1, [pc, #516]	; (8001d24 <can_rx.9463+0x234>)
 8001b1e:	ae01      	add	r6, sp, #4
 8001b20:	698d      	ldr	r5, [r1, #24]
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001b22:	69a3      	ldr	r3, [r4, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8001b24:	2001      	movs	r0, #1
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001b26:	9501      	str	r5, [sp, #4]
  esp->es_next     = elp;
 8001b28:	618e      	str	r6, [r1, #24]
  elp->el_listener = currp;
  elp->el_events   = events;
 8001b2a:	2201      	movs	r2, #1
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8001b2c:	4245      	negs	r5, r0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001b2e:	4688      	mov	r8, r1
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8001b30:	2100      	movs	r1, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001b32:	6073      	str	r3, [r6, #4]
  elp->el_events   = events;
 8001b34:	60b2      	str	r2, [r6, #8]
  elp->el_flags    = (eventflags_t)0;
 8001b36:	60f1      	str	r1, [r6, #12]
  elp->el_wflags   = wflags;
 8001b38:	6135      	str	r5, [r6, #16]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001b3a:	f7fe fdd1 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001b3e:	6827      	ldr	r7, [r4, #0]
 8001b40:	42a7      	cmp	r7, r4
 8001b42:	d005      	beq.n	8001b50 <can_rx.9463+0x60>
 8001b44:	69a3      	ldr	r3, [r4, #24]
 8001b46:	68b9      	ldr	r1, [r7, #8]
 8001b48:	689a      	ldr	r2, [r3, #8]
 8001b4a:	428a      	cmp	r2, r1
 8001b4c:	d200      	bcs.n	8001b50 <can_rx.9463+0x60>
 8001b4e:	e07d      	b.n	8001c4c <can_rx.9463+0x15c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001b50:	b662      	cpsie	i
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8001b52:	2021      	movs	r0, #33	; 0x21
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001b54:	1c25      	adds	r5, r4, #0
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8001b56:	4681      	mov	r9, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001b58:	69a7      	ldr	r7, [r4, #24]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8001b5a:	464b      	mov	r3, r9
 8001b5c:	5cfa      	ldrb	r2, [r7, r3]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001b5e:	b672      	cpsid	i
  (void)p;
  chRegSetThreadName("receiver");
  chEvtRegister(&CAND1.rxfull_event, &el, 0);
  while(!chThdShouldTerminateX()) {
 8001b60:	0752      	lsls	r2, r2, #29
 8001b62:	d450      	bmi.n	8001c06 <can_rx.9463+0x116>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001b64:	f7fe fdd4 	bl	8000710 <_dbg_check_lock>
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8001b68:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8001b6a:	4682      	mov	sl, r0
  if (m == (eventmask_t)0) {
 8001b6c:	2800      	cmp	r0, #0
 8001b6e:	d10c      	bne.n	8001b8a <can_rx.9463+0x9a>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8001b70:	2201      	movs	r2, #1
 8001b72:	4251      	negs	r1, r2
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8001b74:	23fa      	movs	r3, #250	; 0xfa
  if (m == (eventmask_t)0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8001b76:	6279      	str	r1, [r7, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8001b78:	200a      	movs	r0, #10
 8001b7a:	0099      	lsls	r1, r3, #2
 8001b7c:	f7ff fda8 	bl	80016d0 <chSchGoSleepTimeoutS>
 8001b80:	2800      	cmp	r0, #0
 8001b82:	da00      	bge.n	8001b86 <can_rx.9463+0x96>
 8001b84:	e0b1      	b.n	8001cea <can_rx.9463+0x1fa>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 8001b86:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8001b88:	4682      	mov	sl, r0
  }
  ctp->p_epending &= ~m;
 8001b8a:	2200      	movs	r2, #0
 8001b8c:	63ba      	str	r2, [r7, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001b8e:	f7fe fda7 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001b92:	6827      	ldr	r7, [r4, #0]
 8001b94:	42a7      	cmp	r7, r4
 8001b96:	d004      	beq.n	8001ba2 <can_rx.9463+0xb2>
 8001b98:	69a9      	ldr	r1, [r5, #24]
 8001b9a:	68bb      	ldr	r3, [r7, #8]
 8001b9c:	6888      	ldr	r0, [r1, #8]
 8001b9e:	4298      	cmp	r0, r3
 8001ba0:	d358      	bcc.n	8001c54 <can_rx.9463+0x164>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001ba2:	b662      	cpsie	i
    if (chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(100)) == 0)
 8001ba4:	4652      	mov	r2, sl
 8001ba6:	2a00      	cmp	r2, #0
 8001ba8:	d0d6      	beq.n	8001b58 <can_rx.9463+0x68>
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 8001baa:	21d8      	movs	r1, #216	; 0xd8
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 8001bac:	23da      	movs	r3, #218	; 0xda
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 8001bae:	0048      	lsls	r0, r1, #1
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 8001bb0:	005a      	lsls	r2, r3, #1
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 8001bb2:	2703      	movs	r7, #3
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 8001bb4:	4683      	mov	fp, r0
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 8001bb6:	4692      	mov	sl, r2
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001bb8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001bba:	f7fe fda9 	bl	8000710 <_dbg_check_lock>

  osalDbgCheck((canp != NULL) && (crfp != NULL) &&
               (mailbox <= (canmbx_t)CAN_RX_MAILBOXES));

  osalSysLock();
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
 8001bbe:	4641      	mov	r1, r8
 8001bc0:	7808      	ldrb	r0, [r1, #0]
 8001bc2:	1ec3      	subs	r3, r0, #3
 8001bc4:	2b01      	cmp	r3, #1
 8001bc6:	d903      	bls.n	8001bd0 <can_rx.9463+0xe0>
 8001bc8:	b672      	cpsid	i
 8001bca:	4d57      	ldr	r5, [pc, #348]	; (8001d28 <can_rx.9463+0x238>)
 8001bcc:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001bce:	e7fe      	b.n	8001bce <can_rx.9463+0xde>
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
 8001bd0:	2804      	cmp	r0, #4
 8001bd2:	d006      	beq.n	8001be2 <can_rx.9463+0xf2>
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 8001bd4:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 8001bd6:	68c1      	ldr	r1, [r0, #12]
 8001bd8:	420f      	tst	r7, r1
 8001bda:	d120      	bne.n	8001c1e <can_rx.9463+0x12e>
            (canp->can->RF1R & CAN_RF1R_FMP1) != 0);
 8001bdc:	6903      	ldr	r3, [r0, #16]
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 8001bde:	421f      	tst	r7, r3
 8001be0:	d11d      	bne.n	8001c1e <can_rx.9463+0x12e>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001be2:	f7fe fd7d 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001be6:	6827      	ldr	r7, [r4, #0]
 8001be8:	42a7      	cmp	r7, r4
 8001bea:	d005      	beq.n	8001bf8 <can_rx.9463+0x108>
 8001bec:	69a8      	ldr	r0, [r5, #24]
 8001bee:	68ba      	ldr	r2, [r7, #8]
 8001bf0:	6881      	ldr	r1, [r0, #8]
 8001bf2:	4291      	cmp	r1, r2
 8001bf4:	d200      	bcs.n	8001bf8 <can_rx.9463+0x108>
 8001bf6:	e074      	b.n	8001ce2 <can_rx.9463+0x1f2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001bf8:	b662      	cpsie	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001bfa:	69a7      	ldr	r7, [r4, #24]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8001bfc:	464b      	mov	r3, r9
 8001bfe:	5cfa      	ldrb	r2, [r7, r3]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c00:	b672      	cpsid	i

  debug_write("CAN Rx starting");
  (void)p;
  chRegSetThreadName("receiver");
  chEvtRegister(&CAND1.rxfull_event, &el, 0);
  while(!chThdShouldTerminateX()) {
 8001c02:	0752      	lsls	r2, r2, #29
 8001c04:	d5ae      	bpl.n	8001b64 <can_rx.9463+0x74>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001c06:	f7fe fd83 	bl	8000710 <_dbg_check_lock>
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8001c0a:	4948      	ldr	r1, [pc, #288]	; (8001d2c <can_rx.9463+0x23c>)
 8001c0c:	1c08      	adds	r0, r1, #0
 8001c0e:	e002      	b.n	8001c16 <can_rx.9463+0x126>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 8001c10:	42b5      	cmp	r5, r6
 8001c12:	d04e      	beq.n	8001cb2 <can_rx.9463+0x1c2>
 8001c14:	1c28      	adds	r0, r5, #0
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 8001c16:	6805      	ldr	r5, [r0, #0]
 8001c18:	428d      	cmp	r5, r1
 8001c1a:	d1f9      	bne.n	8001c10 <can_rx.9463+0x120>
 8001c1c:	e04b      	b.n	8001cb6 <can_rx.9463+0x1c6>
                     canmbx_t mailbox,
                     CANRxFrame *crfp) {
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
 8001c1e:	68c2      	ldr	r2, [r0, #12]
 8001c20:	4217      	tst	r7, r2
 8001c22:	d01b      	beq.n	8001c5c <can_rx.9463+0x16c>
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 8001c24:	465b      	mov	r3, fp
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 8001c26:	4651      	mov	r1, sl
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 8001c28:	58c2      	ldr	r2, [r0, r3]
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 8001c2a:	5842      	ldr	r2, [r0, r1]
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 8001c2c:	22dc      	movs	r2, #220	; 0xdc
 8001c2e:	0053      	lsls	r3, r2, #1
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 8001c30:	21de      	movs	r1, #222	; 0xde
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 8001c32:	58c2      	ldr	r2, [r0, r3]
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 8001c34:	004a      	lsls	r2, r1, #1

    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;
 8001c36:	2320      	movs	r3, #32
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 8001c38:	5882      	ldr	r2, [r0, r2]

    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;
 8001c3a:	60c3      	str	r3, [r0, #12]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
 8001c3c:	68c1      	ldr	r1, [r0, #12]
 8001c3e:	420f      	tst	r7, r1
 8001c40:	d124      	bne.n	8001c8c <can_rx.9463+0x19c>
      canp->can->IER |= CAN_IER_FMPIE0;
 8001c42:	6943      	ldr	r3, [r0, #20]
 8001c44:	2202      	movs	r2, #2
 8001c46:	431a      	orrs	r2, r3
 8001c48:	6142      	str	r2, [r0, #20]
 8001c4a:	e01f      	b.n	8001c8c <can_rx.9463+0x19c>
 8001c4c:	b672      	cpsid	i
 8001c4e:	4e38      	ldr	r6, [pc, #224]	; (8001d30 <can_rx.9463+0x240>)
 8001c50:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001c52:	e7fe      	b.n	8001c52 <can_rx.9463+0x162>
 8001c54:	b672      	cpsid	i
 8001c56:	4b36      	ldr	r3, [pc, #216]	; (8001d30 <can_rx.9463+0x240>)
 8001c58:	62eb      	str	r3, [r5, #44]	; 0x2c
 8001c5a:	e7fe      	b.n	8001c5a <can_rx.9463+0x16a>
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
      mailbox = 1;
    else if ((canp->can->RF1R & CAN_RF1R_FMP1) != 0)
 8001c5c:	6901      	ldr	r1, [r0, #16]
 8001c5e:	420f      	tst	r7, r1
 8001c60:	d014      	beq.n	8001c8c <can_rx.9463+0x19c>
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
      canp->can->IER |= CAN_IER_FMPIE0;
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
 8001c62:	23e0      	movs	r3, #224	; 0xe0
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 8001c64:	21e2      	movs	r1, #226	; 0xe2
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
      canp->can->IER |= CAN_IER_FMPIE0;
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
 8001c66:	005a      	lsls	r2, r3, #1
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 8001c68:	004b      	lsls	r3, r1, #1
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
      canp->can->IER |= CAN_IER_FMPIE0;
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
 8001c6a:	5882      	ldr	r2, [r0, r2]
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 8001c6c:	58c2      	ldr	r2, [r0, r3]
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 8001c6e:	22e4      	movs	r2, #228	; 0xe4
 8001c70:	0051      	lsls	r1, r2, #1
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 8001c72:	23e6      	movs	r3, #230	; 0xe6
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 8001c74:	5842      	ldr	r2, [r0, r1]
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 8001c76:	005a      	lsls	r2, r3, #1

    /* Releases the mailbox.*/
    canp->can->RF1R = CAN_RF1R_RFOM1;
 8001c78:	2120      	movs	r1, #32
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 8001c7a:	5882      	ldr	r2, [r0, r2]

    /* Releases the mailbox.*/
    canp->can->RF1R = CAN_RF1R_RFOM1;
 8001c7c:	6101      	str	r1, [r0, #16]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
 8001c7e:	6903      	ldr	r3, [r0, #16]
 8001c80:	421f      	tst	r7, r3
 8001c82:	d103      	bne.n	8001c8c <can_rx.9463+0x19c>
      canp->can->IER |= CAN_IER_FMPIE1;
 8001c84:	6941      	ldr	r1, [r0, #20]
 8001c86:	2210      	movs	r2, #16
 8001c88:	430a      	orrs	r2, r1
 8001c8a:	6142      	str	r2, [r0, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001c8c:	f7fe fd28 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001c90:	6820      	ldr	r0, [r4, #0]
 8001c92:	42a0      	cmp	r0, r4
 8001c94:	d004      	beq.n	8001ca0 <can_rx.9463+0x1b0>
 8001c96:	69a9      	ldr	r1, [r5, #24]
 8001c98:	6883      	ldr	r3, [r0, #8]
 8001c9a:	688a      	ldr	r2, [r1, #8]
 8001c9c:	429a      	cmp	r2, r3
 8001c9e:	d304      	bcc.n	8001caa <can_rx.9463+0x1ba>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001ca0:	b662      	cpsie	i
    if (chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(100)) == 0)
      continue;
    while (canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE) == MSG_OK) {
      /* Process message.*/
        debug_write("CAN Rx");
 8001ca2:	4824      	ldr	r0, [pc, #144]	; (8001d34 <can_rx.9463+0x244>)
 8001ca4:	f7fe fe44 	bl	8000930 <debug_write.9476>
 8001ca8:	e786      	b.n	8001bb8 <can_rx.9463+0xc8>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001caa:	b672      	cpsid	i
 8001cac:	4c22      	ldr	r4, [pc, #136]	; (8001d38 <can_rx.9463+0x248>)
 8001cae:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001cb0:	e7fe      	b.n	8001cb0 <can_rx.9463+0x1c0>
  /*lint -restore*/
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 8001cb2:	6837      	ldr	r7, [r6, #0]
 8001cb4:	6007      	str	r7, [r0, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001cb6:	f7fe fd13 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001cba:	6823      	ldr	r3, [r4, #0]
 8001cbc:	42a3      	cmp	r3, r4
 8001cbe:	d004      	beq.n	8001cca <can_rx.9463+0x1da>
 8001cc0:	69a2      	ldr	r2, [r4, #24]
 8001cc2:	6899      	ldr	r1, [r3, #8]
 8001cc4:	6895      	ldr	r5, [r2, #8]
 8001cc6:	428d      	cmp	r5, r1
 8001cc8:	d307      	bcc.n	8001cda <can_rx.9463+0x1ea>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cca:	b662      	cpsie	i
    }
  }
  chEvtUnregister(&CAND1.rxfull_event, &el);
}
 8001ccc:	b007      	add	sp, #28
 8001cce:	bc3c      	pop	{r2, r3, r4, r5}
 8001cd0:	4690      	mov	r8, r2
 8001cd2:	4699      	mov	r9, r3
 8001cd4:	46a2      	mov	sl, r4
 8001cd6:	46ab      	mov	fp, r5
 8001cd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001cda:	b672      	cpsid	i
 8001cdc:	4e14      	ldr	r6, [pc, #80]	; (8001d30 <can_rx.9463+0x240>)
 8001cde:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001ce0:	e7fe      	b.n	8001ce0 <can_rx.9463+0x1f0>
 8001ce2:	b672      	cpsid	i
 8001ce4:	4e14      	ldr	r6, [pc, #80]	; (8001d38 <can_rx.9463+0x248>)
 8001ce6:	62ee      	str	r6, [r5, #44]	; 0x2c
 8001ce8:	e7fe      	b.n	8001ce8 <can_rx.9463+0x1f8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001cea:	f7fe fcf9 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001cee:	682f      	ldr	r7, [r5, #0]
 8001cf0:	42af      	cmp	r7, r5
 8001cf2:	d100      	bne.n	8001cf6 <can_rx.9463+0x206>
 8001cf4:	e780      	b.n	8001bf8 <can_rx.9463+0x108>
 8001cf6:	69a8      	ldr	r0, [r5, #24]
 8001cf8:	68ba      	ldr	r2, [r7, #8]
 8001cfa:	6881      	ldr	r1, [r0, #8]
 8001cfc:	4291      	cmp	r1, r2
 8001cfe:	d300      	bcc.n	8001d02 <can_rx.9463+0x212>
 8001d00:	e77a      	b.n	8001bf8 <can_rx.9463+0x108>
 8001d02:	b672      	cpsid	i
 8001d04:	4c0a      	ldr	r4, [pc, #40]	; (8001d30 <can_rx.9463+0x240>)
 8001d06:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001d08:	e7fe      	b.n	8001d08 <can_rx.9463+0x218>
 8001d0a:	46c0      	nop			; (mov r8, r8)
 8001d0c:	080029b8 	.word	0x080029b8
 8001d10:	02dc6c00 	.word	0x02dc6c00
 8001d14:	20000b58 	.word	0x20000b58
 8001d18:	080029c4 	.word	0x080029c4
 8001d1c:	20001118 	.word	0x20001118
 8001d20:	080029d4 	.word	0x080029d4
 8001d24:	20001680 	.word	0x20001680
 8001d28:	08002a20 	.word	0x08002a20
 8001d2c:	20001698 	.word	0x20001698
 8001d30:	08002a10 	.word	0x08002a10
 8001d34:	080029e0 	.word	0x080029e0
 8001d38:	08002aa0 	.word	0x08002aa0
 8001d3c:	46c0      	nop			; (mov r8, r8)
 8001d3e:	46c0      	nop			; (mov r8, r8)

08001d40 <chIQGetTimeout.4360>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001d40:	b570      	push	{r4, r5, r6, lr}
 8001d42:	1c04      	adds	r4, r0, #0
 8001d44:	1c0e      	adds	r6, r1, #0
 8001d46:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001d48:	f7fe fce2 	bl	8000710 <_dbg_check_lock>
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8001d4c:	69e3      	ldr	r3, [r4, #28]
 8001d4e:	2b00      	cmp	r3, #0
 8001d50:	d001      	beq.n	8001d56 <chIQGetTimeout.4360+0x16>
    iqp->q_notify(iqp);
 8001d52:	1c20      	adds	r0, r4, #0
 8001d54:	4798      	blx	r3
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001d56:	f7ff fa83 	bl	8001260 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8001d5a:	68a0      	ldr	r0, [r4, #8]
  }

  while (chIQIsEmptyI(iqp)) {
 8001d5c:	2800      	cmp	r0, #0
 8001d5e:	d113      	bne.n	8001d88 <chIQGetTimeout.4360+0x48>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001d60:	1c20      	adds	r0, r4, #0
 8001d62:	1c31      	adds	r1, r6, #0
 8001d64:	f7ff fd64 	bl	8001830 <chThdEnqueueTimeoutS>
 8001d68:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 8001d6a:	daf4      	bge.n	8001d56 <chIQGetTimeout.4360+0x16>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001d6c:	f7fe fcb8 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001d70:	4b15      	ldr	r3, [pc, #84]	; (8001dc8 <chIQGetTimeout.4360+0x88>)
 8001d72:	6818      	ldr	r0, [r3, #0]
 8001d74:	4298      	cmp	r0, r3
 8001d76:	d004      	beq.n	8001d82 <chIQGetTimeout.4360+0x42>
 8001d78:	6999      	ldr	r1, [r3, #24]
 8001d7a:	6882      	ldr	r2, [r0, #8]
 8001d7c:	688c      	ldr	r4, [r1, #8]
 8001d7e:	4294      	cmp	r4, r2
 8001d80:	d31d      	bcc.n	8001dbe <chIQGetTimeout.4360+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d82:	b662      	cpsie	i
    iqp->q_rdptr = iqp->q_buffer;
  }
  chSysUnlock();

  return (msg_t)b;
}
 8001d84:	1c28      	adds	r0, r5, #0
 8001d86:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001d88:	68a1      	ldr	r1, [r4, #8]
  b = *iqp->q_rdptr++;
 8001d8a:	69a6      	ldr	r6, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001d8c:	3901      	subs	r1, #1
 8001d8e:	60a1      	str	r1, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001d90:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001d92:	7835      	ldrb	r5, [r6, #0]
 8001d94:	3601      	adds	r6, #1
 8001d96:	61a6      	str	r6, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001d98:	4296      	cmp	r6, r2
 8001d9a:	d301      	bcc.n	8001da0 <chIQGetTimeout.4360+0x60>
    iqp->q_rdptr = iqp->q_buffer;
 8001d9c:	68e3      	ldr	r3, [r4, #12]
 8001d9e:	61a3      	str	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001da0:	f7fe fc9e 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001da4:	4c08      	ldr	r4, [pc, #32]	; (8001dc8 <chIQGetTimeout.4360+0x88>)
 8001da6:	6820      	ldr	r0, [r4, #0]
 8001da8:	42a0      	cmp	r0, r4
 8001daa:	d0ea      	beq.n	8001d82 <chIQGetTimeout.4360+0x42>
 8001dac:	69a1      	ldr	r1, [r4, #24]
 8001dae:	6882      	ldr	r2, [r0, #8]
 8001db0:	688e      	ldr	r6, [r1, #8]
 8001db2:	4296      	cmp	r6, r2
 8001db4:	d2e5      	bcs.n	8001d82 <chIQGetTimeout.4360+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001db6:	b672      	cpsid	i
 8001db8:	4d04      	ldr	r5, [pc, #16]	; (8001dcc <chIQGetTimeout.4360+0x8c>)
 8001dba:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001dbc:	e7fe      	b.n	8001dbc <chIQGetTimeout.4360+0x7c>
 8001dbe:	b672      	cpsid	i
 8001dc0:	4d02      	ldr	r5, [pc, #8]	; (8001dcc <chIQGetTimeout.4360+0x8c>)
 8001dc2:	62dd      	str	r5, [r3, #44]	; 0x2c
 8001dc4:	e7fe      	b.n	8001dc4 <chIQGetTimeout.4360+0x84>
 8001dc6:	46c0      	nop			; (mov r8, r8)
 8001dc8:	20001118 	.word	0x20001118
 8001dcc:	08002a00 	.word	0x08002a00

08001dd0 <gett.8195>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 8001dd0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001dd2:	300c      	adds	r0, #12
 8001dd4:	f7ff ffb4 	bl	8001d40 <chIQGetTimeout.4360>
}
 8001dd8:	bd08      	pop	{r3, pc}
 8001dda:	46c0      	nop			; (mov r8, r8)
 8001ddc:	46c0      	nop			; (mov r8, r8)
 8001dde:	46c0      	nop			; (mov r8, r8)

08001de0 <get.8199>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 8001de0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001de2:	2101      	movs	r1, #1
 8001de4:	300c      	adds	r0, #12
 8001de6:	4249      	negs	r1, r1
 8001de8:	f7ff ffaa 	bl	8001d40 <chIQGetTimeout.4360>
}
 8001dec:	bd08      	pop	{r3, pc}
 8001dee:	46c0      	nop			; (mov r8, r8)

08001df0 <can_tx.9460>:

/*
 * Transmitter thread.
 */
static THD_WORKING_AREA(can_tx_wa, 256);
static THD_FUNCTION(can_tx, p) {
 8001df0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001df2:	4647      	mov	r7, r8
 8001df4:	b480      	push	{r7}
 8001df6:	4c44      	ldr	r4, [pc, #272]	; (8001f08 <can_tx.9460+0x118>)
 8001df8:	4a44      	ldr	r2, [pc, #272]	; (8001f0c <can_tx.9460+0x11c>)
 8001dfa:	69a3      	ldr	r3, [r4, #24]
 8001dfc:	b084      	sub	sp, #16
 8001dfe:	619a      	str	r2, [r3, #24]
  CANTxFrame txmsg;

  (void)p;
  chRegSetThreadName("transmitter");
  txmsg.IDE = CAN_IDE_EXT;
  txmsg.EID = 0x01234567;
 8001e00:	9901      	ldr	r1, [sp, #4]
 8001e02:	4e43      	ldr	r6, [pc, #268]	; (8001f10 <can_tx.9460+0x120>)
 8001e04:	0f48      	lsrs	r0, r1, #29
 8001e06:	0745      	lsls	r5, r0, #29
 8001e08:	4335      	orrs	r5, r6
 8001e0a:	9501      	str	r5, [sp, #4]
 8001e0c:	2721      	movs	r7, #33	; 0x21
 8001e0e:	5ddb      	ldrb	r3, [r3, r7]
  txmsg.RTR = CAN_RTR_DATA;
  txmsg.DLC = 8;
  txmsg.data32[0] = 0x55AA55AA;
  txmsg.data32[1] = 0x00FF00FF;

  while (!chThdShouldTerminateX()) {
 8001e10:	075a      	lsls	r2, r3, #29
 8001e12:	d46d      	bmi.n	8001ef0 <can_tx.9460+0x100>
 8001e14:	4d3f      	ldr	r5, [pc, #252]	; (8001f14 <can_tx.9460+0x124>)
 8001e16:	4a40      	ldr	r2, [pc, #256]	; (8001f18 <can_tx.9460+0x128>)
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 8001e18:	1c2f      	adds	r7, r5, #0
 8001e1a:	4690      	mov	r8, r2
 8001e1c:	3708      	adds	r7, #8
 8001e1e:	1c2e      	adds	r6, r5, #0
 8001e20:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001e22:	f7fe fc75 	bl	8000710 <_dbg_check_lock>

  osalDbgCheck((canp != NULL) && (ctfp != NULL) &&
               (mailbox <= (canmbx_t)CAN_TX_MAILBOXES));

  osalSysLock();
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
 8001e26:	7828      	ldrb	r0, [r5, #0]
 8001e28:	1ec1      	subs	r1, r0, #3
 8001e2a:	2901      	cmp	r1, #1
 8001e2c:	d903      	bls.n	8001e36 <can_tx.9460+0x46>
 8001e2e:	b672      	cpsid	i
 8001e30:	4e3a      	ldr	r6, [pc, #232]	; (8001f1c <can_tx.9460+0x12c>)
 8001e32:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001e34:	e7fe      	b.n	8001e34 <can_tx.9460+0x44>
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
 8001e36:	2804      	cmp	r0, #4
 8001e38:	d005      	beq.n	8001e46 <can_tx.9460+0x56>
 */
bool can_lld_is_tx_empty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return (canp->can->TSR & CAN_TSR_TME) != 0;
 8001e3a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8001e3c:	23e0      	movs	r3, #224	; 0xe0
 8001e3e:	6882      	ldr	r2, [r0, #8]
 8001e40:	0559      	lsls	r1, r3, #21
 8001e42:	420a      	tst	r2, r1
 8001e44:	d10f      	bne.n	8001e66 <can_tx.9460+0x76>
 8001e46:	23fa      	movs	r3, #250	; 0xfa
 8001e48:	1c38      	adds	r0, r7, #0
 8001e4a:	0099      	lsls	r1, r3, #2
 8001e4c:	f7ff fcf0 	bl	8001830 <chThdEnqueueTimeoutS>
  /*lint -restore*/
   msg_t msg = osalThreadEnqueueTimeoutS(&canp->txqueue, timeout);
    if (msg != MSG_OK) {
 8001e50:	2800      	cmp	r0, #0
 8001e52:	d137      	bne.n	8001ec4 <can_tx.9460+0xd4>
 8001e54:	7830      	ldrb	r0, [r6, #0]
  osalSysLock();
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
                "invalid state");

  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
 8001e56:	2804      	cmp	r0, #4
 8001e58:	d0f5      	beq.n	8001e46 <can_tx.9460+0x56>
 8001e5a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8001e5c:	23e0      	movs	r3, #224	; 0xe0
 8001e5e:	6882      	ldr	r2, [r0, #8]
 8001e60:	0559      	lsls	r1, r3, #21
 8001e62:	420a      	tst	r2, r1
 8001e64:	d0ef      	beq.n	8001e46 <can_tx.9460+0x56>
  CAN_TxMailBox_TypeDef *tmbp;

  /* Pointer to a free transmission mailbox.*/
  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
 8001e66:	6882      	ldr	r2, [r0, #8]
 8001e68:	0193      	lsls	r3, r2, #6
 8001e6a:	0f99      	lsrs	r1, r3, #30
 8001e6c:	3118      	adds	r1, #24
  default:
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
 8001e6e:	466b      	mov	r3, sp
  CAN_TxMailBox_TypeDef *tmbp;

  /* Pointer to a free transmission mailbox.*/
  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
 8001e70:	010a      	lsls	r2, r1, #4
  default:
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
 8001e72:	7819      	ldrb	r1, [r3, #0]
  CAN_TxMailBox_TypeDef *tmbp;

  /* Pointer to a free transmission mailbox.*/
  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
 8001e74:	1880      	adds	r0, r0, r2
  default:
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
 8001e76:	220f      	movs	r2, #15
 8001e78:	4391      	bics	r1, r2
 8001e7a:	2308      	movs	r3, #8
 8001e7c:	430b      	orrs	r3, r1
 8001e7e:	21ef      	movs	r1, #239	; 0xef
 8001e80:	4019      	ands	r1, r3
 8001e82:	2220      	movs	r2, #32
 8001e84:	430a      	orrs	r2, r1
 8001e86:	466b      	mov	r3, sp
 8001e88:	701a      	strb	r2, [r3, #0]
 8001e8a:	0691      	lsls	r1, r2, #26
 8001e8c:	d534      	bpl.n	8001ef8 <can_tx.9460+0x108>
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
 8001e8e:	9901      	ldr	r1, [sp, #4]
 8001e90:	2304      	movs	r3, #4
 8001e92:	00ca      	lsls	r2, r1, #3
 8001e94:	4313      	orrs	r3, r2
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
  tmbp->TDLR = ctfp->data32[0];
 8001e96:	4a22      	ldr	r2, [pc, #136]	; (8001f20 <can_tx.9460+0x130>)
  if (ctfp->IDE)
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
 8001e98:	2108      	movs	r1, #8
 8001e9a:	6041      	str	r1, [r0, #4]
  tmbp->TDLR = ctfp->data32[0];
 8001e9c:	6082      	str	r2, [r0, #8]
  tmbp->TDHR = ctfp->data32[1];
 8001e9e:	4921      	ldr	r1, [pc, #132]	; (8001f24 <can_tx.9460+0x134>)
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 8001ea0:	2201      	movs	r2, #1
 8001ea2:	4313      	orrs	r3, r2
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
  tmbp->TDLR = ctfp->data32[0];
  tmbp->TDHR = ctfp->data32[1];
 8001ea4:	60c1      	str	r1, [r0, #12]
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 8001ea6:	6003      	str	r3, [r0, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001ea8:	f7fe fc1a 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001eac:	6820      	ldr	r0, [r4, #0]
 8001eae:	42a0      	cmp	r0, r4
 8001eb0:	d012      	beq.n	8001ed8 <can_tx.9460+0xe8>
 8001eb2:	69a3      	ldr	r3, [r4, #24]
 8001eb4:	6882      	ldr	r2, [r0, #8]
 8001eb6:	6899      	ldr	r1, [r3, #8]
 8001eb8:	4291      	cmp	r1, r2
 8001eba:	d20d      	bcs.n	8001ed8 <can_tx.9460+0xe8>
 8001ebc:	b672      	cpsid	i
 8001ebe:	4d1a      	ldr	r5, [pc, #104]	; (8001f28 <can_tx.9460+0x138>)
 8001ec0:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001ec2:	e7fe      	b.n	8001ec2 <can_tx.9460+0xd2>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001ec4:	f7fe fc0c 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001ec8:	6821      	ldr	r1, [r4, #0]
 8001eca:	42a1      	cmp	r1, r4
 8001ecc:	d004      	beq.n	8001ed8 <can_tx.9460+0xe8>
 8001ece:	69a2      	ldr	r2, [r4, #24]
 8001ed0:	688b      	ldr	r3, [r1, #8]
 8001ed2:	6890      	ldr	r0, [r2, #8]
 8001ed4:	4298      	cmp	r0, r3
 8001ed6:	d312      	bcc.n	8001efe <can_tx.9460+0x10e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001ed8:	b662      	cpsie	i
    canTransmit(&CAND1, CAN_ANY_MAILBOX, &txmsg, MS2ST(100));
    chThdSleepMilliseconds(1000);
 8001eda:	4814      	ldr	r0, [pc, #80]	; (8001f2c <can_tx.9460+0x13c>)
 8001edc:	f7fe fc90 	bl	8000800 <chThdSleep>
    debug_write("CAN Tx");
 8001ee0:	4640      	mov	r0, r8
 8001ee2:	f7fe fd25 	bl	8000930 <debug_write.9476>
 8001ee6:	69a2      	ldr	r2, [r4, #24]
 8001ee8:	2121      	movs	r1, #33	; 0x21
 8001eea:	5c50      	ldrb	r0, [r2, r1]
  txmsg.RTR = CAN_RTR_DATA;
  txmsg.DLC = 8;
  txmsg.data32[0] = 0x55AA55AA;
  txmsg.data32[1] = 0x00FF00FF;

  while (!chThdShouldTerminateX()) {
 8001eec:	0741      	lsls	r1, r0, #29
 8001eee:	d597      	bpl.n	8001e20 <can_tx.9460+0x30>
    canTransmit(&CAND1, CAN_ANY_MAILBOX, &txmsg, MS2ST(100));
    chThdSleepMilliseconds(1000);
    debug_write("CAN Tx");
  }
}
 8001ef0:	b004      	add	sp, #16
 8001ef2:	bc04      	pop	{r2}
 8001ef4:	4690      	mov	r8, r2
 8001ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Preparing the message.*/
  if (ctfp->IDE)
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
 8001ef8:	889a      	ldrh	r2, [r3, #4]
 8001efa:	0553      	lsls	r3, r2, #21
 8001efc:	e7cb      	b.n	8001e96 <can_tx.9460+0xa6>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001efe:	b672      	cpsid	i
 8001f00:	4d09      	ldr	r5, [pc, #36]	; (8001f28 <can_tx.9460+0x138>)
 8001f02:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001f04:	e7fe      	b.n	8001f04 <can_tx.9460+0x114>
 8001f06:	46c0      	nop			; (mov r8, r8)
 8001f08:	20001118 	.word	0x20001118
 8001f0c:	080029e8 	.word	0x080029e8
 8001f10:	01234567 	.word	0x01234567
 8001f14:	20001680 	.word	0x20001680
 8001f18:	080029f4 	.word	0x080029f4
 8001f1c:	08002930 	.word	0x08002930
 8001f20:	55aa55aa 	.word	0x55aa55aa
 8001f24:	00ff00ff 	.word	0x00ff00ff
 8001f28:	08002aa0 	.word	0x08002aa0
 8001f2c:	00002710 	.word	0x00002710

08001f30 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001f30:	4827      	ldr	r0, [pc, #156]	; (8001fd0 <__early_init+0xa0>)
 8001f32:	2301      	movs	r3, #1
 8001f34:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001f36:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001f38:	4313      	orrs	r3, r2
 8001f3a:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001f3c:	6803      	ldr	r3, [r0, #0]
 8001f3e:	4a24      	ldr	r2, [pc, #144]	; (8001fd0 <__early_init+0xa0>)
 8001f40:	4219      	tst	r1, r3
 8001f42:	d0fb      	beq.n	8001f3c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001f44:	6850      	ldr	r0, [r2, #4]
 8001f46:	2103      	movs	r1, #3
 8001f48:	4388      	bics	r0, r1
 8001f4a:	6050      	str	r0, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001f4c:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001f4e:	1c10      	adds	r0, r2, #0

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001f50:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001f52:	210c      	movs	r1, #12
 8001f54:	6843      	ldr	r3, [r0, #4]
 8001f56:	4a1e      	ldr	r2, [pc, #120]	; (8001fd0 <__early_init+0xa0>)
 8001f58:	400b      	ands	r3, r1
 8001f5a:	d1fb      	bne.n	8001f54 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001f5c:	6811      	ldr	r1, [r2, #0]
 8001f5e:	20f9      	movs	r0, #249	; 0xf9
 8001f60:	4001      	ands	r1, r0
 8001f62:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001f64:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001f66:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001f68:	2301      	movs	r3, #1
 8001f6a:	430b      	orrs	r3, r1
 8001f6c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8001f6e:	2002      	movs	r0, #2
 8001f70:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001f72:	4917      	ldr	r1, [pc, #92]	; (8001fd0 <__early_init+0xa0>)
 8001f74:	4218      	tst	r0, r3
 8001f76:	d0fb      	beq.n	8001f70 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001f78:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8001f7a:	2001      	movs	r0, #1
 8001f7c:	4310      	orrs	r0, r2
 8001f7e:	6248      	str	r0, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001f80:	2002      	movs	r0, #2
 8001f82:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001f84:	4a12      	ldr	r2, [pc, #72]	; (8001fd0 <__early_init+0xa0>)
 8001f86:	4218      	tst	r0, r3
 8001f88:	d0fb      	beq.n	8001f82 <__early_init+0x52>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001f8a:	21a0      	movs	r1, #160	; 0xa0
 8001f8c:	0388      	lsls	r0, r1, #14
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8001f8e:	2300      	movs	r3, #0
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001f90:	6050      	str	r0, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8001f92:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8001f94:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001f96:	6811      	ldr	r1, [r2, #0]
 8001f98:	2080      	movs	r0, #128	; 0x80
 8001f9a:	0443      	lsls	r3, r0, #17
 8001f9c:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001f9e:	2180      	movs	r1, #128	; 0x80
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001fa0:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001fa2:	0488      	lsls	r0, r1, #18
 8001fa4:	6813      	ldr	r3, [r2, #0]
 8001fa6:	490a      	ldr	r1, [pc, #40]	; (8001fd0 <__early_init+0xa0>)
 8001fa8:	4203      	tst	r3, r0
 8001faa:	d0fb      	beq.n	8001fa4 <__early_init+0x74>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001fac:	4809      	ldr	r0, [pc, #36]	; (8001fd4 <__early_init+0xa4>)
 8001fae:	2211      	movs	r2, #17
 8001fb0:	6002      	str	r2, [r0, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001fb2:	684a      	ldr	r2, [r1, #4]
 8001fb4:	2302      	movs	r3, #2
 8001fb6:	4313      	orrs	r3, r2
 8001fb8:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001fba:	200c      	movs	r0, #12
 8001fbc:	684b      	ldr	r3, [r1, #4]
 8001fbe:	4a04      	ldr	r2, [pc, #16]	; (8001fd0 <__early_init+0xa0>)
 8001fc0:	4003      	ands	r3, r0
 8001fc2:	2b08      	cmp	r3, #8
 8001fc4:	d1fa      	bne.n	8001fbc <__early_init+0x8c>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001fc6:	6991      	ldr	r1, [r2, #24]
 8001fc8:	2001      	movs	r0, #1
 8001fca:	4308      	orrs	r0, r1
 8001fcc:	6190      	str	r0, [r2, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 8001fce:	4770      	bx	lr
 8001fd0:	40021000 	.word	0x40021000
 8001fd4:	40022000 	.word	0x40022000
 8001fd8:	46c0      	nop			; (mov r8, r8)
 8001fda:	46c0      	nop			; (mov r8, r8)
 8001fdc:	46c0      	nop			; (mov r8, r8)
 8001fde:	46c0      	nop			; (mov r8, r8)

08001fe0 <main>:
 */

/*
 * Application entry point.
 */
int main(void) {
 8001fe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8001fe2:	4bea      	ldr	r3, [pc, #936]	; (800238c <main+0x3ac>)
 8001fe4:	465f      	mov	r7, fp
 8001fe6:	4656      	mov	r6, sl
 8001fe8:	464d      	mov	r5, r9
 8001fea:	4644      	mov	r4, r8
 8001fec:	2101      	movs	r1, #1
 8001fee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001ff0:	b4f0      	push	{r4, r5, r6, r7}
 8001ff2:	2200      	movs	r2, #0
 8001ff4:	424c      	negs	r4, r1
 8001ff6:	629c      	str	r4, [r3, #40]	; 0x28
 8001ff8:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001ffa:	6918      	ldr	r0, [r3, #16]
 8001ffc:	611c      	str	r4, [r3, #16]
 8001ffe:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8002000:	68dd      	ldr	r5, [r3, #12]
 8002002:	48e3      	ldr	r0, [pc, #908]	; (8002390 <main+0x3b0>)

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002004:	2780      	movs	r7, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8002006:	4305      	orrs	r5, r0
 8002008:	60dd      	str	r5, [r3, #12]
 800200a:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800200c:	69de      	ldr	r6, [r3, #28]
 800200e:	0579      	lsls	r1, r7, #21
 8002010:	4331      	orrs	r1, r6
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002012:	4de0      	ldr	r5, [pc, #896]	; (8002394 <main+0x3b4>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002014:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002016:	682c      	ldr	r4, [r5, #0]
 8002018:	2080      	movs	r0, #128	; 0x80
 800201a:	0046      	lsls	r6, r0, #1
 800201c:	4326      	orrs	r6, r4
 800201e:	602e      	str	r6, [r5, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8002020:	6a1f      	ldr	r7, [r3, #32]
 8002022:	21c0      	movs	r1, #192	; 0xc0
 8002024:	008d      	lsls	r5, r1, #2
 8002026:	2480      	movs	r4, #128	; 0x80
 8002028:	402f      	ands	r7, r5
 800202a:	00a0      	lsls	r0, r4, #2
 800202c:	4287      	cmp	r7, r0
 800202e:	d003      	beq.n	8002038 <main+0x58>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002030:	2680      	movs	r6, #128	; 0x80
 8002032:	0277      	lsls	r7, r6, #9
 8002034:	621f      	str	r7, [r3, #32]
    RCC->BDCR = 0;
 8002036:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8002038:	4bd4      	ldr	r3, [pc, #848]	; (800238c <main+0x3ac>)
 800203a:	2280      	movs	r2, #128	; 0x80
 800203c:	6a19      	ldr	r1, [r3, #32]
 800203e:	0215      	lsls	r5, r2, #8
 8002040:	4229      	tst	r1, r5
 8002042:	d107      	bne.n	8002054 <main+0x74>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8002044:	6a1c      	ldr	r4, [r3, #32]
 8002046:	2080      	movs	r0, #128	; 0x80
 8002048:	0086      	lsls	r6, r0, #2
 800204a:	4326      	orrs	r6, r4
 800204c:	621e      	str	r6, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800204e:	6a1f      	ldr	r7, [r3, #32]
 8002050:	433d      	orrs	r5, r7
 8002052:	621d      	str	r5, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002054:	4bcd      	ldr	r3, [pc, #820]	; (800238c <main+0x3ac>)
 8002056:	25fc      	movs	r5, #252	; 0xfc
 8002058:	695a      	ldr	r2, [r3, #20]
 800205a:	03ec      	lsls	r4, r5, #15
 800205c:	4314      	orrs	r4, r2
 800205e:	615c      	str	r4, [r3, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002060:	2090      	movs	r0, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
 8002062:	21fc      	movs	r1, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
 8002064:	4ccc      	ldr	r4, [pc, #816]	; (8002398 <main+0x3b8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002066:	05c6      	lsls	r6, r0, #23
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002068:	4699      	mov	r9, r3
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800206a:	060a      	lsls	r2, r1, #24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800206c:	2300      	movs	r3, #0
 800206e:	6073      	str	r3, [r6, #4]
 8002070:	1c37      	adds	r7, r6, #0
  gpiop->OSPEEDR = config->ospeedr;
 8002072:	60b2      	str	r2, [r6, #8]
 8002074:	1c35      	adds	r5, r6, #0
  gpiop->PUPDR   = config->pupdr;
 8002076:	60f4      	str	r4, [r6, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002078:	46b3      	mov	fp, r6
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800207a:	4ec8      	ldr	r6, [pc, #800]	; (800239c <main+0x3bc>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800207c:	20a0      	movs	r0, #160	; 0xa0
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800207e:	617e      	str	r6, [r7, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002080:	49c7      	ldr	r1, [pc, #796]	; (80023a0 <main+0x3c0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002082:	623b      	str	r3, [r7, #32]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002084:	22fc      	movs	r2, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8002086:	627b      	str	r3, [r7, #36]	; 0x24

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002088:	4cc6      	ldr	r4, [pc, #792]	; (80023a4 <main+0x3c4>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800208a:	0587      	lsls	r7, r0, #22
 800208c:	20a8      	movs	r0, #168	; 0xa8
 800208e:	602f      	str	r7, [r5, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002090:	0095      	lsls	r5, r2, #2
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8002092:	0607      	lsls	r7, r0, #24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002094:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002096:	4ac4      	ldr	r2, [pc, #784]	; (80023a8 <main+0x3c8>)
 8002098:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800209a:	48c4      	ldr	r0, [pc, #784]	; (80023ac <main+0x3cc>)

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800209c:	60cc      	str	r4, [r1, #12]
 800209e:	4dc4      	ldr	r5, [pc, #784]	; (80023b0 <main+0x3d0>)
  gpiop->ODR     = config->odr;
 80020a0:	614e      	str	r6, [r1, #20]
 80020a2:	4cc4      	ldr	r4, [pc, #784]	; (80023b4 <main+0x3d4>)
  gpiop->AFRL    = config->afrl;
 80020a4:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80020a6:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80020a8:	600f      	str	r7, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80020aa:	49c3      	ldr	r1, [pc, #780]	; (80023b8 <main+0x3d8>)
 80020ac:	4fc3      	ldr	r7, [pc, #780]	; (80023bc <main+0x3dc>)
 80020ae:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80020b0:	608a      	str	r2, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80020b2:	60cd      	str	r5, [r1, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80020b4:	4ac2      	ldr	r2, [pc, #776]	; (80023c0 <main+0x3e0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80020b6:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80020b8:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80020ba:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80020bc:	6008      	str	r0, [r1, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80020be:	49c1      	ldr	r1, [pc, #772]	; (80023c4 <main+0x3e4>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80020c0:	607b      	str	r3, [r7, #4]
 80020c2:	4dc1      	ldr	r5, [pc, #772]	; (80023c8 <main+0x3e8>)
  gpiop->OSPEEDR = config->ospeedr;
 80020c4:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80020c6:	4cc1      	ldr	r4, [pc, #772]	; (80023cc <main+0x3ec>)
 80020c8:	60f9      	str	r1, [r7, #12]
  gpiop->ODR     = config->odr;
 80020ca:	617e      	str	r6, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80020cc:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80020ce:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80020d0:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80020d2:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80020d4:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80020d6:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80020d8:	6156      	str	r6, [r2, #20]
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 80020da:	4fbd      	ldr	r7, [pc, #756]	; (80023d0 <main+0x3f0>)
  gpiop->AFRL    = config->afrl;
 80020dc:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80020de:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80020e0:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80020e2:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80020e4:	60ab      	str	r3, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80020e6:	60ec      	str	r4, [r5, #12]
  gpiop->ODR     = config->odr;
 80020e8:	616e      	str	r6, [r5, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80020ea:	1c3e      	adds	r6, r7, #0
 80020ec:	3608      	adds	r6, #8
  gpiop->AFRL    = config->afrl;
 80020ee:	622b      	str	r3, [r5, #32]
 80020f0:	1c38      	adds	r0, r7, #0
  gpiop->AFRH    = config->afrh;
 80020f2:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80020f4:	602b      	str	r3, [r5, #0]
 80020f6:	60be      	str	r6, [r7, #8]
  tqp->p_prev = (thread_t *)tqp;
 80020f8:	60fe      	str	r6, [r7, #12]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80020fa:	1c3e      	adds	r6, r7, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80020fc:	3010      	adds	r0, #16
 80020fe:	3624      	adds	r6, #36	; 0x24
 8002100:	1c3d      	adds	r5, r7, #0
 8002102:	1c3c      	adds	r4, r7, #0
 8002104:	6138      	str	r0, [r7, #16]
  tqp->p_prev = (thread_t *)tqp;
 8002106:	6178      	str	r0, [r7, #20]
 8002108:	627e      	str	r6, [r7, #36]	; 0x24
 800210a:	351c      	adds	r5, #28
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 800210c:	464e      	mov	r6, r9
 800210e:	3420      	adds	r4, #32
 8002110:	1c39      	adds	r1, r7, #0
 8002112:	1c38      	adds	r0, r7, #0
 8002114:	61fd      	str	r5, [r7, #28]
 8002116:	623c      	str	r4, [r7, #32]
 8002118:	69f5      	ldr	r5, [r6, #28]
 800211a:	3118      	adds	r1, #24
 800211c:	3028      	adds	r0, #40	; 0x28
 800211e:	2480      	movs	r4, #128	; 0x80
 8002120:	61b9      	str	r1, [r7, #24]
 8002122:	62b8      	str	r0, [r7, #40]	; 0x28
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 8002124:	49ab      	ldr	r1, [pc, #684]	; (80023d4 <main+0x3f4>)
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 8002126:	04a0      	lsls	r0, r4, #18
 8002128:	2201      	movs	r2, #1
 800212a:	4305      	orrs	r5, r0
 800212c:	703a      	strb	r2, [r7, #0]
  canp->config   = NULL;
 800212e:	607b      	str	r3, [r7, #4]
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 8002130:	62f9      	str	r1, [r7, #44]	; 0x2c
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 8002132:	61f5      	str	r5, [r6, #28]

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 8002134:	2580      	movs	r5, #128	; 0x80
 8002136:	00a8      	lsls	r0, r5, #2
 8002138:	580c      	ldr	r4, [r1, r0]
 800213a:	0c25      	lsrs	r5, r4, #16
 800213c:	042c      	lsls	r4, r5, #16
 800213e:	4da6      	ldr	r5, [pc, #664]	; (80023d8 <main+0x3f8>)
 8002140:	432c      	orrs	r4, r5
 8002142:	500c      	str	r4, [r1, r0]
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
 8002144:	2490      	movs	r4, #144	; 0x90
 8002146:	00a5      	lsls	r5, r4, #2
    CAN1->sFilterRegister[0].FR2 = 0;
 8002148:	2491      	movs	r4, #145	; 0x91
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
 800214a:	514b      	str	r3, [r1, r5]
    CAN1->sFilterRegister[0].FR2 = 0;
 800214c:	00a5      	lsls	r5, r4, #2
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
 800214e:	2481      	movs	r4, #129	; 0x81
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
    CAN1->sFilterRegister[0].FR2 = 0;
 8002150:	514b      	str	r3, [r1, r5]
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
 8002152:	00a5      	lsls	r5, r4, #2
    CAN1->FFA1R = 0;
 8002154:	2485      	movs	r4, #133	; 0x85
    CAN1->sFilterRegister[0].FR2 = 0;
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
 8002156:	514b      	str	r3, [r1, r5]
    CAN1->FFA1R = 0;
 8002158:	00a5      	lsls	r5, r4, #2
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
    CAN1->FA1R = 1 | (1 << can2sb);
#else
    CAN1->FS1R = 1;
 800215a:	2483      	movs	r4, #131	; 0x83
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
    CAN1->FFA1R = 0;
 800215c:	514b      	str	r3, [r1, r5]
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
    CAN1->FA1R = 1 | (1 << can2sb);
#else
    CAN1->FS1R = 1;
 800215e:	00a5      	lsls	r5, r4, #2
    CAN1->FA1R = 1;
 8002160:	2487      	movs	r4, #135	; 0x87
    CAN1->FFA1R = 0;
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
    CAN1->FA1R = 1 | (1 << can2sb);
#else
    CAN1->FS1R = 1;
 8002162:	514a      	str	r2, [r1, r5]
    CAN1->FA1R = 1;
 8002164:	00a5      	lsls	r5, r4, #2
 8002166:	514a      	str	r2, [r1, r5]
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 8002168:	580c      	ldr	r4, [r1, r0]
 800216a:	4394      	bics	r4, r2
 800216c:	500c      	str	r4, [r1, r0]

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800216e:	69f0      	ldr	r0, [r6, #28]
 8002170:	499a      	ldr	r1, [pc, #616]	; (80023dc <main+0x3fc>)
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8002172:	4d9b      	ldr	r5, [pc, #620]	; (80023e0 <main+0x400>)
 8002174:	4001      	ands	r1, r0
 8002176:	61f1      	str	r1, [r6, #28]
 8002178:	4e9a      	ldr	r6, [pc, #616]	; (80023e4 <main+0x404>)
 800217a:	1c2c      	adds	r4, r5, #0
 800217c:	c440      	stmia	r4!, {r6}
 800217e:	46b4      	mov	ip, r6
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8002180:	1c2e      	adds	r6, r5, #0
 8002182:	606c      	str	r4, [r5, #4]
 8002184:	3654      	adds	r6, #84	; 0x54
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002186:	24ca      	movs	r4, #202	; 0xca
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002188:	1c29      	adds	r1, r5, #0
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800218a:	61ae      	str	r6, [r5, #24]
  iqp->q_rdptr   = bp;
 800218c:	626e      	str	r6, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 800218e:	622e      	str	r6, [r5, #32]
 8002190:	310c      	adds	r1, #12
  iqp->q_top     = bp + size;
 8002192:	0060      	lsls	r0, r4, #1
 8002194:	1c2e      	adds	r6, r5, #0
 8002196:	60e9      	str	r1, [r5, #12]
  tqp->p_prev = (thread_t *)tqp;
 8002198:	6129      	str	r1, [r5, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800219a:	3630      	adds	r6, #48	; 0x30
 800219c:	1829      	adds	r1, r5, r0
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800219e:	20b5      	movs	r0, #181	; 0xb5
 80021a0:	632e      	str	r6, [r5, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 80021a2:	636e      	str	r6, [r5, #52]	; 0x34
 80021a4:	0086      	lsls	r6, r0, #2
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80021a6:	61e9      	str	r1, [r5, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80021a8:	63e9      	str	r1, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80021aa:	64a9      	str	r1, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80021ac:	6469      	str	r1, [r5, #68]	; 0x44
  oqp->q_top     = bp + size;
 80021ae:	19a9      	adds	r1, r5, r6
 80021b0:	6429      	str	r1, [r5, #64]	; 0x40
  oqp->q_notify  = onfy;
 80021b2:	488d      	ldr	r0, [pc, #564]	; (80023e8 <main+0x408>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 80021b4:	498d      	ldr	r1, [pc, #564]	; (80023ec <main+0x40c>)
 80021b6:	64e8      	str	r0, [r5, #76]	; 0x4c
 80021b8:	51a9      	str	r1, [r5, r6]
  SD1.clock = STM32_USART1CLK;
 80021ba:	20b6      	movs	r0, #182	; 0xb6
 80021bc:	4e8c      	ldr	r6, [pc, #560]	; (80023f0 <main+0x410>)
 80021be:	0081      	lsls	r1, r0, #2
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80021c0:	24a0      	movs	r4, #160	; 0xa0
 80021c2:	506e      	str	r6, [r5, r1]
 80021c4:	0064      	lsls	r4, r4, #1
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80021c6:	4e8b      	ldr	r6, [pc, #556]	; (80023f4 <main+0x414>)
 80021c8:	20c6      	movs	r0, #198	; 0xc6
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80021ca:	616b      	str	r3, [r5, #20]
 80021cc:	0081      	lsls	r1, r0, #2
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80021ce:	63ac      	str	r4, [r5, #56]	; 0x38
 80021d0:	46b0      	mov	r8, r6
 80021d2:	5876      	ldr	r6, [r6, r1]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80021d4:	722a      	strb	r2, [r5, #8]
 80021d6:	0230      	lsls	r0, r6, #8
 80021d8:	26c0      	movs	r6, #192	; 0xc0
 80021da:	0636      	lsls	r6, r6, #24
 80021dc:	0a00      	lsrs	r0, r0, #8
 80021de:	4330      	orrs	r0, r6
 80021e0:	4646      	mov	r6, r8
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80021e2:	62ab      	str	r3, [r5, #40]	; 0x28
  iqp->q_link    = link;
 80021e4:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80021e6:	652d      	str	r5, [r5, #80]	; 0x50
 80021e8:	5070      	str	r0, [r6, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80021ea:	2180      	movs	r1, #128	; 0x80
 80021ec:	20c0      	movs	r0, #192	; 0xc0
 80021ee:	0509      	lsls	r1, r1, #20
 80021f0:	0040      	lsls	r0, r0, #1
 80021f2:	5031      	str	r1, [r6, r0]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80021f4:	6031      	str	r1, [r6, #0]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80021f6:	4e80      	ldr	r6, [pc, #512]	; (80023f8 <main+0x418>)
 80021f8:	4660      	mov	r0, ip
 80021fa:	1c31      	adds	r1, r6, #0
 80021fc:	c101      	stmia	r1!, {r0}
 80021fe:	6071      	str	r1, [r6, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002200:	1c31      	adds	r1, r6, #0
 8002202:	310c      	adds	r1, #12
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8002204:	1c30      	adds	r0, r6, #0
 8002206:	60f1      	str	r1, [r6, #12]
  tqp->p_prev = (thread_t *)tqp;
 8002208:	6131      	str	r1, [r6, #16]
 800220a:	3054      	adds	r0, #84	; 0x54
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800220c:	21ca      	movs	r1, #202	; 0xca
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800220e:	61b0      	str	r0, [r6, #24]
  iqp->q_rdptr   = bp;
 8002210:	6270      	str	r0, [r6, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8002212:	6230      	str	r0, [r6, #32]
  iqp->q_top     = bp + size;
 8002214:	0048      	lsls	r0, r1, #1
 8002216:	1831      	adds	r1, r6, r0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002218:	2030      	movs	r0, #48	; 0x30
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800221a:	6173      	str	r3, [r6, #20]
 800221c:	1980      	adds	r0, r0, r6
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800221e:	63b4      	str	r4, [r6, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8002220:	24b5      	movs	r4, #181	; 0xb5
 8002222:	6330      	str	r0, [r6, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8002224:	6370      	str	r0, [r6, #52]	; 0x34
 8002226:	00a0      	lsls	r0, r4, #2
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002228:	61f1      	str	r1, [r6, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 800222a:	63f1      	str	r1, [r6, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 800222c:	64b1      	str	r1, [r6, #72]	; 0x48
  oqp->q_wrptr   = bp;
 800222e:	6471      	str	r1, [r6, #68]	; 0x44
  oqp->q_top     = bp + size;
 8002230:	1831      	adds	r1, r6, r0
 8002232:	6431      	str	r1, [r6, #64]	; 0x40
  oqp->q_notify  = onfy;
 8002234:	4c71      	ldr	r4, [pc, #452]	; (80023fc <main+0x41c>)
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8002236:	4972      	ldr	r1, [pc, #456]	; (8002400 <main+0x420>)
 8002238:	64f4      	str	r4, [r6, #76]	; 0x4c
 800223a:	5031      	str	r1, [r6, r0]
  SD2.clock = STM32_USART2CLK;
 800223c:	4c6c      	ldr	r4, [pc, #432]	; (80023f0 <main+0x410>)
 800223e:	20b6      	movs	r0, #182	; 0xb6
 8002240:	0081      	lsls	r1, r0, #2
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8002242:	20c7      	movs	r0, #199	; 0xc7
 8002244:	5074      	str	r4, [r6, r1]
 8002246:	4644      	mov	r4, r8
 8002248:	0081      	lsls	r1, r0, #2
 800224a:	5860      	ldr	r0, [r4, r1]
 800224c:	21ff      	movs	r1, #255	; 0xff
 800224e:	4388      	bics	r0, r1
 8002250:	21c0      	movs	r1, #192	; 0xc0
 8002252:	4301      	orrs	r1, r0
 8002254:	20c7      	movs	r0, #199	; 0xc7
 8002256:	0080      	lsls	r0, r0, #2
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8002258:	7232      	strb	r2, [r6, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800225a:	62b3      	str	r3, [r6, #40]	; 0x28
  iqp->q_link    = link;
 800225c:	62f6      	str	r6, [r6, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 800225e:	6536      	str	r6, [r6, #80]	; 0x50
 8002260:	5021      	str	r1, [r4, r0]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002262:	2180      	movs	r1, #128	; 0x80
 8002264:	20c0      	movs	r0, #192	; 0xc0
 8002266:	0549      	lsls	r1, r1, #21
 8002268:	0040      	lsls	r0, r0, #1
 800226a:	5021      	str	r1, [r4, r0]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800226c:	6021      	str	r1, [r4, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800226e:	464c      	mov	r4, r9
 8002270:	69e1      	ldr	r1, [r4, #28]
 8002272:	4311      	orrs	r1, r2
 8002274:	61e1      	str	r1, [r4, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002276:	4c63      	ldr	r4, [pc, #396]	; (8002404 <main+0x424>)

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002278:	2180      	movs	r1, #128	; 0x80

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800227a:	68a0      	ldr	r0, [r4, #8]
 800227c:	4310      	orrs	r0, r2
 800227e:	60a0      	str	r0, [r4, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002280:	05cc      	lsls	r4, r1, #23
 8002282:	4961      	ldr	r1, [pc, #388]	; (8002408 <main+0x428>)
 8002284:	1c20      	adds	r0, r4, #0
 8002286:	62a1      	str	r1, [r4, #40]	; 0x28
 8002288:	46a2      	mov	sl, r4
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800228a:	2401      	movs	r4, #1
 800228c:	4261      	negs	r1, r4
 800228e:	62c1      	str	r1, [r0, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002290:	6183      	str	r3, [r0, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002292:	6343      	str	r3, [r0, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8002294:	60c3      	str	r3, [r0, #12]
  STM32_ST_TIM->CR2    = 0;
 8002296:	6043      	str	r3, [r0, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002298:	6142      	str	r2, [r0, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800229a:	6002      	str	r2, [r0, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800229c:	20c3      	movs	r0, #195	; 0xc3
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800229e:	468c      	mov	ip, r1
 80022a0:	4644      	mov	r4, r8
 80022a2:	0081      	lsls	r1, r0, #2
 80022a4:	5860      	ldr	r0, [r4, r1]
 80022a6:	0204      	lsls	r4, r0, #8
 80022a8:	0a20      	lsrs	r0, r4, #8
 80022aa:	2480      	movs	r4, #128	; 0x80
 80022ac:	0624      	lsls	r4, r4, #24
 80022ae:	4320      	orrs	r0, r4
 80022b0:	4644      	mov	r4, r8
 80022b2:	5060      	str	r0, [r4, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022b4:	2180      	movs	r1, #128	; 0x80
 80022b6:	20c0      	movs	r0, #192	; 0xc0
 80022b8:	0209      	lsls	r1, r1, #8
 80022ba:	0040      	lsls	r0, r0, #1
 80022bc:	5021      	str	r1, [r4, r0]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80022be:	6021      	str	r1, [r4, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80022c0:	4952      	ldr	r1, [pc, #328]	; (800240c <main+0x42c>)
 80022c2:	4c53      	ldr	r4, [pc, #332]	; (8002410 <main+0x430>)
 80022c4:	6a08      	ldr	r0, [r1, #32]
 80022c6:	4020      	ands	r0, r4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80022c8:	4c52      	ldr	r4, [pc, #328]	; (8002414 <main+0x434>)
 80022ca:	6208      	str	r0, [r1, #32]
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 80022cc:	4660      	mov	r0, ip
 80022ce:	6260      	str	r0, [r4, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80022d0:	1c21      	adds	r1, r4, #0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80022d2:	4851      	ldr	r0, [pc, #324]	; (8002418 <main+0x438>)
 80022d4:	311c      	adds	r1, #28
 80022d6:	61e1      	str	r1, [r4, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80022d8:	6221      	str	r1, [r4, #32]
 80022da:	3007      	adds	r0, #7
 80022dc:	2107      	movs	r1, #7
 80022de:	4388      	bics	r0, r1
 80022e0:	4684      	mov	ip, r0
 80022e2:	484e      	ldr	r0, [pc, #312]	; (800241c <main+0x43c>)
 80022e4:	4661      	mov	r1, ip
 80022e6:	6001      	str	r1, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80022e8:	484d      	ldr	r0, [pc, #308]	; (8002420 <main+0x440>)
 80022ea:	2107      	movs	r1, #7
 80022ec:	4388      	bics	r0, r1
 80022ee:	494d      	ldr	r1, [pc, #308]	; (8002424 <main+0x444>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 80022f0:	60a3      	str	r3, [r4, #8]
 80022f2:	6008      	str	r0, [r1, #0]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80022f4:	494c      	ldr	r1, [pc, #304]	; (8002428 <main+0x448>)
 80022f6:	484d      	ldr	r0, [pc, #308]	; (800242c <main+0x44c>)
  default_heap.h_free.h.u.next = NULL;
 80022f8:	608b      	str	r3, [r1, #8]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80022fa:	6008      	str	r0, [r1, #0]
 80022fc:	1c08      	adds	r0, r1, #0
 80022fe:	3010      	adds	r0, #16
 8002300:	6108      	str	r0, [r1, #16]
  tqp->p_prev = (thread_t *)tqp;
 8002302:	6148      	str	r0, [r1, #20]
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8002304:	1c20      	adds	r0, r4, #0
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
 8002306:	60cb      	str	r3, [r1, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8002308:	618b      	str	r3, [r1, #24]
 800230a:	3040      	adds	r0, #64	; 0x40
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 800230c:	2140      	movs	r1, #64	; 0x40
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 800230e:	62a3      	str	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002310:	6024      	str	r4, [r4, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002312:	6064      	str	r4, [r4, #4]
 8002314:	63a1      	str	r1, [r4, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8002316:	63e0      	str	r0, [r4, #60]	; 0x3c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002318:	2089      	movs	r0, #137	; 0x89
 800231a:	00c0      	lsls	r0, r0, #3
 800231c:	5021      	str	r1, [r4, r0]
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800231e:	4844      	ldr	r0, [pc, #272]	; (8002430 <main+0x450>)
 8002320:	5423      	strb	r3, [r4, r0]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002322:	2090      	movs	r0, #144	; 0x90
 8002324:	00c0      	lsls	r0, r0, #3
 8002326:	5021      	str	r1, [r4, r0]
  tp->p_mtxlist = NULL;
 8002328:	4942      	ldr	r1, [pc, #264]	; (8002434 <main+0x454>)
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800232a:	208f      	movs	r0, #143	; 0x8f
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800232c:	5063      	str	r3, [r4, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800232e:	00c1      	lsls	r1, r0, #3
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002330:	4841      	ldr	r0, [pc, #260]	; (8002438 <main+0x458>)
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002332:	5063      	str	r3, [r4, r1]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002334:	218b      	movs	r1, #139	; 0x8b
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002336:	5422      	strb	r2, [r4, r0]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002338:	00c8      	lsls	r0, r1, #3
 800233a:	5023      	str	r3, [r4, r0]
  REG_INSERT(tp);
 800233c:	238a      	movs	r3, #138	; 0x8a
 800233e:	483f      	ldr	r0, [pc, #252]	; (800243c <main+0x45c>)
 8002340:	00d9      	lsls	r1, r3, #3
 8002342:	2388      	movs	r3, #136	; 0x88
 8002344:	5024      	str	r4, [r4, r0]
 8002346:	5064      	str	r4, [r4, r1]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002348:	208d      	movs	r0, #141	; 0x8d
 800234a:	00d9      	lsls	r1, r3, #3
 800234c:	1863      	adds	r3, r4, r1
 800234e:	00c1      	lsls	r1, r0, #3
 8002350:	1860      	adds	r0, r4, r1
 8002352:	218d      	movs	r1, #141	; 0x8d
 8002354:	00c9      	lsls	r1, r1, #3
 8002356:	5060      	str	r0, [r4, r1]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002358:	4839      	ldr	r0, [pc, #228]	; (8002440 <main+0x460>)
 800235a:	6123      	str	r3, [r4, #16]
 800235c:	1821      	adds	r1, r4, r0
 800235e:	5021      	str	r1, [r4, r0]
  tqp->p_prev = (thread_t *)tqp;
 8002360:	208e      	movs	r0, #142	; 0x8e
 8002362:	00c0      	lsls	r0, r0, #3
 8002364:	6163      	str	r3, [r4, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8002366:	61a3      	str	r3, [r4, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8002368:	238c      	movs	r3, #140	; 0x8c
 800236a:	5021      	str	r1, [r4, r0]
 800236c:	00d9      	lsls	r1, r3, #3
 800236e:	5462      	strb	r2, [r4, r1]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8002370:	4834      	ldr	r0, [pc, #208]	; (8002444 <main+0x464>)
 8002372:	4a35      	ldr	r2, [pc, #212]	; (8002448 <main+0x468>)
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002374:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002376:	5022      	str	r2, [r4, r0]
 8002378:	2b00      	cmp	r3, #0
 800237a:	d102      	bne.n	8002382 <main+0x3a2>
 800237c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800237e:	2900      	cmp	r1, #0
 8002380:	d066      	beq.n	8002450 <main+0x470>
 8002382:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8002384:	4831      	ldr	r0, [pc, #196]	; (800244c <main+0x46c>)
 8002386:	62e0      	str	r0, [r4, #44]	; 0x2c
 8002388:	e7fe      	b.n	8002388 <main+0x3a8>
 800238a:	46c0      	nop			; (mov r8, r8)
 800238c:	40021000 	.word	0x40021000
 8002390:	ffbfffff 	.word	0xffbfffff
 8002394:	40007000 	.word	0x40007000
 8002398:	64155554 	.word	0x64155554
 800239c:	0000ffff 	.word	0x0000ffff
 80023a0:	48000400 	.word	0x48000400
 80023a4:	01555555 	.word	0x01555555
 80023a8:	f00ff003 	.word	0xf00ff003
 80023ac:	00055001 	.word	0x00055001
 80023b0:	05500554 	.word	0x05500554
 80023b4:	0000fc3f 	.word	0x0000fc3f
 80023b8:	48000800 	.word	0x48000800
 80023bc:	48000c00 	.word	0x48000c00
 80023c0:	48001000 	.word	0x48001000
 80023c4:	55555555 	.word	0x55555555
 80023c8:	48001400 	.word	0x48001400
 80023cc:	55555550 	.word	0x55555550
 80023d0:	20001680 	.word	0x20001680
 80023d4:	40006400 	.word	0x40006400
 80023d8:	00000e01 	.word	0x00000e01
 80023dc:	fdffffff 	.word	0xfdffffff
 80023e0:	20000b58 	.word	0x20000b58
 80023e4:	08002a80 	.word	0x08002a80
 80023e8:	08000df1 	.word	0x08000df1
 80023ec:	40013800 	.word	0x40013800
 80023f0:	02dc6c00 	.word	0x02dc6c00
 80023f4:	e000e100 	.word	0xe000e100
 80023f8:	20000e34 	.word	0x20000e34
 80023fc:	08000de1 	.word	0x08000de1
 8002400:	40004400 	.word	0x40004400
 8002404:	40015800 	.word	0x40015800
 8002408:	000012bf 	.word	0x000012bf
 800240c:	e000ed00 	.word	0xe000ed00
 8002410:	ff00ffff 	.word	0xff00ffff
 8002414:	20001118 	.word	0x20001118
 8002418:	20001a80 	.word	0x20001a80
 800241c:	20001110 	.word	0x20001110
 8002420:	20004000 	.word	0x20004000
 8002424:	20000a00 	.word	0x20000a00
 8002428:	20001a60 	.word	0x20001a60
 800242c:	08000b31 	.word	0x08000b31
 8002430:	00000461 	.word	0x00000461
 8002434:	0000047c 	.word	0x0000047c
 8002438:	00000462 	.word	0x00000462
 800243c:	00000454 	.word	0x00000454
 8002440:	0000046c 	.word	0x0000046c
 8002444:	0000045c 	.word	0x0000045c
 8002448:	20000400 	.word	0x20000400
 800244c:	08002a40 	.word	0x08002a40
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002450:	b662      	cpsie	i
 8002452:	4a52      	ldr	r2, [pc, #328]	; (800259c <main+0x5bc>)
 8002454:	69a0      	ldr	r0, [r4, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8002456:	2391      	movs	r3, #145	; 0x91
 8002458:	00d9      	lsls	r1, r3, #3
 800245a:	6182      	str	r2, [r0, #24]
 800245c:	4b50      	ldr	r3, [pc, #320]	; (80025a0 <main+0x5c0>)
 800245e:	1860      	adds	r0, r4, r1
 8002460:	2201      	movs	r2, #1
 8002462:	21e0      	movs	r1, #224	; 0xe0
 8002464:	f7fe fab4 	bl	80009d0 <chThdCreateStatic.constprop.38>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8002468:	4a4e      	ldr	r2, [pc, #312]	; (80025a4 <main+0x5c4>)
  halInit();
  chSysInit();


  /* CAN RX.       */
  palSetPadMode(GPIOA, 11, PAL_STM32_MODE_ALTERNATE | PAL_STM32_PUPDR_PULLUP  | PAL_STM32_ALTERNATE(4));
 800246a:	2380      	movs	r3, #128	; 0x80
 800246c:	0119      	lsls	r1, r3, #4
 800246e:	6182      	str	r2, [r0, #24]
 8002470:	4658      	mov	r0, fp
 8002472:	4a4d      	ldr	r2, [pc, #308]	; (80025a8 <main+0x5c8>)
 8002474:	f7fe ffd4 	bl	8001420 <_pal_lld_setgroupmode>
  /* CAN TX.       */
  palSetPadMode(GPIOA, 12, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_ALTERNATE(4));
 8002478:	2180      	movs	r1, #128	; 0x80
 800247a:	4658      	mov	r0, fp
 800247c:	0149      	lsls	r1, r1, #5
 800247e:	4a4b      	ldr	r2, [pc, #300]	; (80025ac <main+0x5cc>)
 8002480:	f7fe ffce 	bl	8001420 <_pal_lld_setgroupmode>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002484:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002486:	f7fe f943 	bl	8000710 <_dbg_check_lock>
void canStart(CANDriver *canp, const CANConfig *config) {

  osalDbgCheck(canp != NULL);

  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");
 800248a:	7839      	ldrb	r1, [r7, #0]
 800248c:	2901      	cmp	r1, #1
 800248e:	d003      	beq.n	8002498 <main+0x4b8>
 8002490:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8002492:	4e47      	ldr	r6, [pc, #284]	; (80025b0 <main+0x5d0>)
 8002494:	62e6      	str	r6, [r4, #44]	; 0x2c
 8002496:	e7fe      	b.n	8002496 <main+0x4b6>

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
  canp->config = config;
 8002498:	4a46      	ldr	r2, [pc, #280]	; (80025b4 <main+0x5d4>)

  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
 800249a:	2002      	movs	r0, #2
 800249c:	7038      	strb	r0, [r7, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800249e:	20c7      	movs	r0, #199	; 0xc7
  canp->config = config;
 80024a0:	607a      	str	r2, [r7, #4]
 80024a2:	0083      	lsls	r3, r0, #2
 80024a4:	4693      	mov	fp, r2
 80024a6:	4642      	mov	r2, r8
 80024a8:	58d2      	ldr	r2, [r2, r3]
 80024aa:	4843      	ldr	r0, [pc, #268]	; (80025b8 <main+0x5d8>)
 80024ac:	23c0      	movs	r3, #192	; 0xc0
 80024ae:	4010      	ands	r0, r2
 80024b0:	041a      	lsls	r2, r3, #16
 80024b2:	4302      	orrs	r2, r0
 80024b4:	20c7      	movs	r0, #199	; 0xc7
 80024b6:	4643      	mov	r3, r8
 80024b8:	0080      	lsls	r0, r0, #2
 80024ba:	501a      	str	r2, [r3, r0]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80024bc:	22c0      	movs	r2, #192	; 0xc0
 80024be:	4650      	mov	r0, sl
 80024c0:	0052      	lsls	r2, r2, #1
 80024c2:	5098      	str	r0, [r3, r2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80024c4:	6018      	str	r0, [r3, #0]
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX1_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
#endif
    rccEnableCAN1(FALSE);
 80024c6:	464a      	mov	r2, r9
 80024c8:	69d3      	ldr	r3, [r2, #28]
 80024ca:	2080      	movs	r0, #128	; 0x80
 80024cc:	0480      	lsls	r0, r0, #18
 80024ce:	4303      	orrs	r3, r0
 80024d0:	61d3      	str	r3, [r2, #28]
    rccEnableCAN2(FALSE);
  }
#endif

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
 80024d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80024d4:	6019      	str	r1, [r3, #0]
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
 80024d6:	685a      	ldr	r2, [r3, #4]
 80024d8:	4211      	tst	r1, r2
 80024da:	d109      	bne.n	80024f0 <main+0x510>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80024dc:	2008      	movs	r0, #8
 80024de:	2101      	movs	r1, #1
 80024e0:	f7ff f8f6 	bl	80016d0 <chSchGoSleepTimeoutS>
 80024e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80024e6:	6858      	ldr	r0, [r3, #4]
 80024e8:	07c1      	lsls	r1, r0, #31
 80024ea:	d5f7      	bpl.n	80024dc <main+0x4fc>
 80024ec:	6879      	ldr	r1, [r7, #4]
 80024ee:	e000      	b.n	80024f2 <main+0x512>
 80024f0:	4659      	mov	r1, fp
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
 80024f2:	684a      	ldr	r2, [r1, #4]
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  | CAN_IER_LECIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
#else
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 80024f4:	4831      	ldr	r0, [pc, #196]	; (80025bc <main+0x5dc>)
  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
  canp->can->MCR = canp->config->mcr;
 80024f6:	6809      	ldr	r1, [r1, #0]

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
 80024f8:	61da      	str	r2, [r3, #28]
  canp->can->MCR = canp->config->mcr;
 80024fa:	6019      	str	r1, [r3, #0]
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
                   CAN_IER_WKUIE  | CAN_IER_ERRIE  | CAN_IER_LECIE  |
                   CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
                   CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
#else
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 80024fc:	6158      	str	r0, [r3, #20]
  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 80024fe:	2303      	movs	r3, #3
 8002500:	703b      	strb	r3, [r7, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002502:	f7fe f8ed 	bl	80006e0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002506:	6827      	ldr	r7, [r4, #0]
 8002508:	42a7      	cmp	r7, r4
 800250a:	d004      	beq.n	8002516 <main+0x536>
 800250c:	69a2      	ldr	r2, [r4, #24]
 800250e:	68b8      	ldr	r0, [r7, #8]
 8002510:	6891      	ldr	r1, [r2, #8]
 8002512:	4281      	cmp	r1, r0
 8002514:	d33d      	bcc.n	8002592 <main+0x5b2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002516:	b662      	cpsie	i


  /* Initialize connection to STN1110 on SD2
   */
  static SerialConfig stn_uart_cfg;
  stn_uart_cfg.speed=9600;
 8002518:	4b29      	ldr	r3, [pc, #164]	; (80025c0 <main+0x5e0>)
 800251a:	2496      	movs	r4, #150	; 0x96
 800251c:	01a7      	lsls	r7, r4, #6

  /* USART2 TX.       */
  palSetPadMode(GPIOA, 2, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_HIGHEST | PAL_STM32_ALTERNATE(1));
 800251e:	2290      	movs	r2, #144	; 0x90


  /* Initialize connection to STN1110 on SD2
   */
  static SerialConfig stn_uart_cfg;
  stn_uart_cfg.speed=9600;
 8002520:	601f      	str	r7, [r3, #0]

  /* USART2 TX.       */
  palSetPadMode(GPIOA, 2, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_HIGHEST | PAL_STM32_ALTERNATE(1));
 8002522:	05d0      	lsls	r0, r2, #23
 8002524:	2104      	movs	r1, #4
 8002526:	229a      	movs	r2, #154	; 0x9a
 8002528:	f7fe ff7a 	bl	8001420 <_pal_lld_setgroupmode>

  /* USART2 RX.       */
  palSetPadMode(GPIOA, 3, PAL_STM32_MODE_ALTERNATE | PAL_STM32_PUPDR_PULLUP | PAL_STM32_ALTERNATE(1));
 800252c:	2190      	movs	r1, #144	; 0x90
 800252e:	05c8      	lsls	r0, r1, #23
 8002530:	22a2      	movs	r2, #162	; 0xa2
 8002532:	2108      	movs	r1, #8
 8002534:	f7fe ff74 	bl	8001420 <_pal_lld_setgroupmode>

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8002538:	2480      	movs	r4, #128	; 0x80
  palSetPadMode(GPIOA, 2, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_HIGHEST | PAL_STM32_ALTERNATE(1));

  /* USART2 RX.       */
  palSetPadMode(GPIOA, 3, PAL_STM32_MODE_ALTERNATE | PAL_STM32_PUPDR_PULLUP | PAL_STM32_ALTERNATE(1));

  sdStart(&SD2, NULL);
 800253a:	1c30      	adds	r0, r6, #0

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 800253c:	2690      	movs	r6, #144	; 0x90
  palSetPadMode(GPIOA, 2, PAL_STM32_MODE_ALTERNATE | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_HIGHEST | PAL_STM32_ALTERNATE(1));

  /* USART2 RX.       */
  palSetPadMode(GPIOA, 3, PAL_STM32_MODE_ALTERNATE | PAL_STM32_PUPDR_PULLUP | PAL_STM32_ALTERNATE(1));

  sdStart(&SD2, NULL);
 800253e:	f7fe fb27 	bl	8000b90 <sdStart.constprop.10>

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8002542:	05f0      	lsls	r0, r6, #23
 8002544:	00a1      	lsls	r1, r4, #2
 8002546:	2282      	movs	r2, #130	; 0x82
 8002548:	f7fe ff6a 	bl	8001420 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 800254c:	2780      	movs	r7, #128	; 0x80
 800254e:	2090      	movs	r0, #144	; 0x90
 8002550:	00f9      	lsls	r1, r7, #3
 8002552:	2282      	movs	r2, #130	; 0x82
 8002554:	05c0      	lsls	r0, r0, #23
 8002556:	f7fe ff63 	bl	8001420 <_pal_lld_setgroupmode>
  sdStart(&SD1, NULL);
 800255a:	1c28      	adds	r0, r5, #0

  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 800255c:	25a8      	movs	r5, #168	; 0xa8
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
  sdStart(&SD1, NULL);
 800255e:	f7fe fb17 	bl	8000b90 <sdStart.constprop.10>

  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 8002562:	0069      	lsls	r1, r5, #1
 8002564:	2240      	movs	r2, #64	; 0x40
 8002566:	4b17      	ldr	r3, [pc, #92]	; (80025c4 <main+0x5e4>)
 8002568:	4817      	ldr	r0, [pc, #92]	; (80025c8 <main+0x5e8>)
 800256a:	f7fe fa31 	bl	80009d0 <chThdCreateStatic.constprop.38>
  chThdCreateStatic(can_rx_wa, sizeof(can_rx_wa), NORMALPRIO + 7, can_rx, NULL);
 800256e:	23e8      	movs	r3, #232	; 0xe8
 8002570:	0059      	lsls	r1, r3, #1
 8002572:	2247      	movs	r2, #71	; 0x47
 8002574:	4b15      	ldr	r3, [pc, #84]	; (80025cc <main+0x5ec>)
 8002576:	4816      	ldr	r0, [pc, #88]	; (80025d0 <main+0x5f0>)
 8002578:	f7fe fa2a 	bl	80009d0 <chThdCreateStatic.constprop.38>
  chThdCreateStatic(can_tx_wa, sizeof(can_tx_wa), NORMALPRIO + 7, can_tx, NULL);
 800257c:	22e8      	movs	r2, #232	; 0xe8
 800257e:	0051      	lsls	r1, r2, #1
 8002580:	4814      	ldr	r0, [pc, #80]	; (80025d4 <main+0x5f4>)
 8002582:	2247      	movs	r2, #71	; 0x47
 8002584:	4b14      	ldr	r3, [pc, #80]	; (80025d8 <main+0x5f8>)
 8002586:	f7fe fa23 	bl	80009d0 <chThdCreateStatic.constprop.38>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched with output on the serial
   * driver 1.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 800258a:	4814      	ldr	r0, [pc, #80]	; (80025dc <main+0x5fc>)
 800258c:	f7fe f938 	bl	8000800 <chThdSleep>
 8002590:	e7fb      	b.n	800258a <main+0x5aa>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002592:	b672      	cpsid	i
 8002594:	4912      	ldr	r1, [pc, #72]	; (80025e0 <main+0x600>)
 8002596:	62e1      	str	r1, [r4, #44]	; 0x2c
 8002598:	e7fe      	b.n	8002598 <main+0x5b8>
 800259a:	46c0      	nop			; (mov r8, r8)
 800259c:	08002a50 	.word	0x08002a50
 80025a0:	08000e11 	.word	0x08000e11
 80025a4:	08002a48 	.word	0x08002a48
 80025a8:	00000222 	.word	0x00000222
 80025ac:	00000202 	.word	0x00000202
 80025b0:	08002a70 	.word	0x08002a70
 80025b4:	08002a30 	.word	0x08002a30
 80025b8:	ff00ffff 	.word	0xff00ffff
 80025bc:	0001875b 	.word	0x0001875b
 80025c0:	20001a50 	.word	0x20001a50
 80025c4:	08001a11 	.word	0x08001a11
 80025c8:	20000a08 	.word	0x20000a08
 80025cc:	08001af1 	.word	0x08001af1
 80025d0:	200016b0 	.word	0x200016b0
 80025d4:	20001880 	.word	0x20001880
 80025d8:	08001df1 	.word	0x08001df1
 80025dc:	00001388 	.word	0x00001388
 80025e0:	08002aa0 	.word	0x08002aa0
 80025e4:	46c0      	nop			; (mov r8, r8)
 80025e6:	46c0      	nop			; (mov r8, r8)
 80025e8:	46c0      	nop			; (mov r8, r8)
 80025ea:	46c0      	nop			; (mov r8, r8)
 80025ec:	46c0      	nop			; (mov r8, r8)
 80025ee:	46c0      	nop			; (mov r8, r8)

080025f0 <strlen>:
 80025f0:	2300      	movs	r3, #0
 80025f2:	5cc2      	ldrb	r2, [r0, r3]
 80025f4:	3301      	adds	r3, #1
 80025f6:	2a00      	cmp	r2, #0
 80025f8:	d1fb      	bne.n	80025f2 <strlen+0x2>
 80025fa:	1e58      	subs	r0, r3, #1
 80025fc:	4770      	bx	lr
 80025fe:	46c0      	nop			; (mov r8, r8)

08002600 <__func__.5046.8270.4567>:
 8002600:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08002610 <__func__.6452.8271.4565>:
 8002610:	6473 7453 7261 0074 0000 0000 0000 0000     sdStart.........

08002620 <__func__.5761.5091.4562>:
 8002620:	6863 6854 4364 6572 7461 4965 0000 0000     chThdCreateI....

08002630 <__func__.5777.4851.4563>:
 8002630:	6863 6353 5768 6b61 7565 5370 0000 0000     chSchWakeupS....

08002640 <ram_areas.4018.4568>:
 8002640:	2eb0 0800 1a80 2000 1a80 2000 1a80 2000     ....... ... ... 
 8002650:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................
 8002660:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................
 8002670:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................
 8002680:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................
 8002690:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................
 80026a0:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................
 80026b0:	2eb0 0800 0000 0000 0000 0000 0000 0000     ................

080026c0 <__func__.5220.5089.4560>:
 80026c0:	6863 6854 5364 656c 7065 0053 0000 0000     chThdSleepS.....
 80026d0:	5653 3523 0000 0000 5653 3423 0000 0000     SV#5....SV#4....
 80026e0:	7473 6675 3a66 0020 7473 6361 206b 766f     stuff: .stack ov
 80026f0:	7265 6c66 776f 0000 0000 0000 0000 0000     erflow..........

08002700 <__func__.5046.6877.4564>:
 8002700:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08002710 <__func__.5232.5087.4607>:
 8002710:	6863 6854 4464 446f 7165 6575 6575 654e     chThdDoDequeueNe
 8002720:	7478 0049 0000 0000 0000 0000 0000 0000     xtI.............

08002730 <__func__.5046.5090.4559>:
 8002730:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08002740 <__func__.5808.6805.4561>:
 8002740:	6863 514f 7257 7469 5465 6d69 6f65 7475     chOQWriteTimeout
	...
 8002760:	111c 0800 0ede 0800 0ede 0800 0ede 0800     ................
 8002770:	0ede 0800 111c 0800 0ede 0800 0ede 0800     ................
 8002780:	0ede 0800 0ede 0800 0ede 0800 1118 0800     ................
 8002790:	0ede 0800 0ede 0800 0ede 0800 0ede 0800     ................
 80027a0:	0ede 0800 1114 0800 0ede 0800 0ede 0800     ................
 80027b0:	10fc 0800 0ede 0800 0ede 0800 0ede 0800     ................
 80027c0:	0ede 0800 0ede 0800 0ede 0800 0ede 0800     ................
 80027d0:	0ede 0800 0ede 0800 0ede 0800 10e4 0800     ................
 80027e0:	111c 0800 0ede 0800 0ede 0800 0ede 0800     ................
 80027f0:	0ede 0800 111c 0800 0ede 0800 0ede 0800     ................
 8002800:	0ede 0800 0ede 0800 0ede 0800 1118 0800     ................
 8002810:	0ede 0800 0ede 0800 0ede 0800 1092 0800     ................
 8002820:	0ede 0800 1114 0800 0ede 0800 0ede 0800     ................
 8002830:	10fc 0800 0000 0000 0000 0000 0000 0000     ................
 8002840:	131c 0800 1310 0800 1310 0800 1324 0800     ............$...
 8002850:	1306 0800 12fa 0800 1310 0800 1306 0800     ................

08002860 <__func__.5135.4318.4429>:
 8002860:	6863 5456 6f44 6954 6b63 0049 0000 0000     chVTDoTickI.....

08002870 <__func__.5749.4850.4425>:
 8002870:	6863 6353 5268 6165 7964 0049 0000 0000     chSchReadyI.....

08002880 <__func__.6407.7348.4428>:
 8002880:	7473 7453 7261 4174 616c 6d72 0000 0000     stStartAlarm....

08002890 <__func__.6414.7349.4430>:
 8002890:	7473 6553 4174 616c 6d72 0000 0000 0000     stSetAlarm......
 80028a0:	6e28 6c75 296c 0000 5653 3623 0000 0000     (null)..SV#6....
 80028b0:	5653 3723 0000 0000 5653 3823 0000 0000     SV#7....SV#8....
 80028c0:	5653 3923 0000 0000 5653 3123 0030 0000     SV#9....SV#10...
 80028d0:	5653 3123 0031 0000 0000 0000 0000 0000     SV#11...........

080028e0 <__func__.5752.4588.4427>:
 80028e0:	6863 5456 6f44 6553 4974 0000 0000 0000     chVTDoSetI......

080028f0 <__func__.5769.6221.4384>:
 80028f0:	6863 7645 4274 6f72 6461 6163 7473 6c46     chEvtBroadcastFl
 8002900:	6761 4973 0000 0000 0000 0000 0000 0000     agsI............

08002910 <__func__.5786.6219.4385>:
 8002910:	6863 7645 5374 6769 616e 496c 0000 0000     chEvtSignalI....

08002920 <__func__.5772.6804.4523>:
 8002920:	6863 5149 6552 6461 6954 656d 756f 0074     chIQReadTimeout.

08002930 <__func__.6434.7925.4530>:
 8002930:	6163 546e 6172 736e 696d 0074 0000 0000     canTransmit.....

08002940 <__func__.5805.5093.4520>:
 8002940:	6863 6854 4564 6978 5374 0000 0000 0000     chThdExitS......
 8002950:	5453 314e 3131 5f30 5852 0000 6572 6573     STN1110_RX..rese
 8002960:	7474 6e69 0067 0000 6661 6574 2072 6572     tting...after re
 8002970:	6573 0074 5441 4520 0d30 0000 5441 5320     set.AT E0...AT S
 8002980:	2050 0d30 0000 0000 3130 4330 000d 0000     P 0.....010C....
 8002990:	6157 7469 6e69 2067 6f66 2072 5441 7220     Waiting for AT r
 80029a0:	7365 6f70 736e 0065 7942 6574 2073 6572     esponse.Bytes re
 80029b0:	6461 2520 0d69 000a 7266 7165 2520 0d69     ad %i...freq %i.
 80029c0:	000a 0000 4143 204e 7852 7320 6174 7472     ....CAN Rx start
 80029d0:	6e69 0067 6572 6563 7669 7265 0000 0000     ing.receiver....
 80029e0:	4143 204e 7852 0000 7274 6e61 6d73 7469     CAN Rx..transmit
 80029f0:	6574 0072 4143 204e 7854 0000 0000 0000     ter.CAN Tx......

08002a00 <__func__.5046.6803>:
 8002a00:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08002a10 <__func__.5046.6216.4526>:
 8002a10:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08002a20 <__func__.6445.7926.4527>:
 8002a20:	6163 526e 6365 6965 6576 0000 0000 0000     canReceive......

08002a30 <cancfg.9580.4557>:
 8002a30:	0040 0000 0002 0129 0000 0000 0000 0000     @.....).........
 8002a40:	5653 3323 0000 0000 6469 656c 0000 0000     SV#3....idle....

08002a50 <ch_debug.4584>:
 8002a50:	616d 6e69 1600 1844 0404 0848 100c 1814     main..D...H.....
 8002a60:	201c 2221 0000 0000 0000 0000 0000 0000     . !"............

08002a70 <__func__.6411.7921.4580>:
 8002a70:	6163 536e 6174 7472 0000 0000 0000 0000     canStart........

08002a80 <vmt.8322.4627>:
 8002a80:	09c1 0800 1a01 0800 07f1 0800 1de1 0800     ................
 8002a90:	07e1 0800 1dd1 0800 09b1 0800 19f1 0800     ................

08002aa0 <__func__.5046.7920>:
 8002aa0:	6863 7953 5573 6c6e 636f 006b               chSysUnlock.
