
build/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000100 <Reset_Handler>:
 8000100:	b672      	cpsid	i
 8000102:	4822      	ldr	r0, [pc, #136]	; (800018c <endfiniloop+0x4>)
 8000104:	f380 8809 	msr	PSP, r0
 8000108:	2002      	movs	r0, #2
 800010a:	f380 8814 	msr	CONTROL, r0
 800010e:	f3bf 8f6f 	isb	sy
 8000112:	f000 fb4d 	bl	80007b0 <__core_init>
 8000116:	f001 fc13 	bl	8001940 <__early_init>
 800011a:	481d      	ldr	r0, [pc, #116]	; (8000190 <endfiniloop+0x8>)
 800011c:	491d      	ldr	r1, [pc, #116]	; (8000194 <endfiniloop+0xc>)
 800011e:	4a1e      	ldr	r2, [pc, #120]	; (8000198 <endfiniloop+0x10>)

08000120 <msloop>:
 8000120:	4291      	cmp	r1, r2
 8000122:	da02      	bge.n	800012a <endmsloop>
 8000124:	6008      	str	r0, [r1, #0]
 8000126:	3104      	adds	r1, #4
 8000128:	e7fa      	b.n	8000120 <msloop>

0800012a <endmsloop>:
 800012a:	491c      	ldr	r1, [pc, #112]	; (800019c <endfiniloop+0x14>)
 800012c:	4a17      	ldr	r2, [pc, #92]	; (800018c <endfiniloop+0x4>)

0800012e <psloop>:
 800012e:	4291      	cmp	r1, r2
 8000130:	da02      	bge.n	8000138 <endpsloop>
 8000132:	6008      	str	r0, [r1, #0]
 8000134:	3104      	adds	r1, #4
 8000136:	e7fa      	b.n	800012e <psloop>

08000138 <endpsloop>:
 8000138:	4919      	ldr	r1, [pc, #100]	; (80001a0 <endfiniloop+0x18>)
 800013a:	4a1a      	ldr	r2, [pc, #104]	; (80001a4 <endfiniloop+0x1c>)
 800013c:	4b1a      	ldr	r3, [pc, #104]	; (80001a8 <endfiniloop+0x20>)

0800013e <dloop>:
 800013e:	429a      	cmp	r2, r3
 8000140:	da04      	bge.n	800014c <enddloop>
 8000142:	6808      	ldr	r0, [r1, #0]
 8000144:	6010      	str	r0, [r2, #0]
 8000146:	3104      	adds	r1, #4
 8000148:	3204      	adds	r2, #4
 800014a:	e7f8      	b.n	800013e <dloop>

0800014c <enddloop>:
 800014c:	2000      	movs	r0, #0
 800014e:	4917      	ldr	r1, [pc, #92]	; (80001ac <endfiniloop+0x24>)
 8000150:	4a17      	ldr	r2, [pc, #92]	; (80001b0 <endfiniloop+0x28>)

08000152 <bloop>:
 8000152:	4291      	cmp	r1, r2
 8000154:	da02      	bge.n	800015c <endbloop>
 8000156:	6008      	str	r0, [r1, #0]
 8000158:	3104      	adds	r1, #4
 800015a:	e7fa      	b.n	8000152 <bloop>

0800015c <endbloop>:
 800015c:	f000 fac8 	bl	80006f0 <__init_ram_areas>
 8000160:	f000 fb1e 	bl	80007a0 <__late_init>
 8000164:	4c13      	ldr	r4, [pc, #76]	; (80001b4 <endfiniloop+0x2c>)
 8000166:	4d14      	ldr	r5, [pc, #80]	; (80001b8 <endfiniloop+0x30>)

08000168 <initloop>:
 8000168:	42ac      	cmp	r4, r5
 800016a:	da03      	bge.n	8000174 <endinitloop>
 800016c:	6821      	ldr	r1, [r4, #0]
 800016e:	4788      	blx	r1
 8000170:	3404      	adds	r4, #4
 8000172:	e7f9      	b.n	8000168 <initloop>

08000174 <endinitloop>:
 8000174:	f001 f9ac 	bl	80014d0 <main>
 8000178:	4c10      	ldr	r4, [pc, #64]	; (80001bc <endfiniloop+0x34>)
 800017a:	4d11      	ldr	r5, [pc, #68]	; (80001c0 <endfiniloop+0x38>)

0800017c <finiloop>:
 800017c:	42ac      	cmp	r4, r5
 800017e:	da03      	bge.n	8000188 <endfiniloop>
 8000180:	6821      	ldr	r1, [r4, #0]
 8000182:	4788      	blx	r1
 8000184:	3404      	adds	r4, #4
 8000186:	e7f9      	b.n	800017c <finiloop>

08000188 <endfiniloop>:
 8000188:	490e      	ldr	r1, [pc, #56]	; (80001c4 <endfiniloop+0x3c>)
 800018a:	4708      	bx	r1
 800018c:	20000600 	.word	0x20000600
 8000190:	55555555 	.word	0x55555555
 8000194:	20000000 	.word	0x20000000
 8000198:	20000400 	.word	0x20000400
 800019c:	20000400 	.word	0x20000400
 80001a0:	08001da8 	.word	0x08001da8
 80001a4:	20000600 	.word	0x20000600
 80001a8:	20000a00 	.word	0x20000a00
 80001ac:	20000a00 	.word	0x20000a00
 80001b0:	20001428 	.word	0x20001428
 80001b4:	08000100 	.word	0x08000100
 80001b8:	08000100 	.word	0x08000100
 80001bc:	08000100 	.word	0x08000100
 80001c0:	08000100 	.word	0x08000100
 80001c4:	08000791 	.word	0x08000791
	...

080001d0 <_port_switch>:
 80001d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001d2:	4644      	mov	r4, r8
 80001d4:	464d      	mov	r5, r9
 80001d6:	4656      	mov	r6, sl
 80001d8:	465f      	mov	r7, fp
 80001da:	b4f0      	push	{r4, r5, r6, r7}
 80001dc:	466b      	mov	r3, sp
 80001de:	60cb      	str	r3, [r1, #12]
 80001e0:	68c3      	ldr	r3, [r0, #12]
 80001e2:	469d      	mov	sp, r3
 80001e4:	bcf0      	pop	{r4, r5, r6, r7}
 80001e6:	46a0      	mov	r8, r4
 80001e8:	46a9      	mov	r9, r5
 80001ea:	46b2      	mov	sl, r6
 80001ec:	46bb      	mov	fp, r7
 80001ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001f0 <_port_thread_start>:
 80001f0:	f000 f9b6 	bl	8000560 <_dbg_check_unlock>
 80001f4:	b662      	cpsie	i
 80001f6:	1c28      	adds	r0, r5, #0
 80001f8:	47a0      	blx	r4
 80001fa:	2000      	movs	r0, #0
 80001fc:	f001 fc28 	bl	8001a50 <chThdExit>

08000200 <_port_switch_from_isr>:
 8000200:	f000 f9c6 	bl	8000590 <_dbg_check_lock>
 8000204:	f001 fbf4 	bl	80019f0 <chSchDoReschedule>
 8000208:	f000 f9aa 	bl	8000560 <_dbg_check_unlock>

0800020c <_port_exit_from_isr>:
 800020c:	4a01      	ldr	r2, [pc, #4]	; (8000214 <_port_exit_from_isr+0x8>)
 800020e:	4b02      	ldr	r3, [pc, #8]	; (8000218 <_port_exit_from_isr+0xc>)
 8000210:	6013      	str	r3, [r2, #0]
 8000212:	e7fe      	b.n	8000212 <_port_exit_from_isr+0x6>
 8000214:	e000ed04 	.word	0xe000ed04
 8000218:	80000000 	.word	0x80000000
 800021c:	00000000 	.word	0x00000000

08000220 <__aeabi_uidiv>:
 8000220:	2900      	cmp	r1, #0
 8000222:	d034      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>

08000224 <.udivsi3_skip_div0_test>:
 8000224:	2301      	movs	r3, #1
 8000226:	2200      	movs	r2, #0
 8000228:	b410      	push	{r4}
 800022a:	4288      	cmp	r0, r1
 800022c:	d32c      	bcc.n	8000288 <.udivsi3_skip_div0_test+0x64>
 800022e:	2401      	movs	r4, #1
 8000230:	0724      	lsls	r4, r4, #28
 8000232:	42a1      	cmp	r1, r4
 8000234:	d204      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 8000236:	4281      	cmp	r1, r0
 8000238:	d202      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 800023a:	0109      	lsls	r1, r1, #4
 800023c:	011b      	lsls	r3, r3, #4
 800023e:	e7f8      	b.n	8000232 <.udivsi3_skip_div0_test+0xe>
 8000240:	00e4      	lsls	r4, r4, #3
 8000242:	42a1      	cmp	r1, r4
 8000244:	d204      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000246:	4281      	cmp	r1, r0
 8000248:	d202      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 800024a:	0049      	lsls	r1, r1, #1
 800024c:	005b      	lsls	r3, r3, #1
 800024e:	e7f8      	b.n	8000242 <.udivsi3_skip_div0_test+0x1e>
 8000250:	4288      	cmp	r0, r1
 8000252:	d301      	bcc.n	8000258 <.udivsi3_skip_div0_test+0x34>
 8000254:	1a40      	subs	r0, r0, r1
 8000256:	431a      	orrs	r2, r3
 8000258:	084c      	lsrs	r4, r1, #1
 800025a:	42a0      	cmp	r0, r4
 800025c:	d302      	bcc.n	8000264 <.udivsi3_skip_div0_test+0x40>
 800025e:	1b00      	subs	r0, r0, r4
 8000260:	085c      	lsrs	r4, r3, #1
 8000262:	4322      	orrs	r2, r4
 8000264:	088c      	lsrs	r4, r1, #2
 8000266:	42a0      	cmp	r0, r4
 8000268:	d302      	bcc.n	8000270 <.udivsi3_skip_div0_test+0x4c>
 800026a:	1b00      	subs	r0, r0, r4
 800026c:	089c      	lsrs	r4, r3, #2
 800026e:	4322      	orrs	r2, r4
 8000270:	08cc      	lsrs	r4, r1, #3
 8000272:	42a0      	cmp	r0, r4
 8000274:	d302      	bcc.n	800027c <.udivsi3_skip_div0_test+0x58>
 8000276:	1b00      	subs	r0, r0, r4
 8000278:	08dc      	lsrs	r4, r3, #3
 800027a:	4322      	orrs	r2, r4
 800027c:	2800      	cmp	r0, #0
 800027e:	d003      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000280:	091b      	lsrs	r3, r3, #4
 8000282:	d001      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000284:	0909      	lsrs	r1, r1, #4
 8000286:	e7e3      	b.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000288:	1c10      	adds	r0, r2, #0
 800028a:	bc10      	pop	{r4}
 800028c:	4770      	bx	lr
 800028e:	2800      	cmp	r0, #0
 8000290:	d001      	beq.n	8000296 <.udivsi3_skip_div0_test+0x72>
 8000292:	2000      	movs	r0, #0
 8000294:	43c0      	mvns	r0, r0
 8000296:	b407      	push	{r0, r1, r2}
 8000298:	4802      	ldr	r0, [pc, #8]	; (80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029a:	a102      	add	r1, pc, #8	; (adr r1, 80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029c:	1840      	adds	r0, r0, r1
 800029e:	9002      	str	r0, [sp, #8]
 80002a0:	bd03      	pop	{r0, r1, pc}
 80002a2:	46c0      	nop			; (mov r8, r8)
 80002a4:	0000001d 	.word	0x0000001d

080002a8 <__aeabi_uidivmod>:
 80002a8:	2900      	cmp	r1, #0
 80002aa:	d0f0      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>
 80002ac:	b503      	push	{r0, r1, lr}
 80002ae:	f7ff ffb9 	bl	8000224 <.udivsi3_skip_div0_test>
 80002b2:	bc0e      	pop	{r1, r2, r3}
 80002b4:	4342      	muls	r2, r0
 80002b6:	1a89      	subs	r1, r1, r2
 80002b8:	4718      	bx	r3
 80002ba:	46c0      	nop			; (mov r8, r8)
 80002bc:	0000      	movs	r0, r0
	...

080002c0 <__aeabi_idiv0>:
 80002c0:	4770      	bx	lr
 80002c2:	46c0      	nop			; (mov r8, r8)
	...

080002d0 <_dbg_check_lock_from_isr.4415>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80002d0:	4b06      	ldr	r3, [pc, #24]	; (80002ec <_dbg_check_lock_from_isr.4415+0x1c>)
 80002d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80002d4:	2a00      	cmp	r2, #0
 80002d6:	dd02      	ble.n	80002de <_dbg_check_lock_from_isr.4415+0xe>
 80002d8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80002da:	2800      	cmp	r0, #0
 80002dc:	d003      	beq.n	80002e6 <_dbg_check_lock_from_isr.4415+0x16>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80002de:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80002e0:	4a03      	ldr	r2, [pc, #12]	; (80002f0 <_dbg_check_lock_from_isr.4415+0x20>)
 80002e2:	62da      	str	r2, [r3, #44]	; 0x2c
 80002e4:	e7fe      	b.n	80002e4 <_dbg_check_lock_from_isr.4415+0x14>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80002e6:	2101      	movs	r1, #1
 80002e8:	6359      	str	r1, [r3, #52]	; 0x34
}
 80002ea:	4770      	bx	lr
 80002ec:	20000d38 	.word	0x20000d38
 80002f0:	08001b70 	.word	0x08001b70
 80002f4:	46c0      	nop			; (mov r8, r8)
 80002f6:	46c0      	nop			; (mov r8, r8)
 80002f8:	46c0      	nop			; (mov r8, r8)
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	46c0      	nop			; (mov r8, r8)
 80002fe:	46c0      	nop			; (mov r8, r8)

08000300 <_dbg_check_unlock_from_isr.4417>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000300:	4b06      	ldr	r3, [pc, #24]	; (800031c <_dbg_check_unlock_from_isr.4417+0x1c>)
 8000302:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000304:	2a00      	cmp	r2, #0
 8000306:	dd05      	ble.n	8000314 <_dbg_check_unlock_from_isr.4417+0x14>
 8000308:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800030a:	2800      	cmp	r0, #0
 800030c:	dd02      	ble.n	8000314 <_dbg_check_unlock_from_isr.4417+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 800030e:	2100      	movs	r1, #0
 8000310:	6359      	str	r1, [r3, #52]	; 0x34
}
 8000312:	4770      	bx	lr
 8000314:	b672      	cpsid	i
 8000316:	4a02      	ldr	r2, [pc, #8]	; (8000320 <_dbg_check_unlock_from_isr.4417+0x20>)
 8000318:	62da      	str	r2, [r3, #44]	; 0x2c
 800031a:	e7fe      	b.n	800031a <_dbg_check_unlock_from_isr.4417+0x1a>
 800031c:	20000d38 	.word	0x20000d38
 8000320:	08001b78 	.word	0x08001b78
 8000324:	46c0      	nop			; (mov r8, r8)
 8000326:	46c0      	nop			; (mov r8, r8)
 8000328:	46c0      	nop			; (mov r8, r8)
 800032a:	46c0      	nop			; (mov r8, r8)
 800032c:	46c0      	nop			; (mov r8, r8)
 800032e:	46c0      	nop			; (mov r8, r8)

08000330 <_dbg_check_enter_isr.4419>:
 8000330:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000332:	4b07      	ldr	r3, [pc, #28]	; (8000350 <_dbg_check_enter_isr.4419+0x20>)
 8000334:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000336:	2a00      	cmp	r2, #0
 8000338:	db02      	blt.n	8000340 <_dbg_check_enter_isr.4419+0x10>
 800033a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800033c:	2900      	cmp	r1, #0
 800033e:	d003      	beq.n	8000348 <_dbg_check_enter_isr.4419+0x18>
 8000340:	b672      	cpsid	i
 8000342:	4804      	ldr	r0, [pc, #16]	; (8000354 <_dbg_check_enter_isr.4419+0x24>)
 8000344:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000346:	e7fe      	b.n	8000346 <_dbg_check_enter_isr.4419+0x16>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 8000348:	3201      	adds	r2, #1
 800034a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800034c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800034e:	4770      	bx	lr
 8000350:	20000d38 	.word	0x20000d38
 8000354:	08001b80 	.word	0x08001b80
 8000358:	46c0      	nop			; (mov r8, r8)
 800035a:	46c0      	nop			; (mov r8, r8)
 800035c:	46c0      	nop			; (mov r8, r8)
 800035e:	46c0      	nop			; (mov r8, r8)

08000360 <_dbg_check_leave_isr.4421>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000360:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000362:	4b07      	ldr	r3, [pc, #28]	; (8000380 <_dbg_check_leave_isr.4421+0x20>)
 8000364:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000366:	2a00      	cmp	r2, #0
 8000368:	dd02      	ble.n	8000370 <_dbg_check_leave_isr.4421+0x10>
 800036a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800036c:	2900      	cmp	r1, #0
 800036e:	d003      	beq.n	8000378 <_dbg_check_leave_isr.4421+0x18>
 8000370:	b672      	cpsid	i
 8000372:	4804      	ldr	r0, [pc, #16]	; (8000384 <_dbg_check_leave_isr.4421+0x24>)
 8000374:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000376:	e7fe      	b.n	8000376 <_dbg_check_leave_isr.4421+0x16>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8000378:	3a01      	subs	r2, #1
 800037a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800037c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800037e:	4770      	bx	lr
 8000380:	20000d38 	.word	0x20000d38
 8000384:	08001b88 	.word	0x08001b88
 8000388:	46c0      	nop			; (mov r8, r8)
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	46c0      	nop			; (mov r8, r8)
 800038e:	46c0      	nop			; (mov r8, r8)

08000390 <chDbgCheckClassI.4434>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000390:	4b05      	ldr	r3, [pc, #20]	; (80003a8 <chDbgCheckClassI.4434+0x18>)
 8000392:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000394:	2a00      	cmp	r2, #0
 8000396:	db03      	blt.n	80003a0 <chDbgCheckClassI.4434+0x10>
 8000398:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800039a:	2800      	cmp	r0, #0
 800039c:	dd00      	ble.n	80003a0 <chDbgCheckClassI.4434+0x10>
    chSysHalt("SV#10");
  }
}
 800039e:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003a0:	b672      	cpsid	i
 80003a2:	4902      	ldr	r1, [pc, #8]	; (80003ac <chDbgCheckClassI.4434+0x1c>)
 80003a4:	62d9      	str	r1, [r3, #44]	; 0x2c
 80003a6:	e7fe      	b.n	80003a6 <chDbgCheckClassI.4434+0x16>
 80003a8:	20000d38 	.word	0x20000d38
 80003ac:	08001b90 	.word	0x08001b90

080003b0 <chDbgCheckClassS.4439>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80003b0:	4b05      	ldr	r3, [pc, #20]	; (80003c8 <chDbgCheckClassS.4439+0x18>)
 80003b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003b4:	2a00      	cmp	r2, #0
 80003b6:	d103      	bne.n	80003c0 <chDbgCheckClassS.4439+0x10>
 80003b8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80003ba:	2800      	cmp	r0, #0
 80003bc:	dd00      	ble.n	80003c0 <chDbgCheckClassS.4439+0x10>
    chSysHalt("SV#11");
  }
}
 80003be:	4770      	bx	lr
 80003c0:	b672      	cpsid	i
 80003c2:	4902      	ldr	r1, [pc, #8]	; (80003cc <chDbgCheckClassS.4439+0x1c>)
 80003c4:	62d9      	str	r1, [r3, #44]	; 0x2c
 80003c6:	e7fe      	b.n	80003c6 <chDbgCheckClassS.4439+0x16>
 80003c8:	20000d38 	.word	0x20000d38
 80003cc:	08001b98 	.word	0x08001b98

080003d0 <stSetAlarm.4441>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80003d0:	2380      	movs	r3, #128	; 0x80
 80003d2:	05db      	lsls	r3, r3, #23
 80003d4:	68da      	ldr	r2, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80003d6:	0791      	lsls	r1, r2, #30
 80003d8:	d501      	bpl.n	80003de <stSetAlarm.4441+0xe>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80003da:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
 80003dc:	4770      	bx	lr
 80003de:	b672      	cpsid	i
 80003e0:	4801      	ldr	r0, [pc, #4]	; (80003e8 <stSetAlarm.4441+0x18>)
 80003e2:	4902      	ldr	r1, [pc, #8]	; (80003ec <stSetAlarm.4441+0x1c>)
 80003e4:	62c8      	str	r0, [r1, #44]	; 0x2c
 80003e6:	e7fe      	b.n	80003e6 <stSetAlarm.4441+0x16>
 80003e8:	08001b50 	.word	0x08001b50
 80003ec:	20000d38 	.word	0x20000d38

080003f0 <notify2.8355>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80003f0:	4b02      	ldr	r3, [pc, #8]	; (80003fc <notify2.8355+0xc>)
 80003f2:	2280      	movs	r2, #128	; 0x80
 80003f4:	6819      	ldr	r1, [r3, #0]
 80003f6:	430a      	orrs	r2, r1
 80003f8:	601a      	str	r2, [r3, #0]
}
 80003fa:	4770      	bx	lr
 80003fc:	40004400 	.word	0x40004400

08000400 <notify1.8358>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000400:	4b02      	ldr	r3, [pc, #8]	; (800040c <notify1.8358+0xc>)
 8000402:	2280      	movs	r2, #128	; 0x80
 8000404:	6819      	ldr	r1, [r3, #0]
 8000406:	430a      	orrs	r2, r1
 8000408:	601a      	str	r2, [r3, #0]
}
 800040a:	4770      	bx	lr
 800040c:	40013800 	.word	0x40013800

08000410 <_port_irq_epilogue.4479>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000410:	300f      	adds	r0, #15
 8000412:	d011      	beq.n	8000438 <_port_irq_epilogue.4479+0x28>
 8000414:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000416:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800041a:	3b20      	subs	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800041c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000420:	2280      	movs	r2, #128	; 0x80
 8000422:	0450      	lsls	r0, r2, #17
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000424:	4a06      	ldr	r2, [pc, #24]	; (8000440 <_port_irq_epilogue.4479+0x30>)
 8000426:	61d8      	str	r0, [r3, #28]
 8000428:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800042a:	6990      	ldr	r0, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800042c:	6889      	ldr	r1, [r1, #8]
 800042e:	6882      	ldr	r2, [r0, #8]
 8000430:	4291      	cmp	r1, r2
 8000432:	d802      	bhi.n	800043a <_port_irq_epilogue.4479+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000434:	4803      	ldr	r0, [pc, #12]	; (8000444 <_port_irq_epilogue.4479+0x34>)
 8000436:	6198      	str	r0, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000438:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800043a:	4903      	ldr	r1, [pc, #12]	; (8000448 <_port_irq_epilogue.4479+0x38>)
 800043c:	6199      	str	r1, [r3, #24]
 800043e:	e7fb      	b.n	8000438 <_port_irq_epilogue.4479+0x28>
 8000440:	20000d38 	.word	0x20000d38
 8000444:	0800020c 	.word	0x0800020c
 8000448:	08000201 	.word	0x08000201
 800044c:	46c0      	nop			; (mov r8, r8)
 800044e:	46c0      	nop			; (mov r8, r8)

08000450 <NMI_Handler.4487>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000450:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000454:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000456:	f383 8809 	msr	PSP, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800045a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800045c:	4770      	bx	lr
 800045e:	46c0      	nop			; (mov r8, r8)

08000460 <_idle_thread.4252>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000460:	e7fe      	b.n	8000460 <_idle_thread.4252>
 8000462:	46c0      	nop			; (mov r8, r8)
 8000464:	46c0      	nop			; (mov r8, r8)
 8000466:	46c0      	nop			; (mov r8, r8)
 8000468:	46c0      	nop			; (mov r8, r8)
 800046a:	46c0      	nop			; (mov r8, r8)
 800046c:	46c0      	nop			; (mov r8, r8)
 800046e:	46c0      	nop			; (mov r8, r8)

08000470 <BusFault_Handler.4501>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000470:	e7fe      	b.n	8000470 <BusFault_Handler.4501>
 8000472:	46c0      	nop			; (mov r8, r8)
 8000474:	46c0      	nop			; (mov r8, r8)
 8000476:	46c0      	nop			; (mov r8, r8)
 8000478:	46c0      	nop			; (mov r8, r8)
 800047a:	46c0      	nop			; (mov r8, r8)
 800047c:	46c0      	nop			; (mov r8, r8)
 800047e:	46c0      	nop			; (mov r8, r8)

08000480 <Vector7C.4400>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000480:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000482:	464e      	mov	r6, r9
 8000484:	4657      	mov	r7, sl
 8000486:	4645      	mov	r5, r8
 8000488:	b4e0      	push	{r5, r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800048a:	2680      	movs	r6, #128	; 0x80
 800048c:	05f6      	lsls	r6, r6, #23
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800048e:	46f1      	mov	r9, lr
 8000490:	f7ff ff4e 	bl	8000330 <_dbg_check_enter_isr.4419>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000494:	6933      	ldr	r3, [r6, #16]
 8000496:	079a      	lsls	r2, r3, #30
 8000498:	d409      	bmi.n	80004ae <Vector7C.4400+0x2e>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800049a:	f7ff ff61 	bl	8000360 <_dbg_check_leave_isr.4421>
 800049e:	4648      	mov	r0, r9
 80004a0:	f7ff ffb6 	bl	8000410 <_port_irq_epilogue.4479>
}
 80004a4:	bc1c      	pop	{r2, r3, r4}
 80004a6:	4690      	mov	r8, r2
 80004a8:	4699      	mov	r9, r3
 80004aa:	46a2      	mov	sl, r4
 80004ac:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 80004ae:	2000      	movs	r0, #0
 80004b0:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004b2:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80004b4:	f7ff ff0c 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 80004b8:	f7ff ff6a 	bl	8000390 <chDbgCheckClassI.4434>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 80004bc:	f7ff ff68 	bl	8000390 <chDbgCheckClassI.4434>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80004c0:	4c22      	ldr	r4, [pc, #136]	; (800054c <Vector7C.4400+0xcc>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80004c2:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80004c4:	69e5      	ldr	r5, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80004c6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80004c8:	68aa      	ldr	r2, [r5, #8]
 80004ca:	1a5f      	subs	r7, r3, r1
 80004cc:	4297      	cmp	r7, r2
 80004ce:	d31d      	bcc.n	800050c <Vector7C.4400+0x8c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80004d0:	231c      	movs	r3, #28
 80004d2:	1918      	adds	r0, r3, r4
 80004d4:	4680      	mov	r8, r0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80004d6:	2700      	movs	r7, #0
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80004d8:	188a      	adds	r2, r1, r2

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80004da:	68e8      	ldr	r0, [r5, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80004dc:	6829      	ldr	r1, [r5, #0]
 80004de:	4643      	mov	r3, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80004e0:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80004e2:	4682      	mov	sl, r0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80004e4:	604b      	str	r3, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80004e6:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80004e8:	60ef      	str	r7, [r5, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80004ea:	4541      	cmp	r1, r8
 80004ec:	d02b      	beq.n	8000546 <Vector7C.4400+0xc6>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80004ee:	f7ff ff07 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80004f2:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 80004f4:	6928      	ldr	r0, [r5, #16]
 80004f6:	47d0      	blx	sl
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004f8:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80004fa:	f7ff fee9 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80004fe:	69e5      	ldr	r5, [r4, #28]
 8000500:	6a73      	ldr	r3, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000502:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000504:	68aa      	ldr	r2, [r5, #8]
 8000506:	1a58      	subs	r0, r3, r1
 8000508:	4282      	cmp	r2, r0
 800050a:	d9e5      	bls.n	80004d8 <Vector7C.4400+0x58>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800050c:	4e10      	ldr	r6, [pc, #64]	; (8000550 <Vector7C.4400+0xd0>)
 800050e:	42b5      	cmp	r5, r6
 8000510:	d013      	beq.n	800053a <Vector7C.4400+0xba>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8000512:	188f      	adds	r7, r1, r2
 8000514:	1afd      	subs	r5, r7, r3
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000516:	2d01      	cmp	r5, #1
 8000518:	d913      	bls.n	8000542 <Vector7C.4400+0xc2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 800051a:	18ee      	adds	r6, r5, r3
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800051c:	1c30      	adds	r0, r6, #0
 800051e:	f7ff ff57 	bl	80003d0 <stSetAlarm.4441>
 8000522:	2380      	movs	r3, #128	; 0x80
 8000524:	05da      	lsls	r2, r3, #23

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 8000526:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000528:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800052a:	1a75      	subs	r5, r6, r1
 800052c:	1a47      	subs	r7, r0, r1
 800052e:	42af      	cmp	r7, r5
 8000530:	d903      	bls.n	800053a <Vector7C.4400+0xba>
 8000532:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000534:	4e07      	ldr	r6, [pc, #28]	; (8000554 <Vector7C.4400+0xd4>)
 8000536:	62e6      	str	r6, [r4, #44]	; 0x2c
 8000538:	e7fe      	b.n	8000538 <Vector7C.4400+0xb8>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800053a:	f7ff fee1 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800053e:	b662      	cpsie	i
 8000540:	e7ab      	b.n	800049a <Vector7C.4400+0x1a>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000542:	2502      	movs	r5, #2
 8000544:	e7e9      	b.n	800051a <Vector7C.4400+0x9a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000546:	60f7      	str	r7, [r6, #12]
 8000548:	e7d1      	b.n	80004ee <Vector7C.4400+0x6e>
 800054a:	46c0      	nop			; (mov r8, r8)
 800054c:	20000d38 	.word	0x20000d38
 8000550:	20000d54 	.word	0x20000d54
 8000554:	08001c90 	.word	0x08001c90
 8000558:	46c0      	nop			; (mov r8, r8)
 800055a:	46c0      	nop			; (mov r8, r8)
 800055c:	46c0      	nop			; (mov r8, r8)
 800055e:	46c0      	nop			; (mov r8, r8)

08000560 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000560:	4b06      	ldr	r3, [pc, #24]	; (800057c <_dbg_check_unlock+0x1c>)
 8000562:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000564:	2a00      	cmp	r2, #0
 8000566:	d104      	bne.n	8000572 <_dbg_check_unlock+0x12>
 8000568:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800056a:	2900      	cmp	r1, #0
 800056c:	dd01      	ble.n	8000572 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800056e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000570:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000572:	b672      	cpsid	i
 8000574:	4802      	ldr	r0, [pc, #8]	; (8000580 <_dbg_check_unlock+0x20>)
 8000576:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000578:	e7fe      	b.n	8000578 <_dbg_check_unlock+0x18>
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	20000d38 	.word	0x20000d38
 8000580:	08001ba0 	.word	0x08001ba0
 8000584:	46c0      	nop			; (mov r8, r8)
 8000586:	46c0      	nop			; (mov r8, r8)
 8000588:	46c0      	nop			; (mov r8, r8)
 800058a:	46c0      	nop			; (mov r8, r8)
 800058c:	46c0      	nop			; (mov r8, r8)
 800058e:	46c0      	nop			; (mov r8, r8)

08000590 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000590:	4b06      	ldr	r3, [pc, #24]	; (80005ac <_dbg_check_lock+0x1c>)
 8000592:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000594:	2a00      	cmp	r2, #0
 8000596:	d102      	bne.n	800059e <_dbg_check_lock+0xe>
 8000598:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800059a:	2800      	cmp	r0, #0
 800059c:	d003      	beq.n	80005a6 <_dbg_check_lock+0x16>
 800059e:	b672      	cpsid	i
 80005a0:	4a03      	ldr	r2, [pc, #12]	; (80005b0 <_dbg_check_lock+0x20>)
 80005a2:	62da      	str	r2, [r3, #44]	; 0x2c
 80005a4:	e7fe      	b.n	80005a4 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80005a6:	2101      	movs	r1, #1
 80005a8:	6359      	str	r1, [r3, #52]	; 0x34
}
 80005aa:	4770      	bx	lr
 80005ac:	20000d38 	.word	0x20000d38
 80005b0:	08001ba8 	.word	0x08001ba8
 80005b4:	46c0      	nop			; (mov r8, r8)
 80005b6:	46c0      	nop			; (mov r8, r8)
 80005b8:	46c0      	nop			; (mov r8, r8)
 80005ba:	46c0      	nop			; (mov r8, r8)
 80005bc:	46c0      	nop			; (mov r8, r8)
 80005be:	46c0      	nop			; (mov r8, r8)

080005c0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80005c0:	b510      	push	{r4, lr}
 80005c2:	1c04      	adds	r4, r0, #0
 80005c4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80005c6:	f7ff ffe3 	bl	8000590 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();
 80005ca:	f7ff fee1 	bl	8000390 <chDbgCheckClassI.4434>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80005ce:	4910      	ldr	r1, [pc, #64]	; (8000610 <chCoreAlloc+0x50>)
 80005d0:	4810      	ldr	r0, [pc, #64]	; (8000614 <chCoreAlloc+0x54>)
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 80005d2:	1de2      	adds	r2, r4, #7
 80005d4:	2307      	movs	r3, #7
 80005d6:	439a      	bics	r2, r3
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80005d8:	6804      	ldr	r4, [r0, #0]
 80005da:	680b      	ldr	r3, [r1, #0]
 80005dc:	1b19      	subs	r1, r3, r4
 80005de:	428a      	cmp	r2, r1
 80005e0:	d813      	bhi.n	800060a <chCoreAlloc+0x4a>
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80005e2:	18a2      	adds	r2, r4, r2
 80005e4:	6002      	str	r2, [r0, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80005e6:	f7ff ffbb 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80005ea:	480b      	ldr	r0, [pc, #44]	; (8000618 <chCoreAlloc+0x58>)
 80005ec:	6803      	ldr	r3, [r0, #0]
 80005ee:	4283      	cmp	r3, r0
 80005f0:	d004      	beq.n	80005fc <chCoreAlloc+0x3c>
 80005f2:	6981      	ldr	r1, [r0, #24]
 80005f4:	689a      	ldr	r2, [r3, #8]
 80005f6:	6889      	ldr	r1, [r1, #8]
 80005f8:	4291      	cmp	r1, r2
 80005fa:	d302      	bcc.n	8000602 <chCoreAlloc+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005fc:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80005fe:	1c20      	adds	r0, r4, #0
 8000600:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000602:	b672      	cpsid	i
 8000604:	4c05      	ldr	r4, [pc, #20]	; (800061c <chCoreAlloc+0x5c>)
 8000606:	62c4      	str	r4, [r0, #44]	; 0x2c
 8000608:	e7fe      	b.n	8000608 <chCoreAlloc+0x48>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800060a:	2400      	movs	r4, #0
 800060c:	e7eb      	b.n	80005e6 <chCoreAlloc+0x26>
 800060e:	46c0      	nop			; (mov r8, r8)
 8000610:	200012a0 	.word	0x200012a0
 8000614:	200012a4 	.word	0x200012a4
 8000618:	20000d38 	.word	0x20000d38
 800061c:	08001b00 	.word	0x08001b00

08000620 <sdStart.constprop.1>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8000620:	b538      	push	{r3, r4, r5, lr}
 8000622:	1c04      	adds	r4, r0, #0
 8000624:	b672      	cpsid	i

  osalDbgCheck(sdp != NULL);
 8000626:	2800      	cmp	r0, #0
 8000628:	d03c      	beq.n	80006a4 <sdStart.constprop.1+0x84>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800062a:	f7ff ffb1 	bl	8000590 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 800062e:	7a23      	ldrb	r3, [r4, #8]
 8000630:	1e5a      	subs	r2, r3, #1
 8000632:	2a01      	cmp	r2, #1
 8000634:	d904      	bls.n	8000640 <sdStart.constprop.1+0x20>
 8000636:	b672      	cpsid	i
 8000638:	4c22      	ldr	r4, [pc, #136]	; (80006c4 <sdStart.constprop.1+0xa4>)
 800063a:	4b23      	ldr	r3, [pc, #140]	; (80006c8 <sdStart.constprop.1+0xa8>)
 800063c:	62dc      	str	r4, [r3, #44]	; 0x2c
 800063e:	e7fe      	b.n	800063e <sdStart.constprop.1+0x1e>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000640:	2b01      	cmp	r3, #1
 8000642:	d022      	beq.n	800068a <sdStart.constprop.1+0x6a>
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000644:	21cc      	movs	r1, #204	; 0xcc
 8000646:	004b      	lsls	r3, r1, #1
 8000648:	2296      	movs	r2, #150	; 0x96
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800064a:	20ca      	movs	r0, #202	; 0xca
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800064c:	0191      	lsls	r1, r2, #6
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800064e:	0045      	lsls	r5, r0, #1
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000650:	58e0      	ldr	r0, [r4, r3]
 8000652:	f7ff fde5 	bl	8000220 <__aeabi_uidiv>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000656:	5965      	ldr	r5, [r4, r5]
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000658:	4b1c      	ldr	r3, [pc, #112]	; (80006cc <sdStart.constprop.1+0xac>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800065a:	60e8      	str	r0, [r5, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800065c:	481c      	ldr	r0, [pc, #112]	; (80006d0 <sdStart.constprop.1+0xb0>)
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800065e:	2201      	movs	r2, #1
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000660:	6068      	str	r0, [r5, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000662:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000664:	4250      	negs	r0, r2
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000666:	60a9      	str	r1, [r5, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000668:	602b      	str	r3, [r5, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800066a:	6228      	str	r0, [r5, #32]
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 800066c:	2502      	movs	r5, #2
 800066e:	7225      	strb	r5, [r4, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000670:	f7ff ff76 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000674:	4c14      	ldr	r4, [pc, #80]	; (80006c8 <sdStart.constprop.1+0xa8>)
 8000676:	6823      	ldr	r3, [r4, #0]
 8000678:	42a3      	cmp	r3, r4
 800067a:	d004      	beq.n	8000686 <sdStart.constprop.1+0x66>
 800067c:	69a1      	ldr	r1, [r4, #24]
 800067e:	689a      	ldr	r2, [r3, #8]
 8000680:	6888      	ldr	r0, [r1, #8]
 8000682:	4290      	cmp	r0, r2
 8000684:	d312      	bcc.n	80006ac <sdStart.constprop.1+0x8c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000686:	b662      	cpsie	i
  osalSysUnlock();
}
 8000688:	bd38      	pop	{r3, r4, r5, pc}
  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 800068a:	4812      	ldr	r0, [pc, #72]	; (80006d4 <sdStart.constprop.1+0xb4>)
 800068c:	4284      	cmp	r4, r0
 800068e:	d011      	beq.n	80006b4 <sdStart.constprop.1+0x94>
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8000690:	4911      	ldr	r1, [pc, #68]	; (80006d8 <sdStart.constprop.1+0xb8>)
 8000692:	428c      	cmp	r4, r1
 8000694:	d1d6      	bne.n	8000644 <sdStart.constprop.1+0x24>
      rccEnableUSART2(FALSE);
 8000696:	4d11      	ldr	r5, [pc, #68]	; (80006dc <sdStart.constprop.1+0xbc>)
 8000698:	2280      	movs	r2, #128	; 0x80
 800069a:	69eb      	ldr	r3, [r5, #28]
 800069c:	0290      	lsls	r0, r2, #10
 800069e:	4318      	orrs	r0, r3
 80006a0:	61e8      	str	r0, [r5, #28]
 80006a2:	e7cf      	b.n	8000644 <sdStart.constprop.1+0x24>
 80006a4:	4907      	ldr	r1, [pc, #28]	; (80006c4 <sdStart.constprop.1+0xa4>)
 80006a6:	4808      	ldr	r0, [pc, #32]	; (80006c8 <sdStart.constprop.1+0xa8>)
 80006a8:	62c1      	str	r1, [r0, #44]	; 0x2c
 80006aa:	e7fe      	b.n	80006aa <sdStart.constprop.1+0x8a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80006ac:	b672      	cpsid	i
 80006ae:	4d0c      	ldr	r5, [pc, #48]	; (80006e0 <sdStart.constprop.1+0xc0>)
 80006b0:	62e5      	str	r5, [r4, #44]	; 0x2c
 80006b2:	e7fe      	b.n	80006b2 <sdStart.constprop.1+0x92>
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 80006b4:	4d09      	ldr	r5, [pc, #36]	; (80006dc <sdStart.constprop.1+0xbc>)
 80006b6:	2380      	movs	r3, #128	; 0x80
 80006b8:	69a9      	ldr	r1, [r5, #24]
 80006ba:	01da      	lsls	r2, r3, #7
 80006bc:	430a      	orrs	r2, r1
 80006be:	61aa      	str	r2, [r5, #24]
 80006c0:	e7c0      	b.n	8000644 <sdStart.constprop.1+0x24>
 80006c2:	46c0      	nop			; (mov r8, r8)
 80006c4:	08001ce0 	.word	0x08001ce0
 80006c8:	20000d38 	.word	0x20000d38
 80006cc:	0000012d 	.word	0x0000012d
 80006d0:	00004040 	.word	0x00004040
 80006d4:	20000a00 	.word	0x20000a00
 80006d8:	20000b9c 	.word	0x20000b9c
 80006dc:	40021000 	.word	0x40021000
 80006e0:	08001ad0 	.word	0x08001ad0
 80006e4:	46c0      	nop			; (mov r8, r8)
 80006e6:	46c0      	nop			; (mov r8, r8)
 80006e8:	46c0      	nop			; (mov r8, r8)
 80006ea:	46c0      	nop			; (mov r8, r8)
 80006ec:	46c0      	nop			; (mov r8, r8)
 80006ee:	46c0      	nop			; (mov r8, r8)

080006f0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80006f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006f2:	4647      	mov	r7, r8
 80006f4:	b480      	push	{r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80006f6:	4825      	ldr	r0, [pc, #148]	; (800078c <__init_ram_areas+0x9c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80006f8:	2380      	movs	r3, #128	; 0x80
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80006fa:	4684      	mov	ip, r0
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80006fc:	4698      	mov	r8, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80006fe:	2400      	movs	r4, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000700:	44e0      	add	r8, ip
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8000702:	4662      	mov	r2, ip
    uint32_t *p = rap->init_area;
 8000704:	6856      	ldr	r6, [r2, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000706:	6895      	ldr	r5, [r2, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8000708:	6811      	ldr	r1, [r2, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800070a:	42ae      	cmp	r6, r5
 800070c:	d220      	bcs.n	8000750 <__init_ram_areas+0x60>
 800070e:	43f7      	mvns	r7, r6
 8000710:	19e8      	adds	r0, r5, r7
      *p = *tp;
 8000712:	1c0a      	adds	r2, r1, #0
 8000714:	0743      	lsls	r3, r0, #29
 8000716:	ca01      	ldmia	r2!, {r0}
 8000718:	0fdf      	lsrs	r7, r3, #31
 800071a:	1c33      	adds	r3, r6, #0
 800071c:	c301      	stmia	r3!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800071e:	42ab      	cmp	r3, r5
 8000720:	d210      	bcs.n	8000744 <__init_ram_areas+0x54>
 8000722:	2f00      	cmp	r7, #0
 8000724:	d004      	beq.n	8000730 <__init_ram_areas+0x40>
      *p = *tp;
 8000726:	6849      	ldr	r1, [r1, #4]
 8000728:	3204      	adds	r2, #4
 800072a:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800072c:	42ab      	cmp	r3, r5
 800072e:	d209      	bcs.n	8000744 <__init_ram_areas+0x54>
      *p = *tp;
 8000730:	1c10      	adds	r0, r2, #0
 8000732:	c880      	ldmia	r0!, {r7}
 8000734:	1c19      	adds	r1, r3, #0
 8000736:	c180      	stmia	r1!, {r7}
 8000738:	6852      	ldr	r2, [r2, #4]
 800073a:	605a      	str	r2, [r3, #4]
      p++;
 800073c:	1d0b      	adds	r3, r1, #4
 800073e:	1d02      	adds	r2, r0, #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000740:	42ab      	cmp	r3, r5
 8000742:	d3f5      	bcc.n	8000730 <__init_ram_areas+0x40>
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000744:	43f3      	mvns	r3, r6
 8000746:	195d      	adds	r5, r3, r5
 8000748:	08a8      	lsrs	r0, r5, #2
 800074a:	3001      	adds	r0, #1
 800074c:	0087      	lsls	r7, r0, #2
 800074e:	19f6      	adds	r6, r6, r7
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000750:	4661      	mov	r1, ip
 8000752:	68cd      	ldr	r5, [r1, #12]
 8000754:	42ae      	cmp	r6, r5
 8000756:	d211      	bcs.n	800077c <__init_ram_areas+0x8c>
 8000758:	43f2      	mvns	r2, r6
 800075a:	18ab      	adds	r3, r5, r2
 800075c:	0758      	lsls	r0, r3, #29
      *p = 0;
 800075e:	c610      	stmia	r6!, {r4}
 8000760:	0fc7      	lsrs	r7, r0, #31
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000762:	42ae      	cmp	r6, r5
 8000764:	d20a      	bcs.n	800077c <__init_ram_areas+0x8c>
 8000766:	2f00      	cmp	r7, #0
 8000768:	d002      	beq.n	8000770 <__init_ram_areas+0x80>
      *p = 0;
 800076a:	c610      	stmia	r6!, {r4}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800076c:	42ae      	cmp	r6, r5
 800076e:	d205      	bcs.n	800077c <__init_ram_areas+0x8c>
      *p = 0;
 8000770:	1c31      	adds	r1, r6, #0
 8000772:	c110      	stmia	r1!, {r4}
 8000774:	6074      	str	r4, [r6, #4]
      p++;
 8000776:	1d0e      	adds	r6, r1, #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000778:	42ae      	cmp	r6, r5
 800077a:	d3f9      	bcc.n	8000770 <__init_ram_areas+0x80>
      *p = 0;
      p++;
    }
    rap++;
 800077c:	2510      	movs	r5, #16
 800077e:	44ac      	add	ip, r5
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000780:	45c4      	cmp	ip, r8
 8000782:	d3be      	bcc.n	8000702 <__init_ram_areas+0x12>
#endif
}
 8000784:	bc04      	pop	{r2}
 8000786:	4690      	mov	r8, r2
 8000788:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800078a:	46c0      	nop			; (mov r8, r8)
 800078c:	08001c10 	.word	0x08001c10

08000790 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8000790:	e7fe      	b.n	8000790 <__default_exit>
 8000792:	46c0      	nop			; (mov r8, r8)
 8000794:	46c0      	nop			; (mov r8, r8)
 8000796:	46c0      	nop			; (mov r8, r8)
 8000798:	46c0      	nop			; (mov r8, r8)
 800079a:	46c0      	nop			; (mov r8, r8)
 800079c:	46c0      	nop			; (mov r8, r8)
 800079e:	46c0      	nop			; (mov r8, r8)

080007a0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80007a0:	4770      	bx	lr
 80007a2:	46c0      	nop			; (mov r8, r8)
 80007a4:	46c0      	nop			; (mov r8, r8)
 80007a6:	46c0      	nop			; (mov r8, r8)
 80007a8:	46c0      	nop			; (mov r8, r8)
 80007aa:	46c0      	nop			; (mov r8, r8)
 80007ac:	46c0      	nop			; (mov r8, r8)
 80007ae:	46c0      	nop			; (mov r8, r8)

080007b0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80007b0:	4770      	bx	lr
 80007b2:	46c0      	nop			; (mov r8, r8)
 80007b4:	46c0      	nop			; (mov r8, r8)
 80007b6:	46c0      	nop			; (mov r8, r8)
 80007b8:	46c0      	nop			; (mov r8, r8)
 80007ba:	46c0      	nop			; (mov r8, r8)
 80007bc:	46c0      	nop			; (mov r8, r8)
 80007be:	46c0      	nop			; (mov r8, r8)

080007c0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80007c0:	b510      	push	{r4, lr}
 80007c2:	1c04      	adds	r4, r0, #0
  thread_t *cp;

  chDbgCheckClassI();
 80007c4:	f7ff fde4 	bl	8000390 <chDbgCheckClassI.4434>
  chDbgCheck(tp != NULL);
 80007c8:	2c00      	cmp	r4, #0
 80007ca:	d019      	beq.n	8000800 <chSchReadyI+0x40>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 80007cc:	2320      	movs	r3, #32
 80007ce:	5ce2      	ldrb	r2, [r4, r3]
 80007d0:	2a00      	cmp	r2, #0
 80007d2:	d010      	beq.n	80007f6 <chSchReadyI+0x36>
 80007d4:	2a0f      	cmp	r2, #15
 80007d6:	d00e      	beq.n	80007f6 <chSchReadyI+0x36>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80007d8:	2000      	movs	r0, #0
 80007da:	54e0      	strb	r0, [r4, r3]
 80007dc:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80007de:	4b0b      	ldr	r3, [pc, #44]	; (800080c <chSchReadyI+0x4c>)
  do {
    cp = cp->p_next;
 80007e0:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80007e2:	6899      	ldr	r1, [r3, #8]
 80007e4:	4291      	cmp	r1, r2
 80007e6:	d2fb      	bcs.n	80007e0 <chSchReadyI+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80007e8:	6858      	ldr	r0, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80007ea:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 80007ec:	6060      	str	r0, [r4, #4]
  tp->p_prev->p_next = tp;
 80007ee:	6004      	str	r4, [r0, #0]
  cp->p_prev = tp;
 80007f0:	605c      	str	r4, [r3, #4]

  return tp;
}
 80007f2:	1c20      	adds	r0, r4, #0
 80007f4:	bd10      	pop	{r4, pc}
 80007f6:	b672      	cpsid	i
 80007f8:	4c05      	ldr	r4, [pc, #20]	; (8000810 <chSchReadyI+0x50>)
 80007fa:	4a04      	ldr	r2, [pc, #16]	; (800080c <chSchReadyI+0x4c>)
 80007fc:	62d4      	str	r4, [r2, #44]	; 0x2c
 80007fe:	e7fe      	b.n	80007fe <chSchReadyI+0x3e>
 8000800:	b672      	cpsid	i
 8000802:	4903      	ldr	r1, [pc, #12]	; (8000810 <chSchReadyI+0x50>)
 8000804:	4b01      	ldr	r3, [pc, #4]	; (800080c <chSchReadyI+0x4c>)
 8000806:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000808:	e7fe      	b.n	8000808 <chSchReadyI+0x48>
 800080a:	46c0      	nop			; (mov r8, r8)
 800080c:	20000d38 	.word	0x20000d38
 8000810:	08001b10 	.word	0x08001b10
 8000814:	46c0      	nop			; (mov r8, r8)
 8000816:	46c0      	nop			; (mov r8, r8)
 8000818:	46c0      	nop			; (mov r8, r8)
 800081a:	46c0      	nop			; (mov r8, r8)
 800081c:	46c0      	nop			; (mov r8, r8)
 800081e:	46c0      	nop			; (mov r8, r8)

08000820 <wakeup.4792.4157>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000820:	b538      	push	{r3, r4, r5, lr}
 8000822:	1c04      	adds	r4, r0, #0
 8000824:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000826:	f7ff fd53 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 800082a:	2320      	movs	r3, #32
 800082c:	5ce0      	ldrb	r0, [r4, r3]
 800082e:	2807      	cmp	r0, #7
 8000830:	d80e      	bhi.n	8000850 <wakeup.4792.4157+0x30>
 8000832:	4a11      	ldr	r2, [pc, #68]	; (8000878 <wakeup.4792.4157+0x58>)
 8000834:	0081      	lsls	r1, r0, #2
 8000836:	5855      	ldr	r5, [r2, r1]
 8000838:	46af      	mov	pc, r5
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800083a:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 800083c:	f7ff fda8 	bl	8000390 <chDbgCheckClassI.4434>

  sp->s_cnt++;
 8000840:	68ab      	ldr	r3, [r5, #8]
 8000842:	3301      	adds	r3, #1
 8000844:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000846:	6860      	ldr	r0, [r4, #4]
 8000848:	6821      	ldr	r1, [r4, #0]
 800084a:	6001      	str	r1, [r0, #0]
  tp->p_next->p_prev = tp->p_prev;
 800084c:	6822      	ldr	r2, [r4, #0]
 800084e:	6050      	str	r0, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000850:	2001      	movs	r0, #1
 8000852:	4241      	negs	r1, r0
 8000854:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000856:	1c20      	adds	r0, r4, #0
 8000858:	f7ff ffb2 	bl	80007c0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800085c:	f7ff fd50 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000860:	b662      	cpsie	i
  chSysUnlockFromISR();
}
 8000862:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000864:	6a65      	ldr	r5, [r4, #36]	; 0x24
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000866:	2001      	movs	r0, #1
 8000868:	4241      	negs	r1, r0
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 800086a:	2300      	movs	r3, #0
 800086c:	602b      	str	r3, [r5, #0]
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
 800086e:	1c20      	adds	r0, r4, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000870:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000872:	f7ff ffa5 	bl	80007c0 <chSchReadyI>
 8000876:	e7f1      	b.n	800085c <wakeup.4792.4157+0x3c>
 8000878:	08001ab0 	.word	0x08001ab0
 800087c:	46c0      	nop			; (mov r8, r8)
 800087e:	46c0      	nop			; (mov r8, r8)

08000880 <chEvtBroadcastFlagsI.4423>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000882:	4657      	mov	r7, sl
 8000884:	464e      	mov	r6, r9
 8000886:	4645      	mov	r5, r8
 8000888:	b4e0      	push	{r5, r6, r7}
 800088a:	1c06      	adds	r6, r0, #0
 800088c:	1c0f      	adds	r7, r1, #0
  event_listener_t *elp;

  chDbgCheckClassI();
 800088e:	f7ff fd7f 	bl	8000390 <chDbgCheckClassI.4434>
  chDbgCheck(esp != NULL);
 8000892:	2e00      	cmp	r6, #0
 8000894:	d042      	beq.n	800091c <chEvtBroadcastFlagsI.4423+0x9c>

  elp = esp->es_next;
 8000896:	6834      	ldr	r4, [r6, #0]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000898:	2120      	movs	r1, #32
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800089a:	2200      	movs	r2, #0
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800089c:	4689      	mov	r9, r1
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800089e:	4690      	mov	r8, r2
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80008a0:	42a6      	cmp	r6, r4
 80008a2:	d103      	bne.n	80008ac <chEvtBroadcastFlagsI.4423+0x2c>
 80008a4:	e027      	b.n	80008f6 <chEvtBroadcastFlagsI.4423+0x76>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 80008a6:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80008a8:	42a6      	cmp	r6, r4
 80008aa:	d024      	beq.n	80008f6 <chEvtBroadcastFlagsI.4423+0x76>
  /*lint -restore*/
    elp->el_flags |= flags;
 80008ac:	68e3      	ldr	r3, [r4, #12]
 80008ae:	433b      	orrs	r3, r7
 80008b0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80008b2:	2f00      	cmp	r7, #0
 80008b4:	d002      	beq.n	80008bc <chEvtBroadcastFlagsI.4423+0x3c>
 80008b6:	6920      	ldr	r0, [r4, #16]
 80008b8:	4218      	tst	r0, r3
 80008ba:	d0f4      	beq.n	80008a6 <chEvtBroadcastFlagsI.4423+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80008bc:	6865      	ldr	r5, [r4, #4]
 80008be:	68a1      	ldr	r1, [r4, #8]
 80008c0:	468a      	mov	sl, r1
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 80008c2:	f7ff fd65 	bl	8000390 <chDbgCheckClassI.4434>
  chDbgCheck(tp != NULL);
 80008c6:	2d00      	cmp	r5, #0
 80008c8:	d023      	beq.n	8000912 <chEvtBroadcastFlagsI.4423+0x92>

  tp->p_epending |= events;
 80008ca:	6baa      	ldr	r2, [r5, #56]	; 0x38
 80008cc:	4653      	mov	r3, sl
 80008ce:	4313      	orrs	r3, r2
 80008d0:	63ab      	str	r3, [r5, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80008d2:	4648      	mov	r0, r9
 80008d4:	5c29      	ldrb	r1, [r5, r0]
 80008d6:	290a      	cmp	r1, #10
 80008d8:	d012      	beq.n	8000900 <chEvtBroadcastFlagsI.4423+0x80>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 80008da:	290b      	cmp	r1, #11
 80008dc:	d1e3      	bne.n	80008a6 <chEvtBroadcastFlagsI.4423+0x26>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 80008de:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80008e0:	4013      	ands	r3, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 80008e2:	429a      	cmp	r2, r3
 80008e4:	d1df      	bne.n	80008a6 <chEvtBroadcastFlagsI.4423+0x26>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80008e6:	4643      	mov	r3, r8
 80008e8:	626b      	str	r3, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80008ea:	1c28      	adds	r0, r5, #0
 80008ec:	f7ff ff68 	bl	80007c0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 80008f0:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80008f2:	42a6      	cmp	r6, r4
 80008f4:	d1da      	bne.n	80008ac <chEvtBroadcastFlagsI.4423+0x2c>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80008f6:	bc1c      	pop	{r2, r3, r4}
 80008f8:	4690      	mov	r8, r2
 80008fa:	4699      	mov	r9, r3
 80008fc:	46a2      	mov	sl, r4
 80008fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000900:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8000902:	4218      	tst	r0, r3
 8000904:	d0cf      	beq.n	80008a6 <chEvtBroadcastFlagsI.4423+0x26>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000906:	4643      	mov	r3, r8
 8000908:	626b      	str	r3, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 800090a:	1c28      	adds	r0, r5, #0
 800090c:	f7ff ff58 	bl	80007c0 <chSchReadyI>
 8000910:	e7ee      	b.n	80008f0 <chEvtBroadcastFlagsI.4423+0x70>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000912:	b672      	cpsid	i
 8000914:	4e04      	ldr	r6, [pc, #16]	; (8000928 <chEvtBroadcastFlagsI.4423+0xa8>)
 8000916:	4f05      	ldr	r7, [pc, #20]	; (800092c <chEvtBroadcastFlagsI.4423+0xac>)
 8000918:	62fe      	str	r6, [r7, #44]	; 0x2c
 800091a:	e7fe      	b.n	800091a <chEvtBroadcastFlagsI.4423+0x9a>
 800091c:	b672      	cpsid	i
 800091e:	4d04      	ldr	r5, [pc, #16]	; (8000930 <chEvtBroadcastFlagsI.4423+0xb0>)
 8000920:	4902      	ldr	r1, [pc, #8]	; (800092c <chEvtBroadcastFlagsI.4423+0xac>)
 8000922:	62cd      	str	r5, [r1, #44]	; 0x2c
 8000924:	e7fe      	b.n	8000924 <chEvtBroadcastFlagsI.4423+0xa4>
 8000926:	46c0      	nop			; (mov r8, r8)
 8000928:	08001bf0 	.word	0x08001bf0
 800092c:	20000d38 	.word	0x20000d38
 8000930:	08001bc0 	.word	0x08001bc0
 8000934:	46c0      	nop			; (mov r8, r8)
 8000936:	46c0      	nop			; (mov r8, r8)
 8000938:	46c0      	nop			; (mov r8, r8)
 800093a:	46c0      	nop			; (mov r8, r8)
 800093c:	46c0      	nop			; (mov r8, r8)
 800093e:	46c0      	nop			; (mov r8, r8)

08000940 <serve_interrupt.8373.4310>:
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000940:	23ca      	movs	r3, #202	; 0xca
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000942:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000944:	1c04      	adds	r4, r0, #0
  USART_TypeDef *u = sdp->usart;
 8000946:	0058      	lsls	r0, r3, #1
 8000948:	5826      	ldr	r6, [r4, r0]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800094a:	4647      	mov	r7, r8
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 800094c:	6832      	ldr	r2, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800094e:	69f5      	ldr	r5, [r6, #28]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000950:	b480      	push	{r7}
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000952:	4690      	mov	r8, r2
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;
 8000954:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000956:	072b      	lsls	r3, r5, #28
 8000958:	d14b      	bne.n	80009f2 <serve_interrupt.8373.4310+0xb2>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800095a:	05eb      	lsls	r3, r5, #23
 800095c:	d465      	bmi.n	8000a2a <serve_interrupt.8373.4310+0xea>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 800095e:	06aa      	lsls	r2, r5, #26
 8000960:	d500      	bpl.n	8000964 <serve_interrupt.8373.4310+0x24>
 8000962:	e070      	b.n	8000a46 <serve_interrupt.8373.4310+0x106>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000964:	2080      	movs	r0, #128	; 0x80
 8000966:	4643      	mov	r3, r8
 8000968:	4218      	tst	r0, r3
 800096a:	d001      	beq.n	8000970 <serve_interrupt.8373.4310+0x30>
 800096c:	4228      	tst	r0, r5
 800096e:	d104      	bne.n	800097a <serve_interrupt.8373.4310+0x3a>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000970:	066a      	lsls	r2, r5, #25
 8000972:	d42c      	bmi.n	80009ce <serve_interrupt.8373.4310+0x8e>
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    osalSysUnlockFromISR();
  }
}
 8000974:	bc04      	pop	{r2}
 8000976:	4690      	mov	r8, r2
 8000978:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800097a:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800097c:	f7ff fca8 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
  uint8_t b;

  chDbgCheckClassI();
 8000980:	f7ff fd06 	bl	8000390 <chDbgCheckClassI.4434>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000984:	f7ff fd04 	bl	8000390 <chDbgCheckClassI.4434>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000988:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800098a:	6c67      	ldr	r7, [r4, #68]	; 0x44
 800098c:	428f      	cmp	r7, r1
 800098e:	d100      	bne.n	8000992 <serve_interrupt.8373.4310+0x52>
 8000990:	e095      	b.n	8000abe <serve_interrupt.8373.4310+0x17e>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000992:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000994:	6c23      	ldr	r3, [r4, #64]	; 0x40

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000996:	3001      	adds	r0, #1
 8000998:	63a0      	str	r0, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 800099a:	780f      	ldrb	r7, [r1, #0]
 800099c:	3101      	adds	r1, #1
 800099e:	64a1      	str	r1, [r4, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 80009a0:	4299      	cmp	r1, r3
 80009a2:	d301      	bcc.n	80009a8 <serve_interrupt.8373.4310+0x68>
    oqp->q_rdptr = oqp->q_buffer;
 80009a4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80009a6:	64a1      	str	r1, [r4, #72]	; 0x48
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 80009a8:	1c22      	adds	r2, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80009aa:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80009ac:	3230      	adds	r2, #48	; 0x30
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80009ae:	4282      	cmp	r2, r0
 80009b0:	d100      	bne.n	80009b4 <serve_interrupt.8373.4310+0x74>
 80009b2:	e0ab      	b.n	8000b0c <serve_interrupt.8373.4310+0x1cc>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80009b4:	6803      	ldr	r3, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80009b6:	2120      	movs	r1, #32
 80009b8:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->p_next->p_prev = (thread_t *)tqp;
 80009ba:	605a      	str	r2, [r3, #4]
 80009bc:	5c42      	ldrb	r2, [r0, r1]
 80009be:	2a04      	cmp	r2, #4
 80009c0:	d100      	bne.n	80009c4 <serve_interrupt.8373.4310+0x84>
 80009c2:	e09f      	b.n	8000b04 <serve_interrupt.8373.4310+0x1c4>
 80009c4:	b672      	cpsid	i
 80009c6:	4852      	ldr	r0, [pc, #328]	; (8000b10 <serve_interrupt.8373.4310+0x1d0>)
 80009c8:	4f52      	ldr	r7, [pc, #328]	; (8000b14 <serve_interrupt.8373.4310+0x1d4>)
 80009ca:	62f8      	str	r0, [r7, #44]	; 0x2c
 80009cc:	e7fe      	b.n	80009cc <serve_interrupt.8373.4310+0x8c>
 80009ce:	b672      	cpsid	i
 80009d0:	f7ff fc7e 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80009d4:	f7ff fcdc 	bl	8000390 <chDbgCheckClassI.4434>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80009d8:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80009da:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80009dc:	4285      	cmp	r5, r0
 80009de:	d100      	bne.n	80009e2 <serve_interrupt.8373.4310+0xa2>
 80009e0:	e087      	b.n	8000af2 <serve_interrupt.8373.4310+0x1b2>
  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80009e2:	2440      	movs	r4, #64	; 0x40
 80009e4:	4641      	mov	r1, r8
 80009e6:	43a1      	bics	r1, r4
 80009e8:	6031      	str	r1, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80009ea:	f7ff fc89 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009ee:	b662      	cpsie	i
 80009f0:	e7c0      	b.n	8000974 <serve_interrupt.8373.4310+0x34>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 80009f2:	072f      	lsls	r7, r5, #28
    sts |= SD_OVERRUN_ERROR;
 80009f4:	0ff9      	lsrs	r1, r7, #31
 80009f6:	01cf      	lsls	r7, r1, #7
  if (isr & USART_ISR_PE)
 80009f8:	07ea      	lsls	r2, r5, #31
 80009fa:	d501      	bpl.n	8000a00 <serve_interrupt.8373.4310+0xc0>
    sts |= SD_PARITY_ERROR;
 80009fc:	2320      	movs	r3, #32
 80009fe:	431f      	orrs	r7, r3
  if (isr & USART_ISR_FE)
 8000a00:	07ab      	lsls	r3, r5, #30
 8000a02:	d501      	bpl.n	8000a08 <serve_interrupt.8373.4310+0xc8>
    sts |= SD_FRAMING_ERROR;
 8000a04:	2040      	movs	r0, #64	; 0x40
 8000a06:	4307      	orrs	r7, r0
  if (isr & USART_ISR_NE)
 8000a08:	076a      	lsls	r2, r5, #29
 8000a0a:	d502      	bpl.n	8000a12 <serve_interrupt.8373.4310+0xd2>
    sts |= SD_NOISE_ERROR;
 8000a0c:	2280      	movs	r2, #128	; 0x80
 8000a0e:	0051      	lsls	r1, r2, #1
 8000a10:	430f      	orrs	r7, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a12:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000a14:	f7ff fc5c 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
  osalSysLockFromISR();
  chnAddFlagsI(sdp, sts);
 8000a18:	1d20      	adds	r0, r4, #4
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000a1a:	1c39      	adds	r1, r7, #0
 8000a1c:	f7ff ff30 	bl	8000880 <chEvtBroadcastFlagsI.4423>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000a20:	f7ff fc6e 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a24:	b662      	cpsie	i
  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000a26:	05eb      	lsls	r3, r5, #23
 8000a28:	d599      	bpl.n	800095e <serve_interrupt.8373.4310+0x1e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a2a:	b672      	cpsid	i
 8000a2c:	2780      	movs	r7, #128	; 0x80
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000a2e:	f7ff fc4f 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000a32:	1d20      	adds	r0, r4, #4
 8000a34:	00b9      	lsls	r1, r7, #2
 8000a36:	f7ff ff23 	bl	8000880 <chEvtBroadcastFlagsI.4423>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000a3a:	f7ff fc61 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a3e:	b662      	cpsie	i
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000a40:	06aa      	lsls	r2, r5, #26
 8000a42:	d400      	bmi.n	8000a46 <serve_interrupt.8373.4310+0x106>
 8000a44:	e78e      	b.n	8000964 <serve_interrupt.8373.4310+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a46:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000a48:	f7ff fc42 	bl	80002d0 <_dbg_check_lock_from_isr.4415>
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000a4c:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
 8000a4e:	b2df      	uxtb	r7, r3
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8000a50:	f7ff fc9e 	bl	8000390 <chDbgCheckClassI.4434>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000a54:	f7ff fc9c 	bl	8000390 <chDbgCheckClassI.4434>

  return (bool)(chQSpaceI(iqp) == 0U);
 8000a58:	6960      	ldr	r0, [r4, #20]
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000a5a:	2800      	cmp	r0, #0
 8000a5c:	d103      	bne.n	8000a66 <serve_interrupt.8373.4310+0x126>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8000a5e:	1d20      	adds	r0, r4, #4
 8000a60:	2104      	movs	r1, #4
 8000a62:	f7ff ff0d 	bl	8000880 <chEvtBroadcastFlagsI.4423>
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();
 8000a66:	f7ff fc93 	bl	8000390 <chDbgCheckClassI.4434>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000a6a:	f7ff fc91 	bl	8000390 <chDbgCheckClassI.4434>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000a6e:	6a21      	ldr	r1, [r4, #32]
 8000a70:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000a72:	4291      	cmp	r1, r2
 8000a74:	d035      	beq.n	8000ae2 <serve_interrupt.8373.4310+0x1a2>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000a76:	6960      	ldr	r0, [r4, #20]
 8000a78:	3001      	adds	r0, #1
 8000a7a:	6160      	str	r0, [r4, #20]
  *iqp->q_wrptr++ = b;
 8000a7c:	700f      	strb	r7, [r1, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000a7e:	69e7      	ldr	r7, [r4, #28]
  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
 8000a80:	3101      	adds	r1, #1
 8000a82:	6221      	str	r1, [r4, #32]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000a84:	42b9      	cmp	r1, r7
 8000a86:	d301      	bcc.n	8000a8c <serve_interrupt.8373.4310+0x14c>
    iqp->q_wrptr = iqp->q_buffer;
 8000a88:	69a1      	ldr	r1, [r4, #24]
 8000a8a:	6221      	str	r1, [r4, #32]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8000a8c:	1c22      	adds	r2, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000a8e:	68e0      	ldr	r0, [r4, #12]
 8000a90:	320c      	adds	r2, #12
 8000a92:	4282      	cmp	r2, r0
 8000a94:	d00f      	beq.n	8000ab6 <serve_interrupt.8373.4310+0x176>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000a96:	6803      	ldr	r3, [r0, #0]
 8000a98:	2720      	movs	r7, #32
 8000a9a:	60e3      	str	r3, [r4, #12]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000a9c:	605a      	str	r2, [r3, #4]
 8000a9e:	5dc1      	ldrb	r1, [r0, r7]
 8000aa0:	2904      	cmp	r1, #4
 8000aa2:	d004      	beq.n	8000aae <serve_interrupt.8373.4310+0x16e>
 8000aa4:	b672      	cpsid	i
 8000aa6:	4c1a      	ldr	r4, [pc, #104]	; (8000b10 <serve_interrupt.8373.4310+0x1d0>)
 8000aa8:	4d1a      	ldr	r5, [pc, #104]	; (8000b14 <serve_interrupt.8373.4310+0x1d4>)
 8000aaa:	62ec      	str	r4, [r5, #44]	; 0x2c
 8000aac:	e7fe      	b.n	8000aac <serve_interrupt.8373.4310+0x16c>

  tp->p_u.rdymsg = msg;
 8000aae:	2200      	movs	r2, #0
 8000ab0:	6242      	str	r2, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000ab2:	f7ff fe85 	bl	80007c0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000ab6:	f7ff fc23 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000aba:	b662      	cpsie	i
 8000abc:	e752      	b.n	8000964 <serve_interrupt.8373.4310+0x24>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000abe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000ac0:	2a00      	cmp	r2, #0
 8000ac2:	d100      	bne.n	8000ac6 <serve_interrupt.8373.4310+0x186>
 8000ac4:	e765      	b.n	8000992 <serve_interrupt.8373.4310+0x52>
 8000ac6:	2108      	movs	r1, #8
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000ac8:	1d20      	adds	r0, r4, #4
 8000aca:	f7ff fed9 	bl	8000880 <chEvtBroadcastFlagsI.4423>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000ace:	21c0      	movs	r1, #192	; 0xc0
 8000ad0:	4642      	mov	r2, r8
 8000ad2:	438a      	bics	r2, r1
 8000ad4:	2340      	movs	r3, #64	; 0x40
 8000ad6:	4313      	orrs	r3, r2
 8000ad8:	6033      	str	r3, [r6, #0]
 8000ada:	f7ff fc11 	bl	8000300 <_dbg_check_unlock_from_isr.4417>
 8000ade:	b662      	cpsie	i
 8000ae0:	e746      	b.n	8000970 <serve_interrupt.8373.4310+0x30>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000ae2:	6963      	ldr	r3, [r4, #20]
 8000ae4:	2b00      	cmp	r3, #0
 8000ae6:	d0c6      	beq.n	8000a76 <serve_interrupt.8373.4310+0x136>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8000ae8:	1d20      	adds	r0, r4, #4
 8000aea:	2180      	movs	r1, #128	; 0x80
 8000aec:	f7ff fec8 	bl	8000880 <chEvtBroadcastFlagsI.4423>
 8000af0:	e7e1      	b.n	8000ab6 <serve_interrupt.8373.4310+0x176>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000af2:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8000af4:	2f00      	cmp	r7, #0
 8000af6:	d100      	bne.n	8000afa <serve_interrupt.8373.4310+0x1ba>
 8000af8:	e773      	b.n	80009e2 <serve_interrupt.8373.4310+0xa2>

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000afa:	1d20      	adds	r0, r4, #4
 8000afc:	2110      	movs	r1, #16
 8000afe:	f7ff febf 	bl	8000880 <chEvtBroadcastFlagsI.4423>
 8000b02:	e76e      	b.n	80009e2 <serve_interrupt.8373.4310+0xa2>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000b04:	2300      	movs	r3, #0
 8000b06:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000b08:	f7ff fe5a 	bl	80007c0 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8000b0c:	8537      	strh	r7, [r6, #40]	; 0x28
 8000b0e:	e7e4      	b.n	8000ada <serve_interrupt.8373.4310+0x19a>
 8000b10:	08001b20 	.word	0x08001b20
 8000b14:	20000d38 	.word	0x20000d38
 8000b18:	46c0      	nop			; (mov r8, r8)
 8000b1a:	46c0      	nop			; (mov r8, r8)
 8000b1c:	46c0      	nop			; (mov r8, r8)
 8000b1e:	46c0      	nop			; (mov r8, r8)

08000b20 <VectorB0.4306>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000b20:	b510      	push	{r4, lr}
 8000b22:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000b24:	f7ff fc04 	bl	8000330 <_dbg_check_enter_isr.4419>

  serve_interrupt(&SD2);
 8000b28:	4804      	ldr	r0, [pc, #16]	; (8000b3c <VectorB0.4306+0x1c>)
 8000b2a:	f7ff ff09 	bl	8000940 <serve_interrupt.8373.4310>

  OSAL_IRQ_EPILOGUE();
 8000b2e:	f7ff fc17 	bl	8000360 <_dbg_check_leave_isr.4421>
 8000b32:	1c20      	adds	r0, r4, #0
 8000b34:	f7ff fc6c 	bl	8000410 <_port_irq_epilogue.4479>
}
 8000b38:	bd10      	pop	{r4, pc}
 8000b3a:	46c0      	nop			; (mov r8, r8)
 8000b3c:	20000b9c 	.word	0x20000b9c

08000b40 <VectorAC.4308>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000b40:	b510      	push	{r4, lr}
 8000b42:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
 8000b44:	f7ff fbf4 	bl	8000330 <_dbg_check_enter_isr.4419>

  serve_interrupt(&SD1);
 8000b48:	4804      	ldr	r0, [pc, #16]	; (8000b5c <VectorAC.4308+0x1c>)
 8000b4a:	f7ff fef9 	bl	8000940 <serve_interrupt.8373.4310>

  OSAL_IRQ_EPILOGUE();
 8000b4e:	f7ff fc07 	bl	8000360 <_dbg_check_leave_isr.4421>
 8000b52:	1c20      	adds	r0, r4, #0
 8000b54:	f7ff fc5c 	bl	8000410 <_port_irq_epilogue.4479>
}
 8000b58:	bd10      	pop	{r4, pc}
 8000b5a:	46c0      	nop			; (mov r8, r8)
 8000b5c:	20000a00 	.word	0x20000a00

08000b60 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000b60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b62:	465f      	mov	r7, fp
 8000b64:	4656      	mov	r6, sl
 8000b66:	464d      	mov	r5, r9
 8000b68:	4644      	mov	r4, r8
 8000b6a:	b4f0      	push	{r4, r5, r6, r7}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000b6c:	2403      	movs	r4, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000b6e:	0757      	lsls	r7, r2, #29
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000b70:	06d6      	lsls	r6, r2, #27
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8000b72:	0655      	lsls	r5, r2, #25
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000b74:	4014      	ands	r4, r2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000b76:	0552      	lsls	r2, r2, #21
 8000b78:	0f13      	lsrs	r3, r2, #28
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000b7a:	b083      	sub	sp, #12

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8000b7c:	0fad      	lsrs	r5, r5, #30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8000b7e:	2201      	movs	r2, #1

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000b80:	469b      	mov	fp, r3
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000b82:	0fff      	lsrs	r7, r7, #31
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000b84:	0fb6      	lsrs	r6, r6, #30
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000b86:	2300      	movs	r3, #0
  while (true) {
    if ((mask & 1) != 0) {
 8000b88:	4694      	mov	ip, r2
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000b8a:	9500      	str	r5, [sp, #0]
 8000b8c:	e00e      	b.n	8000bac <_pal_lld_setgroupmode+0x4c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000b8e:	6a02      	ldr	r2, [r0, #32]
 8000b90:	464d      	mov	r5, r9
 8000b92:	43aa      	bics	r2, r5
 8000b94:	4645      	mov	r5, r8
 8000b96:	432a      	orrs	r2, r5
 8000b98:	6202      	str	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 8000b9a:	0849      	lsrs	r1, r1, #1
    if (!mask)
 8000b9c:	d03d      	beq.n	8000c1a <_pal_lld_setgroupmode+0xba>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
 8000b9e:	9a00      	ldr	r2, [sp, #0]
      }
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
 8000ba0:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
    pupdr <<= 2;
 8000ba2:	0095      	lsls	r5, r2, #2
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8000ba4:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8000ba6:	9500      	str	r5, [sp, #0]
    moder <<= 2;
 8000ba8:	00a4      	lsls	r4, r4, #2
    bit++;
 8000baa:	3301      	adds	r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8000bac:	4665      	mov	r5, ip
 8000bae:	420d      	tst	r5, r1
 8000bb0:	d0f3      	beq.n	8000b9a <_pal_lld_setgroupmode+0x3a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000bb2:	2207      	movs	r2, #7
 8000bb4:	401a      	ands	r2, r3
 8000bb6:	0095      	lsls	r5, r2, #2
 8000bb8:	465a      	mov	r2, fp
 8000bba:	40aa      	lsls	r2, r5
 8000bbc:	4690      	mov	r8, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000bbe:	220f      	movs	r2, #15
 8000bc0:	40aa      	lsls	r2, r5
 8000bc2:	4691      	mov	r9, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000bc4:	6845      	ldr	r5, [r0, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8000bc6:	4662      	mov	r2, ip
 8000bc8:	409a      	lsls	r2, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000bca:	4395      	bics	r5, r2
 8000bcc:	433d      	orrs	r5, r7
 8000bce:	6045      	str	r5, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000bd0:	6882      	ldr	r2, [r0, #8]
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8000bd2:	005d      	lsls	r5, r3, #1
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000bd4:	4692      	mov	sl, r2
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000bd6:	2203      	movs	r2, #3
 8000bd8:	40aa      	lsls	r2, r5
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000bda:	43d5      	mvns	r5, r2
 8000bdc:	4652      	mov	r2, sl
 8000bde:	402a      	ands	r2, r5
 8000be0:	4332      	orrs	r2, r6
 8000be2:	6082      	str	r2, [r0, #8]
 8000be4:	9501      	str	r5, [sp, #4]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000be6:	68c5      	ldr	r5, [r0, #12]
 8000be8:	1c2a      	adds	r2, r5, #0
 8000bea:	9d01      	ldr	r5, [sp, #4]
 8000bec:	402a      	ands	r2, r5
 8000bee:	9d00      	ldr	r5, [sp, #0]
 8000bf0:	432a      	orrs	r2, r5
 8000bf2:	60c2      	str	r2, [r0, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8000bf4:	2c02      	cmp	r4, #2
 8000bf6:	d017      	beq.n	8000c28 <_pal_lld_setgroupmode+0xc8>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8000bf8:	6802      	ldr	r2, [r0, #0]
 8000bfa:	4692      	mov	sl, r2
 8000bfc:	9a01      	ldr	r2, [sp, #4]
 8000bfe:	4655      	mov	r5, sl
 8000c00:	402a      	ands	r2, r5
 8000c02:	4322      	orrs	r2, r4
 8000c04:	6002      	str	r2, [r0, #0]
        if (bit < 8)
 8000c06:	2b07      	cmp	r3, #7
 8000c08:	d9c1      	bls.n	8000b8e <_pal_lld_setgroupmode+0x2e>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000c0a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000c0c:	464d      	mov	r5, r9
 8000c0e:	43aa      	bics	r2, r5
 8000c10:	4645      	mov	r5, r8
 8000c12:	432a      	orrs	r2, r5
 8000c14:	6242      	str	r2, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
 8000c16:	0849      	lsrs	r1, r1, #1
    if (!mask)
 8000c18:	d1c1      	bne.n	8000b9e <_pal_lld_setgroupmode+0x3e>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8000c1a:	b003      	add	sp, #12
 8000c1c:	bc3c      	pop	{r2, r3, r4, r5}
 8000c1e:	4690      	mov	r8, r2
 8000c20:	4699      	mov	r9, r3
 8000c22:	46a2      	mov	sl, r4
 8000c24:	46ab      	mov	fp, r5
 8000c26:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8000c28:	2b07      	cmp	r3, #7
 8000c2a:	d80d      	bhi.n	8000c48 <_pal_lld_setgroupmode+0xe8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000c2c:	6a02      	ldr	r2, [r0, #32]
 8000c2e:	1c15      	adds	r5, r2, #0
 8000c30:	464a      	mov	r2, r9
 8000c32:	4395      	bics	r5, r2
 8000c34:	4642      	mov	r2, r8
 8000c36:	4315      	orrs	r5, r2
 8000c38:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000c3a:	6805      	ldr	r5, [r0, #0]
 8000c3c:	9a01      	ldr	r2, [sp, #4]
 8000c3e:	402a      	ands	r2, r5
 8000c40:	2502      	movs	r5, #2
 8000c42:	432a      	orrs	r2, r5
 8000c44:	6002      	str	r2, [r0, #0]
 8000c46:	e7a8      	b.n	8000b9a <_pal_lld_setgroupmode+0x3a>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000c48:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000c4a:	464d      	mov	r5, r9
 8000c4c:	43aa      	bics	r2, r5
 8000c4e:	4645      	mov	r5, r8
 8000c50:	432a      	orrs	r2, r5
 8000c52:	6242      	str	r2, [r0, #36]	; 0x24
 8000c54:	e7f1      	b.n	8000c3a <_pal_lld_setgroupmode+0xda>
 8000c56:	46c0      	nop			; (mov r8, r8)
 8000c58:	46c0      	nop			; (mov r8, r8)
 8000c5a:	46c0      	nop			; (mov r8, r8)
 8000c5c:	46c0      	nop			; (mov r8, r8)
 8000c5e:	46c0      	nop			; (mov r8, r8)

08000c60 <_dbg_trace>:
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8000c60:	4a0b      	ldr	r2, [pc, #44]	; (8000c90 <_dbg_trace+0x30>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000c62:	2180      	movs	r1, #128	; 0x80
 8000c64:	05c9      	lsls	r1, r1, #23
 8000c66:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000c68:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8000c6a:	6019      	str	r1, [r3, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 8000c6c:	6991      	ldr	r1, [r2, #24]
 8000c6e:	6059      	str	r1, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8000c70:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000c72:	6099      	str	r1, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000c74:	2120      	movs	r1, #32
 8000c76:	5c40      	ldrb	r0, [r0, r1]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8000c78:	2188      	movs	r1, #136	; 0x88
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000c7a:	7318      	strb	r0, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8000c7c:	00c8      	lsls	r0, r1, #3
 8000c7e:	3310      	adds	r3, #16
 8000c80:	1811      	adds	r1, r2, r0
 8000c82:	428b      	cmp	r3, r1
 8000c84:	d301      	bcc.n	8000c8a <_dbg_trace+0x2a>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8000c86:	1c13      	adds	r3, r2, #0
 8000c88:	3340      	adds	r3, #64	; 0x40
 8000c8a:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8000c8c:	4770      	bx	lr
 8000c8e:	46c0      	nop			; (mov r8, r8)
 8000c90:	20000d38 	.word	0x20000d38
 8000c94:	46c0      	nop			; (mov r8, r8)
 8000c96:	46c0      	nop			; (mov r8, r8)
 8000c98:	46c0      	nop			; (mov r8, r8)
 8000c9a:	46c0      	nop			; (mov r8, r8)
 8000c9c:	46c0      	nop			; (mov r8, r8)
 8000c9e:	46c0      	nop			; (mov r8, r8)

08000ca0 <chThdCreateStatic.constprop.12>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8000ca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ca2:	464f      	mov	r7, r9
 8000ca4:	4646      	mov	r6, r8
 8000ca6:	b4c0      	push	{r6, r7}
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8000ca8:	1c06      	adds	r6, r0, #0
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8000caa:	1c04      	adds	r4, r0, #0
 8000cac:	4688      	mov	r8, r1
 8000cae:	1c17      	adds	r7, r2, #0
 8000cb0:	4699      	mov	r9, r3
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8000cb2:	3648      	adds	r6, #72	; 0x48
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000cb4:	25ff      	movs	r5, #255	; 0xff
 8000cb6:	7005      	strb	r5, [r0, #0]
 8000cb8:	7045      	strb	r5, [r0, #1]
 8000cba:	3002      	adds	r0, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000cbc:	4286      	cmp	r6, r0
 8000cbe:	d1fa      	bne.n	8000cb6 <chThdCreateStatic.constprop.12+0x16>
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8000cc0:	4642      	mov	r2, r8
 8000cc2:	18a3      	adds	r3, r4, r2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000cc4:	429e      	cmp	r6, r3
 8000cc6:	d213      	bcs.n	8000cf0 <chThdCreateStatic.constprop.12+0x50>
 8000cc8:	43f1      	mvns	r1, r6
 8000cca:	185a      	adds	r2, r3, r1
    *startp++ = v;
 8000ccc:	2555      	movs	r5, #85	; 0x55
 8000cce:	2001      	movs	r0, #1
 8000cd0:	1c71      	adds	r1, r6, #1
 8000cd2:	4002      	ands	r2, r0
 8000cd4:	7035      	strb	r5, [r6, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000cd6:	4299      	cmp	r1, r3
 8000cd8:	d00a      	beq.n	8000cf0 <chThdCreateStatic.constprop.12+0x50>
 8000cda:	2a00      	cmp	r2, #0
 8000cdc:	d003      	beq.n	8000ce6 <chThdCreateStatic.constprop.12+0x46>
    *startp++ = v;
 8000cde:	700d      	strb	r5, [r1, #0]
 8000ce0:	3101      	adds	r1, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000ce2:	4299      	cmp	r1, r3
 8000ce4:	d004      	beq.n	8000cf0 <chThdCreateStatic.constprop.12+0x50>
    *startp++ = v;
 8000ce6:	700d      	strb	r5, [r1, #0]
 8000ce8:	704d      	strb	r5, [r1, #1]
 8000cea:	3102      	adds	r1, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000cec:	4299      	cmp	r1, r3
 8000cee:	d1fa      	bne.n	8000ce6 <chThdCreateStatic.constprop.12+0x46>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cf0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000cf2:	f7ff fc4d 	bl	8000590 <_dbg_check_lock>
                       tprio_t prio, tfunc_t pf, void *arg) {
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
 8000cf6:	f7ff fb4b 	bl	8000390 <chDbgCheckClassI.4434>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8000cfa:	2c00      	cmp	r4, #0
 8000cfc:	d05c      	beq.n	8000db8 <chThdCreateStatic.constprop.12+0x118>
 8000cfe:	4643      	mov	r3, r8
 8000d00:	2bcf      	cmp	r3, #207	; 0xcf
 8000d02:	d959      	bls.n	8000db8 <chThdCreateStatic.constprop.12+0x118>
 8000d04:	2f7f      	cmp	r7, #127	; 0x7f
 8000d06:	d857      	bhi.n	8000db8 <chThdCreateStatic.constprop.12+0x118>
 8000d08:	464d      	mov	r5, r9
 8000d0a:	2d00      	cmp	r5, #0
 8000d0c:	d054      	beq.n	8000db8 <chThdCreateStatic.constprop.12+0x118>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000d0e:	4642      	mov	r2, r8
 8000d10:	3a24      	subs	r2, #36	; 0x24
 8000d12:	18a0      	adds	r0, r4, r2
 8000d14:	60e0      	str	r0, [r4, #12]
 8000d16:	6105      	str	r5, [r0, #16]
 8000d18:	4d32      	ldr	r5, [pc, #200]	; (8000de4 <chThdCreateStatic.constprop.12+0x144>)
 8000d1a:	2300      	movs	r3, #0
 8000d1c:	6143      	str	r3, [r0, #20]
 8000d1e:	6205      	str	r5, [r0, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000d20:	2220      	movs	r2, #32
 8000d22:	2002      	movs	r0, #2
 8000d24:	54a0      	strb	r0, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000d26:	2501      	movs	r5, #1
 8000d28:	2022      	movs	r0, #34	; 0x22
 8000d2a:	5425      	strb	r5, [r4, r0]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d2c:	4d2e      	ldr	r5, [pc, #184]	; (8000de8 <chThdCreateStatic.constprop.12+0x148>)
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000d2e:	2121      	movs	r1, #33	; 0x21
 8000d30:	5463      	strb	r3, [r4, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000d32:	63e3      	str	r3, [r4, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8000d34:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8000d36:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8000d38:	1c22      	adds	r2, r4, #0
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d3a:	696b      	ldr	r3, [r5, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8000d3c:	3228      	adds	r2, #40	; 0x28
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d3e:	6125      	str	r5, [r4, #16]
 8000d40:	611c      	str	r4, [r3, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000d42:	62a2      	str	r2, [r4, #40]	; 0x28
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8000d44:	3204      	adds	r2, #4
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000d46:	60a7      	str	r7, [r4, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d48:	6163      	str	r3, [r4, #20]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8000d4a:	61e6      	str	r6, [r4, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8000d4c:	6427      	str	r7, [r4, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000d4e:	62e2      	str	r2, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 8000d50:	6322      	str	r2, [r4, #48]	; 0x30
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d52:	616c      	str	r4, [r5, #20]
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {

  chDbgCheckClassS();
 8000d54:	f7ff fb2c 	bl	80003b0 <chDbgCheckClassS.4439>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000d58:	69a8      	ldr	r0, [r5, #24]
 8000d5a:	682e      	ldr	r6, [r5, #0]
 8000d5c:	6881      	ldr	r1, [r0, #8]
 8000d5e:	42ae      	cmp	r6, r5
 8000d60:	d002      	beq.n	8000d68 <chThdCreateStatic.constprop.12+0xc8>
 8000d62:	68b3      	ldr	r3, [r6, #8]
 8000d64:	4299      	cmp	r1, r3
 8000d66:	d330      	bcc.n	8000dca <chThdCreateStatic.constprop.12+0x12a>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000d68:	2200      	movs	r2, #0
 8000d6a:	6262      	str	r2, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000d6c:	428f      	cmp	r7, r1
 8000d6e:	d930      	bls.n	8000dd2 <chThdCreateStatic.constprop.12+0x132>
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000d70:	f7ff fd26 	bl	80007c0 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000d74:	2620      	movs	r6, #32
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000d76:	1c07      	adds	r7, r0, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000d78:	2001      	movs	r0, #1
 8000d7a:	55a0      	strb	r0, [r4, r6]
    chSysSwitch(ntp, otp);
 8000d7c:	1c38      	adds	r0, r7, #0
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8000d7e:	61ac      	str	r4, [r5, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000d80:	f7ff ff6e 	bl	8000c60 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000d84:	f3ef 8109 	mrs	r1, PSP
 8000d88:	69fb      	ldr	r3, [r7, #28]
 8000d8a:	3924      	subs	r1, #36	; 0x24
 8000d8c:	428b      	cmp	r3, r1
 8000d8e:	d818      	bhi.n	8000dc2 <chThdCreateStatic.constprop.12+0x122>
 8000d90:	1c20      	adds	r0, r4, #0
 8000d92:	1c39      	adds	r1, r7, #0
 8000d94:	f7ff fa1c 	bl	80001d0 <_port_switch>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000d98:	f7ff fbe2 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000d9c:	682f      	ldr	r7, [r5, #0]
 8000d9e:	42af      	cmp	r7, r5
 8000da0:	d004      	beq.n	8000dac <chThdCreateStatic.constprop.12+0x10c>
 8000da2:	69aa      	ldr	r2, [r5, #24]
 8000da4:	68be      	ldr	r6, [r7, #8]
 8000da6:	6890      	ldr	r0, [r2, #8]
 8000da8:	42b0      	cmp	r0, r6
 8000daa:	d316      	bcc.n	8000dda <chThdCreateStatic.constprop.12+0x13a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000dac:	b662      	cpsie	i
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
  chSysUnlock();

  return tp;
}
 8000dae:	1c20      	adds	r0, r4, #0
 8000db0:	bc0c      	pop	{r2, r3}
 8000db2:	4690      	mov	r8, r2
 8000db4:	4699      	mov	r9, r3
 8000db6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000db8:	b672      	cpsid	i
 8000dba:	4d0c      	ldr	r5, [pc, #48]	; (8000dec <chThdCreateStatic.constprop.12+0x14c>)
 8000dbc:	4c0a      	ldr	r4, [pc, #40]	; (8000de8 <chThdCreateStatic.constprop.12+0x148>)
 8000dbe:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000dc0:	e7fe      	b.n	8000dc0 <chThdCreateStatic.constprop.12+0x120>
 8000dc2:	b672      	cpsid	i
 8000dc4:	4c0a      	ldr	r4, [pc, #40]	; (8000df0 <chThdCreateStatic.constprop.12+0x150>)
 8000dc6:	62ec      	str	r4, [r5, #44]	; 0x2c
 8000dc8:	e7fe      	b.n	8000dc8 <chThdCreateStatic.constprop.12+0x128>
 8000dca:	b672      	cpsid	i
 8000dcc:	4b09      	ldr	r3, [pc, #36]	; (8000df4 <chThdCreateStatic.constprop.12+0x154>)
 8000dce:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000dd0:	e7fe      	b.n	8000dd0 <chThdCreateStatic.constprop.12+0x130>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
 8000dd2:	1c20      	adds	r0, r4, #0
 8000dd4:	f7ff fcf4 	bl	80007c0 <chSchReadyI>
 8000dd8:	e7de      	b.n	8000d98 <chThdCreateStatic.constprop.12+0xf8>
 8000dda:	b672      	cpsid	i
 8000ddc:	4906      	ldr	r1, [pc, #24]	; (8000df8 <chThdCreateStatic.constprop.12+0x158>)
 8000dde:	62e9      	str	r1, [r5, #44]	; 0x2c
 8000de0:	e7fe      	b.n	8000de0 <chThdCreateStatic.constprop.12+0x140>
 8000de2:	46c0      	nop			; (mov r8, r8)
 8000de4:	080001f1 	.word	0x080001f1
 8000de8:	20000d38 	.word	0x20000d38
 8000dec:	08001cc0 	.word	0x08001cc0
 8000df0:	08001bb0 	.word	0x08001bb0
 8000df4:	08001c00 	.word	0x08001c00
 8000df8:	08001b40 	.word	0x08001b40
 8000dfc:	46c0      	nop			; (mov r8, r8)
 8000dfe:	46c0      	nop			; (mov r8, r8)

08000e00 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000e00:	b570      	push	{r4, r5, r6, lr}
 8000e02:	1c06      	adds	r6, r0, #0
  thread_t *otp;

  chDbgCheckClassS();
 8000e04:	f7ff fad4 	bl	80003b0 <chDbgCheckClassS.4439>

  otp = currp;
 8000e08:	4c0e      	ldr	r4, [pc, #56]	; (8000e44 <chSchGoSleepS+0x44>)
  otp->p_state = newstate;
 8000e0a:	2220      	movs	r2, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000e0c:	6823      	ldr	r3, [r4, #0]
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000e0e:	69a5      	ldr	r5, [r4, #24]

  tqp->p_next = tp->p_next;
 8000e10:	6819      	ldr	r1, [r3, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e12:	2001      	movs	r0, #1
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 8000e14:	54ae      	strb	r6, [r5, r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000e16:	604c      	str	r4, [r1, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e18:	5498      	strb	r0, [r3, r2]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000e1a:	6021      	str	r1, [r4, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000e1c:	61a3      	str	r3, [r4, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000e1e:	1c28      	adds	r0, r5, #0
 8000e20:	f7ff ff1e 	bl	8000c60 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e24:	f3ef 8609 	mrs	r6, PSP
 8000e28:	69ea      	ldr	r2, [r5, #28]
 8000e2a:	3e24      	subs	r6, #36	; 0x24
 8000e2c:	42b2      	cmp	r2, r6
 8000e2e:	d804      	bhi.n	8000e3a <chSchGoSleepS+0x3a>
 8000e30:	1c29      	adds	r1, r5, #0
 8000e32:	69a0      	ldr	r0, [r4, #24]
 8000e34:	f7ff f9cc 	bl	80001d0 <_port_switch>
}
 8000e38:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e3a:	b672      	cpsid	i
 8000e3c:	4d02      	ldr	r5, [pc, #8]	; (8000e48 <chSchGoSleepS+0x48>)
 8000e3e:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000e40:	e7fe      	b.n	8000e40 <chSchGoSleepS+0x40>
 8000e42:	46c0      	nop			; (mov r8, r8)
 8000e44:	20000d38 	.word	0x20000d38
 8000e48:	08001bb0 	.word	0x08001bb0
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <chSchGoSleepTimeoutS.4368>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000e50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e52:	4647      	mov	r7, r8
 8000e54:	b480      	push	{r7}
 8000e56:	1c0e      	adds	r6, r1, #0
 8000e58:	b086      	sub	sp, #24
 8000e5a:	1c07      	adds	r7, r0, #0

  chDbgCheckClassS();
 8000e5c:	f7ff faa8 	bl	80003b0 <chDbgCheckClassS.4439>

  if (TIME_INFINITE != time) {
 8000e60:	1c71      	adds	r1, r6, #1
 8000e62:	d053      	beq.n	8000f0c <chSchGoSleepTimeoutS.4368+0xbc>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000e64:	4d4c      	ldr	r5, [pc, #304]	; (8000f98 <chSchGoSleepTimeoutS.4368+0x148>)
 8000e66:	69aa      	ldr	r2, [r5, #24]
 8000e68:	4690      	mov	r8, r2
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8000e6a:	f7ff fa91 	bl	8000390 <chDbgCheckClassI.4434>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8000e6e:	2e00      	cmp	r6, #0
 8000e70:	d103      	bne.n	8000e7a <chSchGoSleepTimeoutS.4368+0x2a>
 8000e72:	b672      	cpsid	i
 8000e74:	4b49      	ldr	r3, [pc, #292]	; (8000f9c <chSchGoSleepTimeoutS.4368+0x14c>)
 8000e76:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000e78:	e7fe      	b.n	8000e78 <chSchGoSleepTimeoutS.4368+0x28>

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8000e7a:	4849      	ldr	r0, [pc, #292]	; (8000fa0 <chSchGoSleepTimeoutS.4368+0x150>)
 8000e7c:	2180      	movs	r1, #128	; 0x80
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000e7e:	ac01      	add	r4, sp, #4
 8000e80:	4643      	mov	r3, r8
 8000e82:	05ca      	lsls	r2, r1, #23
  vtp->vt_func = vtfunc;
 8000e84:	60e0      	str	r0, [r4, #12]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000e86:	6123      	str	r3, [r4, #16]
 8000e88:	6a50      	ldr	r0, [r2, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000e8a:	2e01      	cmp	r6, #1
 8000e8c:	d943      	bls.n	8000f16 <chSchGoSleepTimeoutS.4368+0xc6>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000e8e:	1c29      	adds	r1, r5, #0
 8000e90:	69eb      	ldr	r3, [r5, #28]
 8000e92:	311c      	adds	r1, #28
 8000e94:	428b      	cmp	r3, r1
 8000e96:	d044      	beq.n	8000f22 <chSchGoSleepTimeoutS.4368+0xd2>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8000e98:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8000e9a:	6899      	ldr	r1, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8000e9c:	1830      	adds	r0, r6, r0
 8000e9e:	1a86      	subs	r6, r0, r2
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8000ea0:	428e      	cmp	r6, r1
 8000ea2:	d203      	bcs.n	8000eac <chSchGoSleepTimeoutS.4368+0x5c>
 8000ea4:	e06e      	b.n	8000f84 <chSchGoSleepTimeoutS.4368+0x134>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
    p = p->vt_next;
 8000ea6:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8000ea8:	1a76      	subs	r6, r6, r1
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000eaa:	6899      	ldr	r1, [r3, #8]
 8000eac:	42b1      	cmp	r1, r6
 8000eae:	d3fa      	bcc.n	8000ea6 <chSchGoSleepTimeoutS.4368+0x56>
  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
  vtp->vt_delta = delta
 8000eb0:	60a6      	str	r6, [r4, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000eb2:	6899      	ldr	r1, [r3, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000eb4:	6858      	ldr	r0, [r3, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000eb6:	1b8e      	subs	r6, r1, r6
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000eb8:	9301      	str	r3, [sp, #4]
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000eba:	609e      	str	r6, [r3, #8]
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000ebc:	6060      	str	r0, [r4, #4]
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
 8000ebe:	605c      	str	r4, [r3, #4]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000ec0:	2301      	movs	r3, #1
 8000ec2:	425a      	negs	r2, r3
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8000ec4:	6004      	str	r4, [r0, #0]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000ec6:	626a      	str	r2, [r5, #36]	; 0x24
    chSchGoSleepS(newstate);
 8000ec8:	1c38      	adds	r0, r7, #0
 8000eca:	f7ff ff99 	bl	8000e00 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8000ece:	f7ff fa5f 	bl	8000390 <chDbgCheckClassI.4434>
    if (chVTIsArmedI(&vt)) {
 8000ed2:	68e7      	ldr	r7, [r4, #12]
 8000ed4:	2f00      	cmp	r7, #0
 8000ed6:	d013      	beq.n	8000f00 <chSchGoSleepTimeoutS.4368+0xb0>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8000ed8:	f7ff fa5a 	bl	8000390 <chDbgCheckClassI.4434>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8000edc:	69ea      	ldr	r2, [r5, #28]
 8000ede:	42a2      	cmp	r2, r4
 8000ee0:	d030      	beq.n	8000f44 <chSchGoSleepTimeoutS.4368+0xf4>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8000ee2:	6860      	ldr	r0, [r4, #4]
 8000ee4:	6826      	ldr	r6, [r4, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000ee6:	1c2f      	adds	r7, r5, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8000ee8:	6006      	str	r6, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000eea:	6823      	ldr	r3, [r4, #0]
    vtp->vt_func = NULL;
 8000eec:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000eee:	371c      	adds	r7, #28
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000ef0:	6058      	str	r0, [r3, #4]
    vtp->vt_func = NULL;
 8000ef2:	60e1      	str	r1, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000ef4:	42bb      	cmp	r3, r7
 8000ef6:	d003      	beq.n	8000f00 <chSchGoSleepTimeoutS.4368+0xb0>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8000ef8:	68a4      	ldr	r4, [r4, #8]
 8000efa:	689a      	ldr	r2, [r3, #8]
 8000efc:	1910      	adds	r0, r2, r4
 8000efe:	6098      	str	r0, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000f00:	69ad      	ldr	r5, [r5, #24]
 8000f02:	6a68      	ldr	r0, [r5, #36]	; 0x24
}
 8000f04:	b006      	add	sp, #24
 8000f06:	bc04      	pop	{r2}
 8000f08:	4690      	mov	r8, r2
 8000f0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000f0c:	1c38      	adds	r0, r7, #0
 8000f0e:	f7ff ff77 	bl	8000e00 <chSchGoSleepS>
 8000f12:	4d21      	ldr	r5, [pc, #132]	; (8000f98 <chSchGoSleepTimeoutS.4368+0x148>)
 8000f14:	e7f4      	b.n	8000f00 <chSchGoSleepTimeoutS.4368+0xb0>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000f16:	1c29      	adds	r1, r5, #0
 8000f18:	69eb      	ldr	r3, [r5, #28]
 8000f1a:	311c      	adds	r1, #28
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000f1c:	2602      	movs	r6, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000f1e:	428b      	cmp	r3, r1
 8000f20:	d1ba      	bne.n	8000e98 <chSchGoSleepTimeoutS.4368+0x48>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8000f22:	62a8      	str	r0, [r5, #40]	; 0x28
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8000f24:	1832      	adds	r2, r6, r0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000f26:	2080      	movs	r0, #128	; 0x80
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;
 8000f28:	60a6      	str	r6, [r4, #8]
 8000f2a:	05c6      	lsls	r6, r0, #23
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8000f2c:	9301      	str	r3, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000f2e:	6063      	str	r3, [r4, #4]
 8000f30:	68f3      	ldr	r3, [r6, #12]
 8000f32:	2102      	movs	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000f34:	61ec      	str	r4, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 8000f36:	622c      	str	r4, [r5, #32]
 8000f38:	400b      	ands	r3, r1
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000f3a:	d128      	bne.n	8000f8e <chSchGoSleepTimeoutS.4368+0x13e>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000f3c:	6372      	str	r2, [r6, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000f3e:	6133      	str	r3, [r6, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000f40:	60f1      	str	r1, [r6, #12]
 8000f42:	e7c1      	b.n	8000ec8 <chSchGoSleepTimeoutS.4368+0x78>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8000f44:	6820      	ldr	r0, [r4, #0]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000f46:	1c2e      	adds	r6, r5, #0
 8000f48:	361c      	adds	r6, #28
  vtp->vt_func = NULL;
 8000f4a:	2100      	movs	r1, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8000f4c:	61e8      	str	r0, [r5, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 8000f4e:	60e1      	str	r1, [r4, #12]
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000f50:	6046      	str	r6, [r0, #4]
  vtp->vt_func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000f52:	42b0      	cmp	r0, r6
 8000f54:	d012      	beq.n	8000f7c <chSchGoSleepTimeoutS.4368+0x12c>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8000f56:	68a4      	ldr	r4, [r4, #8]
 8000f58:	6883      	ldr	r3, [r0, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000f5a:	2280      	movs	r2, #128	; 0x80
 8000f5c:	18e7      	adds	r7, r4, r3
 8000f5e:	6087      	str	r7, [r0, #8]
 8000f60:	05d0      	lsls	r0, r2, #23
 8000f62:	6a46      	ldr	r6, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8000f64:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8000f66:	1a74      	subs	r4, r6, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8000f68:	42a7      	cmp	r7, r4
 8000f6a:	d9c9      	bls.n	8000f00 <chSchGoSleepTimeoutS.4368+0xb0>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8000f6c:	1b3b      	subs	r3, r7, r4

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000f6e:	2b01      	cmp	r3, #1
 8000f70:	d800      	bhi.n	8000f74 <chSchGoSleepTimeoutS.4368+0x124>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000f72:	2302      	movs	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8000f74:	1998      	adds	r0, r3, r6
 8000f76:	f7ff fa2b 	bl	80003d0 <stSetAlarm.4441>
 8000f7a:	e7c1      	b.n	8000f00 <chSchGoSleepTimeoutS.4368+0xb0>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000f7c:	2780      	movs	r7, #128	; 0x80
 8000f7e:	05fa      	lsls	r2, r7, #23
 8000f80:	60d1      	str	r1, [r2, #12]
 8000f82:	e7bd      	b.n	8000f00 <chSchGoSleepTimeoutS.4368+0xb0>
 8000f84:	f7ff fa24 	bl	80003d0 <stSetAlarm.4441>
 8000f88:	69eb      	ldr	r3, [r5, #28]
 8000f8a:	6899      	ldr	r1, [r3, #8]
 8000f8c:	e78e      	b.n	8000eac <chSchGoSleepTimeoutS.4368+0x5c>
 8000f8e:	b672      	cpsid	i
 8000f90:	4e04      	ldr	r6, [pc, #16]	; (8000fa4 <chSchGoSleepTimeoutS.4368+0x154>)
 8000f92:	62ee      	str	r6, [r5, #44]	; 0x2c
 8000f94:	e7fe      	b.n	8000f94 <chSchGoSleepTimeoutS.4368+0x144>
 8000f96:	46c0      	nop			; (mov r8, r8)
 8000f98:	20000d38 	.word	0x20000d38
 8000f9c:	08001b60 	.word	0x08001b60
 8000fa0:	08000821 	.word	0x08000821
 8000fa4:	08001cd0 	.word	0x08001cd0
 8000fa8:	46c0      	nop			; (mov r8, r8)
 8000faa:	46c0      	nop			; (mov r8, r8)
 8000fac:	46c0      	nop			; (mov r8, r8)
 8000fae:	46c0      	nop			; (mov r8, r8)

08000fb0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000fb0:	b510      	push	{r4, lr}
 8000fb2:	1c04      	adds	r4, r0, #0
 8000fb4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000fb6:	f7ff faeb 	bl	8000590 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 8000fba:	2c00      	cmp	r4, #0
 8000fbc:	d010      	beq.n	8000fe0 <chThdSleep+0x30>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000fbe:	1c21      	adds	r1, r4, #0
 8000fc0:	2008      	movs	r0, #8
 8000fc2:	f7ff ff45 	bl	8000e50 <chSchGoSleepTimeoutS.4368>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000fc6:	f7ff facb 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000fca:	4b0a      	ldr	r3, [pc, #40]	; (8000ff4 <chThdSleep+0x44>)
 8000fcc:	681a      	ldr	r2, [r3, #0]
 8000fce:	429a      	cmp	r2, r3
 8000fd0:	d004      	beq.n	8000fdc <chThdSleep+0x2c>
 8000fd2:	6999      	ldr	r1, [r3, #24]
 8000fd4:	6894      	ldr	r4, [r2, #8]
 8000fd6:	6888      	ldr	r0, [r1, #8]
 8000fd8:	42a0      	cmp	r0, r4
 8000fda:	d306      	bcc.n	8000fea <chThdSleep+0x3a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fdc:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8000fde:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fe0:	b672      	cpsid	i
 8000fe2:	4905      	ldr	r1, [pc, #20]	; (8000ff8 <chThdSleep+0x48>)
 8000fe4:	4b03      	ldr	r3, [pc, #12]	; (8000ff4 <chThdSleep+0x44>)
 8000fe6:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000fe8:	e7fe      	b.n	8000fe8 <chThdSleep+0x38>
 8000fea:	b672      	cpsid	i
 8000fec:	4a03      	ldr	r2, [pc, #12]	; (8000ffc <chThdSleep+0x4c>)
 8000fee:	62da      	str	r2, [r3, #44]	; 0x2c
 8000ff0:	e7fe      	b.n	8000ff0 <chThdSleep+0x40>
 8000ff2:	46c0      	nop			; (mov r8, r8)
 8000ff4:	20000d38 	.word	0x20000d38
 8000ff8:	08001be0 	.word	0x08001be0
 8000ffc:	08001b40 	.word	0x08001b40

08001000 <chThdEnqueueTimeoutS.4364>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001000:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8001002:	2900      	cmp	r1, #0
 8001004:	d00a      	beq.n	800101c <chThdEnqueueTimeoutS.4364+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001006:	4b07      	ldr	r3, [pc, #28]	; (8001024 <chThdEnqueueTimeoutS.4364+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001008:	6842      	ldr	r2, [r0, #4]
 800100a:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800100c:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800100e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001010:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8001012:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001014:	2004      	movs	r0, #4
 8001016:	f7ff ff1b 	bl	8000e50 <chSchGoSleepTimeoutS.4368>
}
 800101a:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 800101c:	2001      	movs	r0, #1
 800101e:	4240      	negs	r0, r0
 8001020:	e7fb      	b.n	800101a <chThdEnqueueTimeoutS.4364+0x1a>
 8001022:	46c0      	nop			; (mov r8, r8)
 8001024:	20000d38 	.word	0x20000d38
 8001028:	46c0      	nop			; (mov r8, r8)
 800102a:	46c0      	nop			; (mov r8, r8)
 800102c:	46c0      	nop			; (mov r8, r8)
 800102e:	46c0      	nop			; (mov r8, r8)

08001030 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001030:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001032:	464e      	mov	r6, r9
 8001034:	4645      	mov	r5, r8
 8001036:	4657      	mov	r7, sl
 8001038:	b4e0      	push	{r5, r6, r7}
 800103a:	1c15      	adds	r5, r2, #0
  qnotify_t nfy = iqp->q_notify;
 800103c:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800103e:	1c04      	adds	r4, r0, #0
 8001040:	1c0e      	adds	r6, r1, #0
 8001042:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8001044:	4690      	mov	r8, r2
 8001046:	b672      	cpsid	i
  size_t r = 0;

  chDbgCheck(n > 0U);
 8001048:	2d00      	cmp	r5, #0
 800104a:	d04b      	beq.n	80010e4 <chIQReadTimeout+0xb4>
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
 800104c:	3d01      	subs	r5, #1
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800104e:	f7ff fa9f 	bl	8000590 <_dbg_check_lock>
 8001052:	19a8      	adds	r0, r5, r6
 8001054:	4d27      	ldr	r5, [pc, #156]	; (80010f4 <chIQReadTimeout+0xc4>)
 8001056:	4682      	mov	sl, r0
                       size_t n, systime_t timeout) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8001058:	2700      	movs	r7, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 800105a:	4643      	mov	r3, r8
 800105c:	2b00      	cmp	r3, #0
 800105e:	d001      	beq.n	8001064 <chIQReadTimeout+0x34>
      nfy(iqp);
 8001060:	1c20      	adds	r0, r4, #0
 8001062:	47c0      	blx	r8
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001064:	f7ff f994 	bl	8000390 <chDbgCheckClassI.4434>

  return (bool)(chQSpaceI(iqp) == 0U);
 8001068:	68a1      	ldr	r1, [r4, #8]
    }

    while (chIQIsEmptyI(iqp)) {
 800106a:	2900      	cmp	r1, #0
 800106c:	d11a      	bne.n	80010a4 <chIQReadTimeout+0x74>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800106e:	1c20      	adds	r0, r4, #0
 8001070:	4649      	mov	r1, r9
 8001072:	f7ff ffc5 	bl	8001000 <chThdEnqueueTimeoutS.4364>
 8001076:	2800      	cmp	r0, #0
 8001078:	d0f4      	beq.n	8001064 <chIQReadTimeout+0x34>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800107a:	f7ff fa71 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800107e:	6828      	ldr	r0, [r5, #0]
 8001080:	42a8      	cmp	r0, r5
 8001082:	d004      	beq.n	800108e <chIQReadTimeout+0x5e>
 8001084:	69ab      	ldr	r3, [r5, #24]
 8001086:	6882      	ldr	r2, [r0, #8]
 8001088:	6899      	ldr	r1, [r3, #8]
 800108a:	4291      	cmp	r1, r2
 800108c:	d306      	bcc.n	800109c <chIQReadTimeout+0x6c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800108e:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 8001090:	1c38      	adds	r0, r7, #0
 8001092:	bc1c      	pop	{r2, r3, r4}
 8001094:	4690      	mov	r8, r2
 8001096:	4699      	mov	r9, r3
 8001098:	46a2      	mov	sl, r4
 800109a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800109c:	b672      	cpsid	i
 800109e:	4c16      	ldr	r4, [pc, #88]	; (80010f8 <chIQReadTimeout+0xc8>)
 80010a0:	62ec      	str	r4, [r5, #44]	; 0x2c
 80010a2:	e7fe      	b.n	80010a2 <chIQReadTimeout+0x72>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80010a4:	68a2      	ldr	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80010a6:	69a0      	ldr	r0, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80010a8:	3a01      	subs	r2, #1
 80010aa:	60a2      	str	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80010ac:	7803      	ldrb	r3, [r0, #0]
 80010ae:	3001      	adds	r0, #1
 80010b0:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 80010b2:	6921      	ldr	r1, [r4, #16]
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80010b4:	61a0      	str	r0, [r4, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 80010b6:	4288      	cmp	r0, r1
 80010b8:	d301      	bcc.n	80010be <chIQReadTimeout+0x8e>
      iqp->q_rdptr = iqp->q_buffer;
 80010ba:	68e2      	ldr	r2, [r4, #12]
 80010bc:	61a2      	str	r2, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80010be:	f7ff fa4f 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80010c2:	6828      	ldr	r0, [r5, #0]
 80010c4:	42a8      	cmp	r0, r5
 80010c6:	d004      	beq.n	80010d2 <chIQReadTimeout+0xa2>
 80010c8:	69ab      	ldr	r3, [r5, #24]
 80010ca:	6882      	ldr	r2, [r0, #8]
 80010cc:	6899      	ldr	r1, [r3, #8]
 80010ce:	4291      	cmp	r1, r2
 80010d0:	d30c      	bcc.n	80010ec <chIQReadTimeout+0xbc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80010d2:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 80010d4:	3701      	adds	r7, #1
    if (--n == 0U) {
 80010d6:	4556      	cmp	r6, sl
 80010d8:	d0da      	beq.n	8001090 <chIQReadTimeout+0x60>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80010da:	3601      	adds	r6, #1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80010dc:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80010de:	f7ff fa57 	bl	8000590 <_dbg_check_lock>
 80010e2:	e7ba      	b.n	800105a <chIQReadTimeout+0x2a>
 80010e4:	4d05      	ldr	r5, [pc, #20]	; (80010fc <chIQReadTimeout+0xcc>)
 80010e6:	4e03      	ldr	r6, [pc, #12]	; (80010f4 <chIQReadTimeout+0xc4>)
 80010e8:	62f5      	str	r5, [r6, #44]	; 0x2c
 80010ea:	e7fe      	b.n	80010ea <chIQReadTimeout+0xba>
 80010ec:	b672      	cpsid	i
 80010ee:	4c02      	ldr	r4, [pc, #8]	; (80010f8 <chIQReadTimeout+0xc8>)
 80010f0:	62ec      	str	r4, [r5, #44]	; 0x2c
 80010f2:	e7fe      	b.n	80010f2 <chIQReadTimeout+0xc2>
 80010f4:	20000d38 	.word	0x20000d38
 80010f8:	08001cb0 	.word	0x08001cb0
 80010fc:	08001ca0 	.word	0x08001ca0

08001100 <chIQGetTimeout.4181>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001100:	b570      	push	{r4, r5, r6, lr}
 8001102:	1c04      	adds	r4, r0, #0
 8001104:	1c0e      	adds	r6, r1, #0
 8001106:	b672      	cpsid	i
 8001108:	f7ff fa42 	bl	8000590 <_dbg_check_lock>
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800110c:	69e3      	ldr	r3, [r4, #28]
 800110e:	2b00      	cmp	r3, #0
 8001110:	d001      	beq.n	8001116 <chIQGetTimeout.4181+0x16>
    iqp->q_notify(iqp);
 8001112:	1c20      	adds	r0, r4, #0
 8001114:	4798      	blx	r3
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001116:	f7ff f93b 	bl	8000390 <chDbgCheckClassI.4434>

  return (bool)(chQSpaceI(iqp) == 0U);
 800111a:	68a0      	ldr	r0, [r4, #8]
  }

  while (chIQIsEmptyI(iqp)) {
 800111c:	2800      	cmp	r0, #0
 800111e:	d113      	bne.n	8001148 <chIQGetTimeout.4181+0x48>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001120:	1c20      	adds	r0, r4, #0
 8001122:	1c31      	adds	r1, r6, #0
 8001124:	f7ff ff6c 	bl	8001000 <chThdEnqueueTimeoutS.4364>
 8001128:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 800112a:	daf4      	bge.n	8001116 <chIQGetTimeout.4181+0x16>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800112c:	f7ff fa18 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001130:	4b15      	ldr	r3, [pc, #84]	; (8001188 <chIQGetTimeout.4181+0x88>)
 8001132:	6818      	ldr	r0, [r3, #0]
 8001134:	4298      	cmp	r0, r3
 8001136:	d004      	beq.n	8001142 <chIQGetTimeout.4181+0x42>
 8001138:	6999      	ldr	r1, [r3, #24]
 800113a:	6882      	ldr	r2, [r0, #8]
 800113c:	688c      	ldr	r4, [r1, #8]
 800113e:	4294      	cmp	r4, r2
 8001140:	d31d      	bcc.n	800117e <chIQGetTimeout.4181+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001142:	b662      	cpsie	i
    iqp->q_rdptr = iqp->q_buffer;
  }
  chSysUnlock();

  return (msg_t)b;
}
 8001144:	1c28      	adds	r0, r5, #0
 8001146:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001148:	68a1      	ldr	r1, [r4, #8]
  b = *iqp->q_rdptr++;
 800114a:	69a6      	ldr	r6, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800114c:	3901      	subs	r1, #1
 800114e:	60a1      	str	r1, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001150:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001152:	7835      	ldrb	r5, [r6, #0]
 8001154:	3601      	adds	r6, #1
 8001156:	61a6      	str	r6, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001158:	4296      	cmp	r6, r2
 800115a:	d301      	bcc.n	8001160 <chIQGetTimeout.4181+0x60>
    iqp->q_rdptr = iqp->q_buffer;
 800115c:	68e3      	ldr	r3, [r4, #12]
 800115e:	61a3      	str	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001160:	f7ff f9fe 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001164:	4c08      	ldr	r4, [pc, #32]	; (8001188 <chIQGetTimeout.4181+0x88>)
 8001166:	6820      	ldr	r0, [r4, #0]
 8001168:	42a0      	cmp	r0, r4
 800116a:	d0ea      	beq.n	8001142 <chIQGetTimeout.4181+0x42>
 800116c:	69a1      	ldr	r1, [r4, #24]
 800116e:	6882      	ldr	r2, [r0, #8]
 8001170:	688e      	ldr	r6, [r1, #8]
 8001172:	4296      	cmp	r6, r2
 8001174:	d2e5      	bcs.n	8001142 <chIQGetTimeout.4181+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001176:	b672      	cpsid	i
 8001178:	4d04      	ldr	r5, [pc, #16]	; (800118c <chIQGetTimeout.4181+0x8c>)
 800117a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800117c:	e7fe      	b.n	800117c <chIQGetTimeout.4181+0x7c>
 800117e:	b672      	cpsid	i
 8001180:	4d02      	ldr	r5, [pc, #8]	; (800118c <chIQGetTimeout.4181+0x8c>)
 8001182:	62dd      	str	r5, [r3, #44]	; 0x2c
 8001184:	e7fe      	b.n	8001184 <chIQGetTimeout.4181+0x84>
 8001186:	46c0      	nop			; (mov r8, r8)
 8001188:	20000d38 	.word	0x20000d38
 800118c:	08001cb0 	.word	0x08001cb0

08001190 <gett.7871>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 8001190:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001192:	300c      	adds	r0, #12
 8001194:	f7ff ffb4 	bl	8001100 <chIQGetTimeout.4181>
}
 8001198:	bd08      	pop	{r3, pc}
 800119a:	46c0      	nop			; (mov r8, r8)
 800119c:	46c0      	nop			; (mov r8, r8)
 800119e:	46c0      	nop			; (mov r8, r8)

080011a0 <get.7875>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 80011a0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80011a2:	2101      	movs	r1, #1
 80011a4:	300c      	adds	r0, #12
 80011a6:	4249      	negs	r1, r1
 80011a8:	f7ff ffaa 	bl	8001100 <chIQGetTimeout.4181>
}
 80011ac:	bd08      	pop	{r3, pc}
 80011ae:	46c0      	nop			; (mov r8, r8)

080011b0 <chOQPutTimeout.4206>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80011b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80011b2:	1c04      	adds	r4, r0, #0
 80011b4:	1c0f      	adds	r7, r1, #0
 80011b6:	1c16      	adds	r6, r2, #0
 80011b8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80011ba:	f7ff f9e9 	bl	8000590 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80011be:	f7ff f8e7 	bl	8000390 <chDbgCheckClassI.4434>

  return (bool)(chQSpaceI(oqp) == 0U);
 80011c2:	68a3      	ldr	r3, [r4, #8]

  chSysLock();
  while (chOQIsFullI(oqp)) {
 80011c4:	2b00      	cmp	r3, #0
 80011c6:	d113      	bne.n	80011f0 <chOQPutTimeout.4206+0x40>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80011c8:	1c20      	adds	r0, r4, #0
 80011ca:	1c31      	adds	r1, r6, #0
 80011cc:	f7ff ff18 	bl	8001000 <chThdEnqueueTimeoutS.4364>
 80011d0:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 80011d2:	daf4      	bge.n	80011be <chOQPutTimeout.4206+0xe>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80011d4:	f7ff f9c4 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80011d8:	4b19      	ldr	r3, [pc, #100]	; (8001240 <chOQPutTimeout.4206+0x90>)
 80011da:	6818      	ldr	r0, [r3, #0]
 80011dc:	4298      	cmp	r0, r3
 80011de:	d004      	beq.n	80011ea <chOQPutTimeout.4206+0x3a>
 80011e0:	6999      	ldr	r1, [r3, #24]
 80011e2:	6882      	ldr	r2, [r0, #8]
 80011e4:	688c      	ldr	r4, [r1, #8]
 80011e6:	4294      	cmp	r4, r2
 80011e8:	d321      	bcc.n	800122e <chOQPutTimeout.4206+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011ea:	b662      	cpsie	i
    oqp->q_notify(oqp);
  }
  chSysUnlock();

  return Q_OK;
}
 80011ec:	1c28      	adds	r0, r5, #0
 80011ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80011f0:	68a0      	ldr	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 80011f2:	6961      	ldr	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80011f4:	3801      	subs	r0, #1
 80011f6:	60a0      	str	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 80011f8:	700f      	strb	r7, [r1, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80011fa:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80011fc:	3101      	adds	r1, #1
 80011fe:	6161      	str	r1, [r4, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001200:	4291      	cmp	r1, r2
 8001202:	d301      	bcc.n	8001208 <chOQPutTimeout.4206+0x58>
    oqp->q_wrptr = oqp->q_buffer;
 8001204:	68e5      	ldr	r5, [r4, #12]
 8001206:	6165      	str	r5, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8001208:	69e6      	ldr	r6, [r4, #28]
 800120a:	2e00      	cmp	r6, #0
 800120c:	d001      	beq.n	8001212 <chOQPutTimeout.4206+0x62>
    oqp->q_notify(oqp);
 800120e:	1c20      	adds	r0, r4, #0
 8001210:	47b0      	blx	r6
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001212:	f7ff f9a5 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001216:	4c0a      	ldr	r4, [pc, #40]	; (8001240 <chOQPutTimeout.4206+0x90>)
 8001218:	6827      	ldr	r7, [r4, #0]
 800121a:	42a7      	cmp	r7, r4
 800121c:	d004      	beq.n	8001228 <chOQPutTimeout.4206+0x78>
 800121e:	69a3      	ldr	r3, [r4, #24]
 8001220:	68b9      	ldr	r1, [r7, #8]
 8001222:	6898      	ldr	r0, [r3, #8]
 8001224:	4288      	cmp	r0, r1
 8001226:	d306      	bcc.n	8001236 <chOQPutTimeout.4206+0x86>
 8001228:	b662      	cpsie	i
 800122a:	2500      	movs	r5, #0
 800122c:	e7de      	b.n	80011ec <chOQPutTimeout.4206+0x3c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800122e:	b672      	cpsid	i
 8001230:	4d04      	ldr	r5, [pc, #16]	; (8001244 <chOQPutTimeout.4206+0x94>)
 8001232:	62dd      	str	r5, [r3, #44]	; 0x2c
 8001234:	e7fe      	b.n	8001234 <chOQPutTimeout.4206+0x84>
 8001236:	b672      	cpsid	i
 8001238:	4a02      	ldr	r2, [pc, #8]	; (8001244 <chOQPutTimeout.4206+0x94>)
 800123a:	62e2      	str	r2, [r4, #44]	; 0x2c
 800123c:	e7fe      	b.n	800123c <chOQPutTimeout.4206+0x8c>
 800123e:	46c0      	nop			; (mov r8, r8)
 8001240:	20000d38 	.word	0x20000d38
 8001244:	08001cb0 	.word	0x08001cb0
 8001248:	46c0      	nop			; (mov r8, r8)
 800124a:	46c0      	nop			; (mov r8, r8)
 800124c:	46c0      	nop			; (mov r8, r8)
 800124e:	46c0      	nop			; (mov r8, r8)

08001250 <putt.7878>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8001250:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001252:	3030      	adds	r0, #48	; 0x30
 8001254:	f7ff ffac 	bl	80011b0 <chOQPutTimeout.4206>
}
 8001258:	bd08      	pop	{r3, pc}
 800125a:	46c0      	nop			; (mov r8, r8)
 800125c:	46c0      	nop			; (mov r8, r8)
 800125e:	46c0      	nop			; (mov r8, r8)

08001260 <put.7883>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8001260:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001262:	2201      	movs	r2, #1
 8001264:	3030      	adds	r0, #48	; 0x30
 8001266:	4252      	negs	r2, r2
 8001268:	f7ff ffa2 	bl	80011b0 <chOQPutTimeout.4206>
}
 800126c:	bd08      	pop	{r3, pc}
 800126e:	46c0      	nop			; (mov r8, r8)

08001270 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001270:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001272:	4645      	mov	r5, r8
 8001274:	4688      	mov	r8, r1
  qnotify_t nfy = oqp->q_notify;
 8001276:	69c1      	ldr	r1, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001278:	4657      	mov	r7, sl
 800127a:	464e      	mov	r6, r9
 800127c:	b4e0      	push	{r5, r6, r7}
 800127e:	1c04      	adds	r4, r0, #0
 8001280:	1c16      	adds	r6, r2, #0
 8001282:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8001284:	4689      	mov	r9, r1
 8001286:	b672      	cpsid	i
  size_t w = 0;

  chDbgCheck(n > 0U);
 8001288:	2a00      	cmp	r2, #0
 800128a:	d04f      	beq.n	800132c <chOQWriteTimeout+0xbc>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800128c:	f7ff f980 	bl	8000590 <_dbg_check_lock>
 8001290:	4d2a      	ldr	r5, [pc, #168]	; (800133c <chOQWriteTimeout+0xcc>)
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8001292:	2700      	movs	r7, #0
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001294:	f7ff f87c 	bl	8000390 <chDbgCheckClassI.4434>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001298:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800129a:	2b00      	cmp	r3, #0
 800129c:	d02b      	beq.n	80012f6 <chOQWriteTimeout+0x86>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800129e:	68a0      	ldr	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 80012a0:	4642      	mov	r2, r8
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80012a2:	3801      	subs	r0, #1
 80012a4:	60a0      	str	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 80012a6:	6963      	ldr	r3, [r4, #20]
 80012a8:	7811      	ldrb	r1, [r2, #0]
 80012aa:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80012ac:	6920      	ldr	r0, [r4, #16]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80012ae:	3301      	adds	r3, #1
 80012b0:	6163      	str	r3, [r4, #20]
    if (oqp->q_wrptr >= oqp->q_top) {
 80012b2:	4283      	cmp	r3, r0
 80012b4:	d301      	bcc.n	80012ba <chOQWriteTimeout+0x4a>
      oqp->q_wrptr = oqp->q_buffer;
 80012b6:	68e3      	ldr	r3, [r4, #12]
 80012b8:	6163      	str	r3, [r4, #20]
    }

    if (nfy != NULL) {
 80012ba:	464a      	mov	r2, r9
 80012bc:	2a00      	cmp	r2, #0
 80012be:	d001      	beq.n	80012c4 <chOQWriteTimeout+0x54>
      nfy(oqp);
 80012c0:	1c20      	adds	r0, r4, #0
 80012c2:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012c4:	f7ff f94c 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80012c8:	6828      	ldr	r0, [r5, #0]
 80012ca:	42a8      	cmp	r0, r5
 80012cc:	d004      	beq.n	80012d8 <chOQWriteTimeout+0x68>
 80012ce:	69a9      	ldr	r1, [r5, #24]
 80012d0:	6883      	ldr	r3, [r0, #8]
 80012d2:	688a      	ldr	r2, [r1, #8]
 80012d4:	429a      	cmp	r2, r3
 80012d6:	d325      	bcc.n	8001324 <chOQWriteTimeout+0xb4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80012d8:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 80012da:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 80012dc:	3701      	adds	r7, #1
    if (--n == 0U) {
 80012de:	2e00      	cmp	r6, #0
 80012e0:	d01a      	beq.n	8001318 <chOQWriteTimeout+0xa8>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80012e2:	2001      	movs	r0, #1
 80012e4:	4480      	add	r8, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80012e6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80012e8:	f7ff f952 	bl	8000590 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80012ec:	f7ff f850 	bl	8000390 <chDbgCheckClassI.4434>

  return (bool)(chQSpaceI(oqp) == 0U);
 80012f0:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80012f2:	2b00      	cmp	r3, #0
 80012f4:	d1d3      	bne.n	800129e <chOQWriteTimeout+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80012f6:	1c20      	adds	r0, r4, #0
 80012f8:	4651      	mov	r1, sl
 80012fa:	f7ff fe81 	bl	8001000 <chThdEnqueueTimeoutS.4364>
 80012fe:	2800      	cmp	r0, #0
 8001300:	d0c8      	beq.n	8001294 <chOQWriteTimeout+0x24>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001302:	f7ff f92d 	bl	8000560 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001306:	6829      	ldr	r1, [r5, #0]
 8001308:	42a9      	cmp	r1, r5
 800130a:	d004      	beq.n	8001316 <chOQWriteTimeout+0xa6>
 800130c:	69aa      	ldr	r2, [r5, #24]
 800130e:	688b      	ldr	r3, [r1, #8]
 8001310:	6890      	ldr	r0, [r2, #8]
 8001312:	4298      	cmp	r0, r3
 8001314:	d30e      	bcc.n	8001334 <chOQWriteTimeout+0xc4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001316:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8001318:	1c38      	adds	r0, r7, #0
 800131a:	bc1c      	pop	{r2, r3, r4}
 800131c:	4690      	mov	r8, r2
 800131e:	4699      	mov	r9, r3
 8001320:	46a2      	mov	sl, r4
 8001322:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001324:	b672      	cpsid	i
 8001326:	4c06      	ldr	r4, [pc, #24]	; (8001340 <chOQWriteTimeout+0xd0>)
 8001328:	62ec      	str	r4, [r5, #44]	; 0x2c
 800132a:	e7fe      	b.n	800132a <chOQWriteTimeout+0xba>
 800132c:	4d05      	ldr	r5, [pc, #20]	; (8001344 <chOQWriteTimeout+0xd4>)
 800132e:	4e03      	ldr	r6, [pc, #12]	; (800133c <chOQWriteTimeout+0xcc>)
 8001330:	62f5      	str	r5, [r6, #44]	; 0x2c
 8001332:	e7fe      	b.n	8001332 <chOQWriteTimeout+0xc2>
 8001334:	b672      	cpsid	i
 8001336:	4c02      	ldr	r4, [pc, #8]	; (8001340 <chOQWriteTimeout+0xd0>)
 8001338:	62ec      	str	r4, [r5, #44]	; 0x2c
 800133a:	e7fe      	b.n	800133a <chOQWriteTimeout+0xca>
 800133c:	20000d38 	.word	0x20000d38
 8001340:	08001cb0 	.word	0x08001cb0
 8001344:	08001ae0 	.word	0x08001ae0
 8001348:	46c0      	nop			; (mov r8, r8)
 800134a:	46c0      	nop			; (mov r8, r8)
 800134c:	46c0      	nop			; (mov r8, r8)
 800134e:	46c0      	nop			; (mov r8, r8)

08001350 <debug_write.8754>:
 */

char stn_rx_buf[1024] = "booo\r\n";

static void debug_write(char *msg)
{
 8001350:	b570      	push	{r4, r5, r6, lr}
 8001352:	1c06      	adds	r6, r0, #0
    sdWrite(&SD1, (uint8_t*)msg, strlen(msg));
 8001354:	f000 fba4 	bl	8001aa0 <strlen>
 8001358:	2401      	movs	r4, #1
 800135a:	4d09      	ldr	r5, [pc, #36]	; (8001380 <debug_write.8754+0x30>)
 800135c:	4264      	negs	r4, r4
 800135e:	1c31      	adds	r1, r6, #0
 8001360:	1c23      	adds	r3, r4, #0
 8001362:	1c02      	adds	r2, r0, #0
 8001364:	1c28      	adds	r0, r5, #0
 8001366:	f7ff ff83 	bl	8001270 <chOQWriteTimeout>
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 800136a:	1c28      	adds	r0, r5, #0
 800136c:	1c22      	adds	r2, r4, #0
 800136e:	210d      	movs	r1, #13
 8001370:	f7ff ff1e 	bl	80011b0 <chOQPutTimeout.4206>
 8001374:	1c28      	adds	r0, r5, #0
 8001376:	210a      	movs	r1, #10
 8001378:	1c22      	adds	r2, r4, #0
 800137a:	f7ff ff19 	bl	80011b0 <chOQPutTimeout.4206>
    sdPut(&SD1, '\r');
    sdPut(&SD1, '\n');
}
 800137e:	bd70      	pop	{r4, r5, r6, pc}
 8001380:	20000a30 	.word	0x20000a30
 8001384:	46c0      	nop			; (mov r8, r8)
 8001386:	46c0      	nop			; (mov r8, r8)
 8001388:	46c0      	nop			; (mov r8, r8)
 800138a:	46c0      	nop			; (mov r8, r8)
 800138c:	46c0      	nop			; (mov r8, r8)
 800138e:	46c0      	nop			; (mov r8, r8)

08001390 <writet.7860>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8001390:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001392:	3030      	adds	r0, #48	; 0x30
 8001394:	f7ff ff6c 	bl	8001270 <chOQWriteTimeout>
}
 8001398:	bd08      	pop	{r3, pc}
 800139a:	46c0      	nop			; (mov r8, r8)
 800139c:	46c0      	nop			; (mov r8, r8)
 800139e:	46c0      	nop			; (mov r8, r8)

080013a0 <write.7866>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80013a0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80013a2:	2301      	movs	r3, #1
 80013a4:	3030      	adds	r0, #48	; 0x30
 80013a6:	425b      	negs	r3, r3
 80013a8:	f7ff ff62 	bl	8001270 <chOQWriteTimeout>
                        n, TIME_INFINITE);
}
 80013ac:	bd08      	pop	{r3, pc}
 80013ae:	46c0      	nop			; (mov r8, r8)

080013b0 <readt.7849.4368>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 80013b0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80013b2:	300c      	adds	r0, #12
 80013b4:	f7ff fe3c 	bl	8001030 <chIQReadTimeout>
}
 80013b8:	bd08      	pop	{r3, pc}
 80013ba:	46c0      	nop			; (mov r8, r8)
 80013bc:	46c0      	nop			; (mov r8, r8)
 80013be:	46c0      	nop			; (mov r8, r8)

080013c0 <read.7855.4374>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80013c0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80013c2:	2301      	movs	r3, #1
 80013c4:	300c      	adds	r0, #12
 80013c6:	425b      	negs	r3, r3
 80013c8:	f7ff fe32 	bl	8001030 <chIQReadTimeout>
                       n, TIME_INFINITE);
}
 80013cc:	bd08      	pop	{r3, pc}
 80013ce:	46c0      	nop			; (mov r8, r8)

080013d0 <STN1110_rx.8747.4187>:
    debug_write("after reset");

}

static THD_WORKING_AREA(wa_STN1110_rx, 128);
static THD_FUNCTION(STN1110_rx, arg) {
 80013d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80013d2:	4b31      	ldr	r3, [pc, #196]	; (8001498 <STN1110_rx.8747.4187+0xc8>)
 80013d4:	4a31      	ldr	r2, [pc, #196]	; (800149c <STN1110_rx.8747.4187+0xcc>)
 80013d6:	6998      	ldr	r0, [r3, #24]
 80013d8:	465f      	mov	r7, fp
 80013da:	4656      	mov	r6, sl
 80013dc:	464d      	mov	r5, r9
 80013de:	4644      	mov	r4, r8
 80013e0:	b4f0      	push	{r4, r5, r6, r7}
 80013e2:	6182      	str	r2, [r0, #24]
    sdPut(&SD1, '\n');
}

static void reset_stn1110(void)
{
    debug_write("resetting");
 80013e4:	482e      	ldr	r0, [pc, #184]	; (80014a0 <STN1110_rx.8747.4187+0xd0>)
 80013e6:	f7ff ffb3 	bl	8001350 <debug_write.8754>
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);


    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 80013ea:	4c2e      	ldr	r4, [pc, #184]	; (80014a4 <STN1110_rx.8747.4187+0xd4>)
    debug_write("resetting");

    /* set NVM reset to disbled (normal running mode)
     * Use internall pullup resistor to disable NVM
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);
 80013ec:	2190      	movs	r1, #144	; 0x90
 80013ee:	05c8      	lsls	r0, r1, #23
 80013f0:	2220      	movs	r2, #32
 80013f2:	2102      	movs	r1, #2
 80013f4:	f7ff fbb4 	bl	8000b60 <_pal_lld_setgroupmode>


    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
 80013f8:	2504      	movs	r5, #4
     * */
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);


    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 80013fa:	2201      	movs	r2, #1
 80013fc:	2104      	movs	r1, #4
 80013fe:	1c20      	adds	r0, r4, #0
 8001400:	f7ff fbae 	bl	8000b60 <_pal_lld_setgroupmode>
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
    chThdSleepMilliseconds(10);
    palSetPad(GPIOB, GPIOB_RESET_STN1110);
    chThdSleepMilliseconds(100);
 8001404:	26fa      	movs	r6, #250	; 0xfa


    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
    chThdSleepMilliseconds(10);
 8001406:	2064      	movs	r0, #100	; 0x64
    palSetPadMode(GPIOA, GPIOB_RESET_NVM_STN1110, PAL_MODE_INPUT_PULLUP);


    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001408:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(10);
 800140a:	f7ff fdd1 	bl	8000fb0 <chThdSleep>
    palSetPad(GPIOB, GPIOB_RESET_STN1110);
    chThdSleepMilliseconds(100);
 800140e:	00b0      	lsls	r0, r6, #2

    /* Toggle Reset Line */
    palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
    palClearPad(GPIOB, GPIOB_RESET_STN1110);
    chThdSleepMilliseconds(10);
    palSetPad(GPIOB, GPIOB_RESET_STN1110);
 8001410:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(100);
 8001412:	f7ff fdcd 	bl	8000fb0 <chThdSleep>
    debug_write("after reset");
 8001416:	4f24      	ldr	r7, [pc, #144]	; (80014a8 <STN1110_rx.8747.4187+0xd8>)
 8001418:	1c38      	adds	r0, r7, #0
 800141a:	f7ff ff99 	bl	8001350 <debug_write.8754>
 800141e:	4b23      	ldr	r3, [pc, #140]	; (80014ac <STN1110_rx.8747.4187+0xdc>)
 8001420:	4823      	ldr	r0, [pc, #140]	; (80014b0 <STN1110_rx.8747.4187+0xe0>)
 8001422:	4a24      	ldr	r2, [pc, #144]	; (80014b4 <STN1110_rx.8747.4187+0xe4>)
 8001424:	46b8      	mov	r8, r7
 8001426:	4e24      	ldr	r6, [pc, #144]	; (80014b8 <STN1110_rx.8747.4187+0xe8>)
 8001428:	4f24      	ldr	r7, [pc, #144]	; (80014bc <STN1110_rx.8747.4187+0xec>)
 800142a:	469b      	mov	fp, r3
 800142c:	4682      	mov	sl, r0
 800142e:	4691      	mov	r9, r2

  while (true) {
      /* Reset the STN1110 */

      debug_write("reset ");
      palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 8001430:	4c1c      	ldr	r4, [pc, #112]	; (80014a4 <STN1110_rx.8747.4187+0xd4>)
  char * at_msg= "AT\r\n";

  while (true) {
      /* Reset the STN1110 */

      debug_write("reset ");
 8001432:	4658      	mov	r0, fp
 8001434:	f7ff ff8c 	bl	8001350 <debug_write.8754>
      palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
      palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001438:	2504      	movs	r5, #4

  while (true) {
      /* Reset the STN1110 */

      debug_write("reset ");
      palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
 800143a:	2201      	movs	r2, #1
 800143c:	1c20      	adds	r0, r4, #0
 800143e:	2104      	movs	r1, #4
 8001440:	f7ff fb8e 	bl	8000b60 <_pal_lld_setgroupmode>
      palClearPad(GPIOB, GPIOB_RESET_STN1110);
 8001444:	8365      	strh	r5, [r4, #26]
      chThdSleepMilliseconds(10);
 8001446:	2064      	movs	r0, #100	; 0x64
 8001448:	f7ff fdb2 	bl	8000fb0 <chThdSleep>
      palSetPad(GPIOB, GPIOB_RESET_STN1110);
      chThdSleepMilliseconds(100);
 800144c:	21fa      	movs	r1, #250	; 0xfa
 800144e:	0088      	lsls	r0, r1, #2

      debug_write("reset ");
      palSetPadMode(GPIOB, GPIOB_RESET_STN1110, PAL_MODE_OUTPUT_PUSHPULL);
      palClearPad(GPIOB, GPIOB_RESET_STN1110);
      chThdSleepMilliseconds(10);
      palSetPad(GPIOB, GPIOB_RESET_STN1110);
 8001450:	8325      	strh	r5, [r4, #24]
      chThdSleepMilliseconds(100);
 8001452:	f7ff fdad 	bl	8000fb0 <chThdSleep>
      debug_write("after reset");
 8001456:	4640      	mov	r0, r8
 8001458:	f7ff ff7a 	bl	8001350 <debug_write.8754>



      debug_write("sending AT");
 800145c:	4650      	mov	r0, sl
 800145e:	f7ff ff77 	bl	8001350 <debug_write.8754>
      sdWrite(&SD2, (uint8_t*)at_msg, strlen(at_msg));
 8001462:	1c38      	adds	r0, r7, #0
 8001464:	2301      	movs	r3, #1
 8001466:	4649      	mov	r1, r9
 8001468:	2204      	movs	r2, #4
 800146a:	425b      	negs	r3, r3
 800146c:	3030      	adds	r0, #48	; 0x30
 800146e:	f7ff feff 	bl	8001270 <chOQWriteTimeout>
      chThdSleepMilliseconds(1000);
 8001472:	4813      	ldr	r0, [pc, #76]	; (80014c0 <STN1110_rx.8747.4187+0xf0>)
 8001474:	f7ff fd9c 	bl	8000fb0 <chThdSleep>
      debug_write("Waiting for AT response");
 8001478:	4812      	ldr	r0, [pc, #72]	; (80014c4 <STN1110_rx.8747.4187+0xf4>)
 800147a:	f7ff ff69 	bl	8001350 <debug_write.8754>
      int bytes_read = sdReadTimeout(&SD2,(uint8_t*)stn_rx_buf,sizeof(stn_rx_buf),5000);
 800147e:	1c38      	adds	r0, r7, #0
 8001480:	2280      	movs	r2, #128	; 0x80
 8001482:	1c31      	adds	r1, r6, #0
 8001484:	00d2      	lsls	r2, r2, #3
 8001486:	4b10      	ldr	r3, [pc, #64]	; (80014c8 <STN1110_rx.8747.4187+0xf8>)
 8001488:	300c      	adds	r0, #12
 800148a:	f7ff fdd1 	bl	8001030 <chIQReadTimeout>
      //chprintf(&SD1, "blah\r\n");
     // chprintf(&SD1, "Bytes read %i\r\n", bytes_read);
//sdGetLine(&SD1, (uint8_t*)stn_rx_buf);
      debug_write(stn_rx_buf);
 800148e:	1c30      	adds	r0, r6, #0
 8001490:	f7ff ff5e 	bl	8001350 <debug_write.8754>
 8001494:	e7cc      	b.n	8001430 <STN1110_rx.8747.4187+0x60>
 8001496:	46c0      	nop			; (mov r8, r8)
 8001498:	20000d38 	.word	0x20000d38
 800149c:	08001d20 	.word	0x08001d20
 80014a0:	08001d2c 	.word	0x08001d2c
 80014a4:	48000400 	.word	0x48000400
 80014a8:	08001d38 	.word	0x08001d38
 80014ac:	08001d44 	.word	0x08001d44
 80014b0:	08001d4c 	.word	0x08001d4c
 80014b4:	08001d58 	.word	0x08001d58
 80014b8:	20000600 	.word	0x20000600
 80014bc:	20000b9c 	.word	0x20000b9c
 80014c0:	00002710 	.word	0x00002710
 80014c4:	08001d60 	.word	0x08001d60
 80014c8:	00001388 	.word	0x00001388
 80014cc:	46c0      	nop			; (mov r8, r8)
 80014ce:	46c0      	nop			; (mov r8, r8)

080014d0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80014d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80014d2:	4be6      	ldr	r3, [pc, #920]	; (800186c <main+0x39c>)
 80014d4:	465f      	mov	r7, fp
 80014d6:	4656      	mov	r6, sl
 80014d8:	464d      	mov	r5, r9
 80014da:	4644      	mov	r4, r8
 80014dc:	2101      	movs	r1, #1
 80014de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80014e0:	b4f0      	push	{r4, r5, r6, r7}
 80014e2:	2200      	movs	r2, #0
 80014e4:	424c      	negs	r4, r1
 80014e6:	629c      	str	r4, [r3, #40]	; 0x28
 80014e8:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80014ea:	6918      	ldr	r0, [r3, #16]
 80014ec:	611c      	str	r4, [r3, #16]
 80014ee:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80014f0:	68dd      	ldr	r5, [r3, #12]
 80014f2:	48df      	ldr	r0, [pc, #892]	; (8001870 <main+0x3a0>)

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80014f4:	2780      	movs	r7, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80014f6:	4305      	orrs	r5, r0
 80014f8:	60dd      	str	r5, [r3, #12]
 80014fa:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80014fc:	69de      	ldr	r6, [r3, #28]
 80014fe:	0579      	lsls	r1, r7, #21
 8001500:	4331      	orrs	r1, r6
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001502:	4ddc      	ldr	r5, [pc, #880]	; (8001874 <main+0x3a4>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001504:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001506:	682c      	ldr	r4, [r5, #0]
 8001508:	2080      	movs	r0, #128	; 0x80
 800150a:	0046      	lsls	r6, r0, #1
 800150c:	4326      	orrs	r6, r4
 800150e:	602e      	str	r6, [r5, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8001510:	6a1f      	ldr	r7, [r3, #32]
 8001512:	21c0      	movs	r1, #192	; 0xc0
 8001514:	008d      	lsls	r5, r1, #2
 8001516:	2480      	movs	r4, #128	; 0x80
 8001518:	402f      	ands	r7, r5
 800151a:	00a0      	lsls	r0, r4, #2
 800151c:	4287      	cmp	r7, r0
 800151e:	d003      	beq.n	8001528 <main+0x58>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001520:	2680      	movs	r6, #128	; 0x80
 8001522:	0277      	lsls	r7, r6, #9
 8001524:	621f      	str	r7, [r3, #32]
    RCC->BDCR = 0;
 8001526:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8001528:	4bd0      	ldr	r3, [pc, #832]	; (800186c <main+0x39c>)
 800152a:	2280      	movs	r2, #128	; 0x80
 800152c:	6a19      	ldr	r1, [r3, #32]
 800152e:	0215      	lsls	r5, r2, #8
 8001530:	4229      	tst	r1, r5
 8001532:	d107      	bne.n	8001544 <main+0x74>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8001534:	6a1c      	ldr	r4, [r3, #32]
 8001536:	2080      	movs	r0, #128	; 0x80
 8001538:	0086      	lsls	r6, r0, #2
 800153a:	4326      	orrs	r6, r4
 800153c:	621e      	str	r6, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800153e:	6a1f      	ldr	r7, [r3, #32]
 8001540:	433d      	orrs	r5, r7
 8001542:	621d      	str	r5, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001544:	48c9      	ldr	r0, [pc, #804]	; (800186c <main+0x39c>)
 8001546:	23fc      	movs	r3, #252	; 0xfc
 8001548:	6941      	ldr	r1, [r0, #20]
 800154a:	03da      	lsls	r2, r3, #15
 800154c:	430a      	orrs	r2, r1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800154e:	2590      	movs	r5, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
 8001550:	24fc      	movs	r4, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
 8001552:	49c9      	ldr	r1, [pc, #804]	; (8001878 <main+0x3a8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001554:	2300      	movs	r3, #0
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001556:	6142      	str	r2, [r0, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001558:	05ee      	lsls	r6, r5, #23
  gpiop->OSPEEDR = config->ospeedr;
 800155a:	0627      	lsls	r7, r4, #24
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800155c:	4dc7      	ldr	r5, [pc, #796]	; (800187c <main+0x3ac>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800155e:	22a0      	movs	r2, #160	; 0xa0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001560:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001562:	0594      	lsls	r4, r2, #22
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001564:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8001566:	60f1      	str	r1, [r6, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001568:	4fc5      	ldr	r7, [pc, #788]	; (8001880 <main+0x3b0>)
  gpiop->OSPEEDR = config->ospeedr;
 800156a:	21fc      	movs	r1, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800156c:	6175      	str	r5, [r6, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800156e:	008a      	lsls	r2, r1, #2
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8001570:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001572:	21a8      	movs	r1, #168	; 0xa8
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8001574:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001576:	6034      	str	r4, [r6, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001578:	4cc2      	ldr	r4, [pc, #776]	; (8001884 <main+0x3b4>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800157a:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800157c:	60ba      	str	r2, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800157e:	060a      	lsls	r2, r1, #24

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001580:	60fc      	str	r4, [r7, #12]
  gpiop->ODR     = config->odr;
 8001582:	617d      	str	r5, [r7, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001584:	4cc0      	ldr	r4, [pc, #768]	; (8001888 <main+0x3b8>)
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8001586:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8001588:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800158a:	603a      	str	r2, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800158c:	4fbf      	ldr	r7, [pc, #764]	; (800188c <main+0x3bc>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800158e:	49c0      	ldr	r1, [pc, #768]	; (8001890 <main+0x3c0>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001590:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001592:	4ac0      	ldr	r2, [pc, #768]	; (8001894 <main+0x3c4>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001594:	60bc      	str	r4, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001596:	4cc0      	ldr	r4, [pc, #768]	; (8001898 <main+0x3c8>)

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001598:	60f9      	str	r1, [r7, #12]
  gpiop->ODR     = config->odr;
 800159a:	617a      	str	r2, [r7, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800159c:	49bf      	ldr	r1, [pc, #764]	; (800189c <main+0x3cc>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800159e:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80015a0:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80015a2:	603c      	str	r4, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80015a4:	4fbe      	ldr	r7, [pc, #760]	; (80018a0 <main+0x3d0>)
 80015a6:	4abf      	ldr	r2, [pc, #764]	; (80018a4 <main+0x3d4>)
 80015a8:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80015aa:	4cbf      	ldr	r4, [pc, #764]	; (80018a8 <main+0x3d8>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80015ac:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80015ae:	60f9      	str	r1, [r7, #12]
  gpiop->ODR     = config->odr;
 80015b0:	617d      	str	r5, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80015b2:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80015b4:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80015b6:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80015b8:	4fbc      	ldr	r7, [pc, #752]	; (80018ac <main+0x3dc>)
 80015ba:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80015bc:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80015be:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80015c0:	6155      	str	r5, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80015c2:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80015c4:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80015c6:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80015c8:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80015ca:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80015cc:	60fc      	str	r4, [r7, #12]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80015ce:	4cb8      	ldr	r4, [pc, #736]	; (80018b0 <main+0x3e0>)
  gpiop->ODR     = config->odr;
 80015d0:	617d      	str	r5, [r7, #20]
 80015d2:	4db8      	ldr	r5, [pc, #736]	; (80018b4 <main+0x3e4>)
  gpiop->AFRL    = config->afrl;
 80015d4:	623b      	str	r3, [r7, #32]
 80015d6:	1c21      	adds	r1, r4, #0
  gpiop->AFRH    = config->afrh;
 80015d8:	627b      	str	r3, [r7, #36]	; 0x24
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80015da:	1c22      	adds	r2, r4, #0
  gpiop->MODER   = config->moder;
 80015dc:	603b      	str	r3, [r7, #0]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80015de:	2701      	movs	r7, #1
 80015e0:	32f4      	adds	r2, #244	; 0xf4
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80015e2:	c120      	stmia	r1!, {r5}
 80015e4:	46ab      	mov	fp, r5
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80015e6:	7227      	strb	r7, [r4, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80015e8:	1c25      	adds	r5, r4, #0
 80015ea:	1c27      	adds	r7, r4, #0
 80015ec:	350c      	adds	r5, #12
 80015ee:	3730      	adds	r7, #48	; 0x30
 80015f0:	61e2      	str	r2, [r4, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80015f2:	63e2      	str	r2, [r4, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80015f4:	64a2      	str	r2, [r4, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80015f6:	6462      	str	r2, [r4, #68]	; 0x44
  oqp->q_top     = bp + size;
 80015f8:	22ca      	movs	r2, #202	; 0xca
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80015fa:	6061      	str	r1, [r4, #4]
 80015fc:	60e5      	str	r5, [r4, #12]
  tqp->p_prev = (thread_t *)tqp;
 80015fe:	6125      	str	r5, [r4, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001600:	6327      	str	r7, [r4, #48]	; 0x30
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001602:	25a0      	movs	r5, #160	; 0xa0
  tqp->p_prev = (thread_t *)tqp;
 8001604:	6367      	str	r7, [r4, #52]	; 0x34
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001606:	1c21      	adds	r1, r4, #0
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001608:	0057      	lsls	r7, r2, #1
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800160a:	3154      	adds	r1, #84	; 0x54
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800160c:	6163      	str	r3, [r4, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800160e:	46aa      	mov	sl, r5
 8001610:	63a5      	str	r5, [r4, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001612:	19e5      	adds	r5, r4, r7
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001614:	61a1      	str	r1, [r4, #24]
  iqp->q_rdptr   = bp;
 8001616:	6261      	str	r1, [r4, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001618:	6221      	str	r1, [r4, #32]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800161a:	6425      	str	r5, [r4, #64]	; 0x40
  oqp->q_notify  = onfy;
 800161c:	49a6      	ldr	r1, [pc, #664]	; (80018b8 <main+0x3e8>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 800161e:	22ca      	movs	r2, #202	; 0xca
 8001620:	4da6      	ldr	r5, [pc, #664]	; (80018bc <main+0x3ec>)
 8001622:	0057      	lsls	r7, r2, #1
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001624:	62a3      	str	r3, [r4, #40]	; 0x28
  SD1.clock = STM32_USART1CLK;
 8001626:	4aa6      	ldr	r2, [pc, #664]	; (80018c0 <main+0x3f0>)
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8001628:	64e1      	str	r1, [r4, #76]	; 0x4c
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800162a:	62e4      	str	r4, [r4, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 800162c:	6524      	str	r4, [r4, #80]	; 0x50
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 800162e:	51e5      	str	r5, [r4, r7]
  SD1.clock = STM32_USART1CLK;
 8001630:	25cc      	movs	r5, #204	; 0xcc
 8001632:	0069      	lsls	r1, r5, #1
 8001634:	5062      	str	r2, [r4, r1]
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8001636:	46b9      	mov	r9, r7
  SD1.clock = STM32_USART1CLK;
 8001638:	4690      	mov	r8, r2
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800163a:	27c6      	movs	r7, #198	; 0xc6
 800163c:	4aa1      	ldr	r2, [pc, #644]	; (80018c4 <main+0x3f4>)
 800163e:	00bd      	lsls	r5, r7, #2
 8001640:	5951      	ldr	r1, [r2, r5]
 8001642:	020f      	lsls	r7, r1, #8
 8001644:	0a39      	lsrs	r1, r7, #8
 8001646:	27c0      	movs	r7, #192	; 0xc0
 8001648:	063f      	lsls	r7, r7, #24
 800164a:	4339      	orrs	r1, r7
 800164c:	5151      	str	r1, [r2, r5]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800164e:	2780      	movs	r7, #128	; 0x80
 8001650:	25c0      	movs	r5, #192	; 0xc0
 8001652:	0069      	lsls	r1, r5, #1
 8001654:	053d      	lsls	r5, r7, #20
 8001656:	5055      	str	r5, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001658:	6015      	str	r5, [r2, #0]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 800165a:	4d9b      	ldr	r5, [pc, #620]	; (80018c8 <main+0x3f8>)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800165c:	468c      	mov	ip, r1
 800165e:	465f      	mov	r7, fp
 8001660:	1c29      	adds	r1, r5, #0
 8001662:	c180      	stmia	r1!, {r7}
 8001664:	6069      	str	r1, [r5, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001666:	2101      	movs	r1, #1
 8001668:	7229      	strb	r1, [r5, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800166a:	1c2f      	adds	r7, r5, #0
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800166c:	1c29      	adds	r1, r5, #0
 800166e:	3154      	adds	r1, #84	; 0x54
 8001670:	370c      	adds	r7, #12
 8001672:	60ef      	str	r7, [r5, #12]
  tqp->p_prev = (thread_t *)tqp;
 8001674:	612f      	str	r7, [r5, #16]
 8001676:	61a9      	str	r1, [r5, #24]
  iqp->q_rdptr   = bp;
 8001678:	6269      	str	r1, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 800167a:	6229      	str	r1, [r5, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800167c:	2730      	movs	r7, #48	; 0x30
  iqp->q_top     = bp + size;
 800167e:	1c29      	adds	r1, r5, #0
 8001680:	31f4      	adds	r1, #244	; 0xf4
 8001682:	197f      	adds	r7, r7, r5
 8001684:	61e9      	str	r1, [r5, #28]
 8001686:	632f      	str	r7, [r5, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8001688:	636f      	str	r7, [r5, #52]	; 0x34
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 800168a:	63e9      	str	r1, [r5, #60]	; 0x3c
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800168c:	4657      	mov	r7, sl
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
 800168e:	64a9      	str	r1, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001690:	6469      	str	r1, [r5, #68]	; 0x44
  oqp->q_top     = bp + size;
 8001692:	21ca      	movs	r1, #202	; 0xca
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001694:	616b      	str	r3, [r5, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001696:	63af      	str	r7, [r5, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001698:	004f      	lsls	r7, r1, #1
 800169a:	19e9      	adds	r1, r5, r7
  oqp->q_notify  = onfy;
 800169c:	4f8b      	ldr	r7, [pc, #556]	; (80018cc <main+0x3fc>)
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800169e:	6429      	str	r1, [r5, #64]	; 0x40
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 80016a0:	498b      	ldr	r1, [pc, #556]	; (80018d0 <main+0x400>)
  oqp->q_notify  = onfy;
 80016a2:	64ef      	str	r7, [r5, #76]	; 0x4c
 80016a4:	464f      	mov	r7, r9
 80016a6:	51e9      	str	r1, [r5, r7]
  SD2.clock = STM32_USART2CLK;
 80016a8:	21cc      	movs	r1, #204	; 0xcc
 80016aa:	4647      	mov	r7, r8
 80016ac:	0049      	lsls	r1, r1, #1
 80016ae:	506f      	str	r7, [r5, r1]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80016b0:	27c7      	movs	r7, #199	; 0xc7
 80016b2:	00b9      	lsls	r1, r7, #2
 80016b4:	5857      	ldr	r7, [r2, r1]
 80016b6:	468b      	mov	fp, r1
 80016b8:	46ba      	mov	sl, r7
 80016ba:	4651      	mov	r1, sl
 80016bc:	27ff      	movs	r7, #255	; 0xff
 80016be:	43b9      	bics	r1, r7
 80016c0:	4689      	mov	r9, r1
 80016c2:	464f      	mov	r7, r9
 80016c4:	21c0      	movs	r1, #192	; 0xc0
 80016c6:	430f      	orrs	r7, r1
 80016c8:	4659      	mov	r1, fp
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80016ca:	62ab      	str	r3, [r5, #40]	; 0x28
  iqp->q_link    = link;
 80016cc:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80016ce:	652d      	str	r5, [r5, #80]	; 0x50
 80016d0:	5057      	str	r7, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80016d2:	2780      	movs	r7, #128	; 0x80
 80016d4:	057f      	lsls	r7, r7, #21
 80016d6:	4661      	mov	r1, ip
 80016d8:	5057      	str	r7, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80016da:	6017      	str	r7, [r2, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80016dc:	69c7      	ldr	r7, [r0, #28]
 80016de:	2101      	movs	r1, #1
 80016e0:	430f      	orrs	r7, r1
 80016e2:	61c7      	str	r7, [r0, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80016e4:	487b      	ldr	r0, [pc, #492]	; (80018d4 <main+0x404>)
 80016e6:	6887      	ldr	r7, [r0, #8]
 80016e8:	430f      	orrs	r7, r1
 80016ea:	6087      	str	r7, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80016ec:	4f7a      	ldr	r7, [pc, #488]	; (80018d8 <main+0x408>)
 80016ee:	2080      	movs	r0, #128	; 0x80
 80016f0:	05c0      	lsls	r0, r0, #23
 80016f2:	6287      	str	r7, [r0, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80016f4:	2701      	movs	r7, #1
 80016f6:	427f      	negs	r7, r7
 80016f8:	62c7      	str	r7, [r0, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80016fa:	6183      	str	r3, [r0, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80016fc:	6343      	str	r3, [r0, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80016fe:	60c3      	str	r3, [r0, #12]
  STM32_ST_TIM->CR2    = 0;
 8001700:	6043      	str	r3, [r0, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001702:	6141      	str	r1, [r0, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001704:	6001      	str	r1, [r0, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001706:	21c3      	movs	r1, #195	; 0xc3
 8001708:	0088      	lsls	r0, r1, #2
 800170a:	5811      	ldr	r1, [r2, r0]
 800170c:	4683      	mov	fp, r0
 800170e:	0209      	lsls	r1, r1, #8
 8001710:	0a08      	lsrs	r0, r1, #8
 8001712:	4682      	mov	sl, r0
 8001714:	2180      	movs	r1, #128	; 0x80
 8001716:	0608      	lsls	r0, r1, #24
 8001718:	4651      	mov	r1, sl
 800171a:	4308      	orrs	r0, r1
 800171c:	4659      	mov	r1, fp
 800171e:	5050      	str	r0, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001720:	2080      	movs	r0, #128	; 0x80
 8001722:	0200      	lsls	r0, r0, #8
 8001724:	4661      	mov	r1, ip
 8001726:	5050      	str	r0, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001728:	6010      	str	r0, [r2, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800172a:	4a6c      	ldr	r2, [pc, #432]	; (80018dc <main+0x40c>)
 800172c:	6a10      	ldr	r0, [r2, #32]
 800172e:	4684      	mov	ip, r0
 8001730:	486b      	ldr	r0, [pc, #428]	; (80018e0 <main+0x410>)
 8001732:	4661      	mov	r1, ip
 8001734:	4008      	ands	r0, r1
 8001736:	6210      	str	r0, [r2, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001738:	486a      	ldr	r0, [pc, #424]	; (80018e4 <main+0x414>)
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800173a:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800173c:	1c02      	adds	r2, r0, #0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800173e:	4f6a      	ldr	r7, [pc, #424]	; (80018e8 <main+0x418>)
 8001740:	321c      	adds	r2, #28
 8001742:	61c2      	str	r2, [r0, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001744:	6202      	str	r2, [r0, #32]
 8001746:	3707      	adds	r7, #7
 8001748:	2207      	movs	r2, #7
 800174a:	4397      	bics	r7, r2
 800174c:	46bb      	mov	fp, r7
 800174e:	4f67      	ldr	r7, [pc, #412]	; (80018ec <main+0x41c>)
 8001750:	4659      	mov	r1, fp
 8001752:	6039      	str	r1, [r7, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001754:	4f66      	ldr	r7, [pc, #408]	; (80018f0 <main+0x420>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001756:	4967      	ldr	r1, [pc, #412]	; (80018f4 <main+0x424>)
 8001758:	4397      	bics	r7, r2
 800175a:	4a67      	ldr	r2, [pc, #412]	; (80018f8 <main+0x428>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800175c:	6083      	str	r3, [r0, #8]
 800175e:	6017      	str	r7, [r2, #0]
 8001760:	4f66      	ldr	r7, [pc, #408]	; (80018fc <main+0x42c>)
 8001762:	1c0a      	adds	r2, r1, #0
 8001764:	3210      	adds	r2, #16
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8001766:	6283      	str	r3, [r0, #40]	; 0x28
 8001768:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800176a:	6040      	str	r0, [r0, #4]
 800176c:	600f      	str	r7, [r1, #0]
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800176e:	1c07      	adds	r7, r0, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001770:	610a      	str	r2, [r1, #16]
  tqp->p_prev = (thread_t *)tqp;
 8001772:	614a      	str	r2, [r1, #20]
 8001774:	3740      	adds	r7, #64	; 0x40
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001776:	2289      	movs	r2, #137	; 0x89
  default_heap.h_free.h.u.next = NULL;
 8001778:	608b      	str	r3, [r1, #8]
  default_heap.h_free.h.size = 0;
 800177a:	60cb      	str	r3, [r1, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 800177c:	618b      	str	r3, [r1, #24]
 800177e:	63c7      	str	r7, [r0, #60]	; 0x3c
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8001780:	2140      	movs	r1, #64	; 0x40
 8001782:	00d7      	lsls	r7, r2, #3
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001784:	4a5e      	ldr	r2, [pc, #376]	; (8001900 <main+0x430>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001786:	51c1      	str	r1, [r0, r7]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001788:	2790      	movs	r7, #144	; 0x90
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800178a:	5483      	strb	r3, [r0, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800178c:	00fa      	lsls	r2, r7, #3
 800178e:	5081      	str	r1, [r0, r2]
 8001790:	6381      	str	r1, [r0, #56]	; 0x38
  tp->p_mtxlist = NULL;
 8001792:	495c      	ldr	r1, [pc, #368]	; (8001904 <main+0x434>)
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001794:	278f      	movs	r7, #143	; 0x8f
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001796:	5043      	str	r3, [r0, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001798:	00fa      	lsls	r2, r7, #3
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800179a:	495b      	ldr	r1, [pc, #364]	; (8001908 <main+0x438>)
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800179c:	5083      	str	r3, [r0, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800179e:	2701      	movs	r7, #1
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80017a0:	228b      	movs	r2, #139	; 0x8b
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80017a2:	5447      	strb	r7, [r0, r1]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80017a4:	00d1      	lsls	r1, r2, #3
 80017a6:	5043      	str	r3, [r0, r1]
  REG_INSERT(tp);
 80017a8:	238a      	movs	r3, #138	; 0x8a
 80017aa:	00df      	lsls	r7, r3, #3
 80017ac:	4a57      	ldr	r2, [pc, #348]	; (800190c <main+0x43c>)
 80017ae:	2188      	movs	r1, #136	; 0x88
 80017b0:	51c0      	str	r0, [r0, r7]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80017b2:	278d      	movs	r7, #141	; 0x8d
 80017b4:	5080      	str	r0, [r0, r2]
 80017b6:	00cb      	lsls	r3, r1, #3
 80017b8:	00fa      	lsls	r2, r7, #3
 80017ba:	278d      	movs	r7, #141	; 0x8d
 80017bc:	18c1      	adds	r1, r0, r3
 80017be:	1883      	adds	r3, r0, r2
 80017c0:	00fa      	lsls	r2, r7, #3
 80017c2:	5083      	str	r3, [r0, r2]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80017c4:	4b52      	ldr	r3, [pc, #328]	; (8001910 <main+0x440>)
  tqp->p_prev = (thread_t *)tqp;
 80017c6:	278e      	movs	r7, #142	; 0x8e
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80017c8:	18c2      	adds	r2, r0, r3
 80017ca:	50c2      	str	r2, [r0, r3]
 80017cc:	6101      	str	r1, [r0, #16]
  tqp->p_prev = (thread_t *)tqp;
 80017ce:	00fb      	lsls	r3, r7, #3
 80017d0:	6141      	str	r1, [r0, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80017d2:	6181      	str	r1, [r0, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80017d4:	218c      	movs	r1, #140	; 0x8c
 80017d6:	50c2      	str	r2, [r0, r3]
 80017d8:	2701      	movs	r7, #1
 80017da:	00ca      	lsls	r2, r1, #3
 80017dc:	5487      	strb	r7, [r0, r2]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 80017de:	494d      	ldr	r1, [pc, #308]	; (8001914 <main+0x444>)
 80017e0:	4b4d      	ldr	r3, [pc, #308]	; (8001918 <main+0x448>)
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80017e2:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80017e4:	50c1      	str	r1, [r0, r3]
 80017e6:	2a00      	cmp	r2, #0
 80017e8:	d102      	bne.n	80017f0 <main+0x320>
 80017ea:	6b47      	ldr	r7, [r0, #52]	; 0x34
 80017ec:	2f00      	cmp	r7, #0
 80017ee:	d003      	beq.n	80017f8 <main+0x328>
 80017f0:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80017f2:	4f4a      	ldr	r7, [pc, #296]	; (800191c <main+0x44c>)
 80017f4:	62c7      	str	r7, [r0, #44]	; 0x2c
 80017f6:	e7fe      	b.n	80017f6 <main+0x326>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80017f8:	b662      	cpsie	i
 80017fa:	4b49      	ldr	r3, [pc, #292]	; (8001920 <main+0x450>)
 80017fc:	6981      	ldr	r1, [r0, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80017fe:	2291      	movs	r2, #145	; 0x91
 8001800:	00d7      	lsls	r7, r2, #3
 8001802:	618b      	str	r3, [r1, #24]
 8001804:	2201      	movs	r2, #1
 8001806:	21e0      	movs	r1, #224	; 0xe0
 8001808:	4b46      	ldr	r3, [pc, #280]	; (8001924 <main+0x454>)
 800180a:	19c0      	adds	r0, r0, r7
 800180c:	f7ff fa48 	bl	8000ca0 <chThdCreateStatic.constprop.12>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8001810:	4945      	ldr	r1, [pc, #276]	; (8001928 <main+0x458>)
  chSysInit();

  /* Initialize connection to STN1110 on SD2
   */
  static SerialConfig stn_uart_cfg;
  stn_uart_cfg.speed=9600;
 8001812:	4b46      	ldr	r3, [pc, #280]	; (800192c <main+0x45c>)
 8001814:	6181      	str	r1, [r0, #24]
 8001816:	2096      	movs	r0, #150	; 0x96
 8001818:	0182      	lsls	r2, r0, #6
 800181a:	601a      	str	r2, [r3, #0]

  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(1));       /* USART2 TX.       */
 800181c:	1c30      	adds	r0, r6, #0
 800181e:	2104      	movs	r1, #4
 8001820:	2282      	movs	r2, #130	; 0x82
 8001822:	f7ff f99d 	bl	8000b60 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(1));       /* USART2 RX.       */
 8001826:	1c30      	adds	r0, r6, #0
 8001828:	2108      	movs	r1, #8
 800182a:	2282      	movs	r2, #130	; 0x82
 800182c:	f7ff f998 	bl	8000b60 <_pal_lld_setgroupmode>
  sdStart(&SD2, NULL);
 8001830:	1c28      	adds	r0, r5, #0

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8001832:	2580      	movs	r5, #128	; 0x80
  static SerialConfig stn_uart_cfg;
  stn_uart_cfg.speed=9600;

  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(1));       /* USART2 TX.       */
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(1));       /* USART2 RX.       */
  sdStart(&SD2, NULL);
 8001834:	f7fe fef4 	bl	8000620 <sdStart.constprop.1>

  /*
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8001838:	1c30      	adds	r0, r6, #0
 800183a:	00a9      	lsls	r1, r5, #2
 800183c:	2282      	movs	r2, #130	; 0x82
 800183e:	f7ff f98f 	bl	8000b60 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 8001842:	1c30      	adds	r0, r6, #0
 8001844:	2680      	movs	r6, #128	; 0x80
 8001846:	00f1      	lsls	r1, r6, #3
 8001848:	2282      	movs	r2, #130	; 0x82
 800184a:	f7ff f989 	bl	8000b60 <_pal_lld_setgroupmode>
  sdStart(&SD1, NULL);
 800184e:	1c20      	adds	r0, r4, #0


  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 8001850:	24a8      	movs	r4, #168	; 0xa8
   * Activates the serial driver 1 (debug port) using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
  sdStart(&SD1, NULL);
 8001852:	f7fe fee5 	bl	8000620 <sdStart.constprop.1>


  /*
   * Creates the processing threads.
   */
  chThdCreateStatic(wa_STN1110_rx, sizeof(wa_STN1110_rx), NORMALPRIO, STN1110_rx, NULL);
 8001856:	4836      	ldr	r0, [pc, #216]	; (8001930 <main+0x460>)
 8001858:	0061      	lsls	r1, r4, #1
 800185a:	2240      	movs	r2, #64	; 0x40
 800185c:	4b35      	ldr	r3, [pc, #212]	; (8001934 <main+0x464>)
 800185e:	f7ff fa1f 	bl	8000ca0 <chThdCreateStatic.constprop.12>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched with output on the serial
   * driver 1.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 8001862:	4835      	ldr	r0, [pc, #212]	; (8001938 <main+0x468>)
 8001864:	f7ff fba4 	bl	8000fb0 <chThdSleep>
 8001868:	e7fb      	b.n	8001862 <main+0x392>
 800186a:	46c0      	nop			; (mov r8, r8)
 800186c:	40021000 	.word	0x40021000
 8001870:	ffbfffff 	.word	0xffbfffff
 8001874:	40007000 	.word	0x40007000
 8001878:	64155554 	.word	0x64155554
 800187c:	0000ffff 	.word	0x0000ffff
 8001880:	48000400 	.word	0x48000400
 8001884:	01555555 	.word	0x01555555
 8001888:	f00ff003 	.word	0xf00ff003
 800188c:	48000800 	.word	0x48000800
 8001890:	05500554 	.word	0x05500554
 8001894:	0000fc3f 	.word	0x0000fc3f
 8001898:	00055001 	.word	0x00055001
 800189c:	55555555 	.word	0x55555555
 80018a0:	48000c00 	.word	0x48000c00
 80018a4:	48001000 	.word	0x48001000
 80018a8:	55555550 	.word	0x55555550
 80018ac:	48001400 	.word	0x48001400
 80018b0:	20000a00 	.word	0x20000a00
 80018b4:	08001cf0 	.word	0x08001cf0
 80018b8:	08000401 	.word	0x08000401
 80018bc:	40013800 	.word	0x40013800
 80018c0:	02dc6c00 	.word	0x02dc6c00
 80018c4:	e000e100 	.word	0xe000e100
 80018c8:	20000b9c 	.word	0x20000b9c
 80018cc:	080003f1 	.word	0x080003f1
 80018d0:	40004400 	.word	0x40004400
 80018d4:	40015800 	.word	0x40015800
 80018d8:	000012bf 	.word	0x000012bf
 80018dc:	e000ed00 	.word	0xe000ed00
 80018e0:	ff00ffff 	.word	0xff00ffff
 80018e4:	20000d38 	.word	0x20000d38
 80018e8:	20001428 	.word	0x20001428
 80018ec:	200012a4 	.word	0x200012a4
 80018f0:	20004000 	.word	0x20004000
 80018f4:	200012a8 	.word	0x200012a8
 80018f8:	200012a0 	.word	0x200012a0
 80018fc:	080005c1 	.word	0x080005c1
 8001900:	00000461 	.word	0x00000461
 8001904:	0000047c 	.word	0x0000047c
 8001908:	00000462 	.word	0x00000462
 800190c:	00000454 	.word	0x00000454
 8001910:	0000046c 	.word	0x0000046c
 8001914:	20000400 	.word	0x20000400
 8001918:	0000045c 	.word	0x0000045c
 800191c:	08001d78 	.word	0x08001d78
 8001920:	08001d90 	.word	0x08001d90
 8001924:	08000461 	.word	0x08000461
 8001928:	08001d80 	.word	0x08001d80
 800192c:	200012c8 	.word	0x200012c8
 8001930:	200012d8 	.word	0x200012d8
 8001934:	080013d1 	.word	0x080013d1
 8001938:	00001388 	.word	0x00001388
 800193c:	46c0      	nop			; (mov r8, r8)
 800193e:	46c0      	nop			; (mov r8, r8)

08001940 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001940:	4827      	ldr	r0, [pc, #156]	; (80019e0 <__early_init+0xa0>)
 8001942:	2301      	movs	r3, #1
 8001944:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001946:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001948:	4313      	orrs	r3, r2
 800194a:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800194c:	6803      	ldr	r3, [r0, #0]
 800194e:	4a24      	ldr	r2, [pc, #144]	; (80019e0 <__early_init+0xa0>)
 8001950:	4219      	tst	r1, r3
 8001952:	d0fb      	beq.n	800194c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001954:	6850      	ldr	r0, [r2, #4]
 8001956:	2103      	movs	r1, #3
 8001958:	4388      	bics	r0, r1
 800195a:	6050      	str	r0, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800195c:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800195e:	1c10      	adds	r0, r2, #0

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001960:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001962:	210c      	movs	r1, #12
 8001964:	6843      	ldr	r3, [r0, #4]
 8001966:	4a1e      	ldr	r2, [pc, #120]	; (80019e0 <__early_init+0xa0>)
 8001968:	400b      	ands	r3, r1
 800196a:	d1fb      	bne.n	8001964 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800196c:	6811      	ldr	r1, [r2, #0]
 800196e:	20f9      	movs	r0, #249	; 0xf9
 8001970:	4001      	ands	r1, r0
 8001972:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001974:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001976:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001978:	2301      	movs	r3, #1
 800197a:	430b      	orrs	r3, r1
 800197c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800197e:	2002      	movs	r0, #2
 8001980:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001982:	4917      	ldr	r1, [pc, #92]	; (80019e0 <__early_init+0xa0>)
 8001984:	4218      	tst	r0, r3
 8001986:	d0fb      	beq.n	8001980 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001988:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 800198a:	2001      	movs	r0, #1
 800198c:	4310      	orrs	r0, r2
 800198e:	6248      	str	r0, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001990:	2002      	movs	r0, #2
 8001992:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001994:	4a12      	ldr	r2, [pc, #72]	; (80019e0 <__early_init+0xa0>)
 8001996:	4218      	tst	r0, r3
 8001998:	d0fb      	beq.n	8001992 <__early_init+0x52>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800199a:	21a0      	movs	r1, #160	; 0xa0
 800199c:	0388      	lsls	r0, r1, #14
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 800199e:	2300      	movs	r3, #0
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 80019a0:	6050      	str	r0, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80019a2:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 80019a4:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80019a6:	6811      	ldr	r1, [r2, #0]
 80019a8:	2080      	movs	r0, #128	; 0x80
 80019aa:	0443      	lsls	r3, r0, #17
 80019ac:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80019ae:	2180      	movs	r1, #128	; 0x80
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80019b0:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80019b2:	0488      	lsls	r0, r1, #18
 80019b4:	6813      	ldr	r3, [r2, #0]
 80019b6:	490a      	ldr	r1, [pc, #40]	; (80019e0 <__early_init+0xa0>)
 80019b8:	4203      	tst	r3, r0
 80019ba:	d0fb      	beq.n	80019b4 <__early_init+0x74>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80019bc:	4809      	ldr	r0, [pc, #36]	; (80019e4 <__early_init+0xa4>)
 80019be:	2211      	movs	r2, #17
 80019c0:	6002      	str	r2, [r0, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80019c2:	684a      	ldr	r2, [r1, #4]
 80019c4:	2302      	movs	r3, #2
 80019c6:	4313      	orrs	r3, r2
 80019c8:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80019ca:	200c      	movs	r0, #12
 80019cc:	684b      	ldr	r3, [r1, #4]
 80019ce:	4a04      	ldr	r2, [pc, #16]	; (80019e0 <__early_init+0xa0>)
 80019d0:	4003      	ands	r3, r0
 80019d2:	2b08      	cmp	r3, #8
 80019d4:	d1fa      	bne.n	80019cc <__early_init+0x8c>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80019d6:	6991      	ldr	r1, [r2, #24]
 80019d8:	2001      	movs	r0, #1
 80019da:	4308      	orrs	r0, r1
 80019dc:	6190      	str	r0, [r2, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 80019de:	4770      	bx	lr
 80019e0:	40021000 	.word	0x40021000
 80019e4:	40022000 	.word	0x40022000
 80019e8:	46c0      	nop			; (mov r8, r8)
 80019ea:	46c0      	nop			; (mov r8, r8)
 80019ec:	46c0      	nop			; (mov r8, r8)
 80019ee:	46c0      	nop			; (mov r8, r8)

080019f0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80019f0:	b538      	push	{r3, r4, r5, lr}
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80019f2:	4d14      	ldr	r5, [pc, #80]	; (8001a44 <chSchDoReschedule+0x54>)
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80019f4:	2120      	movs	r1, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80019f6:	682a      	ldr	r2, [r5, #0]
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80019f8:	69ac      	ldr	r4, [r5, #24]

  tqp->p_next = tp->p_next;
 80019fa:	6813      	ldr	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80019fc:	2001      	movs	r0, #1
 80019fe:	5450      	strb	r0, [r2, r1]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a00:	605d      	str	r5, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001a02:	61aa      	str	r2, [r5, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001a04:	2200      	movs	r2, #0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001a06:	602b      	str	r3, [r5, #0]
 8001a08:	5462      	strb	r2, [r4, r1]
 8001a0a:	68a0      	ldr	r0, [r4, #8]
 8001a0c:	e000      	b.n	8001a10 <chSchDoReschedule+0x20>
 8001a0e:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8001a10:	6899      	ldr	r1, [r3, #8]
 8001a12:	4281      	cmp	r1, r0
 8001a14:	d8fb      	bhi.n	8001a0e <chSchDoReschedule+0x1e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001a16:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001a18:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 8001a1a:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 8001a1c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 8001a1e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
 8001a20:	1c20      	adds	r0, r4, #0
 8001a22:	f7ff f91d 	bl	8000c60 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001a26:	f3ef 8309 	mrs	r3, PSP
 8001a2a:	69e0      	ldr	r0, [r4, #28]
 8001a2c:	3b24      	subs	r3, #36	; 0x24
 8001a2e:	4298      	cmp	r0, r3
 8001a30:	d804      	bhi.n	8001a3c <chSchDoReschedule+0x4c>
 8001a32:	69a8      	ldr	r0, [r5, #24]
 8001a34:	1c21      	adds	r1, r4, #0
 8001a36:	f7fe fbcb 	bl	80001d0 <_port_switch>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8001a3a:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a3c:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001a3e:	4c02      	ldr	r4, [pc, #8]	; (8001a48 <chSchDoReschedule+0x58>)
 8001a40:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001a42:	e7fe      	b.n	8001a42 <chSchDoReschedule+0x52>
 8001a44:	20000d38 	.word	0x20000d38
 8001a48:	08001bb0 	.word	0x08001bb0
 8001a4c:	46c0      	nop			; (mov r8, r8)
 8001a4e:	46c0      	nop			; (mov r8, r8)

08001a50 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001a50:	b570      	push	{r4, r5, r6, lr}
 8001a52:	1c06      	adds	r6, r0, #0
 8001a54:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001a56:	f7fe fd9b 	bl	8000590 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001a5a:	4d0f      	ldr	r5, [pc, #60]	; (8001a98 <chThdExit+0x48>)
 8001a5c:	69ac      	ldr	r4, [r5, #24]

  tp->p_u.exitcode = msg;
 8001a5e:	6266      	str	r6, [r4, #36]	; 0x24
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001a60:	6aa0      	ldr	r0, [r4, #40]	; 0x28
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001a62:	1c26      	adds	r6, r4, #0
 8001a64:	3628      	adds	r6, #40	; 0x28
 8001a66:	42b0      	cmp	r0, r6
 8001a68:	d006      	beq.n	8001a78 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001a6a:	6803      	ldr	r3, [r0, #0]
 8001a6c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001a6e:	f7fe fea7 	bl	80007c0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001a72:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001a74:	42b0      	cmp	r0, r6
 8001a76:	d1f8      	bne.n	8001a6a <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001a78:	2021      	movs	r0, #33	; 0x21
 8001a7a:	5c21      	ldrb	r1, [r4, r0]
 8001a7c:	078a      	lsls	r2, r1, #30
 8001a7e:	d104      	bne.n	8001a8a <chThdExit+0x3a>
    REG_REMOVE(tp);
 8001a80:	6966      	ldr	r6, [r4, #20]
 8001a82:	6922      	ldr	r2, [r4, #16]
 8001a84:	6132      	str	r2, [r6, #16]
 8001a86:	6924      	ldr	r4, [r4, #16]
 8001a88:	6166      	str	r6, [r4, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001a8a:	200f      	movs	r0, #15
 8001a8c:	f7ff f9b8 	bl	8000e00 <chSchGoSleepS>
 8001a90:	b672      	cpsid	i
 8001a92:	4b02      	ldr	r3, [pc, #8]	; (8001a9c <chThdExit+0x4c>)
 8001a94:	62eb      	str	r3, [r5, #44]	; 0x2c
 8001a96:	e7fe      	b.n	8001a96 <chThdExit+0x46>
 8001a98:	20000d38 	.word	0x20000d38
 8001a9c:	08001d10 	.word	0x08001d10

08001aa0 <strlen>:
 8001aa0:	2300      	movs	r3, #0
 8001aa2:	5cc2      	ldrb	r2, [r0, r3]
 8001aa4:	3301      	adds	r3, #1
 8001aa6:	2a00      	cmp	r2, #0
 8001aa8:	d1fb      	bne.n	8001aa2 <strlen+0x2>
 8001aaa:	1e58      	subs	r0, r3, #1
 8001aac:	4770      	bx	lr
 8001aae:	46c0      	nop			; (mov r8, r8)
 8001ab0:	0800085c 	.word	0x0800085c
 8001ab4:	08000850 	.word	0x08000850
 8001ab8:	08000850 	.word	0x08000850
 8001abc:	08000864 	.word	0x08000864
 8001ac0:	08000846 	.word	0x08000846
 8001ac4:	0800083a 	.word	0x0800083a
 8001ac8:	08000850 	.word	0x08000850
 8001acc:	08000846 	.word	0x08000846

08001ad0 <__func__.5046.7946.4596>:
 8001ad0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08001ae0 <__func__.5808.6805.4589>:
 8001ae0:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

08001b00 <__func__.5046.6877.4592>:
 8001b00:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08001b10 <__func__.5749.4850.4644>:
 8001b10:	63536863 61655268 00497964 00000000     chSchReadyI.....

08001b20 <__func__.5232.5087.4636>:
 8001b20:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 8001b30:	00497478 00000000 00000000 00000000     xtI.............

08001b40 <__func__.5046.5090.4587>:
 8001b40:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08001b50 <__func__.6269.7348.4645>:
 8001b50:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08001b60 <__func__.5752.4588.4639>:
 8001b60:	54566863 65536f44 00004974 00000000     chVTDoSetI......
 8001b70:	36235653 00000000 37235653 00000000     SV#6....SV#7....
 8001b80:	38235653 00000000 39235653 00000000     SV#8....SV#9....
 8001b90:	31235653 00000030 31235653 00000031     SV#10...SV#11...
 8001ba0:	35235653 00000000 34235653 00000000     SV#5....SV#4....
 8001bb0:	63617473 766f206b 6c667265 0000776f     stack overflow..

08001bc0 <__func__.5769.6221.4642>:
 8001bc0:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 8001bd0:	49736761 00000000 00000000 00000000     agsI............

08001be0 <__func__.5220.5089.4588>:
 8001be0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

08001bf0 <__func__.5786.6219.4643>:
 8001bf0:	76456863 67695374 496c616e 00000000     chEvtSignalI....

08001c00 <__func__.5777.4851.4591>:
 8001c00:	63536863 6b615768 53707565 00000000     chSchWakeupS....

08001c10 <ram_areas.4018.4597>:
 8001c10:	080021a8 20001428 20001428 20001428     .!..(.. (.. (.. 
 8001c20:	080021a8 00000000 00000000 00000000     .!..............
 8001c30:	080021a8 00000000 00000000 00000000     .!..............
 8001c40:	080021a8 00000000 00000000 00000000     .!..............
 8001c50:	080021a8 00000000 00000000 00000000     .!..............
 8001c60:	080021a8 00000000 00000000 00000000     .!..............
 8001c70:	080021a8 00000000 00000000 00000000     .!..............
 8001c80:	080021a8 00000000 00000000 00000000     .!..............

08001c90 <__func__.5135.4318.4641>:
 8001c90:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

08001ca0 <__func__.5772.6804.4546>:
 8001ca0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

08001cb0 <__func__.5046.6803.4586>:
 8001cb0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08001cc0 <__func__.5761.5091.4590>:
 8001cc0:	68546863 65724364 49657461 00000000     chThdCreateI....

08001cd0 <__func__.6262.7347.4640>:
 8001cd0:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08001ce0 <__func__.6307.7947.4593>:
 8001ce0:	74536473 00747261 00000000 00000000     sdStart.........

08001cf0 <vmt.7998.4547>:
 8001cf0:	080013a1 080013c1 08001261 080011a1     ........a.......
 8001d00:	08001251 08001191 08001391 080013b1     Q...............

08001d10 <__func__.5805.5093.4548>:
 8001d10:	68546863 69784564 00005374 00000000     chThdExitS......
 8001d20:	314e5453 5f303131 00005852 65736572     STN1110_RX..rese
 8001d30:	6e697474 00000067 65746661 65722072     tting...after re
 8001d40:	00746573 65736572 00002074 646e6573     set.reset ..send
 8001d50:	20676e69 00005441 0a0d5441 00000000     ing AT..AT......
 8001d60:	74696157 20676e69 20726f66 72205441     Waiting for AT r
 8001d70:	6f707365 0065736e 33235653 00000000     esponse.SV#3....
 8001d80:	656c6469 00000000 00000000 00000000     idle............

08001d90 <ch_debug.4504>:
 8001d90:	6e69616d 18441600 08480404 1814100c     main..D...H.....
 8001da0:	2221201c 00000000                       . !"....
