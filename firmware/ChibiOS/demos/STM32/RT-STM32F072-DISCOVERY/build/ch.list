
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000100 <Reset_Handler>:
 8000100:	b672      	cpsid	i
 8000102:	4822      	ldr	r0, [pc, #136]	; (800018c <endfiniloop+0x4>)
 8000104:	f380 8809 	msr	PSP, r0
 8000108:	2002      	movs	r0, #2
 800010a:	f380 8814 	msr	CONTROL, r0
 800010e:	f3bf 8f6f 	isb	sy
 8000112:	f003 f88d 	bl	8003230 <__core_init>
 8000116:	f000 ffd3 	bl	80010c0 <__early_init>
 800011a:	481d      	ldr	r0, [pc, #116]	; (8000190 <endfiniloop+0x8>)
 800011c:	491d      	ldr	r1, [pc, #116]	; (8000194 <endfiniloop+0xc>)
 800011e:	4a1e      	ldr	r2, [pc, #120]	; (8000198 <endfiniloop+0x10>)

08000120 <msloop>:
 8000120:	4291      	cmp	r1, r2
 8000122:	da02      	bge.n	800012a <endmsloop>
 8000124:	6008      	str	r0, [r1, #0]
 8000126:	3104      	adds	r1, #4
 8000128:	e7fa      	b.n	8000120 <msloop>

0800012a <endmsloop>:
 800012a:	491c      	ldr	r1, [pc, #112]	; (800019c <endfiniloop+0x14>)
 800012c:	4a17      	ldr	r2, [pc, #92]	; (800018c <endfiniloop+0x4>)

0800012e <psloop>:
 800012e:	4291      	cmp	r1, r2
 8000130:	da02      	bge.n	8000138 <endpsloop>
 8000132:	6008      	str	r0, [r1, #0]
 8000134:	3104      	adds	r1, #4
 8000136:	e7fa      	b.n	800012e <psloop>

08000138 <endpsloop>:
 8000138:	4919      	ldr	r1, [pc, #100]	; (80001a0 <endfiniloop+0x18>)
 800013a:	4a1a      	ldr	r2, [pc, #104]	; (80001a4 <endfiniloop+0x1c>)
 800013c:	4b1a      	ldr	r3, [pc, #104]	; (80001a8 <endfiniloop+0x20>)

0800013e <dloop>:
 800013e:	429a      	cmp	r2, r3
 8000140:	da04      	bge.n	800014c <enddloop>
 8000142:	6808      	ldr	r0, [r1, #0]
 8000144:	6010      	str	r0, [r2, #0]
 8000146:	3104      	adds	r1, #4
 8000148:	3204      	adds	r2, #4
 800014a:	e7f8      	b.n	800013e <dloop>

0800014c <enddloop>:
 800014c:	2000      	movs	r0, #0
 800014e:	4917      	ldr	r1, [pc, #92]	; (80001ac <endfiniloop+0x24>)
 8000150:	4a17      	ldr	r2, [pc, #92]	; (80001b0 <endfiniloop+0x28>)

08000152 <bloop>:
 8000152:	4291      	cmp	r1, r2
 8000154:	da02      	bge.n	800015c <endbloop>
 8000156:	6008      	str	r0, [r1, #0]
 8000158:	3104      	adds	r1, #4
 800015a:	e7fa      	b.n	8000152 <bloop>

0800015c <endbloop>:
 800015c:	f003 f808 	bl	8003170 <__init_ram_areas>
 8000160:	f003 f85e 	bl	8003220 <__late_init>
 8000164:	4c13      	ldr	r4, [pc, #76]	; (80001b4 <endfiniloop+0x2c>)
 8000166:	4d14      	ldr	r5, [pc, #80]	; (80001b8 <endfiniloop+0x30>)

08000168 <initloop>:
 8000168:	42ac      	cmp	r4, r5
 800016a:	da03      	bge.n	8000174 <endinitloop>
 800016c:	6821      	ldr	r1, [r4, #0]
 800016e:	4788      	blx	r1
 8000170:	3404      	adds	r4, #4
 8000172:	e7f9      	b.n	8000168 <initloop>

08000174 <endinitloop>:
 8000174:	f007 fdb4 	bl	8007ce0 <main>
 8000178:	4c10      	ldr	r4, [pc, #64]	; (80001bc <endfiniloop+0x34>)
 800017a:	4d11      	ldr	r5, [pc, #68]	; (80001c0 <endfiniloop+0x38>)

0800017c <finiloop>:
 800017c:	42ac      	cmp	r4, r5
 800017e:	da03      	bge.n	8000188 <endfiniloop>
 8000180:	6821      	ldr	r1, [r4, #0]
 8000182:	4788      	blx	r1
 8000184:	3404      	adds	r4, #4
 8000186:	e7f9      	b.n	800017c <finiloop>

08000188 <endfiniloop>:
 8000188:	490e      	ldr	r1, [pc, #56]	; (80001c4 <endfiniloop+0x3c>)
 800018a:	4708      	bx	r1
 800018c:	20000600 	.word	0x20000600
 8000190:	55555555 	.word	0x55555555
 8000194:	20000000 	.word	0x20000000
 8000198:	20000400 	.word	0x20000400
 800019c:	20000400 	.word	0x20000400
 80001a0:	080096c8 	.word	0x080096c8
 80001a4:	20000600 	.word	0x20000600
 80001a8:	200006b8 	.word	0x200006b8
 80001ac:	200006b8 	.word	0x200006b8
 80001b0:	20001720 	.word	0x20001720
 80001b4:	08000100 	.word	0x08000100
 80001b8:	08000100 	.word	0x08000100
 80001bc:	08000100 	.word	0x08000100
 80001c0:	08000100 	.word	0x08000100
 80001c4:	08003211 	.word	0x08003211
	...

080001d0 <_port_switch>:
 80001d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001d2:	4644      	mov	r4, r8
 80001d4:	464d      	mov	r5, r9
 80001d6:	4656      	mov	r6, sl
 80001d8:	465f      	mov	r7, fp
 80001da:	b4f0      	push	{r4, r5, r6, r7}
 80001dc:	466b      	mov	r3, sp
 80001de:	60cb      	str	r3, [r1, #12]
 80001e0:	68c3      	ldr	r3, [r0, #12]
 80001e2:	469d      	mov	sp, r3
 80001e4:	bcf0      	pop	{r4, r5, r6, r7}
 80001e6:	46a0      	mov	r8, r4
 80001e8:	46a9      	mov	r9, r5
 80001ea:	46b2      	mov	sl, r6
 80001ec:	46bb      	mov	fp, r7
 80001ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001f0 <_port_thread_start>:
 80001f0:	f003 fbbe 	bl	8003970 <_dbg_check_unlock>
 80001f4:	b662      	cpsie	i
 80001f6:	1c28      	adds	r0, r5, #0
 80001f8:	47a0      	blx	r4
 80001fa:	2000      	movs	r0, #0
 80001fc:	f000 ffc0 	bl	8001180 <chThdExit>

08000200 <_port_switch_from_isr>:
 8000200:	f003 fc4e 	bl	8003aa0 <_dbg_check_lock>
 8000204:	f000 ffb4 	bl	8001170 <chSchDoReschedule>
 8000208:	f003 fbb2 	bl	8003970 <_dbg_check_unlock>

0800020c <_port_exit_from_isr>:
 800020c:	4a01      	ldr	r2, [pc, #4]	; (8000214 <_port_exit_from_isr+0x8>)
 800020e:	4b02      	ldr	r3, [pc, #8]	; (8000218 <_port_exit_from_isr+0xc>)
 8000210:	6013      	str	r3, [r2, #0]
 8000212:	e7fe      	b.n	8000212 <_port_exit_from_isr+0x6>
 8000214:	e000ed04 	.word	0xe000ed04
 8000218:	80000000 	.word	0x80000000
 800021c:	00000000 	.word	0x00000000

08000220 <__aeabi_uidiv>:
 8000220:	2900      	cmp	r1, #0
 8000222:	d034      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>

08000224 <.udivsi3_skip_div0_test>:
 8000224:	2301      	movs	r3, #1
 8000226:	2200      	movs	r2, #0
 8000228:	b410      	push	{r4}
 800022a:	4288      	cmp	r0, r1
 800022c:	d32c      	bcc.n	8000288 <.udivsi3_skip_div0_test+0x64>
 800022e:	2401      	movs	r4, #1
 8000230:	0724      	lsls	r4, r4, #28
 8000232:	42a1      	cmp	r1, r4
 8000234:	d204      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 8000236:	4281      	cmp	r1, r0
 8000238:	d202      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x1c>
 800023a:	0109      	lsls	r1, r1, #4
 800023c:	011b      	lsls	r3, r3, #4
 800023e:	e7f8      	b.n	8000232 <.udivsi3_skip_div0_test+0xe>
 8000240:	00e4      	lsls	r4, r4, #3
 8000242:	42a1      	cmp	r1, r4
 8000244:	d204      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000246:	4281      	cmp	r1, r0
 8000248:	d202      	bcs.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 800024a:	0049      	lsls	r1, r1, #1
 800024c:	005b      	lsls	r3, r3, #1
 800024e:	e7f8      	b.n	8000242 <.udivsi3_skip_div0_test+0x1e>
 8000250:	4288      	cmp	r0, r1
 8000252:	d301      	bcc.n	8000258 <.udivsi3_skip_div0_test+0x34>
 8000254:	1a40      	subs	r0, r0, r1
 8000256:	431a      	orrs	r2, r3
 8000258:	084c      	lsrs	r4, r1, #1
 800025a:	42a0      	cmp	r0, r4
 800025c:	d302      	bcc.n	8000264 <.udivsi3_skip_div0_test+0x40>
 800025e:	1b00      	subs	r0, r0, r4
 8000260:	085c      	lsrs	r4, r3, #1
 8000262:	4322      	orrs	r2, r4
 8000264:	088c      	lsrs	r4, r1, #2
 8000266:	42a0      	cmp	r0, r4
 8000268:	d302      	bcc.n	8000270 <.udivsi3_skip_div0_test+0x4c>
 800026a:	1b00      	subs	r0, r0, r4
 800026c:	089c      	lsrs	r4, r3, #2
 800026e:	4322      	orrs	r2, r4
 8000270:	08cc      	lsrs	r4, r1, #3
 8000272:	42a0      	cmp	r0, r4
 8000274:	d302      	bcc.n	800027c <.udivsi3_skip_div0_test+0x58>
 8000276:	1b00      	subs	r0, r0, r4
 8000278:	08dc      	lsrs	r4, r3, #3
 800027a:	4322      	orrs	r2, r4
 800027c:	2800      	cmp	r0, #0
 800027e:	d003      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000280:	091b      	lsrs	r3, r3, #4
 8000282:	d001      	beq.n	8000288 <.udivsi3_skip_div0_test+0x64>
 8000284:	0909      	lsrs	r1, r1, #4
 8000286:	e7e3      	b.n	8000250 <.udivsi3_skip_div0_test+0x2c>
 8000288:	1c10      	adds	r0, r2, #0
 800028a:	bc10      	pop	{r4}
 800028c:	4770      	bx	lr
 800028e:	2800      	cmp	r0, #0
 8000290:	d001      	beq.n	8000296 <.udivsi3_skip_div0_test+0x72>
 8000292:	2000      	movs	r0, #0
 8000294:	43c0      	mvns	r0, r0
 8000296:	b407      	push	{r0, r1, r2}
 8000298:	4802      	ldr	r0, [pc, #8]	; (80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029a:	a102      	add	r1, pc, #8	; (adr r1, 80002a4 <.udivsi3_skip_div0_test+0x80>)
 800029c:	1840      	adds	r0, r0, r1
 800029e:	9002      	str	r0, [sp, #8]
 80002a0:	bd03      	pop	{r0, r1, pc}
 80002a2:	46c0      	nop			; (mov r8, r8)
 80002a4:	0000001d 	.word	0x0000001d

080002a8 <__aeabi_uidivmod>:
 80002a8:	2900      	cmp	r1, #0
 80002aa:	d0f0      	beq.n	800028e <.udivsi3_skip_div0_test+0x6a>
 80002ac:	b503      	push	{r0, r1, lr}
 80002ae:	f7ff ffb9 	bl	8000224 <.udivsi3_skip_div0_test>
 80002b2:	bc0e      	pop	{r1, r2, r3}
 80002b4:	4342      	muls	r2, r0
 80002b6:	1a89      	subs	r1, r1, r2
 80002b8:	4718      	bx	r3
 80002ba:	46c0      	nop			; (mov r8, r8)
 80002bc:	0000      	movs	r0, r0
	...

080002c0 <__aeabi_idiv0>:
 80002c0:	4770      	bx	lr
 80002c2:	46c0      	nop			; (mov r8, r8)
	...

080002d0 <mtx8_setup.9241>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80002d0:	4806      	ldr	r0, [pc, #24]	; (80002ec <mtx8_setup.9241+0x1c>)
 80002d2:	4907      	ldr	r1, [pc, #28]	; (80002f0 <mtx8_setup.9241+0x20>)
 80002d4:	4b07      	ldr	r3, [pc, #28]	; (80002f4 <mtx8_setup.9241+0x24>)
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80002d6:	2200      	movs	r2, #0
 80002d8:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80002da:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80002dc:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 80002de:	6040      	str	r0, [r0, #4]
 80002e0:	6082      	str	r2, [r0, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80002e2:	6009      	str	r1, [r1, #0]
  tqp->p_prev = (thread_t *)tqp;
 80002e4:	6049      	str	r1, [r1, #4]
 80002e6:	608a      	str	r2, [r1, #8]
static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 80002e8:	4770      	bx	lr
 80002ea:	46c0      	nop			; (mov r8, r8)
 80002ec:	20000694 	.word	0x20000694
 80002f0:	20000678 	.word	0x20000678
 80002f4:	20000670 	.word	0x20000670
 80002f8:	46c0      	nop			; (mov r8, r8)
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	46c0      	nop			; (mov r8, r8)
 80002fe:	46c0      	nop			; (mov r8, r8)

08000300 <mtx7_setup.9243>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000300:	4804      	ldr	r0, [pc, #16]	; (8000314 <mtx7_setup.9243+0x14>)
 8000302:	4b05      	ldr	r3, [pc, #20]	; (8000318 <mtx7_setup.9243+0x18>)
 8000304:	2200      	movs	r2, #0
 8000306:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000308:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800030a:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800030c:	6040      	str	r0, [r0, #4]
 800030e:	6082      	str	r2, [r0, #8]

static void mtx7_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 8000310:	4770      	bx	lr
 8000312:	46c0      	nop			; (mov r8, r8)
 8000314:	20000694 	.word	0x20000694
 8000318:	20000670 	.word	0x20000670
 800031c:	46c0      	nop			; (mov r8, r8)
 800031e:	46c0      	nop			; (mov r8, r8)

08000320 <mtx6_setup.9245>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000320:	4804      	ldr	r0, [pc, #16]	; (8000334 <mtx6_setup.9245+0x14>)
 8000322:	4b05      	ldr	r3, [pc, #20]	; (8000338 <mtx6_setup.9245+0x18>)
 8000324:	2200      	movs	r2, #0
 8000326:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000328:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800032a:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800032c:	6040      	str	r0, [r0, #4]
 800032e:	6082      	str	r2, [r0, #8]

static void mtx6_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 8000330:	4770      	bx	lr
 8000332:	46c0      	nop			; (mov r8, r8)
 8000334:	20000694 	.word	0x20000694
 8000338:	20000670 	.word	0x20000670
 800033c:	46c0      	nop			; (mov r8, r8)
 800033e:	46c0      	nop			; (mov r8, r8)

08000340 <mtx5_setup.9247>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000340:	4b02      	ldr	r3, [pc, #8]	; (800034c <mtx5_setup.9247+0xc>)
 8000342:	2200      	movs	r2, #0
 8000344:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000346:	605b      	str	r3, [r3, #4]
 8000348:	609a      	str	r2, [r3, #8]
 */

static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}
 800034a:	4770      	bx	lr
 800034c:	20000694 	.word	0x20000694

08000350 <mtx4_setup.9249>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000350:	4b04      	ldr	r3, [pc, #16]	; (8000364 <mtx4_setup.9249+0x14>)
 8000352:	4805      	ldr	r0, [pc, #20]	; (8000368 <mtx4_setup.9249+0x18>)
 8000354:	2200      	movs	r2, #0
 8000356:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000358:	605b      	str	r3, [r3, #4]
 800035a:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800035c:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800035e:	6040      	str	r0, [r0, #4]
 8000360:	6082      	str	r2, [r0, #8]

static void mtx4_setup(void) {

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8000362:	4770      	bx	lr
 8000364:	20000694 	.word	0x20000694
 8000368:	20000678 	.word	0x20000678
 800036c:	46c0      	nop			; (mov r8, r8)
 800036e:	46c0      	nop			; (mov r8, r8)

08000370 <mtx1_setup.9251>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000370:	4b02      	ldr	r3, [pc, #8]	; (800037c <mtx1_setup.9251+0xc>)
 8000372:	2200      	movs	r2, #0
 8000374:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000376:	605b      	str	r3, [r3, #4]
 8000378:	609a      	str	r2, [r3, #8]
 */

static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}
 800037a:	4770      	bx	lr
 800037c:	20000694 	.word	0x20000694

08000380 <bmk12_setup.10800>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000380:	4b02      	ldr	r3, [pc, #8]	; (800038c <bmk12_setup.10800+0xc>)
 8000382:	2200      	movs	r2, #0
 8000384:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000386:	605b      	str	r3, [r3, #4]
 8000388:	609a      	str	r2, [r3, #8]
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}
 800038a:	4770      	bx	lr
 800038c:	20000de4 	.word	0x20000de4

08000390 <mbox1_setup.9598>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8000390:	4b09      	ldr	r3, [pc, #36]	; (80003b8 <mbox1_setup.9598+0x28>)
 8000392:	4a0a      	ldr	r2, [pc, #40]	; (80003bc <mbox1_setup.9598+0x2c>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000394:	1c18      	adds	r0, r3, #0
 8000396:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8000398:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 800039a:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 800039c:	3214      	adds	r2, #20
 800039e:	301c      	adds	r0, #28
 80003a0:	605a      	str	r2, [r3, #4]
 80003a2:	1c1a      	adds	r2, r3, #0
 80003a4:	3210      	adds	r2, #16
 80003a6:	61d8      	str	r0, [r3, #28]
  tqp->p_prev = (thread_t *)tqp;
 80003a8:	6218      	str	r0, [r3, #32]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 80003aa:	2105      	movs	r1, #5
 80003ac:	2000      	movs	r0, #0
 80003ae:	6259      	str	r1, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80003b0:	611a      	str	r2, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 80003b2:	615a      	str	r2, [r3, #20]
 80003b4:	6198      	str	r0, [r3, #24]
 */

static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}
 80003b6:	4770      	bx	lr
 80003b8:	20000600 	.word	0x20000600
 80003bc:	200006b8 	.word	0x200006b8

080003c0 <sem3_setup.9002>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80003c0:	4b02      	ldr	r3, [pc, #8]	; (80003cc <sem3_setup.9002+0xc>)
 80003c2:	2200      	movs	r2, #0
 80003c4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80003c6:	605b      	str	r3, [r3, #4]
 80003c8:	609a      	str	r2, [r3, #8]
 */

static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80003ca:	4770      	bx	lr
 80003cc:	200006a4 	.word	0x200006a4

080003d0 <sem2_setup.9004>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80003d0:	4b02      	ldr	r3, [pc, #8]	; (80003dc <sem2_setup.9004+0xc>)
 80003d2:	2200      	movs	r2, #0
 80003d4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80003d6:	605b      	str	r3, [r3, #4]
 80003d8:	609a      	str	r2, [r3, #8]
 */

static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80003da:	4770      	bx	lr
 80003dc:	200006a4 	.word	0x200006a4

080003e0 <sem1_setup.9006>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80003e0:	4b02      	ldr	r3, [pc, #8]	; (80003ec <sem1_setup.9006+0xc>)
 80003e2:	2200      	movs	r2, #0
 80003e4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80003e6:	605b      	str	r3, [r3, #4]
 80003e8:	609a      	str	r2, [r3, #8]
 */

static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80003ea:	4770      	bx	lr
 80003ec:	200006a4 	.word	0x200006a4

080003f0 <bmk11_setup.10804>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80003f0:	4b02      	ldr	r3, [pc, #8]	; (80003fc <bmk11_setup.10804+0xc>)
 80003f2:	2201      	movs	r2, #1
 80003f4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80003f6:	605b      	str	r3, [r3, #4]
 80003f8:	609a      	str	r2, [r3, #8]
 */

static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}
 80003fa:	4770      	bx	lr
 80003fc:	20000d48 	.word	0x20000d48

08000400 <bmk7_setup.10806>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000400:	4b02      	ldr	r3, [pc, #8]	; (800040c <bmk7_setup.10806+0xc>)
 8000402:	2200      	movs	r2, #0
 8000404:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000406:	605b      	str	r3, [r3, #4]
 8000408:	609a      	str	r2, [r3, #8]
}

static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 800040a:	4770      	bx	lr
 800040c:	20000d48 	.word	0x20000d48

08000410 <dyn2_setup.10184>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000410:	4b03      	ldr	r3, [pc, #12]	; (8000420 <dyn2_setup.10184+0x10>)
  mp->mp_object_size = size;
 8000412:	21a8      	movs	r1, #168	; 0xa8
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000414:	2200      	movs	r2, #0
  mp->mp_object_size = size;
 8000416:	0048      	lsls	r0, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000418:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 800041a:	6058      	str	r0, [r3, #4]
  mp->mp_provider = provider;
 800041c:	609a      	str	r2, [r3, #8]
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 800041e:	4770      	bx	lr
 8000420:	20000d78 	.word	0x20000d78
 8000424:	46c0      	nop			; (mov r8, r8)
 8000426:	46c0      	nop			; (mov r8, r8)
 8000428:	46c0      	nop			; (mov r8, r8)
 800042a:	46c0      	nop			; (mov r8, r8)
 800042c:	46c0      	nop			; (mov r8, r8)
 800042e:	46c0      	nop			; (mov r8, r8)

08000430 <pools1_setup.10043>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000430:	4b03      	ldr	r3, [pc, #12]	; (8000440 <pools1_setup.10043+0x10>)
  mp->mp_object_size = size;
 8000432:	21a8      	movs	r1, #168	; 0xa8
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000434:	2200      	movs	r2, #0
  mp->mp_object_size = size;
 8000436:	0048      	lsls	r0, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000438:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 800043a:	6058      	str	r0, [r3, #4]
  mp->mp_provider = provider;
 800043c:	609a      	str	r2, [r3, #8]
}

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 800043e:	4770      	bx	lr
 8000440:	20000688 	.word	0x20000688
 8000444:	46c0      	nop			; (mov r8, r8)
 8000446:	46c0      	nop			; (mov r8, r8)
 8000448:	46c0      	nop			; (mov r8, r8)
 800044a:	46c0      	nop			; (mov r8, r8)
 800044c:	46c0      	nop			; (mov r8, r8)
 800044e:	46c0      	nop			; (mov r8, r8)

08000450 <notify.10356>:

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
  (void)qp;
}
 8000450:	4770      	bx	lr
 8000452:	46c0      	nop			; (mov r8, r8)
 8000454:	46c0      	nop			; (mov r8, r8)
 8000456:	46c0      	nop			; (mov r8, r8)
 8000458:	46c0      	nop			; (mov r8, r8)
 800045a:	46c0      	nop			; (mov r8, r8)
 800045c:	46c0      	nop			; (mov r8, r8)
 800045e:	46c0      	nop			; (mov r8, r8)

08000460 <queues2_setup.10383>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000460:	4b07      	ldr	r3, [pc, #28]	; (8000480 <queues2_setup.10383+0x20>)
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8000462:	4808      	ldr	r0, [pc, #32]	; (8000484 <queues2_setup.10383+0x24>)
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000464:	2204      	movs	r2, #4
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8000466:	4908      	ldr	r1, [pc, #32]	; (8000488 <queues2_setup.10383+0x28>)
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000468:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800046a:	60d8      	str	r0, [r3, #12]
  oqp->q_rdptr   = bp;
 800046c:	6198      	str	r0, [r3, #24]
  oqp->q_wrptr   = bp;
 800046e:	6158      	str	r0, [r3, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000470:	2200      	movs	r2, #0
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000472:	3004      	adds	r0, #4
 8000474:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000476:	605b      	str	r3, [r3, #4]
 8000478:	6118      	str	r0, [r3, #16]
  oqp->q_notify  = onfy;
 800047a:	61d9      	str	r1, [r3, #28]
  oqp->q_link    = link;
 800047c:	621a      	str	r2, [r3, #32]
 */

static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 800047e:	4770      	bx	lr
 8000480:	20000628 	.word	0x20000628
 8000484:	200006b8 	.word	0x200006b8
 8000488:	08000451 	.word	0x08000451
 800048c:	46c0      	nop			; (mov r8, r8)
 800048e:	46c0      	nop			; (mov r8, r8)

08000490 <queues1_setup.10388>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000490:	4b07      	ldr	r3, [pc, #28]	; (80004b0 <queues1_setup.10388+0x20>)
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000492:	4a08      	ldr	r2, [pc, #32]	; (80004b4 <queues1_setup.10388+0x24>)
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8000494:	4808      	ldr	r0, [pc, #32]	; (80004b8 <queues1_setup.10388+0x28>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000496:	2100      	movs	r1, #0
  iqp->q_buffer  = bp;
 8000498:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800049a:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800049c:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800049e:	3204      	adds	r2, #4
 80004a0:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80004a2:	605b      	str	r3, [r3, #4]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80004a4:	6099      	str	r1, [r3, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80004a6:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80004a8:	61d8      	str	r0, [r3, #28]
  iqp->q_link    = link;
 80004aa:	6219      	str	r1, [r3, #32]
 */

static void queues1_setup(void) {

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 80004ac:	4770      	bx	lr
 80004ae:	46c0      	nop			; (mov r8, r8)
 80004b0:	2000064c 	.word	0x2000064c
 80004b4:	200006b8 	.word	0x200006b8
 80004b8:	08000451 	.word	0x08000451
 80004bc:	46c0      	nop			; (mov r8, r8)
 80004be:	46c0      	nop			; (mov r8, r8)

080004c0 <tmo.10778>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 80004c0:	4770      	bx	lr
 80004c2:	46c0      	nop			; (mov r8, r8)
 80004c4:	46c0      	nop			; (mov r8, r8)
 80004c6:	46c0      	nop			; (mov r8, r8)
 80004c8:	46c0      	nop			; (mov r8, r8)
 80004ca:	46c0      	nop			; (mov r8, r8)
 80004cc:	46c0      	nop			; (mov r8, r8)
 80004ce:	46c0      	nop			; (mov r8, r8)

080004d0 <null_provider.10040>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 80004d0:	2000      	movs	r0, #0
 80004d2:	4770      	bx	lr
 80004d4:	46c0      	nop			; (mov r8, r8)
 80004d6:	46c0      	nop			; (mov r8, r8)
 80004d8:	46c0      	nop			; (mov r8, r8)
 80004da:	46c0      	nop			; (mov r8, r8)
 80004dc:	46c0      	nop			; (mov r8, r8)
 80004de:	46c0      	nop			; (mov r8, r8)

080004e0 <tmr.8455>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 80004e0:	4b01      	ldr	r3, [pc, #4]	; (80004e8 <tmr.8455+0x8>)
 80004e2:	2201      	movs	r2, #1
 80004e4:	701a      	strb	r2, [r3, #0]
}
 80004e6:	4770      	bx	lr
 80004e8:	20000e18 	.word	0x20000e18
 80004ec:	46c0      	nop			; (mov r8, r8)
 80004ee:	46c0      	nop			; (mov r8, r8)

080004f0 <notify1.8355>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80004f0:	4b02      	ldr	r3, [pc, #8]	; (80004fc <notify1.8355+0xc>)
 80004f2:	2280      	movs	r2, #128	; 0x80
 80004f4:	6819      	ldr	r1, [r3, #0]
 80004f6:	430a      	orrs	r2, r1
 80004f8:	601a      	str	r2, [r3, #0]
}
 80004fa:	4770      	bx	lr
 80004fc:	40013800 	.word	0x40013800

08000500 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000500:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000504:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000506:	f383 8809 	msr	PSP, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800050a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800050c:	4770      	bx	lr
 800050e:	46c0      	nop			; (mov r8, r8)

08000510 <_idle_thread.4252>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000510:	e7fe      	b.n	8000510 <_idle_thread.4252>
 8000512:	46c0      	nop			; (mov r8, r8)
 8000514:	46c0      	nop			; (mov r8, r8)
 8000516:	46c0      	nop			; (mov r8, r8)
 8000518:	46c0      	nop			; (mov r8, r8)
 800051a:	46c0      	nop			; (mov r8, r8)
 800051c:	46c0      	nop			; (mov r8, r8)
 800051e:	46c0      	nop			; (mov r8, r8)

08000520 <chMtxObjectInit>:
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);
 8000520:	2800      	cmp	r0, #0
 8000522:	d004      	beq.n	800052e <chMtxObjectInit+0xe>

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000524:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000526:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000528:	6040      	str	r0, [r0, #4]
 800052a:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 800052c:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800052e:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000530:	4a01      	ldr	r2, [pc, #4]	; (8000538 <chMtxObjectInit+0x18>)
 8000532:	4802      	ldr	r0, [pc, #8]	; (800053c <chMtxObjectInit+0x1c>)
 8000534:	62c2      	str	r2, [r0, #44]	; 0x2c
 8000536:	e7fe      	b.n	8000536 <chMtxObjectInit+0x16>
 8000538:	08008ef0 	.word	0x08008ef0
 800053c:	20001040 	.word	0x20001040

08000540 <dyn1_setup.10180>:

  test_emit_token(*(char *)p);
}

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 8000540:	b508      	push	{r3, lr}
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8000542:	4807      	ldr	r0, [pc, #28]	; (8000560 <dyn1_setup.10180+0x20>)
  heapp->h_free.h.u.next = hp;
 8000544:	4b07      	ldr	r3, [pc, #28]	; (8000564 <dyn1_setup.10180+0x24>)
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8000546:	2200      	movs	r2, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8000548:	21d1      	movs	r1, #209	; 0xd1
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800054a:	6002      	str	r2, [r0, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 800054c:	60c2      	str	r2, [r0, #12]
  hp->h.u.next = NULL;
 800054e:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8000550:	00ca      	lsls	r2, r1, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8000552:	6083      	str	r3, [r0, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8000554:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8000556:	3010      	adds	r0, #16
 8000558:	f7ff ffe2 	bl	8000520 <chMtxObjectInit>

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 800055c:	bd08      	pop	{r3, pc}
 800055e:	46c0      	nop			; (mov r8, r8)
 8000560:	20000d88 	.word	0x20000d88
 8000564:	200006b8 	.word	0x200006b8
 8000568:	46c0      	nop			; (mov r8, r8)
 800056a:	46c0      	nop			; (mov r8, r8)
 800056c:	46c0      	nop			; (mov r8, r8)
 800056e:	46c0      	nop			; (mov r8, r8)

08000570 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000570:	4b05      	ldr	r3, [pc, #20]	; (8000588 <_dbg_check_suspend+0x18>)
 8000572:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000574:	2a00      	cmp	r2, #0
 8000576:	d102      	bne.n	800057e <_dbg_check_suspend+0xe>
 8000578:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800057a:	2800      	cmp	r0, #0
 800057c:	d003      	beq.n	8000586 <_dbg_check_suspend+0x16>
 800057e:	b672      	cpsid	i
 8000580:	4902      	ldr	r1, [pc, #8]	; (800058c <_dbg_check_suspend+0x1c>)
 8000582:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000584:	e7fe      	b.n	8000584 <_dbg_check_suspend+0x14>
    chSysHalt("SV#2");
  }
}
 8000586:	4770      	bx	lr
 8000588:	20001040 	.word	0x20001040
 800058c:	08008470 	.word	0x08008470

08000590 <_dbg_check_enable>:
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000590:	4b05      	ldr	r3, [pc, #20]	; (80005a8 <_dbg_check_enable+0x18>)
 8000592:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000594:	2a00      	cmp	r2, #0
 8000596:	d102      	bne.n	800059e <_dbg_check_enable+0xe>
 8000598:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800059a:	2800      	cmp	r0, #0
 800059c:	d003      	beq.n	80005a6 <_dbg_check_enable+0x16>
 800059e:	b672      	cpsid	i
 80005a0:	4902      	ldr	r1, [pc, #8]	; (80005ac <_dbg_check_enable+0x1c>)
 80005a2:	62d9      	str	r1, [r3, #44]	; 0x2c
 80005a4:	e7fe      	b.n	80005a4 <_dbg_check_enable+0x14>
    chSysHalt("SV#3");
  }
}
 80005a6:	4770      	bx	lr
 80005a8:	20001040 	.word	0x20001040
 80005ac:	08008478 	.word	0x08008478

080005b0 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80005b0:	4b06      	ldr	r3, [pc, #24]	; (80005cc <_dbg_check_lock_from_isr+0x1c>)
 80005b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005b4:	2a00      	cmp	r2, #0
 80005b6:	dd02      	ble.n	80005be <_dbg_check_lock_from_isr+0xe>
 80005b8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80005ba:	2800      	cmp	r0, #0
 80005bc:	d003      	beq.n	80005c6 <_dbg_check_lock_from_isr+0x16>
 80005be:	b672      	cpsid	i
 80005c0:	4a03      	ldr	r2, [pc, #12]	; (80005d0 <_dbg_check_lock_from_isr+0x20>)
 80005c2:	62da      	str	r2, [r3, #44]	; 0x2c
 80005c4:	e7fe      	b.n	80005c4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80005c6:	2101      	movs	r1, #1
 80005c8:	6359      	str	r1, [r3, #52]	; 0x34
}
 80005ca:	4770      	bx	lr
 80005cc:	20001040 	.word	0x20001040
 80005d0:	08008480 	.word	0x08008480
 80005d4:	46c0      	nop			; (mov r8, r8)
 80005d6:	46c0      	nop			; (mov r8, r8)
 80005d8:	46c0      	nop			; (mov r8, r8)
 80005da:	46c0      	nop			; (mov r8, r8)
 80005dc:	46c0      	nop			; (mov r8, r8)
 80005de:	46c0      	nop			; (mov r8, r8)

080005e0 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80005e0:	4b06      	ldr	r3, [pc, #24]	; (80005fc <_dbg_check_unlock_from_isr+0x1c>)
 80005e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005e4:	2a00      	cmp	r2, #0
 80005e6:	dd05      	ble.n	80005f4 <_dbg_check_unlock_from_isr+0x14>
 80005e8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80005ea:	2800      	cmp	r0, #0
 80005ec:	dd02      	ble.n	80005f4 <_dbg_check_unlock_from_isr+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 80005ee:	2100      	movs	r1, #0
 80005f0:	6359      	str	r1, [r3, #52]	; 0x34
}
 80005f2:	4770      	bx	lr
 80005f4:	b672      	cpsid	i
 80005f6:	4a02      	ldr	r2, [pc, #8]	; (8000600 <_dbg_check_unlock_from_isr+0x20>)
 80005f8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005fa:	e7fe      	b.n	80005fa <_dbg_check_unlock_from_isr+0x1a>
 80005fc:	20001040 	.word	0x20001040
 8000600:	08008488 	.word	0x08008488
 8000604:	46c0      	nop			; (mov r8, r8)
 8000606:	46c0      	nop			; (mov r8, r8)
 8000608:	46c0      	nop			; (mov r8, r8)
 800060a:	46c0      	nop			; (mov r8, r8)
 800060c:	46c0      	nop			; (mov r8, r8)
 800060e:	46c0      	nop			; (mov r8, r8)

08000610 <_dbg_check_enter_isr>:
 8000610:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000612:	4b07      	ldr	r3, [pc, #28]	; (8000630 <_dbg_check_enter_isr+0x20>)
 8000614:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000616:	2a00      	cmp	r2, #0
 8000618:	db02      	blt.n	8000620 <_dbg_check_enter_isr+0x10>
 800061a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800061c:	2900      	cmp	r1, #0
 800061e:	d003      	beq.n	8000628 <_dbg_check_enter_isr+0x18>
 8000620:	b672      	cpsid	i
 8000622:	4804      	ldr	r0, [pc, #16]	; (8000634 <_dbg_check_enter_isr+0x24>)
 8000624:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000626:	e7fe      	b.n	8000626 <_dbg_check_enter_isr+0x16>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 8000628:	3201      	adds	r2, #1
 800062a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800062c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800062e:	4770      	bx	lr
 8000630:	20001040 	.word	0x20001040
 8000634:	08008490 	.word	0x08008490
 8000638:	46c0      	nop			; (mov r8, r8)
 800063a:	46c0      	nop			; (mov r8, r8)
 800063c:	46c0      	nop			; (mov r8, r8)
 800063e:	46c0      	nop			; (mov r8, r8)

08000640 <_dbg_check_leave_isr>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000640:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000642:	4b07      	ldr	r3, [pc, #28]	; (8000660 <_dbg_check_leave_isr+0x20>)
 8000644:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000646:	2a00      	cmp	r2, #0
 8000648:	dd02      	ble.n	8000650 <_dbg_check_leave_isr+0x10>
 800064a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800064c:	2900      	cmp	r1, #0
 800064e:	d003      	beq.n	8000658 <_dbg_check_leave_isr+0x18>
 8000650:	b672      	cpsid	i
 8000652:	4804      	ldr	r0, [pc, #16]	; (8000664 <_dbg_check_leave_isr+0x24>)
 8000654:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000656:	e7fe      	b.n	8000656 <_dbg_check_leave_isr+0x16>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8000658:	3a01      	subs	r2, #1
 800065a:	631a      	str	r2, [r3, #48]	; 0x30
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800065c:	b662      	cpsie	i
  port_unlock_from_isr();
}
 800065e:	4770      	bx	lr
 8000660:	20001040 	.word	0x20001040
 8000664:	08008498 	.word	0x08008498
 8000668:	46c0      	nop			; (mov r8, r8)
 800066a:	46c0      	nop			; (mov r8, r8)
 800066c:	46c0      	nop			; (mov r8, r8)
 800066e:	46c0      	nop			; (mov r8, r8)

08000670 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000670:	4b05      	ldr	r3, [pc, #20]	; (8000688 <chDbgCheckClassI+0x18>)
 8000672:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000674:	2a00      	cmp	r2, #0
 8000676:	db03      	blt.n	8000680 <chDbgCheckClassI+0x10>
 8000678:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800067a:	2800      	cmp	r0, #0
 800067c:	dd00      	ble.n	8000680 <chDbgCheckClassI+0x10>
    chSysHalt("SV#10");
  }
}
 800067e:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000680:	b672      	cpsid	i
 8000682:	4902      	ldr	r1, [pc, #8]	; (800068c <chDbgCheckClassI+0x1c>)
 8000684:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000686:	e7fe      	b.n	8000686 <chDbgCheckClassI+0x16>
 8000688:	20001040 	.word	0x20001040
 800068c:	080084a0 	.word	0x080084a0

08000690 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000690:	b510      	push	{r4, lr}
 8000692:	1c04      	adds	r4, r0, #0
  cnt_t n;

  chDbgCheckClassI();
 8000694:	f7ff ffec 	bl	8000670 <chDbgCheckClassI>

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000698:	07e3      	lsls	r3, r4, #31
 800069a:	d512      	bpl.n	80006c2 <chSysIntegrityCheckI+0x32>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 800069c:	4920      	ldr	r1, [pc, #128]	; (8000720 <chSysIntegrityCheckI+0x90>)
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800069e:	2300      	movs	r3, #0
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 80006a0:	680a      	ldr	r2, [r1, #0]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80006a2:	428a      	cmp	r2, r1
 80006a4:	d003      	beq.n	80006ae <chSysIntegrityCheckI+0x1e>
      n++;
      tp = tp->p_next;
 80006a6:	6812      	ldr	r2, [r2, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n++;
 80006a8:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80006aa:	428a      	cmp	r2, r1
 80006ac:	d1fb      	bne.n	80006a6 <chSysIntegrityCheckI+0x16>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 80006ae:	6848      	ldr	r0, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80006b0:	4288      	cmp	r0, r1
 80006b2:	d003      	beq.n	80006bc <chSysIntegrityCheckI+0x2c>
      n--;
      tp = tp->p_prev;
 80006b4:	6840      	ldr	r0, [r0, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n--;
 80006b6:	3b01      	subs	r3, #1
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80006b8:	4288      	cmp	r0, r1
 80006ba:	d1fb      	bne.n	80006b4 <chSysIntegrityCheckI+0x24>
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80006bc:	2001      	movs	r0, #1
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80006be:	2b00      	cmp	r3, #0
 80006c0:	d12b      	bne.n	800071a <chSysIntegrityCheckI+0x8a>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 80006c2:	07a3      	lsls	r3, r4, #30
 80006c4:	d515      	bpl.n	80006f2 <chSysIntegrityCheckI+0x62>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 80006c6:	4916      	ldr	r1, [pc, #88]	; (8000720 <chSysIntegrityCheckI+0x90>)
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80006c8:	2300      	movs	r3, #0
 80006ca:	1c08      	adds	r0, r1, #0
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 80006cc:	69ca      	ldr	r2, [r1, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80006ce:	301c      	adds	r0, #28
 80006d0:	4282      	cmp	r2, r0
 80006d2:	d003      	beq.n	80006dc <chSysIntegrityCheckI+0x4c>
      n++;
      vtp = vtp->vt_next;
 80006d4:	6812      	ldr	r2, [r2, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 80006d6:	3301      	adds	r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80006d8:	4282      	cmp	r2, r0
 80006da:	d1fb      	bne.n	80006d4 <chSysIntegrityCheckI+0x44>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80006dc:	6a08      	ldr	r0, [r1, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80006de:	311c      	adds	r1, #28
 80006e0:	4288      	cmp	r0, r1
 80006e2:	d003      	beq.n	80006ec <chSysIntegrityCheckI+0x5c>
      n--;
      vtp = vtp->vt_prev;
 80006e4:	6840      	ldr	r0, [r0, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 80006e6:	3b01      	subs	r3, #1
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80006e8:	4288      	cmp	r0, r1
 80006ea:	d1fb      	bne.n	80006e4 <chSysIntegrityCheckI+0x54>
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80006ec:	2001      	movs	r0, #1
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80006ee:	2b00      	cmp	r3, #0
 80006f0:	d113      	bne.n	800071a <chSysIntegrityCheckI+0x8a>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 80006f2:	2000      	movs	r0, #0
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80006f4:	0763      	lsls	r3, r4, #29
 80006f6:	d510      	bpl.n	800071a <chSysIntegrityCheckI+0x8a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
 80006f8:	4c09      	ldr	r4, [pc, #36]	; (8000720 <chSysIntegrityCheckI+0x90>)
 80006fa:	6921      	ldr	r1, [r4, #16]
    while (tp != (thread_t *)&ch.rlist) {
 80006fc:	42a1      	cmp	r1, r4
 80006fe:	d00d      	beq.n	800071c <chSysIntegrityCheckI+0x8c>
      n++;
      tp = tp->p_newer;
 8000700:	6909      	ldr	r1, [r1, #16]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 8000702:	3001      	adds	r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8000704:	42a1      	cmp	r1, r4
 8000706:	d1fb      	bne.n	8000700 <chSysIntegrityCheckI+0x70>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 8000708:	6963      	ldr	r3, [r4, #20]
    while (tp != (thread_t *)&ch.rlist) {
 800070a:	42a3      	cmp	r3, r4
 800070c:	d003      	beq.n	8000716 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->p_older;
 800070e:	695b      	ldr	r3, [r3, #20]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 8000710:	3801      	subs	r0, #1
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8000712:	42a3      	cmp	r3, r4
 8000714:	d1fb      	bne.n	800070e <chSysIntegrityCheckI+0x7e>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8000716:	1e43      	subs	r3, r0, #1
 8000718:	4198      	sbcs	r0, r3
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 800071a:	bd10      	pop	{r4, pc}
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800071c:	2000      	movs	r0, #0
 800071e:	e7f3      	b.n	8000708 <chSysIntegrityCheckI+0x78>
 8000720:	20001040 	.word	0x20001040
 8000724:	46c0      	nop			; (mov r8, r8)
 8000726:	46c0      	nop			; (mov r8, r8)
 8000728:	46c0      	nop			; (mov r8, r8)
 800072a:	46c0      	nop			; (mov r8, r8)
 800072c:	46c0      	nop			; (mov r8, r8)
 800072e:	46c0      	nop			; (mov r8, r8)

08000730 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000730:	b510      	push	{r4, lr}
 8000732:	1c04      	adds	r4, r0, #0
  thread_t *cp;

  chDbgCheckClassI();
 8000734:	f7ff ff9c 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000738:	2c00      	cmp	r4, #0
 800073a:	d019      	beq.n	8000770 <chSchReadyI+0x40>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800073c:	2320      	movs	r3, #32
 800073e:	5ce2      	ldrb	r2, [r4, r3]
 8000740:	2a00      	cmp	r2, #0
 8000742:	d010      	beq.n	8000766 <chSchReadyI+0x36>
 8000744:	2a0f      	cmp	r2, #15
 8000746:	d00e      	beq.n	8000766 <chSchReadyI+0x36>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000748:	2000      	movs	r0, #0
 800074a:	54e0      	strb	r0, [r4, r3]
 800074c:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 800074e:	4b0b      	ldr	r3, [pc, #44]	; (800077c <chSchReadyI+0x4c>)
  do {
    cp = cp->p_next;
 8000750:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000752:	6899      	ldr	r1, [r3, #8]
 8000754:	4291      	cmp	r1, r2
 8000756:	d2fb      	bcs.n	8000750 <chSchReadyI+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000758:	6858      	ldr	r0, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800075a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800075c:	6060      	str	r0, [r4, #4]
  tp->p_prev->p_next = tp;
 800075e:	6004      	str	r4, [r0, #0]
  cp->p_prev = tp;
 8000760:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000762:	1c20      	adds	r0, r4, #0
 8000764:	bd10      	pop	{r4, pc}
 8000766:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000768:	4c05      	ldr	r4, [pc, #20]	; (8000780 <chSchReadyI+0x50>)
 800076a:	4a04      	ldr	r2, [pc, #16]	; (800077c <chSchReadyI+0x4c>)
 800076c:	62d4      	str	r4, [r2, #44]	; 0x2c
 800076e:	e7fe      	b.n	800076e <chSchReadyI+0x3e>
 8000770:	b672      	cpsid	i
 8000772:	4903      	ldr	r1, [pc, #12]	; (8000780 <chSchReadyI+0x50>)
 8000774:	4b01      	ldr	r3, [pc, #4]	; (800077c <chSchReadyI+0x4c>)
 8000776:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000778:	e7fe      	b.n	8000778 <chSchReadyI+0x48>
 800077a:	46c0      	nop			; (mov r8, r8)
 800077c:	20001040 	.word	0x20001040
 8000780:	08008440 	.word	0x08008440
 8000784:	46c0      	nop			; (mov r8, r8)
 8000786:	46c0      	nop			; (mov r8, r8)
 8000788:	46c0      	nop			; (mov r8, r8)
 800078a:	46c0      	nop			; (mov r8, r8)
 800078c:	46c0      	nop			; (mov r8, r8)
 800078e:	46c0      	nop			; (mov r8, r8)

08000790 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000790:	b538      	push	{r3, r4, r5, lr}
 8000792:	1c04      	adds	r4, r0, #0
 8000794:	1c0d      	adds	r5, r1, #0

  chDbgCheckClassI();
 8000796:	f7ff ff6b 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800079a:	2c00      	cmp	r4, #0
 800079c:	d01c      	beq.n	80007d8 <chEvtSignalI+0x48>

  tp->p_epending |= events;
 800079e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80007a0:	2320      	movs	r3, #32
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 80007a2:	4329      	orrs	r1, r5
 80007a4:	63a1      	str	r1, [r4, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80007a6:	5ce0      	ldrb	r0, [r4, r3]
 80007a8:	280a      	cmp	r0, #10
 80007aa:	d00c      	beq.n	80007c6 <chEvtSignalI+0x36>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 80007ac:	280b      	cmp	r0, #11
 80007ae:	d000      	beq.n	80007b2 <chEvtSignalI+0x22>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 80007b0:	bd38      	pop	{r3, r4, r5, pc}
  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 80007b2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80007b4:	4011      	ands	r1, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 80007b6:	428a      	cmp	r2, r1
 80007b8:	d1fa      	bne.n	80007b0 <chEvtSignalI+0x20>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80007ba:	2100      	movs	r1, #0
 80007bc:	6261      	str	r1, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
 80007be:	1c20      	adds	r0, r4, #0
 80007c0:	f7ff ffb6 	bl	8000730 <chSchReadyI>
 80007c4:	e7f4      	b.n	80007b0 <chEvtSignalI+0x20>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80007c6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80007c8:	420d      	tst	r5, r1
 80007ca:	d0f1      	beq.n	80007b0 <chEvtSignalI+0x20>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80007cc:	2100      	movs	r1, #0
 80007ce:	6261      	str	r1, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
 80007d0:	1c20      	adds	r0, r4, #0
 80007d2:	f7ff ffad 	bl	8000730 <chSchReadyI>
 80007d6:	e7eb      	b.n	80007b0 <chEvtSignalI+0x20>
 80007d8:	b672      	cpsid	i
 80007da:	4c02      	ldr	r4, [pc, #8]	; (80007e4 <chEvtSignalI+0x54>)
 80007dc:	4b02      	ldr	r3, [pc, #8]	; (80007e8 <chEvtSignalI+0x58>)
 80007de:	62dc      	str	r4, [r3, #44]	; 0x2c
 80007e0:	e7fe      	b.n	80007e0 <chEvtSignalI+0x50>
 80007e2:	46c0      	nop			; (mov r8, r8)
 80007e4:	08008580 	.word	0x08008580
 80007e8:	20001040 	.word	0x20001040
 80007ec:	46c0      	nop			; (mov r8, r8)
 80007ee:	46c0      	nop			; (mov r8, r8)

080007f0 <chCondSignalI.constprop.61>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80007f0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 80007f2:	f7ff ff3d 	bl	8000670 <chDbgCheckClassI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80007f6:	4b06      	ldr	r3, [pc, #24]	; (8000810 <chCondSignalI.constprop.61+0x20>)
 80007f8:	6818      	ldr	r0, [r3, #0]
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 80007fa:	4298      	cmp	r0, r3
 80007fc:	d006      	beq.n	800080c <chCondSignalI.constprop.61+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80007fe:	6802      	ldr	r2, [r0, #0]
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 8000800:	2100      	movs	r1, #0
 8000802:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000804:	6053      	str	r3, [r2, #4]
 8000806:	6241      	str	r1, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000808:	f7ff ff92 	bl	8000730 <chSchReadyI>
  }
}
 800080c:	bd08      	pop	{r3, pc}
 800080e:	46c0      	nop			; (mov r8, r8)
 8000810:	20000670 	.word	0x20000670
 8000814:	46c0      	nop			; (mov r8, r8)
 8000816:	46c0      	nop			; (mov r8, r8)
 8000818:	46c0      	nop			; (mov r8, r8)
 800081a:	46c0      	nop			; (mov r8, r8)
 800081c:	46c0      	nop			; (mov r8, r8)
 800081e:	46c0      	nop			; (mov r8, r8)

08000820 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8000820:	b538      	push	{r3, r4, r5, lr}
 8000822:	1c04      	adds	r4, r0, #0
 8000824:	1c0d      	adds	r5, r1, #0
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8000826:	f7ff ff23 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 800082a:	2c00      	cmp	r4, #0
 800082c:	d005      	beq.n	800083a <chPoolFreeI+0x1a>
 800082e:	2d00      	cmp	r5, #0
 8000830:	d003      	beq.n	800083a <chPoolFreeI+0x1a>

  php->ph_next = mp->mp_next;
 8000832:	6823      	ldr	r3, [r4, #0]
 8000834:	602b      	str	r3, [r5, #0]
  mp->mp_next = php;
 8000836:	6025      	str	r5, [r4, #0]
}
 8000838:	bd38      	pop	{r3, r4, r5, pc}
 800083a:	b672      	cpsid	i
 800083c:	4a01      	ldr	r2, [pc, #4]	; (8000844 <chPoolFreeI+0x24>)
 800083e:	4802      	ldr	r0, [pc, #8]	; (8000848 <chPoolFreeI+0x28>)
 8000840:	62c2      	str	r2, [r0, #44]	; 0x2c
 8000842:	e7fe      	b.n	8000842 <chPoolFreeI+0x22>
 8000844:	08008430 	.word	0x08008430
 8000848:	20001040 	.word	0x20001040
 800084c:	46c0      	nop			; (mov r8, r8)
 800084e:	46c0      	nop			; (mov r8, r8)

08000850 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000850:	4b05      	ldr	r3, [pc, #20]	; (8000868 <chDbgCheckClassS+0x18>)
 8000852:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000854:	2a00      	cmp	r2, #0
 8000856:	d103      	bne.n	8000860 <chDbgCheckClassS+0x10>
 8000858:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800085a:	2800      	cmp	r0, #0
 800085c:	dd00      	ble.n	8000860 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 800085e:	4770      	bx	lr
 8000860:	b672      	cpsid	i
 8000862:	4902      	ldr	r1, [pc, #8]	; (800086c <chDbgCheckClassS+0x1c>)
 8000864:	62d9      	str	r1, [r3, #44]	; 0x2c
 8000866:	e7fe      	b.n	8000866 <chDbgCheckClassS+0x16>
 8000868:	20001040 	.word	0x20001040
 800086c:	080084a8 	.word	0x080084a8

08000870 <stSetAlarm>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000870:	2380      	movs	r3, #128	; 0x80
 8000872:	05db      	lsls	r3, r3, #23
 8000874:	68da      	ldr	r2, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000876:	0791      	lsls	r1, r2, #30
 8000878:	d501      	bpl.n	800087e <stSetAlarm+0xe>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800087a:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
 800087c:	4770      	bx	lr
 800087e:	b672      	cpsid	i
 8000880:	4801      	ldr	r0, [pc, #4]	; (8000888 <stSetAlarm+0x18>)
 8000882:	4902      	ldr	r1, [pc, #8]	; (800088c <stSetAlarm+0x1c>)
 8000884:	62c8      	str	r0, [r1, #44]	; 0x2c
 8000886:	e7fe      	b.n	8000886 <stSetAlarm+0x16>
 8000888:	08008590 	.word	0x08008590
 800088c:	20001040 	.word	0x20001040

08000890 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000890:	b510      	push	{r4, lr}
 8000892:	1c04      	adds	r4, r0, #0

  chDbgCheckClassI();
 8000894:	f7ff feec 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8000898:	2c00      	cmp	r4, #0
 800089a:	d030      	beq.n	80008fe <chVTDoResetI+0x6e>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 800089c:	68e0      	ldr	r0, [r4, #12]
 800089e:	2800      	cmp	r0, #0
 80008a0:	d032      	beq.n	8000908 <chVTDoResetI+0x78>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80008a2:	4b1f      	ldr	r3, [pc, #124]	; (8000920 <chVTDoResetI+0x90>)
 80008a4:	69d9      	ldr	r1, [r3, #28]
 80008a6:	42a1      	cmp	r1, r4
 80008a8:	d00e      	beq.n	80008c8 <chVTDoResetI+0x38>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80008aa:	6860      	ldr	r0, [r4, #4]
 80008ac:	6822      	ldr	r2, [r4, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 80008ae:	2100      	movs	r1, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80008b0:	6002      	str	r2, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80008b2:	6822      	ldr	r2, [r4, #0]
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80008b4:	331c      	adds	r3, #28
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80008b6:	6050      	str	r0, [r2, #4]
    vtp->vt_func = NULL;
 80008b8:	60e1      	str	r1, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80008ba:	429a      	cmp	r2, r3
 80008bc:	d003      	beq.n	80008c6 <chVTDoResetI+0x36>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 80008be:	68a4      	ldr	r4, [r4, #8]
 80008c0:	6893      	ldr	r3, [r2, #8]
 80008c2:	1918      	adds	r0, r3, r4
 80008c4:	6090      	str	r0, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80008c6:	bd10      	pop	{r4, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80008c8:	680a      	ldr	r2, [r1, #0]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80008ca:	1c1c      	adds	r4, r3, #0
 80008cc:	341c      	adds	r4, #28
  vtp->vt_func = NULL;
 80008ce:	2000      	movs	r0, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80008d0:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80008d2:	6054      	str	r4, [r2, #4]
  vtp->vt_func = NULL;
 80008d4:	60c8      	str	r0, [r1, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80008d6:	42a2      	cmp	r2, r4
 80008d8:	d01d      	beq.n	8000916 <chVTDoResetI+0x86>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80008da:	6894      	ldr	r4, [r2, #8]
 80008dc:	6889      	ldr	r1, [r1, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80008de:	6a9b      	ldr	r3, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80008e0:	1909      	adds	r1, r1, r4
 80008e2:	6091      	str	r1, [r2, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80008e4:	2280      	movs	r2, #128	; 0x80
 80008e6:	05d0      	lsls	r0, r2, #23
 80008e8:	6a44      	ldr	r4, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80008ea:	1ae2      	subs	r2, r4, r3

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80008ec:	4291      	cmp	r1, r2
 80008ee:	d9ea      	bls.n	80008c6 <chVTDoResetI+0x36>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80008f0:	1a89      	subs	r1, r1, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80008f2:	2901      	cmp	r1, #1
 80008f4:	d90d      	bls.n	8000912 <chVTDoResetI+0x82>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80008f6:	1908      	adds	r0, r1, r4
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80008f8:	f7ff ffba 	bl	8000870 <stSetAlarm>
 80008fc:	e7e3      	b.n	80008c6 <chVTDoResetI+0x36>
 80008fe:	b672      	cpsid	i
 8000900:	4c08      	ldr	r4, [pc, #32]	; (8000924 <chVTDoResetI+0x94>)
 8000902:	4b07      	ldr	r3, [pc, #28]	; (8000920 <chVTDoResetI+0x90>)
 8000904:	62dc      	str	r4, [r3, #44]	; 0x2c
 8000906:	e7fe      	b.n	8000906 <chVTDoResetI+0x76>
 8000908:	b672      	cpsid	i
 800090a:	4a06      	ldr	r2, [pc, #24]	; (8000924 <chVTDoResetI+0x94>)
 800090c:	4904      	ldr	r1, [pc, #16]	; (8000920 <chVTDoResetI+0x90>)
 800090e:	62ca      	str	r2, [r1, #44]	; 0x2c
 8000910:	e7fe      	b.n	8000910 <chVTDoResetI+0x80>
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000912:	2102      	movs	r1, #2
 8000914:	e7ef      	b.n	80008f6 <chVTDoResetI+0x66>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000916:	2480      	movs	r4, #128	; 0x80
 8000918:	05e3      	lsls	r3, r4, #23
 800091a:	60d8      	str	r0, [r3, #12]
 800091c:	e7d3      	b.n	80008c6 <chVTDoResetI+0x36>
 800091e:	46c0      	nop			; (mov r8, r8)
 8000920:	20001040 	.word	0x20001040
 8000924:	080085a0 	.word	0x080085a0
 8000928:	46c0      	nop			; (mov r8, r8)
 800092a:	46c0      	nop			; (mov r8, r8)
 800092c:	46c0      	nop			; (mov r8, r8)
 800092e:	46c0      	nop			; (mov r8, r8)

08000930 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000932:	1c04      	adds	r4, r0, #0
 8000934:	1c0e      	adds	r6, r1, #0
 8000936:	1c15      	adds	r5, r2, #0
 8000938:	1c1f      	adds	r7, r3, #0
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800093a:	f7ff fe99 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800093e:	2c00      	cmp	r4, #0
 8000940:	d003      	beq.n	800094a <chVTDoSetI+0x1a>
 8000942:	2d00      	cmp	r5, #0
 8000944:	d001      	beq.n	800094a <chVTDoSetI+0x1a>
 8000946:	2e00      	cmp	r6, #0
 8000948:	d104      	bne.n	8000954 <chVTDoSetI+0x24>
 800094a:	b672      	cpsid	i
 800094c:	4d25      	ldr	r5, [pc, #148]	; (80009e4 <chVTDoSetI+0xb4>)
 800094e:	4e26      	ldr	r6, [pc, #152]	; (80009e8 <chVTDoSetI+0xb8>)
 8000950:	62f5      	str	r5, [r6, #44]	; 0x2c
 8000952:	e7fe      	b.n	8000952 <chVTDoSetI+0x22>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000954:	2380      	movs	r3, #128	; 0x80
 8000956:	05d8      	lsls	r0, r3, #23

  vtp->vt_par = par;
 8000958:	6127      	str	r7, [r4, #16]
  vtp->vt_func = vtfunc;
 800095a:	60e5      	str	r5, [r4, #12]
 800095c:	6a42      	ldr	r2, [r0, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800095e:	2e01      	cmp	r6, #1
 8000960:	d921      	bls.n	80009a6 <chVTDoSetI+0x76>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000962:	4d21      	ldr	r5, [pc, #132]	; (80009e8 <chVTDoSetI+0xb8>)
 8000964:	1c29      	adds	r1, r5, #0
 8000966:	69ef      	ldr	r7, [r5, #28]
 8000968:	311c      	adds	r1, #28
 800096a:	428f      	cmp	r7, r1
 800096c:	d022      	beq.n	80009b4 <chVTDoSetI+0x84>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800096e:	18b0      	adds	r0, r6, r2
 8000970:	6aab      	ldr	r3, [r5, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8000972:	68ba      	ldr	r2, [r7, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8000974:	1ac6      	subs	r6, r0, r3
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8000976:	4296      	cmp	r6, r2
 8000978:	d32d      	bcc.n	80009d6 <chVTDoSetI+0xa6>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800097a:	69e8      	ldr	r0, [r5, #28]
  while (p->vt_delta < delta) {
 800097c:	6887      	ldr	r7, [r0, #8]
 800097e:	42be      	cmp	r6, r7
 8000980:	d904      	bls.n	800098c <chVTDoSetI+0x5c>
    delta -= p->vt_delta;
    p = p->vt_next;
 8000982:	6800      	ldr	r0, [r0, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8000984:	1bf6      	subs	r6, r6, r7
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000986:	6887      	ldr	r7, [r0, #8]
 8000988:	42b7      	cmp	r7, r6
 800098a:	d3fa      	bcc.n	8000982 <chVTDoSetI+0x52>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800098c:	6841      	ldr	r1, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
  p->vt_prev = vtp;
  vtp->vt_delta = delta
 800098e:	60a6      	str	r6, [r4, #8]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000990:	6020      	str	r0, [r4, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000992:	6061      	str	r1, [r4, #4]
  vtp->vt_prev->vt_next = vtp;
 8000994:	600c      	str	r4, [r1, #0]
  p->vt_prev = vtp;
 8000996:	6044      	str	r4, [r0, #4]
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000998:	6884      	ldr	r4, [r0, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800099a:	2201      	movs	r2, #1
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800099c:	1ba3      	subs	r3, r4, r6
  ch.vtlist.vt_delta = (systime_t)-1;
 800099e:	4256      	negs	r6, r2
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80009a0:	6083      	str	r3, [r0, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009a2:	626e      	str	r6, [r5, #36]	; 0x24
}
 80009a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80009a6:	4d10      	ldr	r5, [pc, #64]	; (80009e8 <chVTDoSetI+0xb8>)
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80009a8:	2602      	movs	r6, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80009aa:	1c29      	adds	r1, r5, #0
 80009ac:	69ef      	ldr	r7, [r5, #28]
 80009ae:	311c      	adds	r1, #28
 80009b0:	428f      	cmp	r7, r1
 80009b2:	d1dc      	bne.n	800096e <chVTDoSetI+0x3e>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80009b4:	2080      	movs	r0, #128	; 0x80

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 80009b6:	62aa      	str	r2, [r5, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 80009b8:	61ec      	str	r4, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 80009ba:	622c      	str	r4, [r5, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 80009bc:	6027      	str	r7, [r4, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80009be:	6067      	str	r7, [r4, #4]
      vtp->vt_delta = delay;
 80009c0:	60a6      	str	r6, [r4, #8]
 80009c2:	05c4      	lsls	r4, r0, #23
 80009c4:	68e3      	ldr	r3, [r4, #12]
 80009c6:	2102      	movs	r1, #2

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 80009c8:	18b7      	adds	r7, r6, r2
 80009ca:	400b      	ands	r3, r1
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80009cc:	d106      	bne.n	80009dc <chVTDoSetI+0xac>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80009ce:	6367      	str	r7, [r4, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80009d0:	6123      	str	r3, [r4, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80009d2:	60e1      	str	r1, [r4, #12]
 80009d4:	e7e6      	b.n	80009a4 <chVTDoSetI+0x74>
 80009d6:	f7ff ff4b 	bl	8000870 <stSetAlarm>
 80009da:	e7ce      	b.n	800097a <chVTDoSetI+0x4a>
 80009dc:	b672      	cpsid	i
 80009de:	4a03      	ldr	r2, [pc, #12]	; (80009ec <chVTDoSetI+0xbc>)
 80009e0:	62ea      	str	r2, [r5, #44]	; 0x2c
 80009e2:	e7fe      	b.n	80009e2 <chVTDoSetI+0xb2>
 80009e4:	08008460 	.word	0x08008460
 80009e8:	20001040 	.word	0x20001040
 80009ec:	08008450 	.word	0x08008450

080009f0 <_pal_lld_setgroupmode.constprop.18>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80009f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80009f2:	4656      	mov	r6, sl
 80009f4:	464d      	mov	r5, r9
 80009f6:	4644      	mov	r4, r8
 80009f8:	465f      	mov	r7, fp
 80009fa:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80009fc:	2307      	movs	r3, #7
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80009fe:	2102      	movs	r1, #2
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000a00:	250f      	movs	r5, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000a02:	2690      	movs	r6, #144	; 0x90
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000a04:	2703      	movs	r7, #3
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000a06:	4699      	mov	r9, r3
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8000a08:	b083      	sub	sp, #12
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000a0a:	2200      	movs	r2, #0
  while (true) {
    if ((mask & 1) != 0) {
 8000a0c:	2401      	movs	r4, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000a0e:	46a8      	mov	r8, r5
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000a10:	05f3      	lsls	r3, r6, #23
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000a12:	46bc      	mov	ip, r7
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000a14:	468a      	mov	sl, r1
 8000a16:	e008      	b.n	8000a2a <_pal_lld_setgroupmode.constprop.18+0x3a>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000a18:	6a1d      	ldr	r5, [r3, #32]
 8000a1a:	9e01      	ldr	r6, [sp, #4]
 8000a1c:	43bd      	bics	r5, r7
 8000a1e:	432e      	orrs	r6, r5
 8000a20:	621e      	str	r6, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 8000a22:	0840      	lsrs	r0, r0, #1
    if (!mask)
 8000a24:	d02c      	beq.n	8000a80 <_pal_lld_setgroupmode.constprop.18+0x90>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8000a26:	0089      	lsls	r1, r1, #2
    bit++;
 8000a28:	3201      	adds	r2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8000a2a:	4204      	tst	r4, r0
 8000a2c:	d0f9      	beq.n	8000a22 <_pal_lld_setgroupmode.constprop.18+0x32>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000a2e:	464d      	mov	r5, r9
 8000a30:	4015      	ands	r5, r2
 8000a32:	00ad      	lsls	r5, r5, #2
 8000a34:	1c26      	adds	r6, r4, #0
 8000a36:	40ae      	lsls	r6, r5
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000a38:	4647      	mov	r7, r8
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000a3a:	9601      	str	r6, [sp, #4]
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000a3c:	40af      	lsls	r7, r5
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000a3e:	685e      	ldr	r6, [r3, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8000a40:	1c25      	adds	r5, r4, #0
 8000a42:	4095      	lsls	r5, r2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000a44:	43ae      	bics	r6, r5
 8000a46:	605e      	str	r6, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000a48:	689e      	ldr	r6, [r3, #8]
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000a4a:	4665      	mov	r5, ip
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000a4c:	46b3      	mov	fp, r6
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8000a4e:	0056      	lsls	r6, r2, #1
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000a50:	40b5      	lsls	r5, r6
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000a52:	43ed      	mvns	r5, r5
 8000a54:	465e      	mov	r6, fp
 8000a56:	402e      	ands	r6, r5
 8000a58:	609e      	str	r6, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000a5a:	68de      	ldr	r6, [r3, #12]
 8000a5c:	402e      	ands	r6, r5
 8000a5e:	60de      	str	r6, [r3, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8000a60:	2902      	cmp	r1, #2
 8000a62:	d014      	beq.n	8000a8e <_pal_lld_setgroupmode.constprop.18+0x9e>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8000a64:	681e      	ldr	r6, [r3, #0]
 8000a66:	4035      	ands	r5, r6
 8000a68:	430d      	orrs	r5, r1
 8000a6a:	601d      	str	r5, [r3, #0]
        if (bit < 8)
 8000a6c:	2a07      	cmp	r2, #7
 8000a6e:	d9d3      	bls.n	8000a18 <_pal_lld_setgroupmode.constprop.18+0x28>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000a70:	6a5d      	ldr	r5, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 8000a72:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000a74:	43bd      	bics	r5, r7
 8000a76:	9f01      	ldr	r7, [sp, #4]
 8000a78:	432f      	orrs	r7, r5
 8000a7a:	625f      	str	r7, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8000a7c:	2800      	cmp	r0, #0
 8000a7e:	d1d2      	bne.n	8000a26 <_pal_lld_setgroupmode.constprop.18+0x36>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8000a80:	b003      	add	sp, #12
 8000a82:	bc3c      	pop	{r2, r3, r4, r5}
 8000a84:	4690      	mov	r8, r2
 8000a86:	4699      	mov	r9, r3
 8000a88:	46a2      	mov	sl, r4
 8000a8a:	46ab      	mov	fp, r5
 8000a8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8000a8e:	2a07      	cmp	r2, #7
 8000a90:	d80b      	bhi.n	8000aaa <_pal_lld_setgroupmode.constprop.18+0xba>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000a92:	6a1e      	ldr	r6, [r3, #32]
 8000a94:	43be      	bics	r6, r7
 8000a96:	1c37      	adds	r7, r6, #0
 8000a98:	9e01      	ldr	r6, [sp, #4]
 8000a9a:	433e      	orrs	r6, r7
 8000a9c:	621e      	str	r6, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000a9e:	681f      	ldr	r7, [r3, #0]
 8000aa0:	4656      	mov	r6, sl
 8000aa2:	403d      	ands	r5, r7
 8000aa4:	4335      	orrs	r5, r6
 8000aa6:	601d      	str	r5, [r3, #0]
 8000aa8:	e7bb      	b.n	8000a22 <_pal_lld_setgroupmode.constprop.18+0x32>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000aaa:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 8000aac:	43be      	bics	r6, r7
 8000aae:	1c37      	adds	r7, r6, #0
 8000ab0:	9e01      	ldr	r6, [sp, #4]
 8000ab2:	433e      	orrs	r6, r7
 8000ab4:	625e      	str	r6, [r3, #36]	; 0x24
 8000ab6:	e7f2      	b.n	8000a9e <_pal_lld_setgroupmode.constprop.18+0xae>
 8000ab8:	46c0      	nop			; (mov r8, r8)
 8000aba:	46c0      	nop			; (mov r8, r8)
 8000abc:	46c0      	nop			; (mov r8, r8)
 8000abe:	46c0      	nop			; (mov r8, r8)

08000ac0 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(point);
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
 8000ac0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ac2:	4a1f      	ldr	r2, [pc, #124]	; (8000b40 <_test_assert_sequence+0x80>)
 8000ac4:	4647      	mov	r7, r8
 8000ac6:	b480      	push	{r7}
 8000ac8:	4680      	mov	r8, r0
 8000aca:	6817      	ldr	r7, [r2, #0]
  char *cp = tokens_buffer;
 8000acc:	481d      	ldr	r0, [pc, #116]	; (8000b44 <_test_assert_sequence+0x84>)
 8000ace:	4694      	mov	ip, r2
 8000ad0:	1a3c      	subs	r4, r7, r0
 8000ad2:	1c03      	adds	r3, r0, #0
 8000ad4:	07e4      	lsls	r4, r4, #31
 8000ad6:	d514      	bpl.n	8000b02 <_test_assert_sequence+0x42>
  while (cp < tokp) {
 8000ad8:	42b8      	cmp	r0, r7
 8000ada:	d214      	bcs.n	8000b06 <_test_assert_sequence+0x46>
    if (*cp++ != *expected++)
 8000adc:	780e      	ldrb	r6, [r1, #0]
 8000ade:	7805      	ldrb	r5, [r0, #0]
 8000ae0:	1c43      	adds	r3, r0, #1
 8000ae2:	3101      	adds	r1, #1
 8000ae4:	42b5      	cmp	r5, r6
 8000ae6:	d00c      	beq.n	8000b02 <_test_assert_sequence+0x42>
 8000ae8:	e016      	b.n	8000b18 <_test_assert_sequence+0x58>
 8000aea:	781c      	ldrb	r4, [r3, #0]
 8000aec:	780a      	ldrb	r2, [r1, #0]
 8000aee:	1c5e      	adds	r6, r3, #1
 8000af0:	1c4d      	adds	r5, r1, #1
 8000af2:	4294      	cmp	r4, r2
 8000af4:	d110      	bne.n	8000b18 <_test_assert_sequence+0x58>
 8000af6:	785c      	ldrb	r4, [r3, #1]
 8000af8:	784a      	ldrb	r2, [r1, #1]
 8000afa:	1c73      	adds	r3, r6, #1
 8000afc:	1c69      	adds	r1, r5, #1
 8000afe:	4294      	cmp	r4, r2
 8000b00:	d10a      	bne.n	8000b18 <_test_assert_sequence+0x58>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 8000b02:	42bb      	cmp	r3, r7
 8000b04:	d3f1      	bcc.n	8000aea <_test_assert_sequence+0x2a>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8000b06:	7809      	ldrb	r1, [r1, #0]
 8000b08:	2900      	cmp	r1, #0
 8000b0a:	d10f      	bne.n	8000b2c <_test_assert_sequence+0x6c>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8000b0c:	4662      	mov	r2, ip
 8000b0e:	6010      	str	r0, [r2, #0]
     return _test_fail(point);
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
 8000b10:	2000      	movs	r0, #0
}
 8000b12:	bc04      	pop	{r2}
 8000b14:	4690      	mov	r8, r2
 8000b16:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8000b18:	480b      	ldr	r0, [pc, #44]	; (8000b48 <_test_assert_sequence+0x88>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b1a:	4f0c      	ldr	r7, [pc, #48]	; (8000b4c <_test_assert_sequence+0x8c>)
  local_fail = TRUE;
  failpoint = point;
 8000b1c:	4e0c      	ldr	r6, [pc, #48]	; (8000b50 <_test_assert_sequence+0x90>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b1e:	2101      	movs	r1, #1
  local_fail = TRUE;
  failpoint = point;
 8000b20:	4645      	mov	r5, r8
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8000b22:	7001      	strb	r1, [r0, #0]
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b24:	7039      	strb	r1, [r7, #0]
  local_fail = TRUE;
  failpoint = point;
 8000b26:	6035      	str	r5, [r6, #0]

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
    if (*cp++ != *expected++)
     return _test_fail(point);
 8000b28:	2001      	movs	r0, #1
 8000b2a:	e7f2      	b.n	8000b12 <_test_assert_sequence+0x52>
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8000b2c:	4806      	ldr	r0, [pc, #24]	; (8000b48 <_test_assert_sequence+0x88>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b2e:	4f07      	ldr	r7, [pc, #28]	; (8000b4c <_test_assert_sequence+0x8c>)
  local_fail = TRUE;
  failpoint = point;
 8000b30:	4d07      	ldr	r5, [pc, #28]	; (8000b50 <_test_assert_sequence+0x90>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b32:	2301      	movs	r3, #1
  local_fail = TRUE;
  failpoint = point;
 8000b34:	4644      	mov	r4, r8
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8000b36:	7003      	strb	r3, [r0, #0]
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b38:	703b      	strb	r3, [r7, #0]
  local_fail = TRUE;
  failpoint = point;
 8000b3a:	602c      	str	r4, [r5, #0]
  while (cp < tokp) {
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
    return _test_fail(point);
 8000b3c:	2001      	movs	r0, #1
 8000b3e:	e7e8      	b.n	8000b12 <_test_assert_sequence+0x52>
 8000b40:	20000fb8 	.word	0x20000fb8
 8000b44:	200015a8 	.word	0x200015a8
 8000b48:	20000f80 	.word	0x20000f80
 8000b4c:	20000fb0 	.word	0x20000fb0
 8000b50:	20000fb4 	.word	0x20000fb4
 8000b54:	46c0      	nop			; (mov r8, r8)
 8000b56:	46c0      	nop			; (mov r8, r8)
 8000b58:	46c0      	nop			; (mov r8, r8)
 8000b5a:	46c0      	nop			; (mov r8, r8)
 8000b5c:	46c0      	nop			; (mov r8, r8)
 8000b5e:	46c0      	nop			; (mov r8, r8)

08000b60 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8000b60:	2200      	movs	r2, #0
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8000b62:	2900      	cmp	r1, #0
 8000b64:	d107      	bne.n	8000b76 <_test_assert+0x16>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b66:	4a05      	ldr	r2, [pc, #20]	; (8000b7c <_test_assert+0x1c>)
  local_fail = TRUE;
 8000b68:	4905      	ldr	r1, [pc, #20]	; (8000b80 <_test_assert+0x20>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b6a:	2301      	movs	r3, #1
 8000b6c:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 8000b6e:	700b      	strb	r3, [r1, #0]
  failpoint = point;
 8000b70:	4b04      	ldr	r3, [pc, #16]	; (8000b84 <_test_assert+0x24>)
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
 8000b72:	2201      	movs	r2, #1
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
  failpoint = point;
 8000b74:	6018      	str	r0, [r3, #0]
bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
}
 8000b76:	1c10      	adds	r0, r2, #0
 8000b78:	4770      	bx	lr
 8000b7a:	46c0      	nop			; (mov r8, r8)
 8000b7c:	20000fb0 	.word	0x20000fb0
 8000b80:	20000f80 	.word	0x20000f80
 8000b84:	20000fb4 	.word	0x20000fb4
 8000b88:	46c0      	nop			; (mov r8, r8)
 8000b8a:	46c0      	nop			; (mov r8, r8)
 8000b8c:	46c0      	nop			; (mov r8, r8)
 8000b8e:	46c0      	nop			; (mov r8, r8)

08000b90 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000b90:	b538      	push	{r3, r4, r5, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000b92:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000b94:	1c04      	adds	r4, r0, #0
 8000b96:	4d09      	ldr	r5, [pc, #36]	; (8000bbc <test_println+0x2c>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000b98:	2900      	cmp	r1, #0
 8000b9a:	d007      	beq.n	8000bac <test_println+0x1c>
    chSequentialStreamPut(chp, *msgp++);
 8000b9c:	6828      	ldr	r0, [r5, #0]
 8000b9e:	3401      	adds	r4, #1
 8000ba0:	6803      	ldr	r3, [r0, #0]
 8000ba2:	689a      	ldr	r2, [r3, #8]
 8000ba4:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000ba6:	7821      	ldrb	r1, [r4, #0]
 8000ba8:	2900      	cmp	r1, #0
 8000baa:	d1f7      	bne.n	8000b9c <test_println+0xc>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8000bac:	6828      	ldr	r0, [r5, #0]
 8000bae:	2202      	movs	r2, #2
 8000bb0:	6801      	ldr	r1, [r0, #0]
 8000bb2:	680c      	ldr	r4, [r1, #0]
 8000bb4:	4902      	ldr	r1, [pc, #8]	; (8000bc0 <test_println+0x30>)
 8000bb6:	47a0      	blx	r4
}
 8000bb8:	bd38      	pop	{r3, r4, r5, pc}
 8000bba:	46c0      	nop			; (mov r8, r8)
 8000bbc:	20000fbc 	.word	0x20000fbc
 8000bc0:	080084b0 	.word	0x080084b0
 8000bc4:	46c0      	nop			; (mov r8, r8)
 8000bc6:	46c0      	nop			; (mov r8, r8)
 8000bc8:	46c0      	nop			; (mov r8, r8)
 8000bca:	46c0      	nop			; (mov r8, r8)
 8000bcc:	46c0      	nop			; (mov r8, r8)
 8000bce:	46c0      	nop			; (mov r8, r8)

08000bd0 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8000bd0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 8000bd2:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8000bd4:	1c04      	adds	r4, r0, #0

  while (*msgp)
 8000bd6:	2900      	cmp	r1, #0
 8000bd8:	d008      	beq.n	8000bec <test_print+0x1c>
 8000bda:	4d05      	ldr	r5, [pc, #20]	; (8000bf0 <test_print+0x20>)
    chSequentialStreamPut(chp, *msgp++);
 8000bdc:	6828      	ldr	r0, [r5, #0]
 8000bde:	3401      	adds	r4, #1
 8000be0:	6803      	ldr	r3, [r0, #0]
 8000be2:	689a      	ldr	r2, [r3, #8]
 8000be4:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000be6:	7821      	ldrb	r1, [r4, #0]
 8000be8:	2900      	cmp	r1, #0
 8000bea:	d1f7      	bne.n	8000bdc <test_print+0xc>
    chSequentialStreamPut(chp, *msgp++);
}
 8000bec:	bd38      	pop	{r3, r4, r5, pc}
 8000bee:	46c0      	nop			; (mov r8, r8)
 8000bf0:	20000fbc 	.word	0x20000fbc
 8000bf4:	46c0      	nop			; (mov r8, r8)
 8000bf6:	46c0      	nop			; (mov r8, r8)
 8000bf8:	46c0      	nop			; (mov r8, r8)
 8000bfa:	46c0      	nop			; (mov r8, r8)
 8000bfc:	46c0      	nop			; (mov r8, r8)
 8000bfe:	46c0      	nop			; (mov r8, r8)

08000c00 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8000c00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000c02:	4647      	mov	r7, r8
 8000c04:	b480      	push	{r7}
 8000c06:	1c04      	adds	r4, r0, #0
 8000c08:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8000c0a:	2800      	cmp	r0, #0
 8000c0c:	d03b      	beq.n	8000c86 <test_printn+0x86>
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
 8000c0e:	466f      	mov	r7, sp
 8000c10:	466d      	mov	r5, sp
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8000c12:	1c20      	adds	r0, r4, #0
 8000c14:	210a      	movs	r1, #10
 8000c16:	f7ff fb47 	bl	80002a8 <__aeabi_uidivmod>
 8000c1a:	1c0e      	adds	r6, r1, #0
 8000c1c:	3630      	adds	r6, #48	; 0x30
 8000c1e:	b2f6      	uxtb	r6, r6
 8000c20:	702e      	strb	r6, [r5, #0]
 8000c22:	1c20      	adds	r0, r4, #0
 8000c24:	210a      	movs	r1, #10
 8000c26:	f7ff fafb 	bl	8000220 <__aeabi_uidiv>
 8000c2a:	3501      	adds	r5, #1
 8000c2c:	1e04      	subs	r4, r0, #0

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 8000c2e:	d1f0      	bne.n	8000c12 <test_printn+0x12>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000c30:	42bd      	cmp	r5, r7
 8000c32:	d924      	bls.n	8000c7e <test_printn+0x7e>
 8000c34:	2301      	movs	r3, #1
 8000c36:	4258      	negs	r0, r3
 8000c38:	4468      	add	r0, sp
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8000c3a:	1eac      	subs	r4, r5, #2
 8000c3c:	4f15      	ldr	r7, [pc, #84]	; (8000c94 <test_printn+0x94>)
 8000c3e:	4680      	mov	r8, r0
 8000c40:	07e3      	lsls	r3, r4, #31
 8000c42:	d415      	bmi.n	8000c70 <test_printn+0x70>
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      chSequentialStreamPut(chp, *--p);
 8000c44:	6838      	ldr	r0, [r7, #0]
 8000c46:	6801      	ldr	r1, [r0, #0]
 8000c48:	688a      	ldr	r2, [r1, #8]
 8000c4a:	1c31      	adds	r1, r6, #0
 8000c4c:	4790      	blx	r2
 8000c4e:	6838      	ldr	r0, [r7, #0]
 8000c50:	7826      	ldrb	r6, [r4, #0]
 8000c52:	1eec      	subs	r4, r5, #3
 8000c54:	6805      	ldr	r5, [r0, #0]
 8000c56:	1c31      	adds	r1, r6, #0
 8000c58:	68ab      	ldr	r3, [r5, #8]
 8000c5a:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000c5c:	4544      	cmp	r4, r8
 8000c5e:	d00e      	beq.n	8000c7e <test_printn+0x7e>
      chSequentialStreamPut(chp, *--p);
 8000c60:	6838      	ldr	r0, [r7, #0]
 8000c62:	7821      	ldrb	r1, [r4, #0]
 8000c64:	6802      	ldr	r2, [r0, #0]
 8000c66:	1e66      	subs	r6, r4, #1
 8000c68:	6895      	ldr	r5, [r2, #8]
 8000c6a:	47a8      	blx	r5
 8000c6c:	7836      	ldrb	r6, [r6, #0]
 8000c6e:	3c02      	subs	r4, #2
 8000c70:	6838      	ldr	r0, [r7, #0]
 8000c72:	1c31      	adds	r1, r6, #0
 8000c74:	6805      	ldr	r5, [r0, #0]
 8000c76:	68ab      	ldr	r3, [r5, #8]
 8000c78:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000c7a:	4544      	cmp	r4, r8
 8000c7c:	d1f0      	bne.n	8000c60 <test_printn+0x60>
      chSequentialStreamPut(chp, *--p);
  }
}
 8000c7e:	b004      	add	sp, #16
 8000c80:	bc04      	pop	{r2}
 8000c82:	4690      	mov	r8, r2
 8000c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 8000c86:	4f03      	ldr	r7, [pc, #12]	; (8000c94 <test_printn+0x94>)
 8000c88:	6838      	ldr	r0, [r7, #0]
 8000c8a:	6801      	ldr	r1, [r0, #0]
 8000c8c:	688c      	ldr	r4, [r1, #8]
 8000c8e:	2130      	movs	r1, #48	; 0x30
 8000c90:	47a0      	blx	r4
 8000c92:	e7f4      	b.n	8000c7e <test_printn+0x7e>
 8000c94:	20000fbc 	.word	0x20000fbc
 8000c98:	46c0      	nop			; (mov r8, r8)
 8000c9a:	46c0      	nop			; (mov r8, r8)
 8000c9c:	46c0      	nop			; (mov r8, r8)
 8000c9e:	46c0      	nop			; (mov r8, r8)

08000ca0 <bmk13_execute.10796>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8000ca0:	b510      	push	{r4, lr}

  test_print("--- System: ");
 8000ca2:	482e      	ldr	r0, [pc, #184]	; (8000d5c <bmk13_execute.10796+0xbc>)
 8000ca4:	f7ff ff94 	bl	8000bd0 <test_print>
  test_printn(sizeof(ch_system_t));
 8000ca8:	20ad      	movs	r0, #173	; 0xad
 8000caa:	00c0      	lsls	r0, r0, #3
 8000cac:	f7ff ffa8 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000cb0:	4c2b      	ldr	r4, [pc, #172]	; (8000d60 <bmk13_execute.10796+0xc0>)
 8000cb2:	1c20      	adds	r0, r4, #0
 8000cb4:	f7ff ff6c 	bl	8000b90 <test_println>
  test_print("--- Thread: ");
 8000cb8:	482a      	ldr	r0, [pc, #168]	; (8000d64 <bmk13_execute.10796+0xc4>)
 8000cba:	f7ff ff89 	bl	8000bd0 <test_print>
  test_printn(sizeof(thread_t));
 8000cbe:	2048      	movs	r0, #72	; 0x48
 8000cc0:	f7ff ff9e 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000cc4:	1c20      	adds	r0, r4, #0
 8000cc6:	f7ff ff63 	bl	8000b90 <test_println>
  test_print("--- Timer : ");
 8000cca:	4827      	ldr	r0, [pc, #156]	; (8000d68 <bmk13_execute.10796+0xc8>)
 8000ccc:	f7ff ff80 	bl	8000bd0 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8000cd0:	2014      	movs	r0, #20
 8000cd2:	f7ff ff95 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000cd6:	1c20      	adds	r0, r4, #0
 8000cd8:	f7ff ff5a 	bl	8000b90 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 8000cdc:	4823      	ldr	r0, [pc, #140]	; (8000d6c <bmk13_execute.10796+0xcc>)
 8000cde:	f7ff ff77 	bl	8000bd0 <test_print>
  test_printn(sizeof(semaphore_t));
 8000ce2:	200c      	movs	r0, #12
 8000ce4:	f7ff ff8c 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000ce8:	1c20      	adds	r0, r4, #0
 8000cea:	f7ff ff51 	bl	8000b90 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 8000cee:	4820      	ldr	r0, [pc, #128]	; (8000d70 <bmk13_execute.10796+0xd0>)
 8000cf0:	f7ff ff6e 	bl	8000bd0 <test_print>
  test_printn(sizeof(event_source_t));
 8000cf4:	2004      	movs	r0, #4
 8000cf6:	f7ff ff83 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000cfa:	1c20      	adds	r0, r4, #0
 8000cfc:	f7ff ff48 	bl	8000b90 <test_println>
  test_print("--- EventL: ");
 8000d00:	481c      	ldr	r0, [pc, #112]	; (8000d74 <bmk13_execute.10796+0xd4>)
 8000d02:	f7ff ff65 	bl	8000bd0 <test_print>
  test_printn(sizeof(event_listener_t));
 8000d06:	2014      	movs	r0, #20
 8000d08:	f7ff ff7a 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000d0c:	1c20      	adds	r0, r4, #0
 8000d0e:	f7ff ff3f 	bl	8000b90 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8000d12:	4819      	ldr	r0, [pc, #100]	; (8000d78 <bmk13_execute.10796+0xd8>)
 8000d14:	f7ff ff5c 	bl	8000bd0 <test_print>
  test_printn(sizeof(mutex_t));
 8000d18:	2010      	movs	r0, #16
 8000d1a:	f7ff ff71 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000d1e:	1c20      	adds	r0, r4, #0
 8000d20:	f7ff ff36 	bl	8000b90 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8000d24:	4815      	ldr	r0, [pc, #84]	; (8000d7c <bmk13_execute.10796+0xdc>)
 8000d26:	f7ff ff53 	bl	8000bd0 <test_print>
  test_printn(sizeof(condition_variable_t));
 8000d2a:	2008      	movs	r0, #8
 8000d2c:	f7ff ff68 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000d30:	1c20      	adds	r0, r4, #0
 8000d32:	f7ff ff2d 	bl	8000b90 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8000d36:	4812      	ldr	r0, [pc, #72]	; (8000d80 <bmk13_execute.10796+0xe0>)
 8000d38:	f7ff ff4a 	bl	8000bd0 <test_print>
  test_printn(sizeof(io_queue_t));
 8000d3c:	2024      	movs	r0, #36	; 0x24
 8000d3e:	f7ff ff5f 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000d42:	1c20      	adds	r0, r4, #0
 8000d44:	f7ff ff24 	bl	8000b90 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8000d48:	480e      	ldr	r0, [pc, #56]	; (8000d84 <bmk13_execute.10796+0xe4>)
 8000d4a:	f7ff ff41 	bl	8000bd0 <test_print>
  test_printn(sizeof(mailbox_t));
 8000d4e:	2028      	movs	r0, #40	; 0x28
 8000d50:	f7ff ff56 	bl	8000c00 <test_printn>
  test_println(" bytes");
 8000d54:	1c20      	adds	r0, r4, #0
 8000d56:	f7ff ff1b 	bl	8000b90 <test_println>
#endif
}
 8000d5a:	bd10      	pop	{r4, pc}
 8000d5c:	080084b4 	.word	0x080084b4
 8000d60:	080084c4 	.word	0x080084c4
 8000d64:	080084cc 	.word	0x080084cc
 8000d68:	080084dc 	.word	0x080084dc
 8000d6c:	080084ec 	.word	0x080084ec
 8000d70:	080084fc 	.word	0x080084fc
 8000d74:	0800850c 	.word	0x0800850c
 8000d78:	0800851c 	.word	0x0800851c
 8000d7c:	0800852c 	.word	0x0800852c
 8000d80:	0800853c 	.word	0x0800853c
 8000d84:	0800854c 	.word	0x0800854c
 8000d88:	46c0      	nop			; (mov r8, r8)
 8000d8a:	46c0      	nop			; (mov r8, r8)
 8000d8c:	46c0      	nop			; (mov r8, r8)
 8000d8e:	46c0      	nop			; (mov r8, r8)

08000d90 <print_line.8460>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 8000d90:	b538      	push	{r3, r4, r5, lr}
 8000d92:	4d0b      	ldr	r5, [pc, #44]	; (8000dc0 <print_line.8460+0x30>)
 8000d94:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 8000d96:	6828      	ldr	r0, [r5, #0]
 8000d98:	212d      	movs	r1, #45	; 0x2d
 8000d9a:	6803      	ldr	r3, [r0, #0]
 8000d9c:	3c02      	subs	r4, #2
 8000d9e:	689a      	ldr	r2, [r3, #8]
 8000da0:	4790      	blx	r2
 8000da2:	6828      	ldr	r0, [r5, #0]
 8000da4:	6801      	ldr	r1, [r0, #0]
 8000da6:	688b      	ldr	r3, [r1, #8]
 8000da8:	212d      	movs	r1, #45	; 0x2d
 8000daa:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8000dac:	2c00      	cmp	r4, #0
 8000dae:	d1f2      	bne.n	8000d96 <print_line.8460+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8000db0:	6828      	ldr	r0, [r5, #0]
 8000db2:	4904      	ldr	r1, [pc, #16]	; (8000dc4 <print_line.8460+0x34>)
 8000db4:	6804      	ldr	r4, [r0, #0]
 8000db6:	2202      	movs	r2, #2
 8000db8:	6825      	ldr	r5, [r4, #0]
 8000dba:	47a8      	blx	r5
}
 8000dbc:	bd38      	pop	{r3, r4, r5, pc}
 8000dbe:	46c0      	nop			; (mov r8, r8)
 8000dc0:	20000fbc 	.word	0x20000fbc
 8000dc4:	080084b0 	.word	0x080084b0
 8000dc8:	46c0      	nop			; (mov r8, r8)
 8000dca:	46c0      	nop			; (mov r8, r8)
 8000dcc:	46c0      	nop			; (mov r8, r8)
 8000dce:	46c0      	nop			; (mov r8, r8)

08000dd0 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000dd0:	300f      	adds	r0, #15
 8000dd2:	d011      	beq.n	8000df8 <_port_irq_epilogue+0x28>
 8000dd4:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000dd6:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000dda:	3b20      	subs	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000ddc:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000de0:	2280      	movs	r2, #128	; 0x80
 8000de2:	0450      	lsls	r0, r2, #17
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000de4:	4a06      	ldr	r2, [pc, #24]	; (8000e00 <_port_irq_epilogue+0x30>)
 8000de6:	61d8      	str	r0, [r3, #28]
 8000de8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 8000dea:	6990      	ldr	r0, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000dec:	6889      	ldr	r1, [r1, #8]
 8000dee:	6882      	ldr	r2, [r0, #8]
 8000df0:	4291      	cmp	r1, r2
 8000df2:	d802      	bhi.n	8000dfa <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000df4:	4803      	ldr	r0, [pc, #12]	; (8000e04 <_port_irq_epilogue+0x34>)
 8000df6:	6198      	str	r0, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000df8:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000dfa:	4903      	ldr	r1, [pc, #12]	; (8000e08 <_port_irq_epilogue+0x38>)
 8000dfc:	6199      	str	r1, [r3, #24]
 8000dfe:	e7fb      	b.n	8000df8 <_port_irq_epilogue+0x28>
 8000e00:	20001040 	.word	0x20001040
 8000e04:	0800020c 	.word	0x0800020c
 8000e08:	08000201 	.word	0x08000201
 8000e0c:	46c0      	nop			; (mov r8, r8)
 8000e0e:	46c0      	nop			; (mov r8, r8)

08000e10 <_dbg_trace>:
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8000e10:	4a0b      	ldr	r2, [pc, #44]	; (8000e40 <_dbg_trace+0x30>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000e12:	2180      	movs	r1, #128	; 0x80
 8000e14:	05c9      	lsls	r1, r1, #23
 8000e16:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000e18:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8000e1a:	6019      	str	r1, [r3, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 8000e1c:	6991      	ldr	r1, [r2, #24]
 8000e1e:	6059      	str	r1, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8000e20:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000e22:	6099      	str	r1, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000e24:	2120      	movs	r1, #32
 8000e26:	5c40      	ldrb	r0, [r0, r1]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8000e28:	2188      	movs	r1, #136	; 0x88
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8000e2a:	7318      	strb	r0, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8000e2c:	00c8      	lsls	r0, r1, #3
 8000e2e:	3310      	adds	r3, #16
 8000e30:	1811      	adds	r1, r2, r0
 8000e32:	428b      	cmp	r3, r1
 8000e34:	d301      	bcc.n	8000e3a <_dbg_trace+0x2a>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8000e36:	1c13      	adds	r3, r2, #0
 8000e38:	3340      	adds	r3, #64	; 0x40
 8000e3a:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8000e3c:	4770      	bx	lr
 8000e3e:	46c0      	nop			; (mov r8, r8)
 8000e40:	20001040 	.word	0x20001040
 8000e44:	46c0      	nop			; (mov r8, r8)
 8000e46:	46c0      	nop			; (mov r8, r8)
 8000e48:	46c0      	nop			; (mov r8, r8)
 8000e4a:	46c0      	nop			; (mov r8, r8)
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000e50:	b570      	push	{r4, r5, r6, lr}
 8000e52:	1c05      	adds	r5, r0, #0
 8000e54:	1c0e      	adds	r6, r1, #0

  chDbgCheckClassS();
 8000e56:	f7ff fcfb 	bl	8000850 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000e5a:	4c17      	ldr	r4, [pc, #92]	; (8000eb8 <chSchWakeupS+0x68>)
 8000e5c:	69a0      	ldr	r0, [r4, #24]
 8000e5e:	6822      	ldr	r2, [r4, #0]
 8000e60:	6883      	ldr	r3, [r0, #8]
 8000e62:	42a2      	cmp	r2, r4
 8000e64:	d002      	beq.n	8000e6c <chSchWakeupS+0x1c>
 8000e66:	6891      	ldr	r1, [r2, #8]
 8000e68:	428b      	cmp	r3, r1
 8000e6a:	d320      	bcc.n	8000eae <chSchWakeupS+0x5e>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000e6c:	626e      	str	r6, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000e6e:	68ae      	ldr	r6, [r5, #8]
 8000e70:	429e      	cmp	r6, r3
 8000e72:	d918      	bls.n	8000ea6 <chSchWakeupS+0x56>
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000e74:	f7ff fc5c 	bl	8000730 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000e78:	2220      	movs	r2, #32
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000e7a:	1c06      	adds	r6, r0, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000e7c:	2001      	movs	r0, #1
 8000e7e:	54a8      	strb	r0, [r5, r2]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8000e80:	61a5      	str	r5, [r4, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8000e82:	1c30      	adds	r0, r6, #0
 8000e84:	f7ff ffc4 	bl	8000e10 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e88:	f3ef 8309 	mrs	r3, PSP
 8000e8c:	69f1      	ldr	r1, [r6, #28]
 8000e8e:	3b24      	subs	r3, #36	; 0x24
 8000e90:	4299      	cmp	r1, r3
 8000e92:	d804      	bhi.n	8000e9e <chSchWakeupS+0x4e>
 8000e94:	1c28      	adds	r0, r5, #0
 8000e96:	1c31      	adds	r1, r6, #0
 8000e98:	f7ff f99a 	bl	80001d0 <_port_switch>
  }
}
 8000e9c:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e9e:	b672      	cpsid	i
 8000ea0:	4d06      	ldr	r5, [pc, #24]	; (8000ebc <chSchWakeupS+0x6c>)
 8000ea2:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000ea4:	e7fe      	b.n	8000ea4 <chSchWakeupS+0x54>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
 8000ea6:	1c28      	adds	r0, r5, #0
 8000ea8:	f7ff fc42 	bl	8000730 <chSchReadyI>
 8000eac:	e7f6      	b.n	8000e9c <chSchWakeupS+0x4c>
 8000eae:	b672      	cpsid	i
 8000eb0:	4e03      	ldr	r6, [pc, #12]	; (8000ec0 <chSchWakeupS+0x70>)
 8000eb2:	62e6      	str	r6, [r4, #44]	; 0x2c
 8000eb4:	e7fe      	b.n	8000eb4 <chSchWakeupS+0x64>
 8000eb6:	46c0      	nop			; (mov r8, r8)
 8000eb8:	20001040 	.word	0x20001040
 8000ebc:	0800855c 	.word	0x0800855c
 8000ec0:	080085b0 	.word	0x080085b0
 8000ec4:	46c0      	nop			; (mov r8, r8)
 8000ec6:	46c0      	nop			; (mov r8, r8)
 8000ec8:	46c0      	nop			; (mov r8, r8)
 8000eca:	46c0      	nop			; (mov r8, r8)
 8000ecc:	46c0      	nop			; (mov r8, r8)
 8000ece:	46c0      	nop			; (mov r8, r8)

08000ed0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000ed0:	b570      	push	{r4, r5, r6, lr}
 8000ed2:	1c06      	adds	r6, r0, #0
  thread_t *otp;

  chDbgCheckClassS();
 8000ed4:	f7ff fcbc 	bl	8000850 <chDbgCheckClassS>

  otp = currp;
 8000ed8:	4c0e      	ldr	r4, [pc, #56]	; (8000f14 <chSchGoSleepS+0x44>)
  otp->p_state = newstate;
 8000eda:	2220      	movs	r2, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000edc:	6823      	ldr	r3, [r4, #0]
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000ede:	69a5      	ldr	r5, [r4, #24]

  tqp->p_next = tp->p_next;
 8000ee0:	6819      	ldr	r1, [r3, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000ee2:	2001      	movs	r0, #1
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 8000ee4:	54ae      	strb	r6, [r5, r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ee6:	604c      	str	r4, [r1, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000ee8:	5498      	strb	r0, [r3, r2]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000eea:	6021      	str	r1, [r4, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000eec:	61a3      	str	r3, [r4, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000eee:	1c28      	adds	r0, r5, #0
 8000ef0:	f7ff ff8e 	bl	8000e10 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000ef4:	f3ef 8609 	mrs	r6, PSP
 8000ef8:	69ea      	ldr	r2, [r5, #28]
 8000efa:	3e24      	subs	r6, #36	; 0x24
 8000efc:	42b2      	cmp	r2, r6
 8000efe:	d804      	bhi.n	8000f0a <chSchGoSleepS+0x3a>
 8000f00:	1c29      	adds	r1, r5, #0
 8000f02:	69a0      	ldr	r0, [r4, #24]
 8000f04:	f7ff f964 	bl	80001d0 <_port_switch>
}
 8000f08:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f0a:	b672      	cpsid	i
 8000f0c:	4d02      	ldr	r5, [pc, #8]	; (8000f18 <chSchGoSleepS+0x48>)
 8000f0e:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000f10:	e7fe      	b.n	8000f10 <chSchGoSleepS+0x40>
 8000f12:	46c0      	nop			; (mov r8, r8)
 8000f14:	20001040 	.word	0x20001040
 8000f18:	0800855c 	.word	0x0800855c
 8000f1c:	46c0      	nop			; (mov r8, r8)
 8000f1e:	46c0      	nop			; (mov r8, r8)

08000f20 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000f20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f22:	4647      	mov	r7, r8
  thread_t *ctp = currp;
 8000f24:	4e40      	ldr	r6, [pc, #256]	; (8001028 <chMtxLockS+0x108>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000f26:	b480      	push	{r7}
 8000f28:	1c05      	adds	r5, r0, #0
  thread_t *ctp = currp;
 8000f2a:	69b4      	ldr	r4, [r6, #24]

  chDbgCheckClassS();
 8000f2c:	f7ff fc90 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8000f30:	2d00      	cmp	r5, #0
 8000f32:	d036      	beq.n	8000fa2 <chMtxLockS+0x82>

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000f34:	68ab      	ldr	r3, [r5, #8]
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	d03e      	beq.n	8000fb8 <chMtxLockS+0x98>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000f3a:	68a1      	ldr	r1, [r4, #8]
 8000f3c:	689a      	ldr	r2, [r3, #8]
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000f3e:	2020      	movs	r0, #32
 8000f40:	4684      	mov	ip, r0
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000f42:	428a      	cmp	r2, r1
 8000f44:	d213      	bcs.n	8000f6e <chMtxLockS+0x4e>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8000f46:	6099      	str	r1, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000f48:	4667      	mov	r7, ip
 8000f4a:	5dd8      	ldrb	r0, [r3, r7]
 8000f4c:	2806      	cmp	r0, #6
 8000f4e:	d04e      	beq.n	8000fee <chMtxLockS+0xce>
 8000f50:	2807      	cmp	r0, #7
 8000f52:	d038      	beq.n	8000fc6 <chMtxLockS+0xa6>
 8000f54:	2800      	cmp	r0, #0
 8000f56:	d10a      	bne.n	8000f6e <chMtxLockS+0x4e>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000f58:	685f      	ldr	r7, [r3, #4]
 8000f5a:	6818      	ldr	r0, [r3, #0]
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
 8000f5c:	2101      	movs	r1, #1
 8000f5e:	6038      	str	r0, [r7, #0]
 8000f60:	2220      	movs	r2, #32
 8000f62:	5499      	strb	r1, [r3, r2]
  tp->p_next->p_prev = tp->p_prev;
 8000f64:	6819      	ldr	r1, [r3, #0]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000f66:	1c18      	adds	r0, r3, #0
 8000f68:	604f      	str	r7, [r1, #4]
 8000f6a:	f7ff fbe1 	bl	8000730 <chSchReadyI>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8000f6e:	1c29      	adds	r1, r5, #0
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000f70:	1c2b      	adds	r3, r5, #0
  do {
    cp = cp->p_next;
 8000f72:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000f74:	429d      	cmp	r5, r3
 8000f76:	d004      	beq.n	8000f82 <chMtxLockS+0x62>
 8000f78:	689f      	ldr	r7, [r3, #8]
 8000f7a:	68a0      	ldr	r0, [r4, #8]
 8000f7c:	4287      	cmp	r7, r0
 8000f7e:	d2f8      	bcs.n	8000f72 <chMtxLockS+0x52>
 8000f80:	1c19      	adds	r1, r3, #0
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000f82:	684a      	ldr	r2, [r1, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000f84:	6021      	str	r1, [r4, #0]
  tp->p_prev = cp->p_prev;
 8000f86:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 8000f88:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8000f8a:	604c      	str	r4, [r1, #4]
      ctp->p_u.wtmtxp = mp;
 8000f8c:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8000f8e:	2006      	movs	r0, #6
 8000f90:	f7ff ff9e 	bl	8000ed0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
 8000f94:	68ab      	ldr	r3, [r5, #8]
 8000f96:	42a3      	cmp	r3, r4
 8000f98:	d007      	beq.n	8000faa <chMtxLockS+0x8a>
 8000f9a:	b672      	cpsid	i
 8000f9c:	4f23      	ldr	r7, [pc, #140]	; (800102c <chMtxLockS+0x10c>)
 8000f9e:	62f7      	str	r7, [r6, #44]	; 0x2c
 8000fa0:	e7fe      	b.n	8000fa0 <chMtxLockS+0x80>
 8000fa2:	b672      	cpsid	i
 8000fa4:	4821      	ldr	r0, [pc, #132]	; (800102c <chMtxLockS+0x10c>)
 8000fa6:	62f0      	str	r0, [r6, #44]	; 0x2c
 8000fa8:	e7fe      	b.n	8000fa8 <chMtxLockS+0x88>
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
 8000faa:	6be4      	ldr	r4, [r4, #60]	; 0x3c
 8000fac:	42ac      	cmp	r4, r5
 8000fae:	d007      	beq.n	8000fc0 <chMtxLockS+0xa0>
 8000fb0:	b672      	cpsid	i
 8000fb2:	4d1e      	ldr	r5, [pc, #120]	; (800102c <chMtxLockS+0x10c>)
 8000fb4:	62f5      	str	r5, [r6, #44]	; 0x2c
 8000fb6:	e7fe      	b.n	8000fb6 <chMtxLockS+0x96>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8000fb8:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8000fba:	60ac      	str	r4, [r5, #8]
    mp->m_next = ctp->p_mtxlist;
 8000fbc:	60e9      	str	r1, [r5, #12]
    ctp->p_mtxlist = mp;
 8000fbe:	63e5      	str	r5, [r4, #60]	; 0x3c
  }
}
 8000fc0:	bc04      	pop	{r2}
 8000fc2:	4690      	mov	r8, r2
 8000fc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000fc6:	685a      	ldr	r2, [r3, #4]
 8000fc8:	681f      	ldr	r7, [r3, #0]
 8000fca:	6017      	str	r7, [r2, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000fcc:	6818      	ldr	r0, [r3, #0]
 8000fce:	6042      	str	r2, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000fd0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000fd2:	1c10      	adds	r0, r2, #0
  do {
    cp = cp->p_next;
 8000fd4:	6800      	ldr	r0, [r0, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000fd6:	4282      	cmp	r2, r0
 8000fd8:	d003      	beq.n	8000fe2 <chMtxLockS+0xc2>
 8000fda:	6887      	ldr	r7, [r0, #8]
 8000fdc:	428f      	cmp	r7, r1
 8000fde:	d2f9      	bcs.n	8000fd4 <chMtxLockS+0xb4>
 8000fe0:	1c02      	adds	r2, r0, #0
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000fe2:	6851      	ldr	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000fe4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8000fe6:	6059      	str	r1, [r3, #4]
  tp->p_prev->p_next = tp;
 8000fe8:	600b      	str	r3, [r1, #0]
  cp->p_prev = tp;
 8000fea:	6053      	str	r3, [r2, #4]
 8000fec:	e7bf      	b.n	8000f6e <chMtxLockS+0x4e>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000fee:	685f      	ldr	r7, [r3, #4]
 8000ff0:	6818      	ldr	r0, [r3, #0]
 8000ff2:	6038      	str	r0, [r7, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000ff4:	681a      	ldr	r2, [r3, #0]
 8000ff6:	6057      	str	r7, [r2, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000ff8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000ffa:	4690      	mov	r8, r2
 8000ffc:	1c10      	adds	r0, r2, #0

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000ffe:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001000:	4590      	cmp	r8, r2
 8001002:	d003      	beq.n	800100c <chMtxLockS+0xec>
 8001004:	6897      	ldr	r7, [r2, #8]
 8001006:	428f      	cmp	r7, r1
 8001008:	d2f9      	bcs.n	8000ffe <chMtxLockS+0xde>
 800100a:	1c10      	adds	r0, r2, #0
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800100c:	6841      	ldr	r1, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800100e:	6018      	str	r0, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001010:	6059      	str	r1, [r3, #4]
  tp->p_prev->p_next = tp;
 8001012:	600b      	str	r3, [r1, #0]
  cp->p_prev = tp;
 8001014:	6043      	str	r3, [r0, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 8001016:	4643      	mov	r3, r8
 8001018:	689b      	ldr	r3, [r3, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800101a:	68a1      	ldr	r1, [r4, #8]
 800101c:	689a      	ldr	r2, [r3, #8]
 800101e:	428a      	cmp	r2, r1
 8001020:	d200      	bcs.n	8001024 <chMtxLockS+0x104>
 8001022:	e790      	b.n	8000f46 <chMtxLockS+0x26>
 8001024:	e7a3      	b.n	8000f6e <chMtxLockS+0x4e>
 8001026:	46c0      	nop			; (mov r8, r8)
 8001028:	20001040 	.word	0x20001040
 800102c:	08008570 	.word	0x08008570

08001030 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001030:	b570      	push	{r4, r5, r6, lr}
 8001032:	1c0c      	adds	r4, r1, #0
 8001034:	b086      	sub	sp, #24
 8001036:	1c06      	adds	r6, r0, #0

  chDbgCheckClassS();
 8001038:	f7ff fc0a 	bl	8000850 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800103c:	1c63      	adds	r3, r4, #1
 800103e:	d015      	beq.n	800106c <chSchGoSleepTimeoutS+0x3c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001040:	4d0d      	ldr	r5, [pc, #52]	; (8001078 <chSchGoSleepTimeoutS+0x48>)
 8001042:	1c21      	adds	r1, r4, #0
 8001044:	69ab      	ldr	r3, [r5, #24]
 8001046:	4a0d      	ldr	r2, [pc, #52]	; (800107c <chSchGoSleepTimeoutS+0x4c>)
 8001048:	a801      	add	r0, sp, #4
 800104a:	f7ff fc71 	bl	8000930 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800104e:	1c30      	adds	r0, r6, #0
 8001050:	f7ff ff3e 	bl	8000ed0 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8001054:	f7ff fb0c 	bl	8000670 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8001058:	9b04      	ldr	r3, [sp, #16]
 800105a:	2b00      	cmp	r3, #0
 800105c:	d002      	beq.n	8001064 <chSchGoSleepTimeoutS+0x34>
      chVTDoResetI(&vt);
 800105e:	a801      	add	r0, sp, #4
 8001060:	f7ff fc16 	bl	8000890 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8001064:	69a8      	ldr	r0, [r5, #24]
 8001066:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 8001068:	b006      	add	sp, #24
 800106a:	bd70      	pop	{r4, r5, r6, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800106c:	1c30      	adds	r0, r6, #0
 800106e:	f7ff ff2f 	bl	8000ed0 <chSchGoSleepS>
 8001072:	4d01      	ldr	r5, [pc, #4]	; (8001078 <chSchGoSleepTimeoutS+0x48>)
 8001074:	e7f6      	b.n	8001064 <chSchGoSleepTimeoutS+0x34>
 8001076:	46c0      	nop			; (mov r8, r8)
 8001078:	20001040 	.word	0x20001040
 800107c:	08002f91 	.word	0x08002f91

08001080 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001080:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8001082:	2900      	cmp	r1, #0
 8001084:	d00a      	beq.n	800109c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001086:	4b07      	ldr	r3, [pc, #28]	; (80010a4 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001088:	6842      	ldr	r2, [r0, #4]
 800108a:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800108c:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800108e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001090:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8001092:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001094:	2004      	movs	r0, #4
 8001096:	f7ff ffcb 	bl	8001030 <chSchGoSleepTimeoutS>
}
 800109a:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 800109c:	2001      	movs	r0, #1
 800109e:	4240      	negs	r0, r0
 80010a0:	e7fb      	b.n	800109a <chThdEnqueueTimeoutS+0x1a>
 80010a2:	46c0      	nop			; (mov r8, r8)
 80010a4:	20001040 	.word	0x20001040
 80010a8:	46c0      	nop			; (mov r8, r8)
 80010aa:	46c0      	nop			; (mov r8, r8)
 80010ac:	46c0      	nop			; (mov r8, r8)
 80010ae:	46c0      	nop			; (mov r8, r8)

080010b0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 80010b0:	e7fe      	b.n	80010b0 <BusFault_Handler>
 80010b2:	46c0      	nop			; (mov r8, r8)
 80010b4:	46c0      	nop			; (mov r8, r8)
 80010b6:	46c0      	nop			; (mov r8, r8)
 80010b8:	46c0      	nop			; (mov r8, r8)
 80010ba:	46c0      	nop			; (mov r8, r8)
 80010bc:	46c0      	nop			; (mov r8, r8)
 80010be:	46c0      	nop			; (mov r8, r8)

080010c0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010c0:	4827      	ldr	r0, [pc, #156]	; (8001160 <__early_init+0xa0>)
 80010c2:	2301      	movs	r3, #1
 80010c4:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010c6:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010c8:	4313      	orrs	r3, r2
 80010ca:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010cc:	6803      	ldr	r3, [r0, #0]
 80010ce:	4a24      	ldr	r2, [pc, #144]	; (8001160 <__early_init+0xa0>)
 80010d0:	4219      	tst	r1, r3
 80010d2:	d0fb      	beq.n	80010cc <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80010d4:	6850      	ldr	r0, [r2, #4]
 80010d6:	2103      	movs	r1, #3
 80010d8:	4388      	bics	r0, r1
 80010da:	6050      	str	r0, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80010dc:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010de:	1c10      	adds	r0, r2, #0

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80010e0:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010e2:	210c      	movs	r1, #12
 80010e4:	6843      	ldr	r3, [r0, #4]
 80010e6:	4a1e      	ldr	r2, [pc, #120]	; (8001160 <__early_init+0xa0>)
 80010e8:	400b      	ands	r3, r1
 80010ea:	d1fb      	bne.n	80010e4 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010ec:	6811      	ldr	r1, [r2, #0]
 80010ee:	20f9      	movs	r0, #249	; 0xf9
 80010f0:	4001      	ands	r1, r0
 80010f2:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80010f4:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 80010f6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80010f8:	2301      	movs	r3, #1
 80010fa:	430b      	orrs	r3, r1
 80010fc:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 80010fe:	2002      	movs	r0, #2
 8001100:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001102:	4917      	ldr	r1, [pc, #92]	; (8001160 <__early_init+0xa0>)
 8001104:	4218      	tst	r0, r3
 8001106:	d0fb      	beq.n	8001100 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001108:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 800110a:	2001      	movs	r0, #1
 800110c:	4310      	orrs	r0, r2
 800110e:	6248      	str	r0, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001110:	2002      	movs	r0, #2
 8001112:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001114:	4a12      	ldr	r2, [pc, #72]	; (8001160 <__early_init+0xa0>)
 8001116:	4218      	tst	r0, r3
 8001118:	d0fb      	beq.n	8001112 <__early_init+0x52>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800111a:	21a0      	movs	r1, #160	; 0xa0
 800111c:	0388      	lsls	r0, r1, #14
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 800111e:	2300      	movs	r3, #0
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001120:	6050      	str	r0, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8001122:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8001124:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001126:	6811      	ldr	r1, [r2, #0]
 8001128:	2080      	movs	r0, #128	; 0x80
 800112a:	0443      	lsls	r3, r0, #17
 800112c:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800112e:	2180      	movs	r1, #128	; 0x80
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001130:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001132:	0488      	lsls	r0, r1, #18
 8001134:	6813      	ldr	r3, [r2, #0]
 8001136:	490a      	ldr	r1, [pc, #40]	; (8001160 <__early_init+0xa0>)
 8001138:	4203      	tst	r3, r0
 800113a:	d0fb      	beq.n	8001134 <__early_init+0x74>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800113c:	4809      	ldr	r0, [pc, #36]	; (8001164 <__early_init+0xa4>)
 800113e:	2211      	movs	r2, #17
 8001140:	6002      	str	r2, [r0, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001142:	684a      	ldr	r2, [r1, #4]
 8001144:	2302      	movs	r3, #2
 8001146:	4313      	orrs	r3, r2
 8001148:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800114a:	200c      	movs	r0, #12
 800114c:	684b      	ldr	r3, [r1, #4]
 800114e:	4a04      	ldr	r2, [pc, #16]	; (8001160 <__early_init+0xa0>)
 8001150:	4003      	ands	r3, r0
 8001152:	2b08      	cmp	r3, #8
 8001154:	d1fa      	bne.n	800114c <__early_init+0x8c>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001156:	6991      	ldr	r1, [r2, #24]
 8001158:	2001      	movs	r0, #1
 800115a:	4308      	orrs	r0, r1
 800115c:	6190      	str	r0, [r2, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 800115e:	4770      	bx	lr
 8001160:	40021000 	.word	0x40021000
 8001164:	40022000 	.word	0x40022000
 8001168:	46c0      	nop			; (mov r8, r8)
 800116a:	46c0      	nop			; (mov r8, r8)
 800116c:	46c0      	nop			; (mov r8, r8)
 800116e:	46c0      	nop			; (mov r8, r8)

08001170 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001170:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8001172:	f002 f955 	bl	8003420 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8001176:	bd08      	pop	{r3, pc}
 8001178:	46c0      	nop			; (mov r8, r8)
 800117a:	46c0      	nop			; (mov r8, r8)
 800117c:	46c0      	nop			; (mov r8, r8)
 800117e:	46c0      	nop			; (mov r8, r8)

08001180 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001180:	b570      	push	{r4, r5, r6, lr}
 8001182:	1c06      	adds	r6, r0, #0
 8001184:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001186:	f002 fc8b 	bl	8003aa0 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800118a:	4d0f      	ldr	r5, [pc, #60]	; (80011c8 <chThdExit+0x48>)
 800118c:	69ac      	ldr	r4, [r5, #24]

  tp->p_u.exitcode = msg;
 800118e:	6266      	str	r6, [r4, #36]	; 0x24
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001190:	6aa0      	ldr	r0, [r4, #40]	; 0x28
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001192:	1c26      	adds	r6, r4, #0
 8001194:	3628      	adds	r6, #40	; 0x28
 8001196:	42b0      	cmp	r0, r6
 8001198:	d006      	beq.n	80011a8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 800119a:	6803      	ldr	r3, [r0, #0]
 800119c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800119e:	f7ff fac7 	bl	8000730 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80011a2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80011a4:	42b0      	cmp	r0, r6
 80011a6:	d1f8      	bne.n	800119a <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80011a8:	2021      	movs	r0, #33	; 0x21
 80011aa:	5c21      	ldrb	r1, [r4, r0]
 80011ac:	078a      	lsls	r2, r1, #30
 80011ae:	d104      	bne.n	80011ba <chThdExit+0x3a>
    REG_REMOVE(tp);
 80011b0:	6966      	ldr	r6, [r4, #20]
 80011b2:	6922      	ldr	r2, [r4, #16]
 80011b4:	6132      	str	r2, [r6, #16]
 80011b6:	6924      	ldr	r4, [r4, #16]
 80011b8:	6166      	str	r6, [r4, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80011ba:	200f      	movs	r0, #15
 80011bc:	f7ff fe88 	bl	8000ed0 <chSchGoSleepS>
 80011c0:	b672      	cpsid	i
 80011c2:	4b02      	ldr	r3, [pc, #8]	; (80011cc <chThdExit+0x4c>)
 80011c4:	62eb      	str	r3, [r5, #44]	; 0x2c
 80011c6:	e7fe      	b.n	80011c6 <chThdExit+0x46>
 80011c8:	20001040 	.word	0x20001040
 80011cc:	080085c0 	.word	0x080085c0

080011d0 <thread1.10781>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 80011d0:	b508      	push	{r3, lr}

  chThdExit((msg_t)p);
 80011d2:	f7ff ffd5 	bl	8001180 <chThdExit>
 80011d6:	46c0      	nop			; (mov r8, r8)
 80011d8:	46c0      	nop			; (mov r8, r8)
 80011da:	46c0      	nop			; (mov r8, r8)
 80011dc:	46c0      	nop			; (mov r8, r8)
 80011de:	46c0      	nop			; (mov r8, r8)

080011e0 <sem4_execute.9025>:
static THD_FUNCTION(thread4, p) {

  chBSemSignal((binary_semaphore_t *)p);
}

static void sem4_execute(void) {
 80011e0:	b530      	push	{r4, r5, lr}
 80011e2:	b087      	sub	sp, #28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80011e4:	ad03      	add	r5, sp, #12
 80011e6:	2300      	movs	r3, #0
 80011e8:	9503      	str	r5, [sp, #12]
  tqp->p_prev = (thread_t *)tqp;
 80011ea:	606d      	str	r5, [r5, #4]
 80011ec:	60ab      	str	r3, [r5, #8]
 80011ee:	b672      	cpsid	i
 80011f0:	f002 fc56 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 80011f4:	1c28      	adds	r0, r5, #0
 80011f6:	2100      	movs	r1, #0
 80011f8:	f002 fa8a 	bl	8003710 <chSemResetI>
  chSchRescheduleS();
 80011fc:	f002 f940 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001200:	f002 fbb6 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001204:	4cb3      	ldr	r4, [pc, #716]	; (80014d4 <sem4_execute.9025+0x2f4>)
 8001206:	6820      	ldr	r0, [r4, #0]
 8001208:	42a0      	cmp	r0, r4
 800120a:	d004      	beq.n	8001216 <sem4_execute.9025+0x36>
 800120c:	69a2      	ldr	r2, [r4, #24]
 800120e:	6883      	ldr	r3, [r0, #8]
 8001210:	6891      	ldr	r1, [r2, #8]
 8001212:	4299      	cmp	r1, r3
 8001214:	d352      	bcc.n	80012bc <sem4_execute.9025+0xdc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001216:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001218:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800121a:	f002 fc41 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 800121e:	f7ff fa27 	bl	8000670 <chDbgCheckClassI>

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 8001222:	68a8      	ldr	r0, [r5, #8]
 8001224:	1e42      	subs	r2, r0, #1
 8001226:	4310      	orrs	r0, r2
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8001228:	0fc1      	lsrs	r1, r0, #31
 800122a:	2001      	movs	r0, #1
 800122c:	f7ff fc98 	bl	8000b60 <_test_assert>
 8001230:	2800      	cmp	r0, #0
 8001232:	d00c      	beq.n	800124e <sem4_execute.9025+0x6e>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001234:	f002 fb9c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001238:	6823      	ldr	r3, [r4, #0]
 800123a:	42a3      	cmp	r3, r4
 800123c:	d004      	beq.n	8001248 <sem4_execute.9025+0x68>
 800123e:	69a1      	ldr	r1, [r4, #24]
 8001240:	689a      	ldr	r2, [r3, #8]
 8001242:	688d      	ldr	r5, [r1, #8]
 8001244:	4295      	cmp	r5, r2
 8001246:	d33d      	bcc.n	80012c4 <sem4_execute.9025+0xe4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001248:	b662      	cpsie	i

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 800124a:	b007      	add	sp, #28
 800124c:	bd30      	pop	{r4, r5, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800124e:	f002 fb8f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001252:	6821      	ldr	r1, [r4, #0]
 8001254:	42a1      	cmp	r1, r4
 8001256:	d005      	beq.n	8001264 <sem4_execute.9025+0x84>
 8001258:	69a3      	ldr	r3, [r4, #24]
 800125a:	688a      	ldr	r2, [r1, #8]
 800125c:	6898      	ldr	r0, [r3, #8]
 800125e:	4290      	cmp	r0, r2
 8001260:	d200      	bcs.n	8001264 <sem4_execute.9025+0x84>
 8001262:	e11b      	b.n	800149c <sem4_execute.9025+0x2bc>
 8001264:	b662      	cpsie	i
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001266:	69a1      	ldr	r1, [r4, #24]
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8001268:	23a8      	movs	r3, #168	; 0xa8
 800126a:	688a      	ldr	r2, [r1, #8]
 800126c:	489a      	ldr	r0, [pc, #616]	; (80014d8 <sem4_execute.9025+0x2f8>)
 800126e:	0059      	lsls	r1, r3, #1
 8001270:	3a01      	subs	r2, #1
 8001272:	4b9a      	ldr	r3, [pc, #616]	; (80014dc <sem4_execute.9025+0x2fc>)
 8001274:	9500      	str	r5, [sp, #0]
 8001276:	f001 fdeb 	bl	8002e50 <chThdCreateStatic>
 800127a:	4a99      	ldr	r2, [pc, #612]	; (80014e0 <sem4_execute.9025+0x300>)
 800127c:	6010      	str	r0, [r2, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 800127e:	1c28      	adds	r0, r5, #0
 8001280:	f001 f946 	bl	8002510 <chSemWait>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001284:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001286:	f002 fc0b 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 800128a:	f7ff f9f1 	bl	8000670 <chDbgCheckClassI>

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800128e:	68a8      	ldr	r0, [r5, #8]
 8001290:	1e41      	subs	r1, r0, #1
 8001292:	4308      	orrs	r0, r1
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8001294:	0fc1      	lsrs	r1, r0, #31
 8001296:	2002      	movs	r0, #2
 8001298:	f7ff fc62 	bl	8000b60 <_test_assert>
 800129c:	2800      	cmp	r0, #0
 800129e:	d015      	beq.n	80012cc <sem4_execute.9025+0xec>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012a0:	f002 fb66 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80012a4:	6820      	ldr	r0, [r4, #0]
 80012a6:	42a0      	cmp	r0, r4
 80012a8:	d0ce      	beq.n	8001248 <sem4_execute.9025+0x68>
 80012aa:	69a3      	ldr	r3, [r4, #24]
 80012ac:	6885      	ldr	r5, [r0, #8]
 80012ae:	6899      	ldr	r1, [r3, #8]
 80012b0:	42a9      	cmp	r1, r5
 80012b2:	d2c9      	bcs.n	8001248 <sem4_execute.9025+0x68>
 80012b4:	b672      	cpsid	i
 80012b6:	4a8b      	ldr	r2, [pc, #556]	; (80014e4 <sem4_execute.9025+0x304>)
 80012b8:	62e2      	str	r2, [r4, #44]	; 0x2c
 80012ba:	e7fe      	b.n	80012ba <sem4_execute.9025+0xda>
 80012bc:	b672      	cpsid	i
 80012be:	4b8a      	ldr	r3, [pc, #552]	; (80014e8 <sem4_execute.9025+0x308>)
 80012c0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80012c2:	e7fe      	b.n	80012c2 <sem4_execute.9025+0xe2>
 80012c4:	b672      	cpsid	i
 80012c6:	4887      	ldr	r0, [pc, #540]	; (80014e4 <sem4_execute.9025+0x304>)
 80012c8:	62e0      	str	r0, [r4, #44]	; 0x2c
 80012ca:	e7fe      	b.n	80012ca <sem4_execute.9025+0xea>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012cc:	f002 fb50 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80012d0:	6823      	ldr	r3, [r4, #0]
 80012d2:	42a3      	cmp	r3, r4
 80012d4:	d005      	beq.n	80012e2 <sem4_execute.9025+0x102>
 80012d6:	69a2      	ldr	r2, [r4, #24]
 80012d8:	6899      	ldr	r1, [r3, #8]
 80012da:	6890      	ldr	r0, [r2, #8]
 80012dc:	4288      	cmp	r0, r1
 80012de:	d200      	bcs.n	80012e2 <sem4_execute.9025+0x102>
 80012e0:	e0e0      	b.n	80014a4 <sem4_execute.9025+0x2c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80012e2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80012e4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80012e6:	f002 fbdb 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 80012ea:	f7ff f9c1 	bl	8000670 <chDbgCheckClassI>

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80012ee:	68ab      	ldr	r3, [r5, #8]
 80012f0:	2b00      	cmp	r3, #0
 80012f2:	dc02      	bgt.n	80012fa <sem4_execute.9025+0x11a>
    chSemSignalI(&bsp->bs_sem);
 80012f4:	1c28      	adds	r0, r5, #0
 80012f6:	f002 f95b 	bl	80035b0 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80012fa:	f002 f8c1 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012fe:	f002 fb37 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001302:	6820      	ldr	r0, [r4, #0]
 8001304:	42a0      	cmp	r0, r4
 8001306:	d005      	beq.n	8001314 <sem4_execute.9025+0x134>
 8001308:	69a2      	ldr	r2, [r4, #24]
 800130a:	6883      	ldr	r3, [r0, #8]
 800130c:	6891      	ldr	r1, [r2, #8]
 800130e:	4299      	cmp	r1, r3
 8001310:	d200      	bcs.n	8001314 <sem4_execute.9025+0x134>
 8001312:	e0cb      	b.n	80014ac <sem4_execute.9025+0x2cc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001314:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001316:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001318:	f002 fbc2 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 800131c:	f7ff f9a8 	bl	8000670 <chDbgCheckClassI>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 8001320:	68a8      	ldr	r0, [r5, #8]
 8001322:	17c2      	asrs	r2, r0, #31
 8001324:	1a11      	subs	r1, r2, r0
 8001326:	0fc9      	lsrs	r1, r1, #31
 8001328:	2003      	movs	r0, #3
 800132a:	f7ff fc19 	bl	8000b60 <_test_assert>
 800132e:	2800      	cmp	r0, #0
 8001330:	d00f      	beq.n	8001352 <sem4_execute.9025+0x172>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001332:	f002 fb1d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001336:	6825      	ldr	r5, [r4, #0]
 8001338:	42a5      	cmp	r5, r4
 800133a:	d100      	bne.n	800133e <sem4_execute.9025+0x15e>
 800133c:	e784      	b.n	8001248 <sem4_execute.9025+0x68>
 800133e:	69a2      	ldr	r2, [r4, #24]
 8001340:	68ab      	ldr	r3, [r5, #8]
 8001342:	6890      	ldr	r0, [r2, #8]
 8001344:	4298      	cmp	r0, r3
 8001346:	d300      	bcc.n	800134a <sem4_execute.9025+0x16a>
 8001348:	e77e      	b.n	8001248 <sem4_execute.9025+0x68>
 800134a:	b672      	cpsid	i
 800134c:	4965      	ldr	r1, [pc, #404]	; (80014e4 <sem4_execute.9025+0x304>)
 800134e:	62e1      	str	r1, [r4, #44]	; 0x2c
 8001350:	e7fe      	b.n	8001350 <sem4_execute.9025+0x170>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001352:	f002 fb0d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001356:	6823      	ldr	r3, [r4, #0]
 8001358:	42a3      	cmp	r3, r4
 800135a:	d005      	beq.n	8001368 <sem4_execute.9025+0x188>
 800135c:	69a0      	ldr	r0, [r4, #24]
 800135e:	6899      	ldr	r1, [r3, #8]
 8001360:	6882      	ldr	r2, [r0, #8]
 8001362:	428a      	cmp	r2, r1
 8001364:	d200      	bcs.n	8001368 <sem4_execute.9025+0x188>
 8001366:	e0a5      	b.n	80014b4 <sem4_execute.9025+0x2d4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001368:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800136a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800136c:	f002 fb98 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 8001370:	f7ff f97e 	bl	8000670 <chDbgCheckClassI>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8001374:	68a9      	ldr	r1, [r5, #8]
 8001376:	2004      	movs	r0, #4
 8001378:	3901      	subs	r1, #1
 800137a:	424b      	negs	r3, r1
 800137c:	4159      	adcs	r1, r3
 800137e:	f7ff fbef 	bl	8000b60 <_test_assert>
 8001382:	2800      	cmp	r0, #0
 8001384:	d00f      	beq.n	80013a6 <sem4_execute.9025+0x1c6>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001386:	f002 faf3 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800138a:	6821      	ldr	r1, [r4, #0]
 800138c:	42a1      	cmp	r1, r4
 800138e:	d100      	bne.n	8001392 <sem4_execute.9025+0x1b2>
 8001390:	e75a      	b.n	8001248 <sem4_execute.9025+0x68>
 8001392:	69a2      	ldr	r2, [r4, #24]
 8001394:	688b      	ldr	r3, [r1, #8]
 8001396:	6895      	ldr	r5, [r2, #8]
 8001398:	429d      	cmp	r5, r3
 800139a:	d300      	bcc.n	800139e <sem4_execute.9025+0x1be>
 800139c:	e754      	b.n	8001248 <sem4_execute.9025+0x68>
 800139e:	b672      	cpsid	i
 80013a0:	4850      	ldr	r0, [pc, #320]	; (80014e4 <sem4_execute.9025+0x304>)
 80013a2:	62e0      	str	r0, [r4, #44]	; 0x2c
 80013a4:	e7fe      	b.n	80013a4 <sem4_execute.9025+0x1c4>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80013a6:	f002 fae3 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80013aa:	6823      	ldr	r3, [r4, #0]
 80013ac:	42a3      	cmp	r3, r4
 80013ae:	d005      	beq.n	80013bc <sem4_execute.9025+0x1dc>
 80013b0:	69a0      	ldr	r0, [r4, #24]
 80013b2:	6899      	ldr	r1, [r3, #8]
 80013b4:	6882      	ldr	r2, [r0, #8]
 80013b6:	428a      	cmp	r2, r1
 80013b8:	d200      	bcs.n	80013bc <sem4_execute.9025+0x1dc>
 80013ba:	e07f      	b.n	80014bc <sem4_execute.9025+0x2dc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80013bc:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013be:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80013c0:	f002 fb6e 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 80013c4:	f7ff f954 	bl	8000670 <chDbgCheckClassI>

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80013c8:	68ab      	ldr	r3, [r5, #8]
 80013ca:	2b00      	cmp	r3, #0
 80013cc:	dc02      	bgt.n	80013d4 <sem4_execute.9025+0x1f4>
    chSemSignalI(&bsp->bs_sem);
 80013ce:	1c28      	adds	r0, r5, #0
 80013d0:	f002 f8ee 	bl	80035b0 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80013d4:	f002 f854 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80013d8:	f002 faca 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80013dc:	6820      	ldr	r0, [r4, #0]
 80013de:	42a0      	cmp	r0, r4
 80013e0:	d004      	beq.n	80013ec <sem4_execute.9025+0x20c>
 80013e2:	69a2      	ldr	r2, [r4, #24]
 80013e4:	6883      	ldr	r3, [r0, #8]
 80013e6:	6891      	ldr	r1, [r2, #8]
 80013e8:	4299      	cmp	r1, r3
 80013ea:	d36b      	bcc.n	80014c4 <sem4_execute.9025+0x2e4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80013ec:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013ee:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80013f0:	f002 fb56 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 80013f4:	f7ff f93c 	bl	8000670 <chDbgCheckClassI>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 80013f8:	68a8      	ldr	r0, [r5, #8]
 80013fa:	17c2      	asrs	r2, r0, #31
 80013fc:	1a11      	subs	r1, r2, r0
 80013fe:	0fc9      	lsrs	r1, r1, #31
 8001400:	2003      	movs	r0, #3
 8001402:	f7ff fbad 	bl	8000b60 <_test_assert>
 8001406:	2800      	cmp	r0, #0
 8001408:	d00f      	beq.n	800142a <sem4_execute.9025+0x24a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800140a:	f002 fab1 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800140e:	6823      	ldr	r3, [r4, #0]
 8001410:	42a3      	cmp	r3, r4
 8001412:	d100      	bne.n	8001416 <sem4_execute.9025+0x236>
 8001414:	e718      	b.n	8001248 <sem4_execute.9025+0x68>
 8001416:	69a0      	ldr	r0, [r4, #24]
 8001418:	6899      	ldr	r1, [r3, #8]
 800141a:	6882      	ldr	r2, [r0, #8]
 800141c:	428a      	cmp	r2, r1
 800141e:	d300      	bcc.n	8001422 <sem4_execute.9025+0x242>
 8001420:	e712      	b.n	8001248 <sem4_execute.9025+0x68>
 8001422:	b672      	cpsid	i
 8001424:	4d2f      	ldr	r5, [pc, #188]	; (80014e4 <sem4_execute.9025+0x304>)
 8001426:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001428:	e7fe      	b.n	8001428 <sem4_execute.9025+0x248>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800142a:	f002 faa1 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800142e:	6823      	ldr	r3, [r4, #0]
 8001430:	42a3      	cmp	r3, r4
 8001432:	d004      	beq.n	800143e <sem4_execute.9025+0x25e>
 8001434:	69a0      	ldr	r0, [r4, #24]
 8001436:	6899      	ldr	r1, [r3, #8]
 8001438:	6882      	ldr	r2, [r0, #8]
 800143a:	428a      	cmp	r2, r1
 800143c:	d346      	bcc.n	80014cc <sem4_execute.9025+0x2ec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800143e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001440:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001442:	f002 fb2d 	bl	8003aa0 <_dbg_check_lock>
 8001446:	f7ff f913 	bl	8000670 <chDbgCheckClassI>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800144a:	68a9      	ldr	r1, [r5, #8]
 800144c:	2005      	movs	r0, #5
 800144e:	3901      	subs	r1, #1
 8001450:	424b      	negs	r3, r1
 8001452:	4159      	adcs	r1, r3
 8001454:	f7ff fb84 	bl	8000b60 <_test_assert>
 8001458:	2800      	cmp	r0, #0
 800145a:	d00f      	beq.n	800147c <sem4_execute.9025+0x29c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800145c:	f002 fa88 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001460:	6825      	ldr	r5, [r4, #0]
 8001462:	42a5      	cmp	r5, r4
 8001464:	d100      	bne.n	8001468 <sem4_execute.9025+0x288>
 8001466:	e6ef      	b.n	8001248 <sem4_execute.9025+0x68>
 8001468:	69a3      	ldr	r3, [r4, #24]
 800146a:	68aa      	ldr	r2, [r5, #8]
 800146c:	6898      	ldr	r0, [r3, #8]
 800146e:	4290      	cmp	r0, r2
 8001470:	d300      	bcc.n	8001474 <sem4_execute.9025+0x294>
 8001472:	e6e9      	b.n	8001248 <sem4_execute.9025+0x68>
 8001474:	b672      	cpsid	i
 8001476:	491b      	ldr	r1, [pc, #108]	; (80014e4 <sem4_execute.9025+0x304>)
 8001478:	62e1      	str	r1, [r4, #44]	; 0x2c
 800147a:	e7fe      	b.n	800147a <sem4_execute.9025+0x29a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800147c:	f002 fa78 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001480:	6825      	ldr	r5, [r4, #0]
 8001482:	42a5      	cmp	r5, r4
 8001484:	d100      	bne.n	8001488 <sem4_execute.9025+0x2a8>
 8001486:	e6df      	b.n	8001248 <sem4_execute.9025+0x68>
 8001488:	69a3      	ldr	r3, [r4, #24]
 800148a:	68aa      	ldr	r2, [r5, #8]
 800148c:	6898      	ldr	r0, [r3, #8]
 800148e:	4290      	cmp	r0, r2
 8001490:	d300      	bcc.n	8001494 <sem4_execute.9025+0x2b4>
 8001492:	e6d9      	b.n	8001248 <sem4_execute.9025+0x68>
 8001494:	b672      	cpsid	i
 8001496:	4913      	ldr	r1, [pc, #76]	; (80014e4 <sem4_execute.9025+0x304>)
 8001498:	62e1      	str	r1, [r4, #44]	; 0x2c
 800149a:	e7fe      	b.n	800149a <sem4_execute.9025+0x2ba>
 800149c:	b672      	cpsid	i
 800149e:	4811      	ldr	r0, [pc, #68]	; (80014e4 <sem4_execute.9025+0x304>)
 80014a0:	62e0      	str	r0, [r4, #44]	; 0x2c
 80014a2:	e7fe      	b.n	80014a2 <sem4_execute.9025+0x2c2>
 80014a4:	b672      	cpsid	i
 80014a6:	4a0f      	ldr	r2, [pc, #60]	; (80014e4 <sem4_execute.9025+0x304>)
 80014a8:	62e2      	str	r2, [r4, #44]	; 0x2c
 80014aa:	e7fe      	b.n	80014aa <sem4_execute.9025+0x2ca>
 80014ac:	b672      	cpsid	i
 80014ae:	4d0d      	ldr	r5, [pc, #52]	; (80014e4 <sem4_execute.9025+0x304>)
 80014b0:	62e5      	str	r5, [r4, #44]	; 0x2c
 80014b2:	e7fe      	b.n	80014b2 <sem4_execute.9025+0x2d2>
 80014b4:	b672      	cpsid	i
 80014b6:	490b      	ldr	r1, [pc, #44]	; (80014e4 <sem4_execute.9025+0x304>)
 80014b8:	62e1      	str	r1, [r4, #44]	; 0x2c
 80014ba:	e7fe      	b.n	80014ba <sem4_execute.9025+0x2da>
 80014bc:	b672      	cpsid	i
 80014be:	4809      	ldr	r0, [pc, #36]	; (80014e4 <sem4_execute.9025+0x304>)
 80014c0:	62e0      	str	r0, [r4, #44]	; 0x2c
 80014c2:	e7fe      	b.n	80014c2 <sem4_execute.9025+0x2e2>
 80014c4:	b672      	cpsid	i
 80014c6:	4b07      	ldr	r3, [pc, #28]	; (80014e4 <sem4_execute.9025+0x304>)
 80014c8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80014ca:	e7fe      	b.n	80014ca <sem4_execute.9025+0x2ea>
 80014cc:	b672      	cpsid	i
 80014ce:	4d05      	ldr	r5, [pc, #20]	; (80014e4 <sem4_execute.9025+0x304>)
 80014d0:	62e5      	str	r5, [r4, #44]	; 0x2c
 80014d2:	e7fe      	b.n	80014d2 <sem4_execute.9025+0x2f2>
 80014d4:	20001040 	.word	0x20001040
 80014d8:	200006b8 	.word	0x200006b8
 80014dc:	08006d11 	.word	0x08006d11
 80014e0:	200015b8 	.word	0x200015b8
 80014e4:	080085d0 	.word	0x080085d0
 80014e8:	08008600 	.word	0x08008600
 80014ec:	46c0      	nop			; (mov r8, r8)
 80014ee:	46c0      	nop			; (mov r8, r8)

080014f0 <queues2_execute.10392>:

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
}

static void queues2_execute(void) {
 80014f0:	b570      	push	{r4, r5, r6, lr}
 80014f2:	b082      	sub	sp, #8
 80014f4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80014f6:	f002 fad3 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80014fa:	f7ff f8b9 	bl	8000670 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80014fe:	4dd7      	ldr	r5, [pc, #860]	; (800185c <queues2_execute.10392+0x36c>)
 8001500:	2100      	movs	r1, #0
 8001502:	6968      	ldr	r0, [r5, #20]
 8001504:	69aa      	ldr	r2, [r5, #24]
 8001506:	4290      	cmp	r0, r2
 8001508:	d100      	bne.n	800150c <queues2_execute.10392+0x1c>
 800150a:	e1d7      	b.n	80018bc <queues2_execute.10392+0x3cc>
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 800150c:	2001      	movs	r0, #1
 800150e:	f7ff fb27 	bl	8000b60 <_test_assert>
 8001512:	2800      	cmp	r0, #0
 8001514:	d000      	beq.n	8001518 <queues2_execute.10392+0x28>
 8001516:	e1ad      	b.n	8001874 <queues2_execute.10392+0x384>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001518:	f002 fa2a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800151c:	4cd0      	ldr	r4, [pc, #832]	; (8001860 <queues2_execute.10392+0x370>)
 800151e:	6823      	ldr	r3, [r4, #0]
 8001520:	42a3      	cmp	r3, r4
 8001522:	d005      	beq.n	8001530 <queues2_execute.10392+0x40>
 8001524:	69a1      	ldr	r1, [r4, #24]
 8001526:	6898      	ldr	r0, [r3, #8]
 8001528:	688e      	ldr	r6, [r1, #8]
 800152a:	4286      	cmp	r6, r0
 800152c:	d200      	bcs.n	8001530 <queues2_execute.10392+0x40>
 800152e:	e1c1      	b.n	80018b4 <queues2_execute.10392+0x3c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001530:	b662      	cpsie	i
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8001532:	2201      	movs	r2, #1
 8001534:	1c28      	adds	r0, r5, #0
 8001536:	2141      	movs	r1, #65	; 0x41
 8001538:	4252      	negs	r2, r2
 800153a:	f004 fe39 	bl	80061b0 <chOQPutTimeout>
 800153e:	2301      	movs	r3, #1
 8001540:	425a      	negs	r2, r3
 8001542:	1c28      	adds	r0, r5, #0
 8001544:	2142      	movs	r1, #66	; 0x42
 8001546:	2601      	movs	r6, #1
 8001548:	f004 fe32 	bl	80061b0 <chOQPutTimeout>
 800154c:	4272      	negs	r2, r6
 800154e:	1c28      	adds	r0, r5, #0
 8001550:	2143      	movs	r1, #67	; 0x43
 8001552:	f004 fe2d 	bl	80061b0 <chOQPutTimeout>
 8001556:	2201      	movs	r2, #1
 8001558:	1c28      	adds	r0, r5, #0
 800155a:	2144      	movs	r1, #68	; 0x44
 800155c:	4252      	negs	r2, r2
 800155e:	f004 fe27 	bl	80061b0 <chOQPutTimeout>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001562:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001564:	f002 fa9c 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001568:	f7ff f882 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 800156c:	68a9      	ldr	r1, [r5, #8]

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 800156e:	2002      	movs	r0, #2
 8001570:	424b      	negs	r3, r1
 8001572:	4159      	adcs	r1, r3
 8001574:	f7ff faf4 	bl	8000b60 <_test_assert>
 8001578:	2800      	cmp	r0, #0
 800157a:	d000      	beq.n	800157e <queues2_execute.10392+0x8e>
 800157c:	e188      	b.n	8001890 <queues2_execute.10392+0x3a0>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800157e:	f002 f9f7 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001582:	6821      	ldr	r1, [r4, #0]
 8001584:	42a1      	cmp	r1, r4
 8001586:	d005      	beq.n	8001594 <queues2_execute.10392+0xa4>
 8001588:	69a0      	ldr	r0, [r4, #24]
 800158a:	688b      	ldr	r3, [r1, #8]
 800158c:	6886      	ldr	r6, [r0, #8]
 800158e:	429e      	cmp	r6, r3
 8001590:	d200      	bcs.n	8001594 <queues2_execute.10392+0xa4>
 8001592:	e197      	b.n	80018c4 <queues2_execute.10392+0x3d4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001594:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001596:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001598:	f002 fa82 	bl	8003aa0 <_dbg_check_lock>
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 800159c:	1c28      	adds	r0, r5, #0
 800159e:	f001 fe4f 	bl	8003240 <chOQGetI>
 80015a2:	b2c6      	uxtb	r6, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80015a4:	f002 f9e4 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80015a8:	6821      	ldr	r1, [r4, #0]
 80015aa:	42a1      	cmp	r1, r4
 80015ac:	d005      	beq.n	80015ba <queues2_execute.10392+0xca>
 80015ae:	69a2      	ldr	r2, [r4, #24]
 80015b0:	688b      	ldr	r3, [r1, #8]
 80015b2:	6890      	ldr	r0, [r2, #8]
 80015b4:	4298      	cmp	r0, r3
 80015b6:	d200      	bcs.n	80015ba <queues2_execute.10392+0xca>
 80015b8:	e1dd      	b.n	8001976 <queues2_execute.10392+0x486>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80015ba:	b662      	cpsie	i
    chSysUnlock();
    test_emit_token(c);
 80015bc:	1c30      	adds	r0, r6, #0
 80015be:	f003 fd8f 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80015c2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80015c4:	f002 fa6c 	bl	8003aa0 <_dbg_check_lock>
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 80015c8:	1c28      	adds	r0, r5, #0
 80015ca:	f001 fe39 	bl	8003240 <chOQGetI>
 80015ce:	b2c6      	uxtb	r6, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80015d0:	f002 f9ce 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80015d4:	6821      	ldr	r1, [r4, #0]
 80015d6:	42a1      	cmp	r1, r4
 80015d8:	d005      	beq.n	80015e6 <queues2_execute.10392+0xf6>
 80015da:	69a2      	ldr	r2, [r4, #24]
 80015dc:	688b      	ldr	r3, [r1, #8]
 80015de:	6890      	ldr	r0, [r2, #8]
 80015e0:	4298      	cmp	r0, r3
 80015e2:	d200      	bcs.n	80015e6 <queues2_execute.10392+0xf6>
 80015e4:	e1c7      	b.n	8001976 <queues2_execute.10392+0x486>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80015e6:	b662      	cpsie	i
    chSysUnlock();
    test_emit_token(c);
 80015e8:	1c30      	adds	r0, r6, #0
 80015ea:	f003 fd79 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80015ee:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80015f0:	f002 fa56 	bl	8003aa0 <_dbg_check_lock>
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 80015f4:	1c28      	adds	r0, r5, #0
 80015f6:	f001 fe23 	bl	8003240 <chOQGetI>
 80015fa:	b2c6      	uxtb	r6, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80015fc:	f002 f9b8 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001600:	6821      	ldr	r1, [r4, #0]
 8001602:	42a1      	cmp	r1, r4
 8001604:	d005      	beq.n	8001612 <queues2_execute.10392+0x122>
 8001606:	69a2      	ldr	r2, [r4, #24]
 8001608:	688b      	ldr	r3, [r1, #8]
 800160a:	6890      	ldr	r0, [r2, #8]
 800160c:	4298      	cmp	r0, r3
 800160e:	d200      	bcs.n	8001612 <queues2_execute.10392+0x122>
 8001610:	e1b1      	b.n	8001976 <queues2_execute.10392+0x486>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001612:	b662      	cpsie	i
    chSysUnlock();
    test_emit_token(c);
 8001614:	1c30      	adds	r0, r6, #0
 8001616:	f003 fd63 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800161a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800161c:	f002 fa40 	bl	8003aa0 <_dbg_check_lock>
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 8001620:	1c28      	adds	r0, r5, #0
 8001622:	f001 fe0d 	bl	8003240 <chOQGetI>
 8001626:	b2c6      	uxtb	r6, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001628:	f002 f9a2 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800162c:	6821      	ldr	r1, [r4, #0]
 800162e:	42a1      	cmp	r1, r4
 8001630:	d005      	beq.n	800163e <queues2_execute.10392+0x14e>
 8001632:	69a2      	ldr	r2, [r4, #24]
 8001634:	688b      	ldr	r3, [r1, #8]
 8001636:	6890      	ldr	r0, [r2, #8]
 8001638:	4298      	cmp	r0, r3
 800163a:	d200      	bcs.n	800163e <queues2_execute.10392+0x14e>
 800163c:	e19b      	b.n	8001976 <queues2_execute.10392+0x486>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800163e:	b662      	cpsie	i
    chSysUnlock();
    test_emit_token(c);
 8001640:	1c30      	adds	r0, r6, #0
 8001642:	f003 fd4d 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001646:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001648:	f002 fa2a 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800164c:	f7ff f810 	bl	8000670 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001650:	696e      	ldr	r6, [r5, #20]
 8001652:	69aa      	ldr	r2, [r5, #24]
 8001654:	2100      	movs	r1, #0
 8001656:	4296      	cmp	r6, r2
 8001658:	d100      	bne.n	800165c <queues2_execute.10392+0x16c>
 800165a:	e188      	b.n	800196e <queues2_execute.10392+0x47e>
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 800165c:	2003      	movs	r0, #3
 800165e:	f7ff fa7f 	bl	8000b60 <_test_assert>
 8001662:	2800      	cmp	r0, #0
 8001664:	d000      	beq.n	8001668 <queues2_execute.10392+0x178>
 8001666:	e18a      	b.n	800197e <queues2_execute.10392+0x48e>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001668:	f002 f982 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800166c:	6821      	ldr	r1, [r4, #0]
 800166e:	42a1      	cmp	r1, r4
 8001670:	d005      	beq.n	800167e <queues2_execute.10392+0x18e>
 8001672:	69a0      	ldr	r0, [r4, #24]
 8001674:	688b      	ldr	r3, [r1, #8]
 8001676:	6886      	ldr	r6, [r0, #8]
 8001678:	429e      	cmp	r6, r3
 800167a:	d200      	bcs.n	800167e <queues2_execute.10392+0x18e>
 800167c:	e18f      	b.n	800199e <queues2_execute.10392+0x4ae>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800167e:	b662      	cpsie	i
  test_assert_sequence(4, "ABCD");
 8001680:	2004      	movs	r0, #4
 8001682:	4978      	ldr	r1, [pc, #480]	; (8001864 <queues2_execute.10392+0x374>)
 8001684:	f7ff fa1c 	bl	8000ac0 <_test_assert_sequence>
 8001688:	2800      	cmp	r0, #0
 800168a:	d000      	beq.n	800168e <queues2_execute.10392+0x19e>
 800168c:	e0fe      	b.n	800188c <queues2_execute.10392+0x39c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800168e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001690:	f002 fa06 	bl	8003aa0 <_dbg_check_lock>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8001694:	1c28      	adds	r0, r5, #0
 8001696:	f001 fdd3 	bl	8003240 <chOQGetI>
 800169a:	1cc1      	adds	r1, r0, #3
 800169c:	424b      	negs	r3, r1
 800169e:	4159      	adcs	r1, r3
 80016a0:	2005      	movs	r0, #5
 80016a2:	f7ff fa5d 	bl	8000b60 <_test_assert>
 80016a6:	2800      	cmp	r0, #0
 80016a8:	d000      	beq.n	80016ac <queues2_execute.10392+0x1bc>
 80016aa:	e14c      	b.n	8001946 <queues2_execute.10392+0x456>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80016ac:	f002 f960 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80016b0:	6821      	ldr	r1, [r4, #0]
 80016b2:	42a1      	cmp	r1, r4
 80016b4:	d005      	beq.n	80016c2 <queues2_execute.10392+0x1d2>
 80016b6:	69a2      	ldr	r2, [r4, #24]
 80016b8:	688e      	ldr	r6, [r1, #8]
 80016ba:	6890      	ldr	r0, [r2, #8]
 80016bc:	42b0      	cmp	r0, r6
 80016be:	d200      	bcs.n	80016c2 <queues2_execute.10392+0x1d2>
 80016c0:	e151      	b.n	8001966 <queues2_execute.10392+0x476>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80016c2:	b662      	cpsie	i
thread_t *threads[MAX_THREADS];

/*
 * Pointers to the working areas.
 */
void * ROMCONST wa[5] = {test.wa.T0, test.wa.T1, test.wa.T2,
 80016c4:	4e68      	ldr	r6, [pc, #416]	; (8001868 <queues2_execute.10392+0x378>)
 80016c6:	23a8      	movs	r3, #168	; 0xa8
 80016c8:	0059      	lsls	r1, r3, #1
 80016ca:	1871      	adds	r1, r6, r1

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 80016cc:	2300      	movs	r3, #0
 80016ce:	1c28      	adds	r0, r5, #0
 80016d0:	2208      	movs	r2, #8
 80016d2:	f002 fb85 	bl	8003de0 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 80016d6:	1f01      	subs	r1, r0, #4
 80016d8:	424b      	negs	r3, r1
 80016da:	4159      	adcs	r1, r3
 80016dc:	2006      	movs	r0, #6
 80016de:	f7ff fa3f 	bl	8000b60 <_test_assert>
 80016e2:	2800      	cmp	r0, #0
 80016e4:	d000      	beq.n	80016e8 <queues2_execute.10392+0x1f8>
 80016e6:	e0d1      	b.n	800188c <queues2_execute.10392+0x39c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016e8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80016ea:	f002 f9d9 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80016ee:	f7fe ffbf 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 80016f2:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 80016f4:	2007      	movs	r0, #7
 80016f6:	424b      	negs	r3, r1
 80016f8:	4159      	adcs	r1, r3
 80016fa:	f7ff fa31 	bl	8000b60 <_test_assert>
 80016fe:	2800      	cmp	r0, #0
 8001700:	d000      	beq.n	8001704 <queues2_execute.10392+0x214>
 8001702:	e10e      	b.n	8001922 <queues2_execute.10392+0x432>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001704:	f002 f934 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001708:	6820      	ldr	r0, [r4, #0]
 800170a:	42a0      	cmp	r0, r4
 800170c:	d005      	beq.n	800171a <queues2_execute.10392+0x22a>
 800170e:	69a2      	ldr	r2, [r4, #24]
 8001710:	6883      	ldr	r3, [r0, #8]
 8001712:	6891      	ldr	r1, [r2, #8]
 8001714:	4299      	cmp	r1, r3
 8001716:	d200      	bcs.n	800171a <queues2_execute.10392+0x22a>
 8001718:	e111      	b.n	800193e <queues2_execute.10392+0x44e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800171a:	b662      	cpsie	i
 800171c:	69a0      	ldr	r0, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800171e:	2100      	movs	r1, #0
 8001720:	6882      	ldr	r2, [r0, #8]
 8001722:	23a8      	movs	r3, #168	; 0xa8
 8001724:	9100      	str	r1, [sp, #0]
 8001726:	3201      	adds	r2, #1
 8001728:	0059      	lsls	r1, r3, #1
 800172a:	1c30      	adds	r0, r6, #0
 800172c:	4b4f      	ldr	r3, [pc, #316]	; (800186c <queues2_execute.10392+0x37c>)
 800172e:	f001 fb8f 	bl	8002e50 <chThdCreateStatic>
 8001732:	4a4f      	ldr	r2, [pc, #316]	; (8001870 <queues2_execute.10392+0x380>)
 8001734:	6010      	str	r0, [r2, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001736:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001738:	f002 f9b2 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800173c:	f7fe ff98 	bl	8000670 <chDbgCheckClassI>

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 8001740:	6928      	ldr	r0, [r5, #16]
 8001742:	68e9      	ldr	r1, [r5, #12]
 8001744:	68ab      	ldr	r3, [r5, #8]
 8001746:	1a42      	subs	r2, r0, r1
 8001748:	1ad1      	subs	r1, r2, r3
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 800174a:	3904      	subs	r1, #4
 800174c:	424b      	negs	r3, r1
 800174e:	4159      	adcs	r1, r3
 8001750:	2008      	movs	r0, #8
 8001752:	f7ff fa05 	bl	8000b60 <_test_assert>
 8001756:	2800      	cmp	r0, #0
 8001758:	d000      	beq.n	800175c <queues2_execute.10392+0x26c>
 800175a:	e0c8      	b.n	80018ee <queues2_execute.10392+0x3fe>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800175c:	f002 f908 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001760:	6823      	ldr	r3, [r4, #0]
 8001762:	42a3      	cmp	r3, r4
 8001764:	d005      	beq.n	8001772 <queues2_execute.10392+0x282>
 8001766:	69a0      	ldr	r0, [r4, #24]
 8001768:	689a      	ldr	r2, [r3, #8]
 800176a:	6881      	ldr	r1, [r0, #8]
 800176c:	4291      	cmp	r1, r2
 800176e:	d200      	bcs.n	8001772 <queues2_execute.10392+0x282>
 8001770:	e0cb      	b.n	800190a <queues2_execute.10392+0x41a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001772:	b662      	cpsie	i
  test_wait_threads();
 8001774:	f000 f9dc 	bl	8001b30 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001778:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800177a:	f002 f991 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800177e:	f7fe ff77 	bl	8000670 <chDbgCheckClassI>

  oqp->q_rdptr = oqp->q_buffer;
 8001782:	68eb      	ldr	r3, [r5, #12]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 8001784:	6928      	ldr	r0, [r5, #16]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8001786:	61ab      	str	r3, [r5, #24]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 8001788:	1ac1      	subs	r1, r0, r3
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800178a:	1c28      	adds	r0, r5, #0
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 800178c:	616b      	str	r3, [r5, #20]
  oqp->q_counter = chQSizeX(oqp);
 800178e:	60a9      	str	r1, [r5, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8001790:	f001 fdc6 	bl	8003320 <chThdDequeueAllI.constprop.72>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001794:	f002 f8ec 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001798:	6823      	ldr	r3, [r4, #0]
 800179a:	42a3      	cmp	r3, r4
 800179c:	d005      	beq.n	80017aa <queues2_execute.10392+0x2ba>
 800179e:	69a2      	ldr	r2, [r4, #24]
 80017a0:	6899      	ldr	r1, [r3, #8]
 80017a2:	6890      	ldr	r0, [r2, #8]
 80017a4:	4288      	cmp	r0, r1
 80017a6:	d200      	bcs.n	80017aa <queues2_execute.10392+0x2ba>
 80017a8:	e0b3      	b.n	8001912 <queues2_execute.10392+0x422>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80017aa:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80017ac:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80017ae:	f002 f977 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80017b2:	f7fe ff5d 	bl	8000670 <chDbgCheckClassI>

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 80017b6:	68e8      	ldr	r0, [r5, #12]
 80017b8:	692a      	ldr	r2, [r5, #16]
 80017ba:	68ab      	ldr	r3, [r5, #8]
 80017bc:	1a11      	subs	r1, r2, r0

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 80017be:	1ac9      	subs	r1, r1, r3
 80017c0:	424b      	negs	r3, r1
 80017c2:	4159      	adcs	r1, r3
 80017c4:	2009      	movs	r0, #9
 80017c6:	f7ff f9cb 	bl	8000b60 <_test_assert>
 80017ca:	2800      	cmp	r0, #0
 80017cc:	d000      	beq.n	80017d0 <queues2_execute.10392+0x2e0>
 80017ce:	e07d      	b.n	80018cc <queues2_execute.10392+0x3dc>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80017d0:	f002 f8ce 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80017d4:	6823      	ldr	r3, [r4, #0]
 80017d6:	42a3      	cmp	r3, r4
 80017d8:	d005      	beq.n	80017e6 <queues2_execute.10392+0x2f6>
 80017da:	69a2      	ldr	r2, [r4, #24]
 80017dc:	6899      	ldr	r1, [r3, #8]
 80017de:	6890      	ldr	r0, [r2, #8]
 80017e0:	4288      	cmp	r0, r1
 80017e2:	d200      	bcs.n	80017e6 <queues2_execute.10392+0x2f6>
 80017e4:	e099      	b.n	800191a <queues2_execute.10392+0x42a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80017e6:	b662      	cpsie	i
 80017e8:	3651      	adds	r6, #81	; 0x51
 80017ea:	36ff      	adds	r6, #255	; 0xff

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80017ec:	1c31      	adds	r1, r6, #0
 80017ee:	2300      	movs	r3, #0
 80017f0:	1c28      	adds	r0, r5, #0
 80017f2:	2202      	movs	r2, #2
 80017f4:	f002 faf4 	bl	8003de0 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80017f8:	1e81      	subs	r1, r0, #2
 80017fa:	424b      	negs	r3, r1
 80017fc:	4159      	adcs	r1, r3
 80017fe:	200a      	movs	r0, #10
 8001800:	f7ff f9ae 	bl	8000b60 <_test_assert>
 8001804:	2800      	cmp	r0, #0
 8001806:	d141      	bne.n	800188c <queues2_execute.10392+0x39c>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8001808:	1c31      	adds	r1, r6, #0
 800180a:	2300      	movs	r3, #0
 800180c:	1c28      	adds	r0, r5, #0
 800180e:	2202      	movs	r2, #2
 8001810:	f002 fae6 	bl	8003de0 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8001814:	1e81      	subs	r1, r0, #2
 8001816:	424b      	negs	r3, r1
 8001818:	4159      	adcs	r1, r3
 800181a:	200b      	movs	r0, #11
 800181c:	f7ff f9a0 	bl	8000b60 <_test_assert>
 8001820:	2800      	cmp	r0, #0
 8001822:	d133      	bne.n	800188c <queues2_execute.10392+0x39c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001824:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001826:	f002 f93b 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800182a:	f7fe ff21 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 800182e:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 8001830:	200c      	movs	r0, #12
 8001832:	424b      	negs	r3, r1
 8001834:	4159      	adcs	r1, r3
 8001836:	f7ff f993 	bl	8000b60 <_test_assert>
 800183a:	2800      	cmp	r0, #0
 800183c:	d154      	bne.n	80018e8 <queues2_execute.10392+0x3f8>
 800183e:	f002 f917 	bl	8003a70 <chSysUnlock.10381>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 8001842:	1c28      	adds	r0, r5, #0
 8001844:	2100      	movs	r1, #0
 8001846:	220a      	movs	r2, #10
 8001848:	f004 fcb2 	bl	80061b0 <chOQPutTimeout>
 800184c:	1c41      	adds	r1, r0, #1
 800184e:	424b      	negs	r3, r1
 8001850:	4159      	adcs	r1, r3
 8001852:	200d      	movs	r0, #13
 8001854:	f7ff f984 	bl	8000b60 <_test_assert>
 8001858:	e018      	b.n	800188c <queues2_execute.10392+0x39c>
 800185a:	46c0      	nop			; (mov r8, r8)
 800185c:	20000628 	.word	0x20000628
 8001860:	20001040 	.word	0x20001040
 8001864:	080085e0 	.word	0x080085e0
 8001868:	200006b8 	.word	0x200006b8
 800186c:	08006271 	.word	0x08006271
 8001870:	200015b8 	.word	0x200015b8
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001874:	f002 f87c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001878:	4c4b      	ldr	r4, [pc, #300]	; (80019a8 <queues2_execute.10392+0x4b8>)
 800187a:	6820      	ldr	r0, [r4, #0]
 800187c:	42a0      	cmp	r0, r4
 800187e:	d004      	beq.n	800188a <queues2_execute.10392+0x39a>
 8001880:	69a2      	ldr	r2, [r4, #24]
 8001882:	6885      	ldr	r5, [r0, #8]
 8001884:	6891      	ldr	r1, [r2, #8]
 8001886:	42a9      	cmp	r1, r5
 8001888:	d310      	bcc.n	80018ac <queues2_execute.10392+0x3bc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800188a:	b662      	cpsie	i
}
 800188c:	b002      	add	sp, #8
 800188e:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001890:	f002 f86e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001894:	6820      	ldr	r0, [r4, #0]
 8001896:	42a0      	cmp	r0, r4
 8001898:	d0f7      	beq.n	800188a <queues2_execute.10392+0x39a>
 800189a:	69a2      	ldr	r2, [r4, #24]
 800189c:	6885      	ldr	r5, [r0, #8]
 800189e:	6891      	ldr	r1, [r2, #8]
 80018a0:	42a9      	cmp	r1, r5
 80018a2:	d2f2      	bcs.n	800188a <queues2_execute.10392+0x39a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80018a4:	b672      	cpsid	i
 80018a6:	4e41      	ldr	r6, [pc, #260]	; (80019ac <queues2_execute.10392+0x4bc>)
 80018a8:	62e6      	str	r6, [r4, #44]	; 0x2c
 80018aa:	e7fe      	b.n	80018aa <queues2_execute.10392+0x3ba>
 80018ac:	b672      	cpsid	i
 80018ae:	4e3f      	ldr	r6, [pc, #252]	; (80019ac <queues2_execute.10392+0x4bc>)
 80018b0:	62e6      	str	r6, [r4, #44]	; 0x2c
 80018b2:	e7fe      	b.n	80018b2 <queues2_execute.10392+0x3c2>
 80018b4:	b672      	cpsid	i
 80018b6:	4b3d      	ldr	r3, [pc, #244]	; (80019ac <queues2_execute.10392+0x4bc>)
 80018b8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80018ba:	e7fe      	b.n	80018ba <queues2_execute.10392+0x3ca>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80018bc:	68a9      	ldr	r1, [r5, #8]
 80018be:	1e4b      	subs	r3, r1, #1
 80018c0:	4199      	sbcs	r1, r3
 80018c2:	e623      	b.n	800150c <queues2_execute.10392+0x1c>
 80018c4:	b672      	cpsid	i
 80018c6:	4b39      	ldr	r3, [pc, #228]	; (80019ac <queues2_execute.10392+0x4bc>)
 80018c8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80018ca:	e7fe      	b.n	80018ca <queues2_execute.10392+0x3da>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80018cc:	f002 f850 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80018d0:	6826      	ldr	r6, [r4, #0]
 80018d2:	42a6      	cmp	r6, r4
 80018d4:	d0d9      	beq.n	800188a <queues2_execute.10392+0x39a>
 80018d6:	69a3      	ldr	r3, [r4, #24]
 80018d8:	68b0      	ldr	r0, [r6, #8]
 80018da:	689a      	ldr	r2, [r3, #8]
 80018dc:	4282      	cmp	r2, r0
 80018de:	d2d4      	bcs.n	800188a <queues2_execute.10392+0x39a>
 80018e0:	b672      	cpsid	i
 80018e2:	4932      	ldr	r1, [pc, #200]	; (80019ac <queues2_execute.10392+0x4bc>)
 80018e4:	62e1      	str	r1, [r4, #44]	; 0x2c
 80018e6:	e7fe      	b.n	80018e6 <queues2_execute.10392+0x3f6>
  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 80018e8:	f002 f8c2 	bl	8003a70 <chSysUnlock.10381>
 80018ec:	e7ce      	b.n	800188c <queues2_execute.10392+0x39c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80018ee:	f002 f83f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80018f2:	6823      	ldr	r3, [r4, #0]
 80018f4:	42a3      	cmp	r3, r4
 80018f6:	d0c8      	beq.n	800188a <queues2_execute.10392+0x39a>
 80018f8:	69a2      	ldr	r2, [r4, #24]
 80018fa:	6899      	ldr	r1, [r3, #8]
 80018fc:	6890      	ldr	r0, [r2, #8]
 80018fe:	4288      	cmp	r0, r1
 8001900:	d2c3      	bcs.n	800188a <queues2_execute.10392+0x39a>
 8001902:	b672      	cpsid	i
 8001904:	4d29      	ldr	r5, [pc, #164]	; (80019ac <queues2_execute.10392+0x4bc>)
 8001906:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001908:	e7fe      	b.n	8001908 <queues2_execute.10392+0x418>
 800190a:	b672      	cpsid	i
 800190c:	4e27      	ldr	r6, [pc, #156]	; (80019ac <queues2_execute.10392+0x4bc>)
 800190e:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001910:	e7fe      	b.n	8001910 <queues2_execute.10392+0x420>
 8001912:	b672      	cpsid	i
 8001914:	4d25      	ldr	r5, [pc, #148]	; (80019ac <queues2_execute.10392+0x4bc>)
 8001916:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001918:	e7fe      	b.n	8001918 <queues2_execute.10392+0x428>
 800191a:	b672      	cpsid	i
 800191c:	4d23      	ldr	r5, [pc, #140]	; (80019ac <queues2_execute.10392+0x4bc>)
 800191e:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001920:	e7fe      	b.n	8001920 <queues2_execute.10392+0x430>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001922:	f002 f825 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001926:	6823      	ldr	r3, [r4, #0]
 8001928:	42a3      	cmp	r3, r4
 800192a:	d0ae      	beq.n	800188a <queues2_execute.10392+0x39a>
 800192c:	69a2      	ldr	r2, [r4, #24]
 800192e:	6899      	ldr	r1, [r3, #8]
 8001930:	6890      	ldr	r0, [r2, #8]
 8001932:	4288      	cmp	r0, r1
 8001934:	d2a9      	bcs.n	800188a <queues2_execute.10392+0x39a>
 8001936:	b672      	cpsid	i
 8001938:	4d1c      	ldr	r5, [pc, #112]	; (80019ac <queues2_execute.10392+0x4bc>)
 800193a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800193c:	e7fe      	b.n	800193c <queues2_execute.10392+0x44c>
 800193e:	b672      	cpsid	i
 8001940:	4e1a      	ldr	r6, [pc, #104]	; (80019ac <queues2_execute.10392+0x4bc>)
 8001942:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001944:	e7fe      	b.n	8001944 <queues2_execute.10392+0x454>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001946:	f002 f813 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800194a:	6823      	ldr	r3, [r4, #0]
 800194c:	42a3      	cmp	r3, r4
 800194e:	d100      	bne.n	8001952 <queues2_execute.10392+0x462>
 8001950:	e79b      	b.n	800188a <queues2_execute.10392+0x39a>
 8001952:	69a2      	ldr	r2, [r4, #24]
 8001954:	6899      	ldr	r1, [r3, #8]
 8001956:	6890      	ldr	r0, [r2, #8]
 8001958:	4288      	cmp	r0, r1
 800195a:	d300      	bcc.n	800195e <queues2_execute.10392+0x46e>
 800195c:	e795      	b.n	800188a <queues2_execute.10392+0x39a>
 800195e:	b672      	cpsid	i
 8001960:	4d12      	ldr	r5, [pc, #72]	; (80019ac <queues2_execute.10392+0x4bc>)
 8001962:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001964:	e7fe      	b.n	8001964 <queues2_execute.10392+0x474>
 8001966:	b672      	cpsid	i
 8001968:	4e10      	ldr	r6, [pc, #64]	; (80019ac <queues2_execute.10392+0x4bc>)
 800196a:	62e6      	str	r6, [r4, #44]	; 0x2c
 800196c:	e7fe      	b.n	800196c <queues2_execute.10392+0x47c>
 800196e:	68a9      	ldr	r1, [r5, #8]
 8001970:	1e4b      	subs	r3, r1, #1
 8001972:	4199      	sbcs	r1, r3
 8001974:	e672      	b.n	800165c <queues2_execute.10392+0x16c>
 8001976:	b672      	cpsid	i
 8001978:	4e0c      	ldr	r6, [pc, #48]	; (80019ac <queues2_execute.10392+0x4bc>)
 800197a:	62e6      	str	r6, [r4, #44]	; 0x2c
 800197c:	e7fe      	b.n	800197c <queues2_execute.10392+0x48c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800197e:	f001 fff7 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001982:	6823      	ldr	r3, [r4, #0]
 8001984:	42a3      	cmp	r3, r4
 8001986:	d100      	bne.n	800198a <queues2_execute.10392+0x49a>
 8001988:	e77f      	b.n	800188a <queues2_execute.10392+0x39a>
 800198a:	69a2      	ldr	r2, [r4, #24]
 800198c:	6899      	ldr	r1, [r3, #8]
 800198e:	6890      	ldr	r0, [r2, #8]
 8001990:	4288      	cmp	r0, r1
 8001992:	d300      	bcc.n	8001996 <queues2_execute.10392+0x4a6>
 8001994:	e779      	b.n	800188a <queues2_execute.10392+0x39a>
 8001996:	b672      	cpsid	i
 8001998:	4d04      	ldr	r5, [pc, #16]	; (80019ac <queues2_execute.10392+0x4bc>)
 800199a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800199c:	e7fe      	b.n	800199c <queues2_execute.10392+0x4ac>
 800199e:	b672      	cpsid	i
 80019a0:	4e02      	ldr	r6, [pc, #8]	; (80019ac <queues2_execute.10392+0x4bc>)
 80019a2:	62e6      	str	r6, [r4, #44]	; 0x2c
 80019a4:	e7fe      	b.n	80019a4 <queues2_execute.10392+0x4b4>
 80019a6:	46c0      	nop			; (mov r8, r8)
 80019a8:	20001040 	.word	0x20001040
 80019ac:	080085f0 	.word	0x080085f0

080019b0 <chThdRelease.4196>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80019b0:	b570      	push	{r4, r5, r6, lr}
 80019b2:	1c04      	adds	r4, r0, #0
 80019b4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80019b6:	f002 f873 	bl	8003aa0 <_dbg_check_lock>
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
 80019ba:	2222      	movs	r2, #34	; 0x22
 80019bc:	5ca3      	ldrb	r3, [r4, r2]
 80019be:	2b00      	cmp	r3, #0
 80019c0:	d015      	beq.n	80019ee <chThdRelease.4196+0x3e>
  tp->p_refs--;
 80019c2:	3b01      	subs	r3, #1
 80019c4:	b2d8      	uxtb	r0, r3
 80019c6:	54a0      	strb	r0, [r4, r2]
  refs = tp->p_refs;

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 80019c8:	2800      	cmp	r0, #0
 80019ca:	d103      	bne.n	80019d4 <chThdRelease.4196+0x24>
 80019cc:	2120      	movs	r1, #32
 80019ce:	5c65      	ldrb	r5, [r4, r1]
 80019d0:	2d0f      	cmp	r5, #15
 80019d2:	d015      	beq.n	8001a00 <chThdRelease.4196+0x50>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80019d4:	f001 ffcc 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80019d8:	4c2f      	ldr	r4, [pc, #188]	; (8001a98 <chThdRelease.4196+0xe8>)
 80019da:	6820      	ldr	r0, [r4, #0]
 80019dc:	42a0      	cmp	r0, r4
 80019de:	d004      	beq.n	80019ea <chThdRelease.4196+0x3a>
 80019e0:	69a1      	ldr	r1, [r4, #24]
 80019e2:	6886      	ldr	r6, [r0, #8]
 80019e4:	688d      	ldr	r5, [r1, #8]
 80019e6:	42b5      	cmp	r5, r6
 80019e8:	d306      	bcc.n	80019f8 <chThdRelease.4196+0x48>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80019ea:	b662      	cpsie	i
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
}
 80019ec:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80019ee:	b672      	cpsid	i
 80019f0:	482a      	ldr	r0, [pc, #168]	; (8001a9c <chThdRelease.4196+0xec>)
 80019f2:	4b29      	ldr	r3, [pc, #164]	; (8001a98 <chThdRelease.4196+0xe8>)
 80019f4:	62d8      	str	r0, [r3, #44]	; 0x2c
 80019f6:	e7fe      	b.n	80019f6 <chThdRelease.4196+0x46>
 80019f8:	b672      	cpsid	i
 80019fa:	4b29      	ldr	r3, [pc, #164]	; (8001aa0 <chThdRelease.4196+0xf0>)
 80019fc:	62e3      	str	r3, [r4, #44]	; 0x2c
 80019fe:	e7fe      	b.n	80019fe <chThdRelease.4196+0x4e>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8001a00:	2621      	movs	r6, #33	; 0x21
 8001a02:	5da3      	ldrb	r3, [r4, r6]
 8001a04:	2203      	movs	r2, #3
 8001a06:	4013      	ands	r3, r2
 8001a08:	2b01      	cmp	r3, #1
 8001a0a:	d028      	beq.n	8001a5e <chThdRelease.4196+0xae>
 8001a0c:	2b02      	cmp	r3, #2
 8001a0e:	d1e1      	bne.n	80019d4 <chThdRelease.4196+0x24>
      return;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001a10:	6960      	ldr	r0, [r4, #20]
 8001a12:	6922      	ldr	r2, [r4, #16]
 8001a14:	6102      	str	r2, [r0, #16]
 8001a16:	6921      	ldr	r1, [r4, #16]
 8001a18:	6148      	str	r0, [r1, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001a1a:	f001 ffa9 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001a1e:	4d1e      	ldr	r5, [pc, #120]	; (8001a98 <chThdRelease.4196+0xe8>)
 8001a20:	682e      	ldr	r6, [r5, #0]
 8001a22:	42ae      	cmp	r6, r5
 8001a24:	d004      	beq.n	8001a30 <chThdRelease.4196+0x80>
 8001a26:	69ab      	ldr	r3, [r5, #24]
 8001a28:	68b2      	ldr	r2, [r6, #8]
 8001a2a:	6898      	ldr	r0, [r3, #8]
 8001a2c:	4290      	cmp	r0, r2
 8001a2e:	d32b      	bcc.n	8001a88 <chThdRelease.4196+0xd8>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a30:	b662      	cpsie	i
#endif
      chSysUnlock();
      chPoolFree(tp->p_mpool, tp);
 8001a32:	6c66      	ldr	r6, [r4, #68]	; 0x44
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a34:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001a36:	f002 f833 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 8001a3a:	1c21      	adds	r1, r4, #0
 8001a3c:	1c30      	adds	r0, r6, #0
 8001a3e:	f7fe feef 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001a42:	f001 ff95 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001a46:	682c      	ldr	r4, [r5, #0]
 8001a48:	42ac      	cmp	r4, r5
 8001a4a:	d0ce      	beq.n	80019ea <chThdRelease.4196+0x3a>
 8001a4c:	69a9      	ldr	r1, [r5, #24]
 8001a4e:	68a3      	ldr	r3, [r4, #8]
 8001a50:	6888      	ldr	r0, [r1, #8]
 8001a52:	4298      	cmp	r0, r3
 8001a54:	d2c9      	bcs.n	80019ea <chThdRelease.4196+0x3a>
 8001a56:	b672      	cpsid	i
 8001a58:	4a12      	ldr	r2, [pc, #72]	; (8001aa4 <chThdRelease.4196+0xf4>)
 8001a5a:	62ea      	str	r2, [r5, #44]	; 0x2c
 8001a5c:	e7fe      	b.n	8001a5c <chThdRelease.4196+0xac>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001a5e:	6965      	ldr	r5, [r4, #20]
 8001a60:	6921      	ldr	r1, [r4, #16]
 8001a62:	6129      	str	r1, [r5, #16]
 8001a64:	6920      	ldr	r0, [r4, #16]
 8001a66:	6145      	str	r5, [r0, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001a68:	f001 ff82 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001a6c:	4b0a      	ldr	r3, [pc, #40]	; (8001a98 <chThdRelease.4196+0xe8>)
 8001a6e:	681a      	ldr	r2, [r3, #0]
 8001a70:	429a      	cmp	r2, r3
 8001a72:	d004      	beq.n	8001a7e <chThdRelease.4196+0xce>
 8001a74:	699e      	ldr	r6, [r3, #24]
 8001a76:	6891      	ldr	r1, [r2, #8]
 8001a78:	68b5      	ldr	r5, [r6, #8]
 8001a7a:	428d      	cmp	r5, r1
 8001a7c:	d308      	bcc.n	8001a90 <chThdRelease.4196+0xe0>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a7e:	b662      	cpsie	i
#endif
      chSysUnlock();
      chHeapFree(tp);
 8001a80:	1c20      	adds	r0, r4, #0
 8001a82:	f000 ff85 	bl	8002990 <chHeapFree>
 8001a86:	e7b1      	b.n	80019ec <chThdRelease.4196+0x3c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a88:	b672      	cpsid	i
 8001a8a:	4e05      	ldr	r6, [pc, #20]	; (8001aa0 <chThdRelease.4196+0xf0>)
 8001a8c:	62ee      	str	r6, [r5, #44]	; 0x2c
 8001a8e:	e7fe      	b.n	8001a8e <chThdRelease.4196+0xde>
 8001a90:	b672      	cpsid	i
 8001a92:	4c03      	ldr	r4, [pc, #12]	; (8001aa0 <chThdRelease.4196+0xf0>)
 8001a94:	62dc      	str	r4, [r3, #44]	; 0x2c
 8001a96:	e7fe      	b.n	8001a96 <chThdRelease.4196+0xe6>
 8001a98:	20001040 	.word	0x20001040
 8001a9c:	08008640 	.word	0x08008640
 8001aa0:	080086a0 	.word	0x080086a0
 8001aa4:	08008980 	.word	0x08008980
 8001aa8:	46c0      	nop			; (mov r8, r8)
 8001aaa:	46c0      	nop			; (mov r8, r8)
 8001aac:	46c0      	nop			; (mov r8, r8)
 8001aae:	46c0      	nop			; (mov r8, r8)

08001ab0 <chThdWait.4165>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001ab0:	b570      	push	{r4, r5, r6, lr}
 8001ab2:	1c04      	adds	r4, r0, #0
 8001ab4:	b672      	cpsid	i
  msg_t msg;

  chDbgCheck(tp != NULL);
 8001ab6:	2800      	cmp	r0, #0
 8001ab8:	d030      	beq.n	8001b1c <chThdWait.4165+0x6c>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001aba:	f001 fff1 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
 8001abe:	4d19      	ldr	r5, [pc, #100]	; (8001b24 <chThdWait.4165+0x74>)
 8001ac0:	69ab      	ldr	r3, [r5, #24]
 8001ac2:	42a3      	cmp	r3, r4
 8001ac4:	d026      	beq.n	8001b14 <chThdWait.4165+0x64>
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
 8001ac6:	2222      	movs	r2, #34	; 0x22
 8001ac8:	5ca0      	ldrb	r0, [r4, r2]
 8001aca:	2800      	cmp	r0, #0
 8001acc:	d01e      	beq.n	8001b0c <chThdWait.4165+0x5c>
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 8001ace:	2120      	movs	r1, #32
 8001ad0:	5c66      	ldrb	r6, [r4, r1]
 8001ad2:	2e0f      	cmp	r6, #15
 8001ad4:	d005      	beq.n	8001ae2 <chThdWait.4165+0x32>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 8001ad6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    list_insert(currp, &tp->p_waiting);
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001ad8:	2009      	movs	r0, #9
 8001ada:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8001adc:	62a3      	str	r3, [r4, #40]	; 0x28
 8001ade:	f7ff f9f7 	bl	8000ed0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001ae2:	6a66      	ldr	r6, [r4, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001ae4:	f001 ff44 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001ae8:	682b      	ldr	r3, [r5, #0]
 8001aea:	42ab      	cmp	r3, r5
 8001aec:	d004      	beq.n	8001af8 <chThdWait.4165+0x48>
 8001aee:	69a8      	ldr	r0, [r5, #24]
 8001af0:	689a      	ldr	r2, [r3, #8]
 8001af2:	6881      	ldr	r1, [r0, #8]
 8001af4:	4291      	cmp	r1, r2
 8001af6:	d305      	bcc.n	8001b04 <chThdWait.4165+0x54>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001af8:	b662      	cpsie	i
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001afa:	1c20      	adds	r0, r4, #0
 8001afc:	f7ff ff58 	bl	80019b0 <chThdRelease.4196>
#endif

  return msg;
}
 8001b00:	1c30      	adds	r0, r6, #0
 8001b02:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001b04:	b672      	cpsid	i
 8001b06:	4c08      	ldr	r4, [pc, #32]	; (8001b28 <chThdWait.4165+0x78>)
 8001b08:	62ec      	str	r4, [r5, #44]	; 0x2c
 8001b0a:	e7fe      	b.n	8001b0a <chThdWait.4165+0x5a>
 8001b0c:	b672      	cpsid	i
 8001b0e:	4e07      	ldr	r6, [pc, #28]	; (8001b2c <chThdWait.4165+0x7c>)
 8001b10:	62ee      	str	r6, [r5, #44]	; 0x2c
 8001b12:	e7fe      	b.n	8001b12 <chThdWait.4165+0x62>
 8001b14:	b672      	cpsid	i
 8001b16:	4b05      	ldr	r3, [pc, #20]	; (8001b2c <chThdWait.4165+0x7c>)
 8001b18:	62eb      	str	r3, [r5, #44]	; 0x2c
 8001b1a:	e7fe      	b.n	8001b1a <chThdWait.4165+0x6a>
 8001b1c:	4d03      	ldr	r5, [pc, #12]	; (8001b2c <chThdWait.4165+0x7c>)
 8001b1e:	4801      	ldr	r0, [pc, #4]	; (8001b24 <chThdWait.4165+0x74>)
 8001b20:	62c5      	str	r5, [r0, #44]	; 0x2c
 8001b22:	e7fe      	b.n	8001b22 <chThdWait.4165+0x72>
 8001b24:	20001040 	.word	0x20001040
 8001b28:	08008b00 	.word	0x08008b00
 8001b2c:	08008610 	.word	0x08008610

08001b30 <test_wait_threads>:
}

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8001b30:	b510      	push	{r4, lr}
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001b32:	4c12      	ldr	r4, [pc, #72]	; (8001b7c <test_wait_threads+0x4c>)
 8001b34:	6820      	ldr	r0, [r4, #0]
 8001b36:	2800      	cmp	r0, #0
 8001b38:	d003      	beq.n	8001b42 <test_wait_threads+0x12>
      chThdWait(threads[i]);
 8001b3a:	f7ff ffb9 	bl	8001ab0 <chThdWait.4165>
      threads[i] = NULL;
 8001b3e:	2300      	movs	r3, #0
 8001b40:	6023      	str	r3, [r4, #0]
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001b42:	6860      	ldr	r0, [r4, #4]
 8001b44:	2800      	cmp	r0, #0
 8001b46:	d003      	beq.n	8001b50 <test_wait_threads+0x20>
      chThdWait(threads[i]);
 8001b48:	f7ff ffb2 	bl	8001ab0 <chThdWait.4165>
      threads[i] = NULL;
 8001b4c:	2000      	movs	r0, #0
 8001b4e:	6060      	str	r0, [r4, #4]
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001b50:	68a0      	ldr	r0, [r4, #8]
 8001b52:	2800      	cmp	r0, #0
 8001b54:	d003      	beq.n	8001b5e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 8001b56:	f7ff ffab 	bl	8001ab0 <chThdWait.4165>
      threads[i] = NULL;
 8001b5a:	2100      	movs	r1, #0
 8001b5c:	60a1      	str	r1, [r4, #8]
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001b5e:	68e0      	ldr	r0, [r4, #12]
 8001b60:	2800      	cmp	r0, #0
 8001b62:	d003      	beq.n	8001b6c <test_wait_threads+0x3c>
      chThdWait(threads[i]);
 8001b64:	f7ff ffa4 	bl	8001ab0 <chThdWait.4165>
      threads[i] = NULL;
 8001b68:	2200      	movs	r2, #0
 8001b6a:	60e2      	str	r2, [r4, #12]
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001b6c:	6920      	ldr	r0, [r4, #16]
 8001b6e:	2800      	cmp	r0, #0
 8001b70:	d003      	beq.n	8001b7a <test_wait_threads+0x4a>
      chThdWait(threads[i]);
 8001b72:	f7ff ff9d 	bl	8001ab0 <chThdWait.4165>
      threads[i] = NULL;
 8001b76:	2300      	movs	r3, #0
 8001b78:	6123      	str	r3, [r4, #16]
    }
}
 8001b7a:	bd10      	pop	{r4, pc}
 8001b7c:	200015b8 	.word	0x200015b8

08001b80 <bmk7_execute.10823>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001b80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001b82:	4647      	mov	r7, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001b84:	4c4e      	ldr	r4, [pc, #312]	; (8001cc0 <bmk7_execute.10823+0x140>)
 8001b86:	b480      	push	{r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001b88:	69a0      	ldr	r0, [r4, #24]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001b8a:	4e4e      	ldr	r6, [pc, #312]	; (8001cc4 <bmk7_execute.10823+0x144>)
 8001b8c:	4b4e      	ldr	r3, [pc, #312]	; (8001cc8 <bmk7_execute.10823+0x148>)
 8001b8e:	6882      	ldr	r2, [r0, #8]
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001b90:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001b92:	2700      	movs	r7, #0
 8001b94:	21a8      	movs	r1, #168	; 0xa8
 8001b96:	4698      	mov	r8, r3
 8001b98:	3205      	adds	r2, #5
 8001b9a:	9700      	str	r7, [sp, #0]
 8001b9c:	1c18      	adds	r0, r3, #0
 8001b9e:	0049      	lsls	r1, r1, #1
 8001ba0:	1c33      	adds	r3, r6, #0
 8001ba2:	f001 f955 	bl	8002e50 <chThdCreateStatic>
 8001ba6:	4d49      	ldr	r5, [pc, #292]	; (8001ccc <bmk7_execute.10823+0x14c>)
 8001ba8:	69a2      	ldr	r2, [r4, #24]
 8001baa:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001bac:	6892      	ldr	r2, [r2, #8]
 8001bae:	4640      	mov	r0, r8
 8001bb0:	23a8      	movs	r3, #168	; 0xa8
 8001bb2:	3051      	adds	r0, #81	; 0x51
 8001bb4:	0059      	lsls	r1, r3, #1
 8001bb6:	3204      	adds	r2, #4
 8001bb8:	1c33      	adds	r3, r6, #0
 8001bba:	9700      	str	r7, [sp, #0]
 8001bbc:	30ff      	adds	r0, #255	; 0xff
 8001bbe:	f001 f947 	bl	8002e50 <chThdCreateStatic>
 8001bc2:	69a2      	ldr	r2, [r4, #24]
 8001bc4:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001bc6:	20a8      	movs	r0, #168	; 0xa8
 8001bc8:	6892      	ldr	r2, [r2, #8]
 8001bca:	0081      	lsls	r1, r0, #2
 8001bcc:	1c08      	adds	r0, r1, #0
 8001bce:	23a8      	movs	r3, #168	; 0xa8
 8001bd0:	0059      	lsls	r1, r3, #1
 8001bd2:	3203      	adds	r2, #3
 8001bd4:	1c33      	adds	r3, r6, #0
 8001bd6:	9700      	str	r7, [sp, #0]
 8001bd8:	4440      	add	r0, r8
 8001bda:	f001 f939 	bl	8002e50 <chThdCreateStatic>
 8001bde:	69a2      	ldr	r2, [r4, #24]
 8001be0:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001be2:	20fc      	movs	r0, #252	; 0xfc
 8001be4:	6892      	ldr	r2, [r2, #8]
 8001be6:	0081      	lsls	r1, r0, #2
 8001be8:	1c08      	adds	r0, r1, #0
 8001bea:	23a8      	movs	r3, #168	; 0xa8
 8001bec:	0059      	lsls	r1, r3, #1
 8001bee:	3202      	adds	r2, #2
 8001bf0:	1c33      	adds	r3, r6, #0
 8001bf2:	9700      	str	r7, [sp, #0]
 8001bf4:	4440      	add	r0, r8
 8001bf6:	f001 f92b 	bl	8002e50 <chThdCreateStatic>
 8001bfa:	69a2      	ldr	r2, [r4, #24]
 8001bfc:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001bfe:	20a8      	movs	r0, #168	; 0xa8
 8001c00:	6892      	ldr	r2, [r2, #8]
 8001c02:	00c1      	lsls	r1, r0, #3
 8001c04:	1c08      	adds	r0, r1, #0
 8001c06:	9700      	str	r7, [sp, #0]
 8001c08:	27a8      	movs	r7, #168	; 0xa8
 8001c0a:	0079      	lsls	r1, r7, #1
 8001c0c:	1c33      	adds	r3, r6, #0
 8001c0e:	3201      	adds	r2, #1
 8001c10:	4440      	add	r0, r8
 8001c12:	f001 f91d 	bl	8002e50 <chThdCreateStatic>
 8001c16:	6128      	str	r0, [r5, #16]

  n = 0;
  test_wait_tick();
 8001c18:	f000 fd72 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 8001c1c:	f003 fe88 	bl	8005930 <test_start_timer.constprop.11>
 8001c20:	4e2b      	ldr	r6, [pc, #172]	; (8001cd0 <bmk7_execute.10823+0x150>)
 8001c22:	4f2c      	ldr	r7, [pc, #176]	; (8001cd4 <bmk7_execute.10823+0x154>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);

  n = 0;
 8001c24:	2500      	movs	r5, #0
 8001c26:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001c28:	f001 ff3a 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001c2c:	1c30      	adds	r0, r6, #0
 8001c2e:	2100      	movs	r1, #0
 8001c30:	f001 fd6e 	bl	8003710 <chSemResetI>
  chSchRescheduleS();
 8001c34:	f001 fc24 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001c38:	f001 fe9a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001c3c:	6823      	ldr	r3, [r4, #0]
 8001c3e:	42a3      	cmp	r3, r4
 8001c40:	d004      	beq.n	8001c4c <bmk7_execute.10823+0xcc>
 8001c42:	69a0      	ldr	r0, [r4, #24]
 8001c44:	689a      	ldr	r2, [r3, #8]
 8001c46:	6881      	ldr	r1, [r0, #8]
 8001c48:	4291      	cmp	r1, r2
 8001c4a:	d331      	bcc.n	8001cb0 <bmk7_execute.10823+0x130>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c4c:	b662      	cpsie	i
    chSemReset(&sem1, 0);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001c4e:	783b      	ldrb	r3, [r7, #0]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 8001c50:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001c52:	2b00      	cmp	r3, #0
 8001c54:	d0e7      	beq.n	8001c26 <bmk7_execute.10823+0xa6>
  test_terminate_threads();
 8001c56:	f002 f843 	bl	8003ce0 <test_terminate_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c5a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001c5c:	f001 ff20 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001c60:	1c30      	adds	r0, r6, #0
 8001c62:	2100      	movs	r1, #0
 8001c64:	f001 fd54 	bl	8003710 <chSemResetI>
  chSchRescheduleS();
 8001c68:	f001 fc0a 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001c6c:	f001 fe80 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001c70:	6826      	ldr	r6, [r4, #0]
 8001c72:	42a6      	cmp	r6, r4
 8001c74:	d004      	beq.n	8001c80 <bmk7_execute.10823+0x100>
 8001c76:	69a7      	ldr	r7, [r4, #24]
 8001c78:	68b1      	ldr	r1, [r6, #8]
 8001c7a:	68b8      	ldr	r0, [r7, #8]
 8001c7c:	4288      	cmp	r0, r1
 8001c7e:	d31b      	bcc.n	8001cb8 <bmk7_execute.10823+0x138>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c80:	b662      	cpsie	i
  chSemReset(&sem1, 0);
  test_wait_threads();
 8001c82:	f7ff ff55 	bl	8001b30 <test_wait_threads>

  test_print("--- Score : ");
 8001c86:	4814      	ldr	r0, [pc, #80]	; (8001cd8 <bmk7_execute.10823+0x158>)
 8001c88:	f7fe ffa2 	bl	8000bd0 <test_print>
  test_printn(n);
  test_print(" reschedules/S, ");
  test_printn(n * 6);
 8001c8c:	006c      	lsls	r4, r5, #1
  test_terminate_threads();
  chSemReset(&sem1, 0);
  test_wait_threads();

  test_print("--- Score : ");
  test_printn(n);
 8001c8e:	1c28      	adds	r0, r5, #0
 8001c90:	f7fe ffb6 	bl	8000c00 <test_printn>
  test_print(" reschedules/S, ");
  test_printn(n * 6);
 8001c94:	1965      	adds	r5, r4, r5
  chSemReset(&sem1, 0);
  test_wait_threads();

  test_print("--- Score : ");
  test_printn(n);
  test_print(" reschedules/S, ");
 8001c96:	4811      	ldr	r0, [pc, #68]	; (8001cdc <bmk7_execute.10823+0x15c>)
 8001c98:	f7fe ff9a 	bl	8000bd0 <test_print>
  test_printn(n * 6);
 8001c9c:	0068      	lsls	r0, r5, #1
 8001c9e:	f7fe ffaf 	bl	8000c00 <test_printn>
  test_println(" ctxswc/S");
 8001ca2:	480f      	ldr	r0, [pc, #60]	; (8001ce0 <bmk7_execute.10823+0x160>)
 8001ca4:	f7fe ff74 	bl	8000b90 <test_println>
}
 8001ca8:	b002      	add	sp, #8
 8001caa:	bc04      	pop	{r2}
 8001cac:	4690      	mov	r8, r2
 8001cae:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001cb0:	b672      	cpsid	i
 8001cb2:	4b0c      	ldr	r3, [pc, #48]	; (8001ce4 <bmk7_execute.10823+0x164>)
 8001cb4:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001cb6:	e7fe      	b.n	8001cb6 <bmk7_execute.10823+0x136>
 8001cb8:	b672      	cpsid	i
 8001cba:	4a0a      	ldr	r2, [pc, #40]	; (8001ce4 <bmk7_execute.10823+0x164>)
 8001cbc:	62e2      	str	r2, [r4, #44]	; 0x2c
 8001cbe:	e7fe      	b.n	8001cbe <bmk7_execute.10823+0x13e>
 8001cc0:	20001040 	.word	0x20001040
 8001cc4:	080025c1 	.word	0x080025c1
 8001cc8:	200006b8 	.word	0x200006b8
 8001ccc:	200015b8 	.word	0x200015b8
 8001cd0:	20000d48 	.word	0x20000d48
 8001cd4:	20000e18 	.word	0x20000e18
 8001cd8:	08008650 	.word	0x08008650
 8001cdc:	08008660 	.word	0x08008660
 8001ce0:	08008674 	.word	0x08008674
 8001ce4:	08008600 	.word	0x08008600
 8001ce8:	46c0      	nop			; (mov r8, r8)
 8001cea:	46c0      	nop			; (mov r8, r8)
 8001cec:	46c0      	nop			; (mov r8, r8)
 8001cee:	46c0      	nop			; (mov r8, r8)

08001cf0 <bmk4_execute.10827>:
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8001cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001cf2:	4c30      	ldr	r4, [pc, #192]	; (8001db4 <bmk4_execute.10827+0xc4>)
 8001cf4:	b083      	sub	sp, #12
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001cf6:	69a3      	ldr	r3, [r4, #24]
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8001cf8:	2000      	movs	r0, #0
 8001cfa:	689a      	ldr	r2, [r3, #8]
 8001cfc:	21a8      	movs	r1, #168	; 0xa8
 8001cfe:	0049      	lsls	r1, r1, #1
 8001d00:	4b2d      	ldr	r3, [pc, #180]	; (8001db8 <bmk4_execute.10827+0xc8>)
 8001d02:	3201      	adds	r2, #1
 8001d04:	9000      	str	r0, [sp, #0]
 8001d06:	482d      	ldr	r0, [pc, #180]	; (8001dbc <bmk4_execute.10827+0xcc>)
 8001d08:	f001 f8a2 	bl	8002e50 <chThdCreateStatic>
 8001d0c:	4a2c      	ldr	r2, [pc, #176]	; (8001dc0 <bmk4_execute.10827+0xd0>)
 8001d0e:	1c05      	adds	r5, r0, #0
 8001d10:	6010      	str	r0, [r2, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 8001d12:	f000 fcf5 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 8001d16:	f003 fe0b 	bl	8005930 <test_start_timer.constprop.11>
 8001d1a:	4f2a      	ldr	r7, [pc, #168]	; (8001dc4 <bmk4_execute.10827+0xd4>)
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
                                      thread4, NULL);
  n = 0;
 8001d1c:	2600      	movs	r6, #0
 8001d1e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001d20:	f001 febe 	bl	8003aa0 <_dbg_check_lock>
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8001d24:	1c28      	adds	r0, r5, #0
 8001d26:	2100      	movs	r1, #0
 8001d28:	f7ff f892 	bl	8000e50 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8001d2c:	1c28      	adds	r0, r5, #0
 8001d2e:	2100      	movs	r1, #0
 8001d30:	f7ff f88e 	bl	8000e50 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8001d34:	1c28      	adds	r0, r5, #0
 8001d36:	2100      	movs	r1, #0
 8001d38:	f7ff f88a 	bl	8000e50 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8001d3c:	1c28      	adds	r0, r5, #0
 8001d3e:	2100      	movs	r1, #0
 8001d40:	f7ff f886 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001d44:	f001 fe14 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001d48:	6823      	ldr	r3, [r4, #0]
 8001d4a:	42a3      	cmp	r3, r4
 8001d4c:	d004      	beq.n	8001d58 <bmk4_execute.10827+0x68>
 8001d4e:	69a0      	ldr	r0, [r4, #24]
 8001d50:	689a      	ldr	r2, [r3, #8]
 8001d52:	6881      	ldr	r1, [r0, #8]
 8001d54:	4291      	cmp	r1, r2
 8001d56:	d324      	bcc.n	8001da2 <bmk4_execute.10827+0xb2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d58:	b662      	cpsie	i
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001d5a:	783b      	ldrb	r3, [r7, #0]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8001d5c:	3604      	adds	r6, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001d5e:	2b00      	cmp	r3, #0
 8001d60:	d0dd      	beq.n	8001d1e <bmk4_execute.10827+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001d62:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001d64:	f001 fe9c 	bl	8003aa0 <_dbg_check_lock>
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 8001d68:	1c28      	adds	r0, r5, #0
 8001d6a:	2501      	movs	r5, #1
 8001d6c:	4269      	negs	r1, r5
 8001d6e:	f7ff f86f 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001d72:	f001 fdfd 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001d76:	6827      	ldr	r7, [r4, #0]
 8001d78:	42a7      	cmp	r7, r4
 8001d7a:	d004      	beq.n	8001d86 <bmk4_execute.10827+0x96>
 8001d7c:	69a0      	ldr	r0, [r4, #24]
 8001d7e:	68ba      	ldr	r2, [r7, #8]
 8001d80:	6881      	ldr	r1, [r0, #8]
 8001d82:	4291      	cmp	r1, r2
 8001d84:	d311      	bcc.n	8001daa <bmk4_execute.10827+0xba>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d86:	b662      	cpsie	i
  chSysUnlock();

  test_wait_threads();
 8001d88:	f7ff fed2 	bl	8001b30 <test_wait_threads>
  test_print("--- Score : ");
 8001d8c:	480e      	ldr	r0, [pc, #56]	; (8001dc8 <bmk4_execute.10827+0xd8>)
 8001d8e:	f7fe ff1f 	bl	8000bd0 <test_print>
  test_printn(n * 2);
 8001d92:	0070      	lsls	r0, r6, #1
 8001d94:	f7fe ff34 	bl	8000c00 <test_printn>
  test_println(" ctxswc/S");
 8001d98:	480c      	ldr	r0, [pc, #48]	; (8001dcc <bmk4_execute.10827+0xdc>)
 8001d9a:	f7fe fef9 	bl	8000b90 <test_println>
}
 8001d9e:	b003      	add	sp, #12
 8001da0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001da2:	b672      	cpsid	i
 8001da4:	4b0a      	ldr	r3, [pc, #40]	; (8001dd0 <bmk4_execute.10827+0xe0>)
 8001da6:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001da8:	e7fe      	b.n	8001da8 <bmk4_execute.10827+0xb8>
 8001daa:	b672      	cpsid	i
 8001dac:	4e08      	ldr	r6, [pc, #32]	; (8001dd0 <bmk4_execute.10827+0xe0>)
 8001dae:	62e6      	str	r6, [r4, #44]	; 0x2c
 8001db0:	e7fe      	b.n	8001db0 <bmk4_execute.10827+0xc0>
 8001db2:	46c0      	nop			; (mov r8, r8)
 8001db4:	20001040 	.word	0x20001040
 8001db8:	08004251 	.word	0x08004251
 8001dbc:	200006b8 	.word	0x200006b8
 8001dc0:	200015b8 	.word	0x200015b8
 8001dc4:	20000e18 	.word	0x20000e18
 8001dc8:	08008650 	.word	0x08008650
 8001dcc:	08008674 	.word	0x08008674
 8001dd0:	08008ab0 	.word	0x08008ab0
 8001dd4:	46c0      	nop			; (mov r8, r8)
 8001dd6:	46c0      	nop			; (mov r8, r8)
 8001dd8:	46c0      	nop			; (mov r8, r8)
 8001dda:	46c0      	nop			; (mov r8, r8)
 8001ddc:	46c0      	nop			; (mov r8, r8)
 8001dde:	46c0      	nop			; (mov r8, r8)

08001de0 <bmk3_execute.10832>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8001de0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001de2:	464f      	mov	r7, r9
 8001de4:	4646      	mov	r6, r8
 8001de6:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001de8:	4f2f      	ldr	r7, [pc, #188]	; (8001ea8 <bmk3_execute.10832+0xc8>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001dea:	4b30      	ldr	r3, [pc, #192]	; (8001eac <bmk3_execute.10832+0xcc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001dec:	69b8      	ldr	r0, [r7, #24]
 8001dee:	25a8      	movs	r5, #168	; 0xa8
 8001df0:	6882      	ldr	r2, [r0, #8]
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8001df2:	b083      	sub	sp, #12
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001df4:	006d      	lsls	r5, r5, #1
 8001df6:	2600      	movs	r6, #0
 8001df8:	4698      	mov	r8, r3
 8001dfa:	1c29      	adds	r1, r5, #0
 8001dfc:	3201      	adds	r2, #1
 8001dfe:	9600      	str	r6, [sp, #0]
 8001e00:	1c18      	adds	r0, r3, #0
 8001e02:	4b2b      	ldr	r3, [pc, #172]	; (8001eb0 <bmk3_execute.10832+0xd0>)
 8001e04:	f001 f824 	bl	8002e50 <chThdCreateStatic>
 8001e08:	4c2a      	ldr	r4, [pc, #168]	; (8001eb4 <bmk3_execute.10832+0xd4>)
 8001e0a:	69b9      	ldr	r1, [r7, #24]
 8001e0c:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8001e0e:	688a      	ldr	r2, [r1, #8]
 8001e10:	4640      	mov	r0, r8
 8001e12:	4b29      	ldr	r3, [pc, #164]	; (8001eb8 <bmk3_execute.10832+0xd8>)
 8001e14:	3051      	adds	r0, #81	; 0x51
 8001e16:	1c29      	adds	r1, r5, #0
 8001e18:	3a02      	subs	r2, #2
 8001e1a:	9600      	str	r6, [sp, #0]
 8001e1c:	30ff      	adds	r0, #255	; 0xff
 8001e1e:	4699      	mov	r9, r3
 8001e20:	f001 f816 	bl	8002e50 <chThdCreateStatic>
 8001e24:	69b9      	ldr	r1, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8001e26:	22a8      	movs	r2, #168	; 0xa8
 8001e28:	0093      	lsls	r3, r2, #2
 8001e2a:	688a      	ldr	r2, [r1, #8]

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8001e2c:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8001e2e:	1c18      	adds	r0, r3, #0
 8001e30:	1c29      	adds	r1, r5, #0
 8001e32:	464b      	mov	r3, r9
 8001e34:	4440      	add	r0, r8
 8001e36:	3a03      	subs	r2, #3
 8001e38:	9600      	str	r6, [sp, #0]
 8001e3a:	f001 f809 	bl	8002e50 <chThdCreateStatic>
 8001e3e:	69bb      	ldr	r3, [r7, #24]
 8001e40:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8001e42:	20fc      	movs	r0, #252	; 0xfc
 8001e44:	0082      	lsls	r2, r0, #2
 8001e46:	1c10      	adds	r0, r2, #0
 8001e48:	689a      	ldr	r2, [r3, #8]
 8001e4a:	1c29      	adds	r1, r5, #0
 8001e4c:	464b      	mov	r3, r9
 8001e4e:	4440      	add	r0, r8
 8001e50:	3a04      	subs	r2, #4
 8001e52:	9600      	str	r6, [sp, #0]
 8001e54:	f000 fffc 	bl	8002e50 <chThdCreateStatic>
 8001e58:	69bf      	ldr	r7, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8001e5a:	21a8      	movs	r1, #168	; 0xa8
 8001e5c:	68ba      	ldr	r2, [r7, #8]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8001e5e:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8001e60:	00c8      	lsls	r0, r1, #3
 8001e62:	3a05      	subs	r2, #5
 8001e64:	1c29      	adds	r1, r5, #0
 8001e66:	464b      	mov	r3, r9
 8001e68:	4440      	add	r0, r8
 8001e6a:	9600      	str	r6, [sp, #0]
 8001e6c:	f000 fff0 	bl	8002e50 <chThdCreateStatic>
 8001e70:	6120      	str	r0, [r4, #16]
  n = msg_loop_test(threads[0]);
 8001e72:	6820      	ldr	r0, [r4, #0]
 8001e74:	f003 fd94 	bl	80059a0 <msg_loop_test.10829>
 8001e78:	1c05      	adds	r5, r0, #0
  test_wait_threads();
 8001e7a:	f7ff fe59 	bl	8001b30 <test_wait_threads>
  test_print("--- Score : ");
 8001e7e:	480f      	ldr	r0, [pc, #60]	; (8001ebc <bmk3_execute.10832+0xdc>)
 8001e80:	f7fe fea6 	bl	8000bd0 <test_print>
  test_printn(n);
 8001e84:	1c28      	adds	r0, r5, #0
 8001e86:	f7fe febb 	bl	8000c00 <test_printn>
  test_print(" msgs/S, ");
 8001e8a:	480d      	ldr	r0, [pc, #52]	; (8001ec0 <bmk3_execute.10832+0xe0>)
 8001e8c:	f7fe fea0 	bl	8000bd0 <test_print>
  test_printn(n << 1);
 8001e90:	0068      	lsls	r0, r5, #1
 8001e92:	f7fe feb5 	bl	8000c00 <test_printn>
  test_println(" ctxswc/S");
 8001e96:	480b      	ldr	r0, [pc, #44]	; (8001ec4 <bmk3_execute.10832+0xe4>)
 8001e98:	f7fe fe7a 	bl	8000b90 <test_println>
}
 8001e9c:	b003      	add	sp, #12
 8001e9e:	bc0c      	pop	{r2, r3}
 8001ea0:	4690      	mov	r8, r2
 8001ea2:	4699      	mov	r9, r3
 8001ea4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001ea6:	46c0      	nop			; (mov r8, r8)
 8001ea8:	20001040 	.word	0x20001040
 8001eac:	200006b8 	.word	0x200006b8
 8001eb0:	080040b1 	.word	0x080040b1
 8001eb4:	200015b8 	.word	0x200015b8
 8001eb8:	080011d1 	.word	0x080011d1
 8001ebc:	08008650 	.word	0x08008650
 8001ec0:	08008680 	.word	0x08008680
 8001ec4:	08008674 	.word	0x08008674
 8001ec8:	46c0      	nop			; (mov r8, r8)
 8001eca:	46c0      	nop			; (mov r8, r8)
 8001ecc:	46c0      	nop			; (mov r8, r8)
 8001ece:	46c0      	nop			; (mov r8, r8)

08001ed0 <bmk2_execute.10834>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8001ed0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001ed2:	4b12      	ldr	r3, [pc, #72]	; (8001f1c <bmk2_execute.10834+0x4c>)
 8001ed4:	b082      	sub	sp, #8
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001ed6:	6998      	ldr	r0, [r3, #24]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001ed8:	2100      	movs	r1, #0
 8001eda:	6882      	ldr	r2, [r0, #8]
 8001edc:	24a8      	movs	r4, #168	; 0xa8
 8001ede:	4b10      	ldr	r3, [pc, #64]	; (8001f20 <bmk2_execute.10834+0x50>)
 8001ee0:	9100      	str	r1, [sp, #0]
 8001ee2:	3201      	adds	r2, #1
 8001ee4:	0061      	lsls	r1, r4, #1
 8001ee6:	480f      	ldr	r0, [pc, #60]	; (8001f24 <bmk2_execute.10834+0x54>)
 8001ee8:	f000 ffb2 	bl	8002e50 <chThdCreateStatic>
 8001eec:	4a0e      	ldr	r2, [pc, #56]	; (8001f28 <bmk2_execute.10834+0x58>)
 8001eee:	6010      	str	r0, [r2, #0]
  n = msg_loop_test(threads[0]);
 8001ef0:	f003 fd56 	bl	80059a0 <msg_loop_test.10829>
 8001ef4:	1c04      	adds	r4, r0, #0
  test_wait_threads();
 8001ef6:	f7ff fe1b 	bl	8001b30 <test_wait_threads>
  test_print("--- Score : ");
 8001efa:	480c      	ldr	r0, [pc, #48]	; (8001f2c <bmk2_execute.10834+0x5c>)
 8001efc:	f7fe fe68 	bl	8000bd0 <test_print>
  test_printn(n);
 8001f00:	1c20      	adds	r0, r4, #0
 8001f02:	f7fe fe7d 	bl	8000c00 <test_printn>
  test_print(" msgs/S, ");
 8001f06:	480a      	ldr	r0, [pc, #40]	; (8001f30 <bmk2_execute.10834+0x60>)
 8001f08:	f7fe fe62 	bl	8000bd0 <test_print>
  test_printn(n << 1);
 8001f0c:	0060      	lsls	r0, r4, #1
 8001f0e:	f7fe fe77 	bl	8000c00 <test_printn>
  test_println(" ctxswc/S");
 8001f12:	4808      	ldr	r0, [pc, #32]	; (8001f34 <bmk2_execute.10834+0x64>)
 8001f14:	f7fe fe3c 	bl	8000b90 <test_println>
}
 8001f18:	b002      	add	sp, #8
 8001f1a:	bd10      	pop	{r4, pc}
 8001f1c:	20001040 	.word	0x20001040
 8001f20:	080040b1 	.word	0x080040b1
 8001f24:	200006b8 	.word	0x200006b8
 8001f28:	200015b8 	.word	0x200015b8
 8001f2c:	08008650 	.word	0x08008650
 8001f30:	08008680 	.word	0x08008680
 8001f34:	08008674 	.word	0x08008674
 8001f38:	46c0      	nop			; (mov r8, r8)
 8001f3a:	46c0      	nop			; (mov r8, r8)
 8001f3c:	46c0      	nop			; (mov r8, r8)
 8001f3e:	46c0      	nop			; (mov r8, r8)

08001f40 <bmk1_execute.10836>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8001f40:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001f42:	4b12      	ldr	r3, [pc, #72]	; (8001f8c <bmk1_execute.10836+0x4c>)
 8001f44:	b082      	sub	sp, #8
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001f46:	6998      	ldr	r0, [r3, #24]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8001f48:	2100      	movs	r1, #0
 8001f4a:	6882      	ldr	r2, [r0, #8]
 8001f4c:	24a8      	movs	r4, #168	; 0xa8
 8001f4e:	4b10      	ldr	r3, [pc, #64]	; (8001f90 <bmk1_execute.10836+0x50>)
 8001f50:	9100      	str	r1, [sp, #0]
 8001f52:	3a01      	subs	r2, #1
 8001f54:	0061      	lsls	r1, r4, #1
 8001f56:	480f      	ldr	r0, [pc, #60]	; (8001f94 <bmk1_execute.10836+0x54>)
 8001f58:	f000 ff7a 	bl	8002e50 <chThdCreateStatic>
 8001f5c:	4a0e      	ldr	r2, [pc, #56]	; (8001f98 <bmk1_execute.10836+0x58>)
 8001f5e:	6010      	str	r0, [r2, #0]
  n = msg_loop_test(threads[0]);
 8001f60:	f003 fd1e 	bl	80059a0 <msg_loop_test.10829>
 8001f64:	1c04      	adds	r4, r0, #0
  test_wait_threads();
 8001f66:	f7ff fde3 	bl	8001b30 <test_wait_threads>
  test_print("--- Score : ");
 8001f6a:	480c      	ldr	r0, [pc, #48]	; (8001f9c <bmk1_execute.10836+0x5c>)
 8001f6c:	f7fe fe30 	bl	8000bd0 <test_print>
  test_printn(n);
 8001f70:	1c20      	adds	r0, r4, #0
 8001f72:	f7fe fe45 	bl	8000c00 <test_printn>
  test_print(" msgs/S, ");
 8001f76:	480a      	ldr	r0, [pc, #40]	; (8001fa0 <bmk1_execute.10836+0x60>)
 8001f78:	f7fe fe2a 	bl	8000bd0 <test_print>
  test_printn(n << 1);
 8001f7c:	0060      	lsls	r0, r4, #1
 8001f7e:	f7fe fe3f 	bl	8000c00 <test_printn>
  test_println(" ctxswc/S");
 8001f82:	4808      	ldr	r0, [pc, #32]	; (8001fa4 <bmk1_execute.10836+0x64>)
 8001f84:	f7fe fe04 	bl	8000b90 <test_println>
}
 8001f88:	b002      	add	sp, #8
 8001f8a:	bd10      	pop	{r4, pc}
 8001f8c:	20001040 	.word	0x20001040
 8001f90:	080040b1 	.word	0x080040b1
 8001f94:	200006b8 	.word	0x200006b8
 8001f98:	200015b8 	.word	0x200015b8
 8001f9c:	08008650 	.word	0x08008650
 8001fa0:	08008680 	.word	0x08008680
 8001fa4:	08008674 	.word	0x08008674
 8001fa8:	46c0      	nop			; (mov r8, r8)
 8001faa:	46c0      	nop			; (mov r8, r8)
 8001fac:	46c0      	nop			; (mov r8, r8)
 8001fae:	46c0      	nop			; (mov r8, r8)

08001fb0 <bmk5_execute.10825>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8001fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001fb2:	4b17      	ldr	r3, [pc, #92]	; (8002010 <bmk5_execute.10825+0x60>)
 8001fb4:	464f      	mov	r7, r9
 8001fb6:	4646      	mov	r6, r8
 8001fb8:	b4c0      	push	{r6, r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001fba:	6998      	ldr	r0, [r3, #24]
 8001fbc:	b083      	sub	sp, #12

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8001fbe:	6881      	ldr	r1, [r0, #8]
 * a second of continuous operations.
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
 8001fc0:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8001fc2:	3901      	subs	r1, #1
 8001fc4:	4689      	mov	r9, r1
  test_wait_tick();
 8001fc6:	f000 fb9b 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 8001fca:	f003 fcb1 	bl	8005930 <test_start_timer.constprop.11>
 8001fce:	4a11      	ldr	r2, [pc, #68]	; (8002014 <bmk5_execute.10825+0x64>)
 8001fd0:	4f11      	ldr	r7, [pc, #68]	; (8002018 <bmk5_execute.10825+0x68>)
 8001fd2:	4e12      	ldr	r6, [pc, #72]	; (800201c <bmk5_execute.10825+0x6c>)
 8001fd4:	4690      	mov	r8, r2
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8001fd6:	2500      	movs	r5, #0
 8001fd8:	23a8      	movs	r3, #168	; 0xa8
 8001fda:	0059      	lsls	r1, r3, #1
 8001fdc:	464a      	mov	r2, r9
 8001fde:	1c3b      	adds	r3, r7, #0
 8001fe0:	9500      	str	r5, [sp, #0]
 8001fe2:	4640      	mov	r0, r8
 8001fe4:	f000 ff34 	bl	8002e50 <chThdCreateStatic>
 8001fe8:	f7ff fd62 	bl	8001ab0 <chThdWait.4165>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001fec:	7830      	ldrb	r0, [r6, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8001fee:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001ff0:	2800      	cmp	r0, #0
 8001ff2:	d0f1      	beq.n	8001fd8 <bmk5_execute.10825+0x28>
  test_print("--- Score : ");
 8001ff4:	480a      	ldr	r0, [pc, #40]	; (8002020 <bmk5_execute.10825+0x70>)
 8001ff6:	f7fe fdeb 	bl	8000bd0 <test_print>
  test_printn(n);
 8001ffa:	1c20      	adds	r0, r4, #0
 8001ffc:	f7fe fe00 	bl	8000c00 <test_printn>
  test_println(" threads/S");
 8002000:	4808      	ldr	r0, [pc, #32]	; (8002024 <bmk5_execute.10825+0x74>)
 8002002:	f7fe fdc5 	bl	8000b90 <test_println>
}
 8002006:	b003      	add	sp, #12
 8002008:	bc0c      	pop	{r2, r3}
 800200a:	4690      	mov	r8, r2
 800200c:	4699      	mov	r9, r3
 800200e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002010:	20001040 	.word	0x20001040
 8002014:	200006b8 	.word	0x200006b8
 8002018:	080011d1 	.word	0x080011d1
 800201c:	20000e18 	.word	0x20000e18
 8002020:	08008650 	.word	0x08008650
 8002024:	0800868c 	.word	0x0800868c
 8002028:	46c0      	nop			; (mov r8, r8)
 800202a:	46c0      	nop			; (mov r8, r8)
 800202c:	46c0      	nop			; (mov r8, r8)
 800202e:	46c0      	nop			; (mov r8, r8)

08002030 <regfind.10172.4182>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8002030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002032:	464f      	mov	r7, r9
 8002034:	4646      	mov	r6, r8
 8002036:	b4c0      	push	{r6, r7}
 8002038:	4681      	mov	r9, r0
 800203a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800203c:	f001 fd30 	bl	8003aa0 <_dbg_check_lock>
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8002040:	4c27      	ldr	r4, [pc, #156]	; (80020e0 <regfind.10172.4182+0xb0>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 8002042:	2322      	movs	r3, #34	; 0x22
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8002044:	6925      	ldr	r5, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 8002046:	5cea      	ldrb	r2, [r5, r3]
 8002048:	3201      	adds	r2, #1
 800204a:	54ea      	strb	r2, [r5, r3]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800204c:	f001 fc90 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002050:	6820      	ldr	r0, [r4, #0]
 8002052:	42a0      	cmp	r0, r4
 8002054:	d004      	beq.n	8002060 <regfind.10172.4182+0x30>
 8002056:	69a1      	ldr	r1, [r4, #24]
 8002058:	6887      	ldr	r7, [r0, #8]
 800205a:	688e      	ldr	r6, [r1, #8]
 800205c:	42be      	cmp	r6, r7
 800205e:	d32d      	bcc.n	80020bc <regfind.10172.4182+0x8c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002060:	b662      	cpsie	i
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
 8002062:	2322      	movs	r3, #34	; 0x22
  thread_t *ftp;
  bool found = false;
 8002064:	2700      	movs	r7, #0
 8002066:	4698      	mov	r8, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002068:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800206a:	f001 fd19 	bl	8003aa0 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 800206e:	692e      	ldr	r6, [r5, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8002070:	42a6      	cmp	r6, r4
 8002072:	d021      	beq.n	80020b8 <regfind.10172.4182+0x88>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
 8002074:	4642      	mov	r2, r8
 8002076:	5cb0      	ldrb	r0, [r6, r2]
 8002078:	28ff      	cmp	r0, #255	; 0xff
 800207a:	d02c      	beq.n	80020d6 <regfind.10172.4182+0xa6>
    ntp->p_refs++;
 800207c:	3001      	adds	r0, #1
 800207e:	54b0      	strb	r0, [r6, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002080:	f001 fc76 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002084:	6823      	ldr	r3, [r4, #0]
 8002086:	42a3      	cmp	r3, r4
 8002088:	d004      	beq.n	8002094 <regfind.10172.4182+0x64>
 800208a:	69a2      	ldr	r2, [r4, #24]
 800208c:	6899      	ldr	r1, [r3, #8]
 800208e:	6890      	ldr	r0, [r2, #8]
 8002090:	4288      	cmp	r0, r1
 8002092:	d317      	bcc.n	80020c4 <regfind.10172.4182+0x94>

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
 8002094:	464b      	mov	r3, r9
 8002096:	1ae8      	subs	r0, r5, r3
 8002098:	4242      	negs	r2, r0
 800209a:	4150      	adcs	r0, r2
 800209c:	4307      	orrs	r7, r0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800209e:	b662      	cpsie	i
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80020a0:	1c28      	adds	r0, r5, #0
 80020a2:	f7ff fc85 	bl	80019b0 <chThdRelease.4196>
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
 80020a6:	2e00      	cmp	r6, #0
 80020a8:	d010      	beq.n	80020cc <regfind.10172.4182+0x9c>
  bool found = false;

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
    ftp = chRegNextThread(ftp);
 80020aa:	1c35      	adds	r5, r6, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80020ac:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80020ae:	f001 fcf7 	bl	8003aa0 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 80020b2:	692e      	ldr	r6, [r5, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80020b4:	42a6      	cmp	r6, r4
 80020b6:	d1dd      	bne.n	8002074 <regfind.10172.4182+0x44>
  /*lint -restore*/
    ntp = NULL;
 80020b8:	2600      	movs	r6, #0
 80020ba:	e7e1      	b.n	8002080 <regfind.10172.4182+0x50>
 80020bc:	b672      	cpsid	i
 80020be:	4a09      	ldr	r2, [pc, #36]	; (80020e4 <regfind.10172.4182+0xb4>)
 80020c0:	62e2      	str	r2, [r4, #44]	; 0x2c
 80020c2:	e7fe      	b.n	80020c2 <regfind.10172.4182+0x92>
 80020c4:	b672      	cpsid	i
 80020c6:	4e07      	ldr	r6, [pc, #28]	; (80020e4 <regfind.10172.4182+0xb4>)
 80020c8:	62e6      	str	r6, [r4, #44]	; 0x2c
 80020ca:	e7fe      	b.n	80020ca <regfind.10172.4182+0x9a>
  } while (ftp != NULL);
  return found;
}
 80020cc:	1c38      	adds	r0, r7, #0
 80020ce:	bc0c      	pop	{r2, r3}
 80020d0:	4690      	mov	r8, r2
 80020d2:	4699      	mov	r9, r3
 80020d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80020d6:	b672      	cpsid	i
 80020d8:	4d03      	ldr	r5, [pc, #12]	; (80020e8 <regfind.10172.4182+0xb8>)
 80020da:	62e5      	str	r5, [r4, #44]	; 0x2c
 80020dc:	e7fe      	b.n	80020dc <regfind.10172.4182+0xac>
 80020de:	46c0      	nop			; (mov r8, r8)
 80020e0:	20001040 	.word	0x20001040
 80020e4:	08008630 	.word	0x08008630
 80020e8:	08008620 	.word	0x08008620
 80020ec:	46c0      	nop			; (mov r8, r8)
 80020ee:	46c0      	nop			; (mov r8, r8)

080020f0 <chThdCreateFromMemoryPool.constprop.70>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 80020f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80020f2:	4647      	mov	r7, r8
 80020f4:	b480      	push	{r7}
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80020f6:	4e2a      	ldr	r6, [pc, #168]	; (80021a0 <chThdCreateFromMemoryPool.constprop.70+0xb0>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 80020f8:	b082      	sub	sp, #8
 80020fa:	1c07      	adds	r7, r0, #0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80020fc:	1c30      	adds	r0, r6, #0
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 80020fe:	4688      	mov	r8, r1
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002100:	f002 f84e 	bl	80041a0 <chPoolAlloc>
 8002104:	1e04      	subs	r4, r0, #0
  if (wsp == NULL) {
 8002106:	d048      	beq.n	800219a <chThdCreateFromMemoryPool.constprop.70+0xaa>
    return NULL;
  }

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8002108:	1c03      	adds	r3, r0, #0
 800210a:	3348      	adds	r3, #72	; 0x48
 800210c:	1c05      	adds	r5, r0, #0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 800210e:	22ff      	movs	r2, #255	; 0xff
 8002110:	702a      	strb	r2, [r5, #0]
 8002112:	706a      	strb	r2, [r5, #1]
 8002114:	3502      	adds	r5, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002116:	42ab      	cmp	r3, r5
 8002118:	d1fa      	bne.n	8002110 <chThdCreateFromMemoryPool.constprop.70+0x20>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800211a:	6870      	ldr	r0, [r6, #4]
 800211c:	1825      	adds	r5, r4, r0
 800211e:	42ab      	cmp	r3, r5
 8002120:	d213      	bcs.n	800214a <chThdCreateFromMemoryPool.constprop.70+0x5a>
 8002122:	43d9      	mvns	r1, r3
    *startp++ = v;
 8002124:	2255      	movs	r2, #85	; 0x55
 8002126:	1869      	adds	r1, r5, r1
 8002128:	2001      	movs	r0, #1
 800212a:	701a      	strb	r2, [r3, #0]
 800212c:	3301      	adds	r3, #1
 800212e:	4001      	ands	r1, r0
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002130:	42ab      	cmp	r3, r5
 8002132:	d00a      	beq.n	800214a <chThdCreateFromMemoryPool.constprop.70+0x5a>
 8002134:	2900      	cmp	r1, #0
 8002136:	d003      	beq.n	8002140 <chThdCreateFromMemoryPool.constprop.70+0x50>
    *startp++ = v;
 8002138:	701a      	strb	r2, [r3, #0]
 800213a:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800213c:	42ab      	cmp	r3, r5
 800213e:	d004      	beq.n	800214a <chThdCreateFromMemoryPool.constprop.70+0x5a>
    *startp++ = v;
 8002140:	701a      	strb	r2, [r3, #0]
 8002142:	705a      	strb	r2, [r3, #1]
 8002144:	3302      	adds	r3, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002146:	42ab      	cmp	r3, r5
 8002148:	d1fa      	bne.n	8002140 <chThdCreateFromMemoryPool.constprop.70+0x50>
 800214a:	b672      	cpsid	i
 800214c:	f001 fca8 	bl	8003aa0 <_dbg_check_lock>
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 8002150:	4643      	mov	r3, r8
 8002152:	9300      	str	r3, [sp, #0]
 8002154:	6871      	ldr	r1, [r6, #4]
 8002156:	4b13      	ldr	r3, [pc, #76]	; (80021a4 <chThdCreateFromMemoryPool.constprop.70+0xb4>)
 8002158:	1c20      	adds	r0, r4, #0
 800215a:	1c3a      	adds	r2, r7, #0
 800215c:	f001 f9a8 	bl	80034b0 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 8002160:	2502      	movs	r5, #2
 8002162:	2221      	movs	r2, #33	; 0x21
  tp->p_mpool = mp;
 8002164:	6446      	str	r6, [r0, #68]	; 0x44
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 8002166:	5485      	strb	r5, [r0, r2]
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8002168:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 800216a:	1c04      	adds	r4, r0, #0
  tp->p_flags = CH_FLAG_MODE_MPOOL;
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 800216c:	f7fe fe70 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002170:	f001 fbfe 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002174:	480c      	ldr	r0, [pc, #48]	; (80021a8 <chThdCreateFromMemoryPool.constprop.70+0xb8>)
 8002176:	6806      	ldr	r6, [r0, #0]
 8002178:	4286      	cmp	r6, r0
 800217a:	d004      	beq.n	8002186 <chThdCreateFromMemoryPool.constprop.70+0x96>
 800217c:	6981      	ldr	r1, [r0, #24]
 800217e:	68b3      	ldr	r3, [r6, #8]
 8002180:	688f      	ldr	r7, [r1, #8]
 8002182:	429f      	cmp	r7, r3
 8002184:	d305      	bcc.n	8002192 <chThdCreateFromMemoryPool.constprop.70+0xa2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002186:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8002188:	1c20      	adds	r0, r4, #0
 800218a:	b002      	add	sp, #8
 800218c:	bc04      	pop	{r2}
 800218e:	4690      	mov	r8, r2
 8002190:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002192:	b672      	cpsid	i
 8002194:	4c05      	ldr	r4, [pc, #20]	; (80021ac <chThdCreateFromMemoryPool.constprop.70+0xbc>)
 8002196:	62c4      	str	r4, [r0, #44]	; 0x2c
 8002198:	e7fe      	b.n	8002198 <chThdCreateFromMemoryPool.constprop.70+0xa8>

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
 800219a:	2400      	movs	r4, #0
 800219c:	e7f4      	b.n	8002188 <chThdCreateFromMemoryPool.constprop.70+0x98>
 800219e:	46c0      	nop			; (mov r8, r8)
 80021a0:	20000d78 	.word	0x20000d78
 80021a4:	080053c1 	.word	0x080053c1
 80021a8:	20001040 	.word	0x20001040
 80021ac:	080086a0 	.word	0x080086a0

080021b0 <chThdCreateFromHeap.constprop.71>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80021b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80021b2:	4647      	mov	r7, r8
 80021b4:	b480      	push	{r7}
 80021b6:	4688      	mov	r8, r1
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80021b8:	21a8      	movs	r1, #168	; 0xa8
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80021ba:	b082      	sub	sp, #8
 80021bc:	1c07      	adds	r7, r0, #0
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80021be:	0049      	lsls	r1, r1, #1
 80021c0:	4827      	ldr	r0, [pc, #156]	; (8002260 <chThdCreateFromHeap.constprop.71+0xb0>)
 80021c2:	f000 fb9d 	bl	8002900 <chHeapAlloc>
 80021c6:	1e04      	subs	r4, r0, #0
  if (wsp == NULL) {
 80021c8:	d047      	beq.n	800225a <chThdCreateFromHeap.constprop.71+0xaa>
    return NULL;
  }

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80021ca:	1c03      	adds	r3, r0, #0
 80021cc:	3348      	adds	r3, #72	; 0x48
 80021ce:	1c05      	adds	r5, r0, #0
    *startp++ = v;
 80021d0:	22ff      	movs	r2, #255	; 0xff
 80021d2:	702a      	strb	r2, [r5, #0]
 80021d4:	706a      	strb	r2, [r5, #1]
 80021d6:	3502      	adds	r5, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80021d8:	42ab      	cmp	r3, r5
 80021da:	d1fa      	bne.n	80021d2 <chThdCreateFromHeap.constprop.71+0x22>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 80021dc:	20a8      	movs	r0, #168	; 0xa8
 80021de:	0046      	lsls	r6, r0, #1
 80021e0:	19a5      	adds	r5, r4, r6
    *startp++ = v;
 80021e2:	2055      	movs	r0, #85	; 0x55
 80021e4:	1b59      	subs	r1, r3, r5
 80021e6:	2201      	movs	r2, #1
 80021e8:	7018      	strb	r0, [r3, #0]
 80021ea:	3301      	adds	r3, #1
 80021ec:	438a      	bics	r2, r1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80021ee:	429d      	cmp	r5, r3
 80021f0:	d00a      	beq.n	8002208 <chThdCreateFromHeap.constprop.71+0x58>
 80021f2:	2a00      	cmp	r2, #0
 80021f4:	d003      	beq.n	80021fe <chThdCreateFromHeap.constprop.71+0x4e>
    *startp++ = v;
 80021f6:	7018      	strb	r0, [r3, #0]
 80021f8:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80021fa:	429d      	cmp	r5, r3
 80021fc:	d004      	beq.n	8002208 <chThdCreateFromHeap.constprop.71+0x58>
    *startp++ = v;
 80021fe:	7018      	strb	r0, [r3, #0]
 8002200:	7058      	strb	r0, [r3, #1]
 8002202:	3302      	adds	r3, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002204:	429d      	cmp	r5, r3
 8002206:	d1fa      	bne.n	80021fe <chThdCreateFromHeap.constprop.71+0x4e>
 8002208:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800220a:	f001 fc49 	bl	8003aa0 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 800220e:	26a8      	movs	r6, #168	; 0xa8
 8002210:	4643      	mov	r3, r8
 8002212:	1c3a      	adds	r2, r7, #0
 8002214:	9300      	str	r3, [sp, #0]
 8002216:	1c20      	adds	r0, r4, #0
 8002218:	4b12      	ldr	r3, [pc, #72]	; (8002264 <chThdCreateFromHeap.constprop.71+0xb4>)
 800221a:	0071      	lsls	r1, r6, #1
 800221c:	f001 f948 	bl	80034b0 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8002220:	2501      	movs	r5, #1
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002222:	1c04      	adds	r4, r0, #0
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8002224:	2021      	movs	r0, #33	; 0x21
 8002226:	5425      	strb	r5, [r4, r0]
  chSchWakeupS(tp, MSG_OK);
 8002228:	2100      	movs	r1, #0
 800222a:	1c20      	adds	r0, r4, #0
 800222c:	f7fe fe10 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002230:	f001 fb9e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002234:	4f0c      	ldr	r7, [pc, #48]	; (8002268 <chThdCreateFromHeap.constprop.71+0xb8>)
 8002236:	683a      	ldr	r2, [r7, #0]
 8002238:	42ba      	cmp	r2, r7
 800223a:	d004      	beq.n	8002246 <chThdCreateFromHeap.constprop.71+0x96>
 800223c:	69b9      	ldr	r1, [r7, #24]
 800223e:	6896      	ldr	r6, [r2, #8]
 8002240:	688b      	ldr	r3, [r1, #8]
 8002242:	42b3      	cmp	r3, r6
 8002244:	d305      	bcc.n	8002252 <chThdCreateFromHeap.constprop.71+0xa2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002246:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8002248:	1c20      	adds	r0, r4, #0
 800224a:	b002      	add	sp, #8
 800224c:	bc04      	pop	{r2}
 800224e:	4690      	mov	r8, r2
 8002250:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002252:	b672      	cpsid	i
 8002254:	4c05      	ldr	r4, [pc, #20]	; (800226c <chThdCreateFromHeap.constprop.71+0xbc>)
 8002256:	62fc      	str	r4, [r7, #44]	; 0x2c
 8002258:	e7fe      	b.n	8002258 <chThdCreateFromHeap.constprop.71+0xa8>
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
  if (wsp == NULL) {
    return NULL;
 800225a:	2400      	movs	r4, #0
 800225c:	e7f4      	b.n	8002248 <chThdCreateFromHeap.constprop.71+0x98>
 800225e:	46c0      	nop			; (mov r8, r8)
 8002260:	20000d88 	.word	0x20000d88
 8002264:	080053c1 	.word	0x080053c1
 8002268:	20001040 	.word	0x20001040
 800226c:	080086a0 	.word	0x080086a0

08002270 <dyn3_execute.10176>:
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 8002270:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002272:	4d4f      	ldr	r5, [pc, #316]	; (80023b0 <dyn3_execute.10176+0x140>)
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8002274:	494f      	ldr	r1, [pc, #316]	; (80023b4 <dyn3_execute.10176+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002276:	69ab      	ldr	r3, [r5, #24]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8002278:	2622      	movs	r6, #34	; 0x22
static void dyn3_execute(void) {
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 800227a:	6898      	ldr	r0, [r3, #8]
 800227c:	3801      	subs	r0, #1
 800227e:	f7ff ff97 	bl	80021b0 <chThdCreateFromHeap.constprop.71>
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8002282:	5d81      	ldrb	r1, [r0, r6]
static void dyn3_execute(void) {
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8002284:	1c04      	adds	r4, r0, #0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8002286:	3901      	subs	r1, #1
 8002288:	424b      	negs	r3, r1
 800228a:	4159      	adcs	r1, r3
 800228c:	2001      	movs	r0, #1
 800228e:	f7fe fc67 	bl	8000b60 <_test_assert>
 8002292:	2800      	cmp	r0, #0
 8002294:	d000      	beq.n	8002298 <dyn3_execute.10176+0x28>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
}
 8002296:	bd70      	pop	{r4, r5, r6, pc}
 8002298:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800229a:	f001 fc01 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
 800229e:	5da0      	ldrb	r0, [r4, r6]
 80022a0:	28ff      	cmp	r0, #255	; 0xff
 80022a2:	d07d      	beq.n	80023a0 <dyn3_execute.10176+0x130>
  tp->p_refs++;
 80022a4:	3001      	adds	r0, #1
 80022a6:	55a0      	strb	r0, [r4, r6]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80022a8:	f001 fb62 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80022ac:	6829      	ldr	r1, [r5, #0]
 80022ae:	42a9      	cmp	r1, r5
 80022b0:	d004      	beq.n	80022bc <dyn3_execute.10176+0x4c>
 80022b2:	69aa      	ldr	r2, [r5, #24]
 80022b4:	688b      	ldr	r3, [r1, #8]
 80022b6:	6896      	ldr	r6, [r2, #8]
 80022b8:	429e      	cmp	r6, r3
 80022ba:	d375      	bcc.n	80023a8 <dyn3_execute.10176+0x138>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80022bc:	b662      	cpsie	i

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
  chThdAddRef(tp);
  test_assert(2, tp->p_refs == 2, "references increase failure");
 80022be:	2522      	movs	r5, #34	; 0x22
 80022c0:	5d61      	ldrb	r1, [r4, r5]
 80022c2:	2002      	movs	r0, #2
 80022c4:	3902      	subs	r1, #2
 80022c6:	424b      	negs	r3, r1
 80022c8:	4159      	adcs	r1, r3
 80022ca:	f7fe fc49 	bl	8000b60 <_test_assert>
 80022ce:	2800      	cmp	r0, #0
 80022d0:	d1e1      	bne.n	8002296 <dyn3_execute.10176+0x26>
  chThdRelease(tp);
 80022d2:	1c20      	adds	r0, r4, #0
 80022d4:	f7ff fb6c 	bl	80019b0 <chThdRelease.4196>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 80022d8:	5d61      	ldrb	r1, [r4, r5]
 80022da:	2003      	movs	r0, #3
 80022dc:	3901      	subs	r1, #1
 80022de:	424b      	negs	r3, r1
 80022e0:	4159      	adcs	r1, r3
 80022e2:	f7fe fc3d 	bl	8000b60 <_test_assert>
 80022e6:	2800      	cmp	r0, #0
 80022e8:	d1d5      	bne.n	8002296 <dyn3_execute.10176+0x26>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 80022ea:	1c20      	adds	r0, r4, #0
 80022ec:	f7ff fea0 	bl	8002030 <regfind.10172.4182>
 80022f0:	1c01      	adds	r1, r0, #0
 80022f2:	2004      	movs	r0, #4
 80022f4:	f7fe fc34 	bl	8000b60 <_test_assert>
 80022f8:	2800      	cmp	r0, #0
 80022fa:	d1cc      	bne.n	8002296 <dyn3_execute.10176+0x26>
  test_assert(5, regfind(tp), "thread disappeared");
 80022fc:	1c20      	adds	r0, r4, #0
 80022fe:	f7ff fe97 	bl	8002030 <regfind.10172.4182>
 8002302:	1c01      	adds	r1, r0, #0
 8002304:	2005      	movs	r0, #5
 8002306:	f7fe fc2b 	bl	8000b60 <_test_assert>
 800230a:	2800      	cmp	r0, #0
 800230c:	d1c3      	bne.n	8002296 <dyn3_execute.10176+0x26>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800230e:	1c20      	adds	r0, r4, #0
 8002310:	f7ff fb4e 	bl	80019b0 <chThdRelease.4196>
  test_assert(6, tp->p_refs == 0, "detach failure");
 8002314:	5d61      	ldrb	r1, [r4, r5]
 8002316:	2006      	movs	r0, #6
 8002318:	424b      	negs	r3, r1
 800231a:	4159      	adcs	r1, r3
 800231c:	f7fe fc20 	bl	8000b60 <_test_assert>
 8002320:	2800      	cmp	r0, #0
 8002322:	d1b8      	bne.n	8002296 <dyn3_execute.10176+0x26>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 8002324:	2620      	movs	r6, #32
 8002326:	5da1      	ldrb	r1, [r4, r6]
 8002328:	2007      	movs	r0, #7
 800232a:	424b      	negs	r3, r1
 800232c:	4159      	adcs	r1, r3
 800232e:	f7fe fc17 	bl	8000b60 <_test_assert>
 8002332:	2800      	cmp	r0, #0
 8002334:	d1af      	bne.n	8002296 <dyn3_execute.10176+0x26>
  test_assert(8, regfind(tp), "thread disappeared");
 8002336:	1c20      	adds	r0, r4, #0
 8002338:	f7ff fe7a 	bl	8002030 <regfind.10172.4182>
 800233c:	1c01      	adds	r1, r0, #0
 800233e:	2008      	movs	r0, #8
 8002340:	f7fe fc0e 	bl	8000b60 <_test_assert>
 8002344:	2800      	cmp	r0, #0
 8002346:	d1a6      	bne.n	8002296 <dyn3_execute.10176+0x26>
  test_assert(9, regfind(tp), "thread disappeared");
 8002348:	1c20      	adds	r0, r4, #0
 800234a:	f7ff fe71 	bl	8002030 <regfind.10172.4182>
 800234e:	1c01      	adds	r1, r0, #0
 8002350:	2009      	movs	r0, #9
 8002352:	f7fe fc05 	bl	8000b60 <_test_assert>
 8002356:	2800      	cmp	r0, #0
 8002358:	d19d      	bne.n	8002296 <dyn3_execute.10176+0x26>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 800235a:	20fa      	movs	r0, #250	; 0xfa
 800235c:	0040      	lsls	r0, r0, #1
 800235e:	f000 f9a7 	bl	80026b0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8002362:	5da1      	ldrb	r1, [r4, r6]
 8002364:	200a      	movs	r0, #10
 8002366:	390f      	subs	r1, #15
 8002368:	424b      	negs	r3, r1
 800236a:	4159      	adcs	r1, r3
 800236c:	f7fe fbf8 	bl	8000b60 <_test_assert>
 8002370:	2800      	cmp	r0, #0
 8002372:	d000      	beq.n	8002376 <dyn3_execute.10176+0x106>
 8002374:	e78f      	b.n	8002296 <dyn3_execute.10176+0x26>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 8002376:	1c20      	adds	r0, r4, #0
 8002378:	f7ff fe5a 	bl	8002030 <regfind.10172.4182>
 800237c:	1c01      	adds	r1, r0, #0
 800237e:	200b      	movs	r0, #11
 8002380:	f7fe fbee 	bl	8000b60 <_test_assert>
 8002384:	2800      	cmp	r0, #0
 8002386:	d000      	beq.n	800238a <dyn3_execute.10176+0x11a>
 8002388:	e785      	b.n	8002296 <dyn3_execute.10176+0x26>
  test_assert(12, !regfind(tp), "thread still in registry");
 800238a:	1c20      	adds	r0, r4, #0
 800238c:	f7ff fe50 	bl	8002030 <regfind.10172.4182>
 8002390:	2401      	movs	r4, #1
 8002392:	1c01      	adds	r1, r0, #0
 8002394:	4061      	eors	r1, r4
 8002396:	b2c9      	uxtb	r1, r1
 8002398:	200c      	movs	r0, #12
 800239a:	f7fe fbe1 	bl	8000b60 <_test_assert>
 800239e:	e77a      	b.n	8002296 <dyn3_execute.10176+0x26>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80023a0:	b672      	cpsid	i
 80023a2:	4b05      	ldr	r3, [pc, #20]	; (80023b8 <dyn3_execute.10176+0x148>)
 80023a4:	62eb      	str	r3, [r5, #44]	; 0x2c
 80023a6:	e7fe      	b.n	80023a6 <dyn3_execute.10176+0x136>
 80023a8:	b672      	cpsid	i
 80023aa:	4a04      	ldr	r2, [pc, #16]	; (80023bc <dyn3_execute.10176+0x14c>)
 80023ac:	62ea      	str	r2, [r5, #44]	; 0x2c
 80023ae:	e7fe      	b.n	80023ae <dyn3_execute.10176+0x13e>
 80023b0:	20001040 	.word	0x20001040
 80023b4:	08008698 	.word	0x08008698
 80023b8:	080086b0 	.word	0x080086b0
 80023bc:	080086a0 	.word	0x080086a0

080023c0 <chEvtWaitOne.constprop.49>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 80023c0:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80023c2:	4c12      	ldr	r4, [pc, #72]	; (800240c <chEvtWaitOne.constprop.49+0x4c>)
 80023c4:	69a5      	ldr	r5, [r4, #24]
 80023c6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80023c8:	f001 fb6a 	bl	8003aa0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80023cc:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
 80023ce:	2900      	cmp	r1, #0
 80023d0:	d106      	bne.n	80023e0 <chEvtWaitOne.constprop.49+0x20>
    ctp->p_u.ewmask = events;
 80023d2:	2301      	movs	r3, #1
 80023d4:	4258      	negs	r0, r3
 80023d6:	6268      	str	r0, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 80023d8:	200a      	movs	r0, #10
 80023da:	f7fe fd79 	bl	8000ed0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80023de:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  }
  m ^= m & (m - (eventmask_t)1);
 80023e0:	424e      	negs	r6, r1
 80023e2:	400e      	ands	r6, r1
  ctp->p_epending &= ~m;
 80023e4:	43b1      	bics	r1, r6
 80023e6:	63a9      	str	r1, [r5, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80023e8:	f001 fac2 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80023ec:	6825      	ldr	r5, [r4, #0]
 80023ee:	42a5      	cmp	r5, r4
 80023f0:	d004      	beq.n	80023fc <chEvtWaitOne.constprop.49+0x3c>
 80023f2:	69a2      	ldr	r2, [r4, #24]
 80023f4:	68ab      	ldr	r3, [r5, #8]
 80023f6:	6890      	ldr	r0, [r2, #8]
 80023f8:	4298      	cmp	r0, r3
 80023fa:	d302      	bcc.n	8002402 <chEvtWaitOne.constprop.49+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80023fc:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 80023fe:	1c30      	adds	r0, r6, #0
 8002400:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002402:	b672      	cpsid	i
 8002404:	4902      	ldr	r1, [pc, #8]	; (8002410 <chEvtWaitOne.constprop.49+0x50>)
 8002406:	62e1      	str	r1, [r4, #44]	; 0x2c
 8002408:	e7fe      	b.n	8002408 <chEvtWaitOne.constprop.49+0x48>
 800240a:	46c0      	nop			; (mov r8, r8)
 800240c:	20001040 	.word	0x20001040
 8002410:	08008b50 	.word	0x08008b50
 8002414:	46c0      	nop			; (mov r8, r8)
 8002416:	46c0      	nop			; (mov r8, r8)
 8002418:	46c0      	nop			; (mov r8, r8)
 800241a:	46c0      	nop			; (mov r8, r8)
 800241c:	46c0      	nop			; (mov r8, r8)
 800241e:	46c0      	nop			; (mov r8, r8)

08002420 <chMBPost.constprop.36>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002420:	b570      	push	{r4, r5, r6, lr}
 8002422:	1c06      	adds	r6, r0, #0
 8002424:	1c0c      	adds	r4, r1, #0
 8002426:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002428:	f001 fb3a 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 800242c:	f7fe fa10 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002430:	4d13      	ldr	r5, [pc, #76]	; (8002480 <chMBPost.constprop.36+0x60>)
 8002432:	1c21      	adds	r1, r4, #0
 8002434:	1c28      	adds	r0, r5, #0
 8002436:	f001 f883 	bl	8003540 <chSemWaitTimeoutS>
 800243a:	1e04      	subs	r4, r0, #0
  if (rdymsg == MSG_OK) {
 800243c:	d10e      	bne.n	800245c <chMBPost.constprop.36+0x3c>
    *mbp->mb_wrptr++ = msg;
 800243e:	1c2b      	adds	r3, r5, #0
 8002440:	3b1c      	subs	r3, #28
 8002442:	689a      	ldr	r2, [r3, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002444:	6859      	ldr	r1, [r3, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8002446:	c240      	stmia	r2!, {r6}
 8002448:	609a      	str	r2, [r3, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 800244a:	428a      	cmp	r2, r1
 800244c:	d301      	bcc.n	8002452 <chMBPost.constprop.36+0x32>
      mbp->mb_wrptr = mbp->mb_buffer;
 800244e:	6818      	ldr	r0, [r3, #0]
 8002450:	6098      	str	r0, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002452:	480c      	ldr	r0, [pc, #48]	; (8002484 <chMBPost.constprop.36+0x64>)
 8002454:	f001 f8ac 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 8002458:	f001 f812 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800245c:	f001 fa88 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002460:	4e09      	ldr	r6, [pc, #36]	; (8002488 <chMBPost.constprop.36+0x68>)
 8002462:	6835      	ldr	r5, [r6, #0]
 8002464:	42b5      	cmp	r5, r6
 8002466:	d004      	beq.n	8002472 <chMBPost.constprop.36+0x52>
 8002468:	69b3      	ldr	r3, [r6, #24]
 800246a:	68aa      	ldr	r2, [r5, #8]
 800246c:	6899      	ldr	r1, [r3, #8]
 800246e:	4291      	cmp	r1, r2
 8002470:	d302      	bcc.n	8002478 <chMBPost.constprop.36+0x58>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002472:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8002474:	1c20      	adds	r0, r4, #0
 8002476:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002478:	b672      	cpsid	i
 800247a:	4c04      	ldr	r4, [pc, #16]	; (800248c <chMBPost.constprop.36+0x6c>)
 800247c:	62f4      	str	r4, [r6, #44]	; 0x2c
 800247e:	e7fe      	b.n	800247e <chMBPost.constprop.36+0x5e>
 8002480:	2000061c 	.word	0x2000061c
 8002484:	20000610 	.word	0x20000610
 8002488:	20001040 	.word	0x20001040
 800248c:	08008b10 	.word	0x08008b10

08002490 <chMBPostAhead.constprop.33>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002490:	b570      	push	{r4, r5, r6, lr}
 8002492:	1c06      	adds	r6, r0, #0
 8002494:	1c0c      	adds	r4, r1, #0
 8002496:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002498:	f001 fb02 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 800249c:	f7fe f9d8 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80024a0:	4d14      	ldr	r5, [pc, #80]	; (80024f4 <chMBPostAhead.constprop.33+0x64>)
 80024a2:	1c21      	adds	r1, r4, #0
 80024a4:	1c28      	adds	r0, r5, #0
 80024a6:	f001 f84b 	bl	8003540 <chSemWaitTimeoutS>
 80024aa:	1e04      	subs	r4, r0, #0
  if (rdymsg == MSG_OK) {
 80024ac:	d110      	bne.n	80024d0 <chMBPostAhead.constprop.33+0x40>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80024ae:	1c2a      	adds	r2, r5, #0
 80024b0:	3a1c      	subs	r2, #28
 80024b2:	68d3      	ldr	r3, [r2, #12]
 80024b4:	6811      	ldr	r1, [r2, #0]
 80024b6:	3b04      	subs	r3, #4
 80024b8:	60d3      	str	r3, [r2, #12]
 80024ba:	428b      	cmp	r3, r1
 80024bc:	d202      	bcs.n	80024c4 <chMBPostAhead.constprop.33+0x34>
      mbp->mb_rdptr = mbp->mb_top - 1;
 80024be:	6853      	ldr	r3, [r2, #4]
 80024c0:	3b04      	subs	r3, #4
 80024c2:	60d3      	str	r3, [r2, #12]
    }
    *mbp->mb_rdptr = msg;
 80024c4:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 80024c6:	480c      	ldr	r0, [pc, #48]	; (80024f8 <chMBPostAhead.constprop.33+0x68>)
 80024c8:	f001 f872 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 80024cc:	f000 ffd8 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80024d0:	f001 fa4e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80024d4:	4809      	ldr	r0, [pc, #36]	; (80024fc <chMBPostAhead.constprop.33+0x6c>)
 80024d6:	6806      	ldr	r6, [r0, #0]
 80024d8:	4286      	cmp	r6, r0
 80024da:	d004      	beq.n	80024e6 <chMBPostAhead.constprop.33+0x56>
 80024dc:	6985      	ldr	r5, [r0, #24]
 80024de:	68b2      	ldr	r2, [r6, #8]
 80024e0:	68a9      	ldr	r1, [r5, #8]
 80024e2:	4291      	cmp	r1, r2
 80024e4:	d302      	bcc.n	80024ec <chMBPostAhead.constprop.33+0x5c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80024e6:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 80024e8:	1c20      	adds	r0, r4, #0
 80024ea:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80024ec:	b672      	cpsid	i
 80024ee:	4c04      	ldr	r4, [pc, #16]	; (8002500 <chMBPostAhead.constprop.33+0x70>)
 80024f0:	62c4      	str	r4, [r0, #44]	; 0x2c
 80024f2:	e7fe      	b.n	80024f2 <chMBPostAhead.constprop.33+0x62>
 80024f4:	2000061c 	.word	0x2000061c
 80024f8:	20000610 	.word	0x20000610
 80024fc:	20001040 	.word	0x20001040
 8002500:	08008b10 	.word	0x08008b10
 8002504:	46c0      	nop			; (mov r8, r8)
 8002506:	46c0      	nop			; (mov r8, r8)
 8002508:	46c0      	nop			; (mov r8, r8)
 800250a:	46c0      	nop			; (mov r8, r8)
 800250c:	46c0      	nop			; (mov r8, r8)
 800250e:	46c0      	nop			; (mov r8, r8)

08002510 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8002510:	b538      	push	{r3, r4, r5, lr}
 8002512:	1c04      	adds	r4, r0, #0
 8002514:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002516:	f001 fac3 	bl	8003aa0 <_dbg_check_lock>
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {

  chDbgCheckClassS();
 800251a:	f7fe f999 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 800251e:	2c00      	cmp	r4, #0
 8002520:	d01f      	beq.n	8002562 <chSemWait+0x52>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 8002522:	68a3      	ldr	r3, [r4, #8]
 8002524:	6822      	ldr	r2, [r4, #0]
 8002526:	2b00      	cmp	r3, #0
 8002528:	db06      	blt.n	8002538 <chSemWait+0x28>
 800252a:	4294      	cmp	r4, r2
 800252c:	d006      	beq.n	800253c <chSemWait+0x2c>
 800252e:	b672      	cpsid	i
 8002530:	4d17      	ldr	r5, [pc, #92]	; (8002590 <chSemWait+0x80>)
 8002532:	4818      	ldr	r0, [pc, #96]	; (8002594 <chSemWait+0x84>)
 8002534:	62c5      	str	r5, [r0, #44]	; 0x2c
 8002536:	e7fe      	b.n	8002536 <chSemWait+0x26>
 8002538:	4294      	cmp	r4, r2
 800253a:	d0f8      	beq.n	800252e <chSemWait+0x1e>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800253c:	3b01      	subs	r3, #1
 800253e:	60a3      	str	r3, [r4, #8]
 8002540:	2b00      	cmp	r3, #0
 8002542:	db17      	blt.n	8002574 <chSemWait+0x64>
 8002544:	4d13      	ldr	r5, [pc, #76]	; (8002594 <chSemWait+0x84>)
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 8002546:	2400      	movs	r4, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002548:	f001 fa12 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800254c:	6828      	ldr	r0, [r5, #0]
 800254e:	42a8      	cmp	r0, r5
 8002550:	d004      	beq.n	800255c <chSemWait+0x4c>
 8002552:	69aa      	ldr	r2, [r5, #24]
 8002554:	6883      	ldr	r3, [r0, #8]
 8002556:	6891      	ldr	r1, [r2, #8]
 8002558:	4299      	cmp	r1, r3
 800255a:	d307      	bcc.n	800256c <chSemWait+0x5c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800255c:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 800255e:	1c20      	adds	r0, r4, #0
 8002560:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002562:	b672      	cpsid	i
 8002564:	4a0a      	ldr	r2, [pc, #40]	; (8002590 <chSemWait+0x80>)
 8002566:	490b      	ldr	r1, [pc, #44]	; (8002594 <chSemWait+0x84>)
 8002568:	62ca      	str	r2, [r1, #44]	; 0x2c
 800256a:	e7fe      	b.n	800256a <chSemWait+0x5a>
 800256c:	b672      	cpsid	i
 800256e:	4c0a      	ldr	r4, [pc, #40]	; (8002598 <chSemWait+0x88>)
 8002570:	62ec      	str	r4, [r5, #44]	; 0x2c
 8002572:	e7fe      	b.n	8002572 <chSemWait+0x62>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 8002574:	4d07      	ldr	r5, [pc, #28]	; (8002594 <chSemWait+0x84>)
 8002576:	69a8      	ldr	r0, [r5, #24]
 8002578:	6244      	str	r4, [r0, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800257a:	6861      	ldr	r1, [r4, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800257c:	6004      	str	r4, [r0, #0]
  tp->p_prev = tqp->p_prev;
 800257e:	6041      	str	r1, [r0, #4]
  tp->p_prev->p_next = tp;
 8002580:	6008      	str	r0, [r1, #0]
  tqp->p_prev = tp;
 8002582:	6060      	str	r0, [r4, #4]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8002584:	2005      	movs	r0, #5
 8002586:	f7fe fca3 	bl	8000ed0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 800258a:	69ab      	ldr	r3, [r5, #24]
 800258c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800258e:	e7db      	b.n	8002548 <chSemWait+0x38>
 8002590:	08008720 	.word	0x08008720
 8002594:	20001040 	.word	0x20001040
 8002598:	08008600 	.word	0x08008600
 800259c:	46c0      	nop			; (mov r8, r8)
 800259e:	46c0      	nop			; (mov r8, r8)

080025a0 <thread3.8989.4125>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread3, p) {
 80025a0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 80025a2:	4c04      	ldr	r4, [pc, #16]	; (80025b4 <thread3.8989.4125+0x14>)
 80025a4:	1c20      	adds	r0, r4, #0
 80025a6:	f7ff ffb3 	bl	8002510 <chSemWait>
  chSemSignal(&sem1);
 80025aa:	1c20      	adds	r0, r4, #0
 80025ac:	f001 fae0 	bl	8003b70 <chSemSignal>
}
 80025b0:	bd10      	pop	{r4, pc}
 80025b2:	46c0      	nop			; (mov r8, r8)
 80025b4:	200006a4 	.word	0x200006a4
 80025b8:	46c0      	nop			; (mov r8, r8)
 80025ba:	46c0      	nop			; (mov r8, r8)
 80025bc:	46c0      	nop			; (mov r8, r8)
 80025be:	46c0      	nop			; (mov r8, r8)

080025c0 <thread3.10787>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 80025c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80025c2:	4c08      	ldr	r4, [pc, #32]	; (80025e4 <thread3.10787+0x24>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80025c4:	2321      	movs	r3, #33	; 0x21
 80025c6:	69a2      	ldr	r2, [r4, #24]
 80025c8:	5cd0      	ldrb	r0, [r2, r3]

  (void)p;
  while (!chThdShouldTerminateX())
 80025ca:	0742      	lsls	r2, r0, #29
 80025cc:	d409      	bmi.n	80025e2 <thread3.10787+0x22>
 80025ce:	4f06      	ldr	r7, [pc, #24]	; (80025e8 <thread3.10787+0x28>)
 80025d0:	2621      	movs	r6, #33	; 0x21
 80025d2:	2504      	movs	r5, #4
    chSemWait(&sem1);
 80025d4:	1c38      	adds	r0, r7, #0
 80025d6:	f7ff ff9b 	bl	8002510 <chSemWait>
 80025da:	69a1      	ldr	r1, [r4, #24]
 80025dc:	5d8b      	ldrb	r3, [r1, r6]
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 80025de:	421d      	tst	r5, r3
 80025e0:	d0f8      	beq.n	80025d4 <thread3.10787+0x14>
    chSemWait(&sem1);
}
 80025e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80025e4:	20001040 	.word	0x20001040
 80025e8:	20000d48 	.word	0x20000d48
 80025ec:	46c0      	nop			; (mov r8, r8)
 80025ee:	46c0      	nop			; (mov r8, r8)

080025f0 <chThdYield.4150>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 80025f0:	b538      	push	{r3, r4, r5, lr}
 80025f2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80025f4:	f001 fa54 	bl	8003aa0 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();
 80025f8:	f7fe f92a 	bl	8000850 <chDbgCheckClassS>
 *
 * @sclass
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();
 80025fc:	f7fe f928 	bl	8000850 <chDbgCheckClassS>

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8002600:	4c19      	ldr	r4, [pc, #100]	; (8002668 <chThdYield.4150+0x78>)
 8002602:	6823      	ldr	r3, [r4, #0]
 8002604:	69a5      	ldr	r5, [r4, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8002606:	6899      	ldr	r1, [r3, #8]
 8002608:	68aa      	ldr	r2, [r5, #8]
 800260a:	4291      	cmp	r1, r2
 800260c:	d20b      	bcs.n	8002626 <chThdYield.4150+0x36>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800260e:	f001 f9af 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002612:	6825      	ldr	r5, [r4, #0]
 8002614:	42a5      	cmp	r5, r4
 8002616:	d004      	beq.n	8002622 <chThdYield.4150+0x32>
 8002618:	69a1      	ldr	r1, [r4, #24]
 800261a:	68ab      	ldr	r3, [r5, #8]
 800261c:	688a      	ldr	r2, [r1, #8]
 800261e:	429a      	cmp	r2, r3
 8002620:	d319      	bcc.n	8002656 <chThdYield.4150+0x66>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002622:	b662      	cpsie	i

  chSysLock();
  chSchDoYieldS();
  chSysUnlock();
}
 8002624:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002626:	6818      	ldr	r0, [r3, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8002628:	2101      	movs	r1, #1
 800262a:	2220      	movs	r2, #32
  tqp->p_next->p_prev = (thread_t *)tqp;
 800262c:	6044      	str	r4, [r0, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800262e:	6020      	str	r0, [r4, #0]
 8002630:	5499      	strb	r1, [r3, r2]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
 8002632:	1c28      	adds	r0, r5, #0
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8002634:	61a3      	str	r3, [r4, #24]
#endif
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
 8002636:	f7fe f87b 	bl	8000730 <chSchReadyI>
  chSysSwitch(currp, otp);
 800263a:	1c28      	adds	r0, r5, #0
 800263c:	f7fe fbe8 	bl	8000e10 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8002640:	f3ef 8309 	mrs	r3, PSP
 8002644:	69e8      	ldr	r0, [r5, #28]
 8002646:	3b24      	subs	r3, #36	; 0x24
 8002648:	4298      	cmp	r0, r3
 800264a:	d808      	bhi.n	800265e <chThdYield.4150+0x6e>
 800264c:	69a0      	ldr	r0, [r4, #24]
 800264e:	1c29      	adds	r1, r5, #0
 8002650:	f7fd fdbe 	bl	80001d0 <_port_switch>
 8002654:	e7db      	b.n	800260e <chThdYield.4150+0x1e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002656:	b672      	cpsid	i
 8002658:	4804      	ldr	r0, [pc, #16]	; (800266c <chThdYield.4150+0x7c>)
 800265a:	62e0      	str	r0, [r4, #44]	; 0x2c
 800265c:	e7fe      	b.n	800265c <chThdYield.4150+0x6c>
 800265e:	b672      	cpsid	i
 8002660:	4d03      	ldr	r5, [pc, #12]	; (8002670 <chThdYield.4150+0x80>)
 8002662:	62e5      	str	r5, [r4, #44]	; 0x2c
 8002664:	e7fe      	b.n	8002664 <chThdYield.4150+0x74>
 8002666:	46c0      	nop			; (mov r8, r8)
 8002668:	20001040 	.word	0x20001040
 800266c:	08008b00 	.word	0x08008b00
 8002670:	0800855c 	.word	0x0800855c
 8002674:	46c0      	nop			; (mov r8, r8)
 8002676:	46c0      	nop			; (mov r8, r8)
 8002678:	46c0      	nop			; (mov r8, r8)
 800267a:	46c0      	nop			; (mov r8, r8)
 800267c:	46c0      	nop			; (mov r8, r8)
 800267e:	46c0      	nop			; (mov r8, r8)

08002680 <thread8.10784>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8002680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002682:	4f0a      	ldr	r7, [pc, #40]	; (80026ac <thread8.10784+0x2c>)
 8002684:	1c04      	adds	r4, r0, #0
 8002686:	2621      	movs	r6, #33	; 0x21
 8002688:	2504      	movs	r5, #4

  do {
    chThdYield();
 800268a:	f7ff ffb1 	bl	80025f0 <chThdYield.4150>
    chThdYield();
 800268e:	f7ff ffaf 	bl	80025f0 <chThdYield.4150>
    chThdYield();
 8002692:	f7ff ffad 	bl	80025f0 <chThdYield.4150>
    chThdYield();
 8002696:	f7ff ffab 	bl	80025f0 <chThdYield.4150>
    (*(uint32_t *)p) += 4;
 800269a:	6823      	ldr	r3, [r4, #0]
 800269c:	69ba      	ldr	r2, [r7, #24]
 800269e:	3304      	adds	r3, #4
 80026a0:	6023      	str	r3, [r4, #0]
 80026a2:	5d90      	ldrb	r0, [r2, r6]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 80026a4:	4205      	tst	r5, r0
 80026a6:	d0f0      	beq.n	800268a <thread8.10784+0xa>
}
 80026a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80026aa:	46c0      	nop			; (mov r8, r8)
 80026ac:	20001040 	.word	0x20001040

080026b0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80026b0:	b510      	push	{r4, lr}
 80026b2:	1c04      	adds	r4, r0, #0
 80026b4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80026b6:	f001 f9f3 	bl	8003aa0 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 80026ba:	2c00      	cmp	r4, #0
 80026bc:	d010      	beq.n	80026e0 <chThdSleep+0x30>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80026be:	1c21      	adds	r1, r4, #0
 80026c0:	2008      	movs	r0, #8
 80026c2:	f7fe fcb5 	bl	8001030 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80026c6:	f001 f953 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80026ca:	4b0a      	ldr	r3, [pc, #40]	; (80026f4 <chThdSleep+0x44>)
 80026cc:	681a      	ldr	r2, [r3, #0]
 80026ce:	429a      	cmp	r2, r3
 80026d0:	d004      	beq.n	80026dc <chThdSleep+0x2c>
 80026d2:	6999      	ldr	r1, [r3, #24]
 80026d4:	6894      	ldr	r4, [r2, #8]
 80026d6:	6888      	ldr	r0, [r1, #8]
 80026d8:	42a0      	cmp	r0, r4
 80026da:	d306      	bcc.n	80026ea <chThdSleep+0x3a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80026dc:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 80026de:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80026e0:	b672      	cpsid	i
 80026e2:	4905      	ldr	r1, [pc, #20]	; (80026f8 <chThdSleep+0x48>)
 80026e4:	4b03      	ldr	r3, [pc, #12]	; (80026f4 <chThdSleep+0x44>)
 80026e6:	62d9      	str	r1, [r3, #44]	; 0x2c
 80026e8:	e7fe      	b.n	80026e8 <chThdSleep+0x38>
 80026ea:	b672      	cpsid	i
 80026ec:	4a03      	ldr	r2, [pc, #12]	; (80026fc <chThdSleep+0x4c>)
 80026ee:	62da      	str	r2, [r3, #44]	; 0x2c
 80026f0:	e7fe      	b.n	80026f0 <chThdSleep+0x40>
 80026f2:	46c0      	nop			; (mov r8, r8)
 80026f4:	20001040 	.word	0x20001040
 80026f8:	08008af0 	.word	0x08008af0
 80026fc:	08008b00 	.word	0x08008b00

08002700 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8002700:	b510      	push	{r4, lr}

  chThdSleep(1);
 8002702:	2001      	movs	r0, #1
 8002704:	f7ff ffd4 	bl	80026b0 <chThdSleep>
 8002708:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800270a:	f001 f9c9 	bl	8003aa0 <_dbg_check_lock>
 800270e:	2380      	movs	r3, #128	; 0x80
 8002710:	05d8      	lsls	r0, r3, #23
 8002712:	6a44      	ldr	r4, [r0, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002714:	f001 f92c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002718:	4b07      	ldr	r3, [pc, #28]	; (8002738 <test_wait_tick+0x38>)
 800271a:	681a      	ldr	r2, [r3, #0]
 800271c:	429a      	cmp	r2, r3
 800271e:	d004      	beq.n	800272a <test_wait_tick+0x2a>
 8002720:	6999      	ldr	r1, [r3, #24]
 8002722:	6892      	ldr	r2, [r2, #8]
 8002724:	6888      	ldr	r0, [r1, #8]
 8002726:	4290      	cmp	r0, r2
 8002728:	d302      	bcc.n	8002730 <test_wait_tick+0x30>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800272a:	b662      	cpsie	i
  return chVTGetSystemTime();
}
 800272c:	1c20      	adds	r0, r4, #0
 800272e:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002730:	b672      	cpsid	i
 8002732:	4c02      	ldr	r4, [pc, #8]	; (800273c <test_wait_tick+0x3c>)
 8002734:	62dc      	str	r4, [r3, #44]	; 0x2c
 8002736:	e7fe      	b.n	8002736 <test_wait_tick+0x36>
 8002738:	20001040 	.word	0x20001040
 800273c:	08008a00 	.word	0x08008a00

08002740 <Thread2.11102>:

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
 8002740:	b538      	push	{r3, r4, r5, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8002742:	4b08      	ldr	r3, [pc, #32]	; (8002764 <Thread2.11102+0x24>)
 8002744:	4a08      	ldr	r2, [pc, #32]	; (8002768 <Thread2.11102+0x28>)
 8002746:	6998      	ldr	r0, [r3, #24]

  (void)arg;
  chRegSetThreadName("blinker2");
  while (true) {
    palClearPad(GPIOC, GPIOC_LED_GREEN);
 8002748:	2480      	movs	r4, #128	; 0x80
 800274a:	4d08      	ldr	r5, [pc, #32]	; (800276c <Thread2.11102+0x2c>)
 800274c:	6182      	str	r2, [r0, #24]
 800274e:	00a4      	lsls	r4, r4, #2
 8002750:	836c      	strh	r4, [r5, #26]
    chThdSleepMilliseconds(250);
 8002752:	4807      	ldr	r0, [pc, #28]	; (8002770 <Thread2.11102+0x30>)
 8002754:	f7ff ffac 	bl	80026b0 <chThdSleep>
    palSetPad(GPIOC, GPIOC_LED_GREEN);
 8002758:	832c      	strh	r4, [r5, #24]
    chThdSleepMilliseconds(250);
 800275a:	4805      	ldr	r0, [pc, #20]	; (8002770 <Thread2.11102+0x30>)
 800275c:	f7ff ffa8 	bl	80026b0 <chThdSleep>
 8002760:	e7f6      	b.n	8002750 <Thread2.11102+0x10>
 8002762:	46c0      	nop			; (mov r8, r8)
 8002764:	20001040 	.word	0x20001040
 8002768:	080086f0 	.word	0x080086f0
 800276c:	48000800 	.word	0x48000800
 8002770:	000009c4 	.word	0x000009c4
 8002774:	46c0      	nop			; (mov r8, r8)
 8002776:	46c0      	nop			; (mov r8, r8)
 8002778:	46c0      	nop			; (mov r8, r8)
 800277a:	46c0      	nop			; (mov r8, r8)
 800277c:	46c0      	nop			; (mov r8, r8)
 800277e:	46c0      	nop			; (mov r8, r8)

08002780 <Thread1.11105>:

/*
 * Blue LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002780:	b538      	push	{r3, r4, r5, lr}
 8002782:	4b07      	ldr	r3, [pc, #28]	; (80027a0 <Thread1.11105+0x20>)
 8002784:	4a07      	ldr	r2, [pc, #28]	; (80027a4 <Thread1.11105+0x24>)
 8002786:	6998      	ldr	r0, [r3, #24]

  (void)arg;
  chRegSetThreadName("blinker1");
  while (true) {
    palClearPad(GPIOC, GPIOC_LED_BLUE);
 8002788:	4d07      	ldr	r5, [pc, #28]	; (80027a8 <Thread1.11105+0x28>)
 800278a:	6182      	str	r2, [r0, #24]
 800278c:	2480      	movs	r4, #128	; 0x80
 800278e:	836c      	strh	r4, [r5, #26]
    chThdSleepMilliseconds(500);
 8002790:	4806      	ldr	r0, [pc, #24]	; (80027ac <Thread1.11105+0x2c>)
 8002792:	f7ff ff8d 	bl	80026b0 <chThdSleep>
    palSetPad(GPIOC, GPIOC_LED_BLUE);
 8002796:	832c      	strh	r4, [r5, #24]
    chThdSleepMilliseconds(500);
 8002798:	4804      	ldr	r0, [pc, #16]	; (80027ac <Thread1.11105+0x2c>)
 800279a:	f7ff ff89 	bl	80026b0 <chThdSleep>
 800279e:	e7f6      	b.n	800278e <Thread1.11105+0xe>
 80027a0:	20001040 	.word	0x20001040
 80027a4:	080086fc 	.word	0x080086fc
 80027a8:	48000800 	.word	0x48000800
 80027ac:	00001388 	.word	0x00001388

080027b0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80027b0:	b510      	push	{r4, lr}
 80027b2:	1c04      	adds	r4, r0, #0
 80027b4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80027b6:	f001 f973 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  chMtxLockS(mp);
 80027ba:	1c20      	adds	r0, r4, #0
 80027bc:	f7fe fbb0 	bl	8000f20 <chMtxLockS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80027c0:	f001 f8d6 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80027c4:	4b07      	ldr	r3, [pc, #28]	; (80027e4 <chMtxLock+0x34>)
 80027c6:	681a      	ldr	r2, [r3, #0]
 80027c8:	429a      	cmp	r2, r3
 80027ca:	d004      	beq.n	80027d6 <chMtxLock+0x26>
 80027cc:	6999      	ldr	r1, [r3, #24]
 80027ce:	6894      	ldr	r4, [r2, #8]
 80027d0:	6888      	ldr	r0, [r1, #8]
 80027d2:	42a0      	cmp	r0, r4
 80027d4:	d301      	bcc.n	80027da <chMtxLock+0x2a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80027d6:	b662      	cpsie	i
  chSysUnlock();
}
 80027d8:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80027da:	b672      	cpsid	i
 80027dc:	4a02      	ldr	r2, [pc, #8]	; (80027e8 <chMtxLock+0x38>)
 80027de:	62da      	str	r2, [r3, #44]	; 0x2c
 80027e0:	e7fe      	b.n	80027e0 <chMtxLock+0x30>
 80027e2:	46c0      	nop			; (mov r8, r8)
 80027e4:	20001040 	.word	0x20001040
 80027e8:	080089f0 	.word	0x080089f0
 80027ec:	46c0      	nop			; (mov r8, r8)
 80027ee:	46c0      	nop			; (mov r8, r8)

080027f0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80027f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 80027f2:	4d30      	ldr	r5, [pc, #192]	; (80028b4 <chMtxUnlock+0xc4>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80027f4:	4646      	mov	r6, r8
 80027f6:	464f      	mov	r7, r9
 80027f8:	b4c0      	push	{r6, r7}
 80027fa:	1c04      	adds	r4, r0, #0
  thread_t *ctp = currp;
 80027fc:	69ae      	ldr	r6, [r5, #24]
 80027fe:	b672      	cpsid	i
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8002800:	2800      	cmp	r0, #0
 8002802:	d00c      	beq.n	800281e <chMtxUnlock+0x2e>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002804:	f001 f94c 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 8002808:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 800280a:	2b00      	cmp	r3, #0
 800280c:	d04d      	beq.n	80028aa <chMtxUnlock+0xba>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 800280e:	689a      	ldr	r2, [r3, #8]
 8002810:	4690      	mov	r8, r2
 8002812:	42b2      	cmp	r2, r6
 8002814:	d006      	beq.n	8002824 <chMtxUnlock+0x34>
 8002816:	b672      	cpsid	i
 8002818:	4927      	ldr	r1, [pc, #156]	; (80028b8 <chMtxUnlock+0xc8>)
 800281a:	62e9      	str	r1, [r5, #44]	; 0x2c
 800281c:	e7fe      	b.n	800281c <chMtxUnlock+0x2c>
 800281e:	4f26      	ldr	r7, [pc, #152]	; (80028b8 <chMtxUnlock+0xc8>)
 8002820:	62ef      	str	r7, [r5, #44]	; 0x2c
 8002822:	e7fe      	b.n	8002822 <chMtxUnlock+0x32>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 8002824:	429c      	cmp	r4, r3
 8002826:	d003      	beq.n	8002830 <chMtxUnlock+0x40>
 8002828:	b672      	cpsid	i
 800282a:	4823      	ldr	r0, [pc, #140]	; (80028b8 <chMtxUnlock+0xc8>)
 800282c:	62e8      	str	r0, [r5, #44]	; 0x2c
 800282e:	e7fe      	b.n	800282e <chMtxUnlock+0x3e>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002830:	68e6      	ldr	r6, [r4, #12]
 8002832:	63d6      	str	r6, [r2, #60]	; 0x3c
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8002834:	f7fe f80c 	bl	8000850 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002838:	6827      	ldr	r7, [r4, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800283a:	42bc      	cmp	r4, r7
 800283c:	d032      	beq.n	80028a4 <chMtxUnlock+0xb4>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800283e:	4643      	mov	r3, r8
 8002840:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002842:	4691      	mov	r9, r2
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002844:	2e00      	cmp	r6, #0
 8002846:	d00b      	beq.n	8002860 <chMtxUnlock+0x70>
 8002848:	f7fe f802 	bl	8000850 <chDbgCheckClassS>
 800284c:	6830      	ldr	r0, [r6, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800284e:	4286      	cmp	r6, r0
 8002850:	d003      	beq.n	800285a <chMtxUnlock+0x6a>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8002852:	6881      	ldr	r1, [r0, #8]
 8002854:	4589      	cmp	r9, r1
 8002856:	d200      	bcs.n	800285a <chMtxUnlock+0x6a>
 8002858:	4689      	mov	r9, r1
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 800285a:	68f6      	ldr	r6, [r6, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800285c:	2e00      	cmp	r6, #0
 800285e:	d1f3      	bne.n	8002848 <chMtxUnlock+0x58>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002860:	6838      	ldr	r0, [r7, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8002862:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8002864:	464a      	mov	r2, r9
 8002866:	4643      	mov	r3, r8
 8002868:	609a      	str	r2, [r3, #8]
 800286a:	6020      	str	r0, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800286c:	6044      	str	r4, [r0, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 800286e:	60e1      	str	r1, [r4, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8002870:	60a7      	str	r7, [r4, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002872:	1c38      	adds	r0, r7, #0
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
 8002874:	63fc      	str	r4, [r7, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002876:	f7fd ff5b 	bl	8000730 <chSchReadyI>
      chSchRescheduleS();
 800287a:	f000 fe01 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800287e:	f001 f877 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002882:	682c      	ldr	r4, [r5, #0]
 8002884:	42ac      	cmp	r4, r5
 8002886:	d004      	beq.n	8002892 <chMtxUnlock+0xa2>
 8002888:	69af      	ldr	r7, [r5, #24]
 800288a:	68a2      	ldr	r2, [r4, #8]
 800288c:	68be      	ldr	r6, [r7, #8]
 800288e:	4296      	cmp	r6, r2
 8002890:	d304      	bcc.n	800289c <chMtxUnlock+0xac>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002892:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8002894:	bc0c      	pop	{r2, r3}
 8002896:	4690      	mov	r8, r2
 8002898:	4699      	mov	r9, r3
 800289a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800289c:	b672      	cpsid	i
 800289e:	4b07      	ldr	r3, [pc, #28]	; (80028bc <chMtxUnlock+0xcc>)
 80028a0:	62eb      	str	r3, [r5, #44]	; 0x2c
 80028a2:	e7fe      	b.n	80028a2 <chMtxUnlock+0xb2>
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->m_owner = NULL;
 80028a4:	2100      	movs	r1, #0
 80028a6:	60a1      	str	r1, [r4, #8]
 80028a8:	e7e9      	b.n	800287e <chMtxUnlock+0x8e>
 80028aa:	b672      	cpsid	i
 80028ac:	4c02      	ldr	r4, [pc, #8]	; (80028b8 <chMtxUnlock+0xc8>)
 80028ae:	62ec      	str	r4, [r5, #44]	; 0x2c
 80028b0:	e7fe      	b.n	80028b0 <chMtxUnlock+0xc0>
 80028b2:	46c0      	nop			; (mov r8, r8)
 80028b4:	20001040 	.word	0x20001040
 80028b8:	08008710 	.word	0x08008710
 80028bc:	080089f0 	.word	0x080089f0

080028c0 <thread4b.9233>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread4b, p) {
 80028c0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 80028c2:	4805      	ldr	r0, [pc, #20]	; (80028d8 <thread4b.9233+0x18>)
 80028c4:	f7ff fef4 	bl	80026b0 <chThdSleep>
  chMtxLock(&m1);
 80028c8:	4c04      	ldr	r4, [pc, #16]	; (80028dc <thread4b.9233+0x1c>)
 80028ca:	1c20      	adds	r0, r4, #0
 80028cc:	f7ff ff70 	bl	80027b0 <chMtxLock>
  chMtxUnlock(&m1);
 80028d0:	1c20      	adds	r0, r4, #0
 80028d2:	f7ff ff8d 	bl	80027f0 <chMtxUnlock>
}
 80028d6:	bd10      	pop	{r4, pc}
 80028d8:	000005dc 	.word	0x000005dc
 80028dc:	20000694 	.word	0x20000694

080028e0 <thread4a.9236>:
}

static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 80028e0:	20fa      	movs	r0, #250	; 0xfa

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 80028e2:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 80028e4:	0040      	lsls	r0, r0, #1
 80028e6:	f7ff fee3 	bl	80026b0 <chThdSleep>
  chMtxLock(&m2);
 80028ea:	4c04      	ldr	r4, [pc, #16]	; (80028fc <thread4a.9236+0x1c>)
 80028ec:	1c20      	adds	r0, r4, #0
 80028ee:	f7ff ff5f 	bl	80027b0 <chMtxLock>
  chMtxUnlock(&m2);
 80028f2:	1c20      	adds	r0, r4, #0
 80028f4:	f7ff ff7c 	bl	80027f0 <chMtxUnlock>
}
 80028f8:	bd10      	pop	{r4, pc}
 80028fa:	46c0      	nop			; (mov r8, r8)
 80028fc:	20000678 	.word	0x20000678

08002900 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8002900:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002902:	4647      	mov	r7, r8
 8002904:	b480      	push	{r7}
 8002906:	1e07      	subs	r7, r0, #0
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8002908:	d038      	beq.n	800297c <chHeapAlloc+0x7c>
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 800290a:	1dce      	adds	r6, r1, #7
  qp = &heapp->h_free;

  H_LOCK(heapp);
 800290c:	2110      	movs	r1, #16

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 800290e:	2307      	movs	r3, #7
  qp = &heapp->h_free;
 8002910:	1c3d      	adds	r5, r7, #0

  H_LOCK(heapp);
 8002912:	19c8      	adds	r0, r1, r7

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 8002914:	439e      	bics	r6, r3
  qp = &heapp->h_free;
 8002916:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8002918:	4680      	mov	r8, r0
 800291a:	f7ff ff49 	bl	80027b0 <chMtxLock>
 800291e:	e000      	b.n	8002922 <chHeapAlloc+0x22>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8002920:	1c25      	adds	r5, r4, #0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 8002922:	682c      	ldr	r4, [r5, #0]
 8002924:	2c00      	cmp	r4, #0
 8002926:	d01a      	beq.n	800295e <chHeapAlloc+0x5e>
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8002928:	6863      	ldr	r3, [r4, #4]
 800292a:	429e      	cmp	r6, r3
 800292c:	d8f8      	bhi.n	8002920 <chHeapAlloc+0x20>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800292e:	1c31      	adds	r1, r6, #0
 8002930:	3108      	adds	r1, #8
 8002932:	4299      	cmp	r1, r3
 8002934:	d810      	bhi.n	8002958 <chHeapAlloc+0x58>
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8002936:	6822      	ldr	r2, [r4, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002938:	1b9b      	subs	r3, r3, r6
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 800293a:	1860      	adds	r0, r4, r1
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 800293c:	3b08      	subs	r3, #8
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 800293e:	6002      	str	r2, [r0, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002940:	6043      	str	r3, [r0, #4]
        qp->h.u.next = fp;
 8002942:	6028      	str	r0, [r5, #0]
        hp->h.size = size;
 8002944:	6066      	str	r6, [r4, #4]
      }
      hp->h.u.heap = heapp;
      H_UNLOCK(heapp);
 8002946:	4640      	mov	r0, r8
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8002948:	6027      	str	r7, [r4, #0]
      H_UNLOCK(heapp);
 800294a:	f7ff ff51 	bl	80027f0 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 800294e:	1c20      	adds	r0, r4, #0
 8002950:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8002952:	bc04      	pop	{r2}
 8002954:	4690      	mov	r8, r2
 8002956:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 8002958:	6826      	ldr	r6, [r4, #0]
 800295a:	602e      	str	r6, [r5, #0]
 800295c:	e7f3      	b.n	8002946 <chHeapAlloc+0x46>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 800295e:	4640      	mov	r0, r8
 8002960:	f7ff ff46 	bl	80027f0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 8002964:	683a      	ldr	r2, [r7, #0]
 8002966:	2a00      	cmp	r2, #0
 8002968:	d00a      	beq.n	8002980 <chHeapAlloc+0x80>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 800296a:	1c30      	adds	r0, r6, #0
 800296c:	3008      	adds	r0, #8
 800296e:	4790      	blx	r2
    if (hp != NULL) {
 8002970:	2800      	cmp	r0, #0
 8002972:	d005      	beq.n	8002980 <chHeapAlloc+0x80>
      hp->h.u.heap = heapp;
 8002974:	6007      	str	r7, [r0, #0]
      hp->h.size = size;
 8002976:	6046      	str	r6, [r0, #4]
      hp++;

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 8002978:	3008      	adds	r0, #8
 800297a:	e7ea      	b.n	8002952 <chHeapAlloc+0x52>
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 800297c:	4f01      	ldr	r7, [pc, #4]	; (8002984 <chHeapAlloc+0x84>)
 800297e:	e7c4      	b.n	800290a <chHeapAlloc+0xa>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 8002980:	2000      	movs	r0, #0
 8002982:	e7e6      	b.n	8002952 <chHeapAlloc+0x52>
 8002984:	20000f88 	.word	0x20000f88
 8002988:	46c0      	nop			; (mov r8, r8)
 800298a:	46c0      	nop			; (mov r8, r8)
 800298c:	46c0      	nop			; (mov r8, r8)
 800298e:	46c0      	nop			; (mov r8, r8)

08002990 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002990:	b570      	push	{r4, r5, r6, lr}
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);
 8002992:	2800      	cmp	r0, #0
 8002994:	d047      	beq.n	8002a26 <chHeapFree+0x96>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8002996:	1c04      	adds	r4, r0, #0
 8002998:	3c08      	subs	r4, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800299a:	6825      	ldr	r5, [r4, #0]
  qp = &heapp->h_free;
 800299c:	1c2e      	adds	r6, r5, #0

  H_LOCK(heapp);
 800299e:	3510      	adds	r5, #16

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 80029a0:	3608      	adds	r6, #8

  H_LOCK(heapp);
 80029a2:	1c28      	adds	r0, r5, #0
 80029a4:	f7ff ff04 	bl	80027b0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 80029a8:	1c33      	adds	r3, r6, #0

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");
 80029aa:	42a3      	cmp	r3, r4
 80029ac:	d804      	bhi.n	80029b8 <chHeapFree+0x28>
 80029ae:	685a      	ldr	r2, [r3, #4]
 80029b0:	3208      	adds	r2, #8
 80029b2:	1898      	adds	r0, r3, r2
 80029b4:	4284      	cmp	r4, r0
 80029b6:	d310      	bcc.n	80029da <chHeapFree+0x4a>

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80029b8:	42b3      	cmp	r3, r6
 80029ba:	d001      	beq.n	80029c0 <chHeapFree+0x30>
 80029bc:	42a3      	cmp	r3, r4
 80029be:	d211      	bcs.n	80029e4 <chHeapFree+0x54>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80029c0:	6819      	ldr	r1, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80029c2:	2900      	cmp	r1, #0
 80029c4:	d010      	beq.n	80029e8 <chHeapFree+0x58>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80029c6:	428c      	cmp	r4, r1
 80029c8:	d30e      	bcc.n	80029e8 <chHeapFree+0x58>
 80029ca:	1c0b      	adds	r3, r1, #0
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");
 80029cc:	42a3      	cmp	r3, r4
 80029ce:	d8f3      	bhi.n	80029b8 <chHeapFree+0x28>
 80029d0:	685a      	ldr	r2, [r3, #4]
 80029d2:	3208      	adds	r2, #8
 80029d4:	1898      	adds	r0, r3, r2
 80029d6:	4284      	cmp	r4, r0
 80029d8:	d2ee      	bcs.n	80029b8 <chHeapFree+0x28>
 80029da:	b672      	cpsid	i
 80029dc:	4d14      	ldr	r5, [pc, #80]	; (8002a30 <chHeapFree+0xa0>)
 80029de:	4b15      	ldr	r3, [pc, #84]	; (8002a34 <chHeapFree+0xa4>)
 80029e0:	62dd      	str	r5, [r3, #44]	; 0x2c
 80029e2:	e7fe      	b.n	80029e2 <chHeapFree+0x52>
 80029e4:	681b      	ldr	r3, [r3, #0]
 80029e6:	e7e0      	b.n	80029aa <chHeapFree+0x1a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80029e8:	6866      	ldr	r6, [r4, #4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 80029ea:	6021      	str	r1, [r4, #0]
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80029ec:	1c32      	adds	r2, r6, #0

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
 80029ee:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80029f0:	3208      	adds	r2, #8
 80029f2:	6820      	ldr	r0, [r4, #0]
 80029f4:	18a2      	adds	r2, r4, r2
 80029f6:	4282      	cmp	r2, r0
 80029f8:	d105      	bne.n	8002a06 <chHeapFree+0x76>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80029fa:	6851      	ldr	r1, [r2, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 80029fc:	6812      	ldr	r2, [r2, #0]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80029fe:	1876      	adds	r6, r6, r1
 8002a00:	3608      	adds	r6, #8
 8002a02:	6066      	str	r6, [r4, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8002a04:	6022      	str	r2, [r4, #0]
      }
      if ((LIMIT(qp) == hp)) {
 8002a06:	6858      	ldr	r0, [r3, #4]
 8002a08:	1c01      	adds	r1, r0, #0
 8002a0a:	3108      	adds	r1, #8
 8002a0c:	185e      	adds	r6, r3, r1
 8002a0e:	42b4      	cmp	r4, r6
 8002a10:	d105      	bne.n	8002a1e <chHeapFree+0x8e>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8002a12:	6862      	ldr	r2, [r4, #4]
        qp->h.u.next = hp->h.u.next;
 8002a14:	6824      	ldr	r4, [r4, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8002a16:	1880      	adds	r0, r0, r2
 8002a18:	3008      	adds	r0, #8
 8002a1a:	6058      	str	r0, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8002a1c:	601c      	str	r4, [r3, #0]
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002a1e:	1c28      	adds	r0, r5, #0
 8002a20:	f7ff fee6 	bl	80027f0 <chMtxUnlock>

  return;
}
 8002a24:	bd70      	pop	{r4, r5, r6, pc}
 8002a26:	b672      	cpsid	i
 8002a28:	4901      	ldr	r1, [pc, #4]	; (8002a30 <chHeapFree+0xa0>)
 8002a2a:	4e02      	ldr	r6, [pc, #8]	; (8002a34 <chHeapFree+0xa4>)
 8002a2c:	62f1      	str	r1, [r6, #44]	; 0x2c
 8002a2e:	e7fe      	b.n	8002a2e <chHeapFree+0x9e>
 8002a30:	080086e0 	.word	0x080086e0
 8002a34:	20001040 	.word	0x20001040
 8002a38:	46c0      	nop			; (mov r8, r8)
 8002a3a:	46c0      	nop			; (mov r8, r8)
 8002a3c:	46c0      	nop			; (mov r8, r8)
 8002a3e:	46c0      	nop			; (mov r8, r8)

08002a40 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002a40:	b570      	push	{r4, r5, r6, lr}
 8002a42:	1c04      	adds	r4, r0, #0
 8002a44:	1c0e      	adds	r6, r1, #0
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8002a46:	2800      	cmp	r0, #0
 8002a48:	d017      	beq.n	8002a7a <chHeapStatus+0x3a>
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8002a4a:	1c25      	adds	r5, r4, #0
 8002a4c:	3510      	adds	r5, #16
 8002a4e:	1c28      	adds	r0, r5, #0
 8002a50:	f7ff feae 	bl	80027b0 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002a54:	68a3      	ldr	r3, [r4, #8]
 8002a56:	2200      	movs	r2, #0
 8002a58:	2400      	movs	r4, #0
 8002a5a:	2b00      	cmp	r3, #0
 8002a5c:	d005      	beq.n	8002a6a <chHeapStatus+0x2a>
    sz += qp->h.u.next->h.size;
 8002a5e:	6859      	ldr	r1, [r3, #4]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002a60:	681b      	ldr	r3, [r3, #0]
    sz += qp->h.u.next->h.size;
 8002a62:	1852      	adds	r2, r2, r1
    n++;
 8002a64:	3401      	adds	r4, #1

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002a66:	2b00      	cmp	r3, #0
 8002a68:	d1f9      	bne.n	8002a5e <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8002a6a:	2e00      	cmp	r6, #0
 8002a6c:	d000      	beq.n	8002a70 <chHeapStatus+0x30>
    *sizep = sz;
 8002a6e:	6032      	str	r2, [r6, #0]
  }
  H_UNLOCK(heapp);
 8002a70:	1c28      	adds	r0, r5, #0
 8002a72:	f7ff febd 	bl	80027f0 <chMtxUnlock>

  return n;
}
 8002a76:	1c20      	adds	r0, r4, #0
 8002a78:	bd70      	pop	{r4, r5, r6, pc}
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002a7a:	4c01      	ldr	r4, [pc, #4]	; (8002a80 <chHeapStatus+0x40>)
 8002a7c:	e7e5      	b.n	8002a4a <chHeapStatus+0xa>
 8002a7e:	46c0      	nop			; (mov r8, r8)
 8002a80:	20000f88 	.word	0x20000f88
 8002a84:	46c0      	nop			; (mov r8, r8)
 8002a86:	46c0      	nop			; (mov r8, r8)
 8002a88:	46c0      	nop			; (mov r8, r8)
 8002a8a:	46c0      	nop			; (mov r8, r8)
 8002a8c:	46c0      	nop			; (mov r8, r8)
 8002a8e:	46c0      	nop			; (mov r8, r8)

08002a90 <heap1_execute.10010>:
static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}

static void heap1_execute(void) {
 8002a90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002a92:	b083      	sub	sp, #12

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8002a94:	a901      	add	r1, sp, #4
 8002a96:	2000      	movs	r0, #0
 8002a98:	f7ff ffd2 	bl	8002a40 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8002a9c:	2110      	movs	r1, #16
 8002a9e:	2000      	movs	r0, #0
 8002aa0:	f7ff ff2e 	bl	8002900 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8002aa4:	1c01      	adds	r1, r0, #0
  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
 8002aa6:	1c04      	adds	r4, r0, #0
  test_assert(1, p1 != NULL, "allocation failed");
 8002aa8:	1e4b      	subs	r3, r1, #1
 8002aaa:	4199      	sbcs	r1, r3
 8002aac:	2001      	movs	r0, #1
 8002aae:	f7fe f857 	bl	8000b60 <_test_assert>
 8002ab2:	2800      	cmp	r0, #0
 8002ab4:	d001      	beq.n	8002aba <heap1_execute.10010+0x2a>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8002ab6:	b003      	add	sp, #12
 8002ab8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8002aba:	1c20      	adds	r0, r4, #0
 8002abc:	f7ff ff68 	bl	8002990 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8002ac0:	497c      	ldr	r1, [pc, #496]	; (8002cb4 <heap1_execute.10010+0x224>)
 8002ac2:	2000      	movs	r0, #0
 8002ac4:	f7ff ff1c 	bl	8002900 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8002ac8:	4241      	negs	r1, r0
 8002aca:	4141      	adcs	r1, r0
 8002acc:	2002      	movs	r0, #2
 8002ace:	f7fe f847 	bl	8000b60 <_test_assert>
 8002ad2:	2800      	cmp	r0, #0
 8002ad4:	d1ef      	bne.n	8002ab6 <heap1_execute.10010+0x26>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8002ad6:	4c78      	ldr	r4, [pc, #480]	; (8002cb8 <heap1_execute.10010+0x228>)
 8002ad8:	a901      	add	r1, sp, #4
 8002ada:	1c20      	adds	r0, r4, #0
 8002adc:	f7ff ffb0 	bl	8002a40 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002ae0:	2110      	movs	r1, #16
 8002ae2:	1c20      	adds	r0, r4, #0
 8002ae4:	f7ff ff0c 	bl	8002900 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002ae8:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002aea:	1c07      	adds	r7, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002aec:	1c20      	adds	r0, r4, #0
 8002aee:	f7ff ff07 	bl	8002900 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8002af2:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002af4:	1c06      	adds	r6, r0, #0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8002af6:	1c20      	adds	r0, r4, #0
 8002af8:	f7ff ff02 	bl	8002900 <chHeapAlloc>
 8002afc:	1c05      	adds	r5, r0, #0
  chHeapFree(p1);                               /* Does not merge.*/
 8002afe:	1c38      	adds	r0, r7, #0
 8002b00:	f7ff ff46 	bl	8002990 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8002b04:	1c30      	adds	r0, r6, #0
 8002b06:	f7ff ff43 	bl	8002990 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8002b0a:	1c28      	adds	r0, r5, #0
 8002b0c:	f7ff ff40 	bl	8002990 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002b10:	4669      	mov	r1, sp
 8002b12:	1c20      	adds	r0, r4, #0
 8002b14:	f7ff ff94 	bl	8002a40 <chHeapStatus>
 8002b18:	1e41      	subs	r1, r0, #1
 8002b1a:	424b      	negs	r3, r1
 8002b1c:	4159      	adcs	r1, r3
 8002b1e:	2003      	movs	r0, #3
 8002b20:	f7fe f81e 	bl	8000b60 <_test_assert>
 8002b24:	2800      	cmp	r0, #0
 8002b26:	d1c6      	bne.n	8002ab6 <heap1_execute.10010+0x26>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002b28:	2110      	movs	r1, #16
 8002b2a:	1c20      	adds	r0, r4, #0
 8002b2c:	f7ff fee8 	bl	8002900 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002b30:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002b32:	1c07      	adds	r7, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002b34:	1c20      	adds	r0, r4, #0
 8002b36:	f7ff fee3 	bl	8002900 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8002b3a:	2110      	movs	r1, #16
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002b3c:	1c06      	adds	r6, r0, #0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8002b3e:	1c20      	adds	r0, r4, #0
 8002b40:	f7ff fede 	bl	8002900 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8002b44:	f7ff ff24 	bl	8002990 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8002b48:	1c30      	adds	r0, r6, #0
 8002b4a:	f7ff ff21 	bl	8002990 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8002b4e:	1c38      	adds	r0, r7, #0
 8002b50:	f7ff ff1e 	bl	8002990 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002b54:	4669      	mov	r1, sp
 8002b56:	1c20      	adds	r0, r4, #0
 8002b58:	f7ff ff72 	bl	8002a40 <chHeapStatus>
 8002b5c:	1e41      	subs	r1, r0, #1
 8002b5e:	424b      	negs	r3, r1
 8002b60:	4159      	adcs	r1, r3
 8002b62:	2004      	movs	r0, #4
 8002b64:	f7fd fffc 	bl	8000b60 <_test_assert>
 8002b68:	2800      	cmp	r0, #0
 8002b6a:	d1a4      	bne.n	8002ab6 <heap1_execute.10010+0x26>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8002b6c:	2111      	movs	r1, #17
 8002b6e:	1c20      	adds	r0, r4, #0
 8002b70:	f7ff fec6 	bl	8002900 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002b74:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8002b76:	1c05      	adds	r5, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002b78:	1c20      	adds	r0, r4, #0
 8002b7a:	f7ff fec1 	bl	8002900 <chHeapAlloc>
 8002b7e:	1c07      	adds	r7, r0, #0
  chHeapFree(p1);
 8002b80:	1c28      	adds	r0, r5, #0
 8002b82:	f7ff ff05 	bl	8002990 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8002b86:	4669      	mov	r1, sp
 8002b88:	1c20      	adds	r0, r4, #0
 8002b8a:	f7ff ff59 	bl	8002a40 <chHeapStatus>
 8002b8e:	1e81      	subs	r1, r0, #2
 8002b90:	424b      	negs	r3, r1
 8002b92:	4159      	adcs	r1, r3
 8002b94:	2005      	movs	r0, #5
 8002b96:	f7fd ffe3 	bl	8000b60 <_test_assert>
 8002b9a:	2800      	cmp	r0, #0
 8002b9c:	d000      	beq.n	8002ba0 <heap1_execute.10010+0x110>
 8002b9e:	e78a      	b.n	8002ab6 <heap1_execute.10010+0x26>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002ba0:	2110      	movs	r1, #16
 8002ba2:	1c20      	adds	r0, r4, #0
 8002ba4:	f7ff feac 	bl	8002900 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8002ba8:	4669      	mov	r1, sp
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002baa:	1c06      	adds	r6, r0, #0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8002bac:	1c20      	adds	r0, r4, #0
 8002bae:	f7ff ff47 	bl	8002a40 <chHeapStatus>
 8002bb2:	2101      	movs	r1, #1
 8002bb4:	2801      	cmp	r0, #1
 8002bb6:	d006      	beq.n	8002bc6 <heap1_execute.10010+0x136>
 8002bb8:	4669      	mov	r1, sp
 8002bba:	1c20      	adds	r0, r4, #0
 8002bbc:	f7ff ff40 	bl	8002a40 <chHeapStatus>
 8002bc0:	1e81      	subs	r1, r0, #2
 8002bc2:	424b      	negs	r3, r1
 8002bc4:	4159      	adcs	r1, r3
 8002bc6:	2006      	movs	r0, #6
 8002bc8:	f7fd ffca 	bl	8000b60 <_test_assert>
 8002bcc:	2800      	cmp	r0, #0
 8002bce:	d000      	beq.n	8002bd2 <heap1_execute.10010+0x142>
 8002bd0:	e771      	b.n	8002ab6 <heap1_execute.10010+0x26>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 8002bd2:	1c38      	adds	r0, r7, #0
 8002bd4:	f7ff fedc 	bl	8002990 <chHeapFree>
  chHeapFree(p1);
 8002bd8:	1c30      	adds	r0, r6, #0
 8002bda:	f7ff fed9 	bl	8002990 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002bde:	4669      	mov	r1, sp
 8002be0:	1c20      	adds	r0, r4, #0
 8002be2:	f7ff ff2d 	bl	8002a40 <chHeapStatus>
 8002be6:	1e41      	subs	r1, r0, #1
 8002be8:	424b      	negs	r3, r1
 8002bea:	4159      	adcs	r1, r3
 8002bec:	2007      	movs	r0, #7
 8002bee:	f7fd ffb7 	bl	8000b60 <_test_assert>
 8002bf2:	2800      	cmp	r0, #0
 8002bf4:	d000      	beq.n	8002bf8 <heap1_execute.10010+0x168>
 8002bf6:	e75e      	b.n	8002ab6 <heap1_execute.10010+0x26>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002bf8:	2110      	movs	r1, #16
 8002bfa:	1c20      	adds	r0, r4, #0
 8002bfc:	f7ff fe80 	bl	8002900 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002c00:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002c02:	1c07      	adds	r7, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002c04:	1c20      	adds	r0, r4, #0
 8002c06:	f7ff fe7b 	bl	8002900 <chHeapAlloc>
 8002c0a:	1c05      	adds	r5, r0, #0
  chHeapFree(p1);
 8002c0c:	1c38      	adds	r0, r7, #0
 8002c0e:	f7ff febf 	bl	8002990 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8002c12:	4669      	mov	r1, sp
 8002c14:	1c20      	adds	r0, r4, #0
 8002c16:	f7ff ff13 	bl	8002a40 <chHeapStatus>
 8002c1a:	1e81      	subs	r1, r0, #2
 8002c1c:	424b      	negs	r3, r1
 8002c1e:	4159      	adcs	r1, r3
 8002c20:	2008      	movs	r0, #8
 8002c22:	f7fd ff9d 	bl	8000b60 <_test_assert>
 8002c26:	2800      	cmp	r0, #0
 8002c28:	d000      	beq.n	8002c2c <heap1_execute.10010+0x19c>
 8002c2a:	e744      	b.n	8002ab6 <heap1_execute.10010+0x26>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8002c2c:	2120      	movs	r1, #32
 8002c2e:	1c20      	adds	r0, r4, #0
 8002c30:	f7ff fe66 	bl	8002900 <chHeapAlloc>
  chHeapFree(p1);
 8002c34:	f7ff feac 	bl	8002990 <chHeapFree>
  chHeapFree(p2);
 8002c38:	1c28      	adds	r0, r5, #0
 8002c3a:	f7ff fea9 	bl	8002990 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002c3e:	4669      	mov	r1, sp
 8002c40:	1c20      	adds	r0, r4, #0
 8002c42:	f7ff fefd 	bl	8002a40 <chHeapStatus>
 8002c46:	1e41      	subs	r1, r0, #1
 8002c48:	424b      	negs	r3, r1
 8002c4a:	4159      	adcs	r1, r3
 8002c4c:	2009      	movs	r0, #9
 8002c4e:	f7fd ff87 	bl	8000b60 <_test_assert>
 8002c52:	2800      	cmp	r0, #0
 8002c54:	d000      	beq.n	8002c58 <heap1_execute.10010+0x1c8>
 8002c56:	e72e      	b.n	8002ab6 <heap1_execute.10010+0x26>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 8002c58:	4669      	mov	r1, sp
 8002c5a:	1c20      	adds	r0, r4, #0
 8002c5c:	f7ff fef0 	bl	8002a40 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8002c60:	9900      	ldr	r1, [sp, #0]
 8002c62:	1c20      	adds	r0, r4, #0
 8002c64:	f7ff fe4c 	bl	8002900 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8002c68:	4669      	mov	r1, sp
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 8002c6a:	1c06      	adds	r6, r0, #0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8002c6c:	1c20      	adds	r0, r4, #0
 8002c6e:	f7ff fee7 	bl	8002a40 <chHeapStatus>
 8002c72:	4241      	negs	r1, r0
 8002c74:	4141      	adcs	r1, r0
 8002c76:	200a      	movs	r0, #10
 8002c78:	f7fd ff72 	bl	8000b60 <_test_assert>
 8002c7c:	2800      	cmp	r0, #0
 8002c7e:	d000      	beq.n	8002c82 <heap1_execute.10010+0x1f2>
 8002c80:	e719      	b.n	8002ab6 <heap1_execute.10010+0x26>
  chHeapFree(p1);
 8002c82:	1c30      	adds	r0, r6, #0
 8002c84:	f7ff fe84 	bl	8002990 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002c88:	4669      	mov	r1, sp
 8002c8a:	1c20      	adds	r0, r4, #0
 8002c8c:	f7ff fed8 	bl	8002a40 <chHeapStatus>
 8002c90:	1e41      	subs	r1, r0, #1
 8002c92:	424b      	negs	r3, r1
 8002c94:	4159      	adcs	r1, r3
 8002c96:	200b      	movs	r0, #11
 8002c98:	f7fd ff62 	bl	8000b60 <_test_assert>
 8002c9c:	2800      	cmp	r0, #0
 8002c9e:	d000      	beq.n	8002ca2 <heap1_execute.10010+0x212>
 8002ca0:	e709      	b.n	8002ab6 <heap1_execute.10010+0x26>
  test_assert(12, n == sz, "size changed");
 8002ca2:	9b01      	ldr	r3, [sp, #4]
 8002ca4:	9a00      	ldr	r2, [sp, #0]
 8002ca6:	200c      	movs	r0, #12
 8002ca8:	1ad1      	subs	r1, r2, r3
 8002caa:	424b      	negs	r3, r1
 8002cac:	4159      	adcs	r1, r3
 8002cae:	f7fd ff57 	bl	8000b60 <_test_assert>
 8002cb2:	e700      	b.n	8002ab6 <heap1_execute.10010+0x26>
 8002cb4:	ffffff00 	.word	0xffffff00
 8002cb8:	20000d58 	.word	0x20000d58
 8002cbc:	46c0      	nop			; (mov r8, r8)
 8002cbe:	46c0      	nop			; (mov r8, r8)

08002cc0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 8002cc0:	b538      	push	{r3, r4, r5, lr}
 8002cc2:	1c05      	adds	r5, r0, #0
 8002cc4:	1c0c      	adds	r4, r1, #0
 8002cc6:	b672      	cpsid	i
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));
 8002cc8:	2800      	cmp	r0, #0
 8002cca:	d01a      	beq.n	8002d02 <chEvtUnregister+0x42>
 8002ccc:	2900      	cmp	r1, #0
 8002cce:	d018      	beq.n	8002d02 <chEvtUnregister+0x42>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002cd0:	f000 fee6 	bl	8003aa0 <_dbg_check_lock>
 8002cd4:	1c2b      	adds	r3, r5, #0
 8002cd6:	e000      	b.n	8002cda <chEvtUnregister+0x1a>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 8002cd8:	1c13      	adds	r3, r2, #0
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 8002cda:	681a      	ldr	r2, [r3, #0]
 8002cdc:	42aa      	cmp	r2, r5
 8002cde:	d003      	beq.n	8002ce8 <chEvtUnregister+0x28>
  /*lint -restore*/
    if (p->el_next == elp) {
 8002ce0:	4294      	cmp	r4, r2
 8002ce2:	d1f9      	bne.n	8002cd8 <chEvtUnregister+0x18>
      p->el_next = elp->el_next;
 8002ce4:	6820      	ldr	r0, [r4, #0]
 8002ce6:	6018      	str	r0, [r3, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002ce8:	f000 fe42 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002cec:	4c09      	ldr	r4, [pc, #36]	; (8002d14 <chEvtUnregister+0x54>)
 8002cee:	6822      	ldr	r2, [r4, #0]
 8002cf0:	42a2      	cmp	r2, r4
 8002cf2:	d004      	beq.n	8002cfe <chEvtUnregister+0x3e>
 8002cf4:	69a1      	ldr	r1, [r4, #24]
 8002cf6:	6893      	ldr	r3, [r2, #8]
 8002cf8:	688d      	ldr	r5, [r1, #8]
 8002cfa:	429d      	cmp	r5, r3
 8002cfc:	d305      	bcc.n	8002d0a <chEvtUnregister+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002cfe:	b662      	cpsie	i
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
}
 8002d00:	bd38      	pop	{r3, r4, r5, pc}
 8002d02:	4c05      	ldr	r4, [pc, #20]	; (8002d18 <chEvtUnregister+0x58>)
 8002d04:	4a03      	ldr	r2, [pc, #12]	; (8002d14 <chEvtUnregister+0x54>)
 8002d06:	62d4      	str	r4, [r2, #44]	; 0x2c
 8002d08:	e7fe      	b.n	8002d08 <chEvtUnregister+0x48>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d0a:	b672      	cpsid	i
 8002d0c:	4803      	ldr	r0, [pc, #12]	; (8002d1c <chEvtUnregister+0x5c>)
 8002d0e:	62e0      	str	r0, [r4, #44]	; 0x2c
 8002d10:	e7fe      	b.n	8002d10 <chEvtUnregister+0x50>
 8002d12:	46c0      	nop			; (mov r8, r8)
 8002d14:	20001040 	.word	0x20001040
 8002d18:	080086c0 	.word	0x080086c0
 8002d1c:	08008b50 	.word	0x08008b50

08002d20 <evt1_execute.9787>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8002d20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002d22:	4647      	mov	r7, r8
 8002d24:	b480      	push	{r7}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8002d26:	4c44      	ldr	r4, [pc, #272]	; (8002e38 <evt1_execute.9787+0x118>)
 8002d28:	b08a      	sub	sp, #40	; 0x28
 8002d2a:	6024      	str	r4, [r4, #0]
 8002d2c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002d2e:	f000 feb7 	bl	8003aa0 <_dbg_check_lock>
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8002d32:	4d42      	ldr	r5, [pc, #264]	; (8002e3c <evt1_execute.9787+0x11c>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8002d34:	6822      	ldr	r2, [r4, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 8002d36:	69a8      	ldr	r0, [r5, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8002d38:	2701      	movs	r7, #1

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8002d3a:	ab00      	add	r3, sp, #0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8002d3c:	9200      	str	r2, [sp, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 8002d3e:	2101      	movs	r1, #1
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8002d40:	427a      	negs	r2, r7
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8002d42:	2600      	movs	r6, #0

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8002d44:	6023      	str	r3, [r4, #0]
  elp->el_listener = currp;
 8002d46:	9001      	str	r0, [sp, #4]
  elp->el_events   = events;
 8002d48:	9102      	str	r1, [sp, #8]
  elp->el_flags    = (eventflags_t)0;
 8002d4a:	9603      	str	r6, [sp, #12]
  elp->el_wflags   = wflags;
 8002d4c:	9204      	str	r2, [sp, #16]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002d4e:	f000 fe0f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002d52:	682b      	ldr	r3, [r5, #0]
 8002d54:	42ab      	cmp	r3, r5
 8002d56:	d004      	beq.n	8002d62 <evt1_execute.9787+0x42>
 8002d58:	69a8      	ldr	r0, [r5, #24]
 8002d5a:	689e      	ldr	r6, [r3, #8]
 8002d5c:	6881      	ldr	r1, [r0, #8]
 8002d5e:	42b1      	cmp	r1, r6
 8002d60:	d328      	bcc.n	8002db4 <evt1_execute.9787+0x94>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002d62:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d64:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002d66:	f000 fe9b 	bl	8003aa0 <_dbg_check_lock>
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8002d6a:	6822      	ldr	r2, [r4, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 8002d6c:	69ab      	ldr	r3, [r5, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8002d6e:	2601      	movs	r6, #1
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8002d70:	af05      	add	r7, sp, #20
 8002d72:	9205      	str	r2, [sp, #20]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 8002d74:	2002      	movs	r0, #2
  elp->el_flags    = (eventflags_t)0;
 8002d76:	2100      	movs	r1, #0
  elp->el_wflags   = wflags;
 8002d78:	4272      	negs	r2, r6
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8002d7a:	607b      	str	r3, [r7, #4]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8002d7c:	6027      	str	r7, [r4, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
 8002d7e:	60b8      	str	r0, [r7, #8]
  elp->el_flags    = (eventflags_t)0;
 8002d80:	60f9      	str	r1, [r7, #12]
  elp->el_wflags   = wflags;
 8002d82:	613a      	str	r2, [r7, #16]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002d84:	f000 fdf4 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002d88:	682b      	ldr	r3, [r5, #0]
 8002d8a:	42ab      	cmp	r3, r5
 8002d8c:	d004      	beq.n	8002d98 <evt1_execute.9787+0x78>
 8002d8e:	69a8      	ldr	r0, [r5, #24]
 8002d90:	689e      	ldr	r6, [r3, #8]
 8002d92:	6881      	ldr	r1, [r0, #8]
 8002d94:	42b1      	cmp	r1, r6
 8002d96:	d311      	bcc.n	8002dbc <evt1_execute.9787+0x9c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002d98:	b662      	cpsie	i
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->es_next);
 8002d9a:	6822      	ldr	r2, [r4, #0]
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8002d9c:	2001      	movs	r0, #1
 8002d9e:	1b11      	subs	r1, r2, r4
 8002da0:	1e4b      	subs	r3, r1, #1
 8002da2:	4199      	sbcs	r1, r3
 8002da4:	f7fd fedc 	bl	8000b60 <_test_assert>
 8002da8:	2800      	cmp	r0, #0
 8002daa:	d00b      	beq.n	8002dc4 <evt1_execute.9787+0xa4>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 8002dac:	b00a      	add	sp, #40	; 0x28
 8002dae:	bc04      	pop	{r2}
 8002db0:	4690      	mov	r8, r2
 8002db2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002db4:	b672      	cpsid	i
 8002db6:	4f22      	ldr	r7, [pc, #136]	; (8002e40 <evt1_execute.9787+0x120>)
 8002db8:	62ef      	str	r7, [r5, #44]	; 0x2c
 8002dba:	e7fe      	b.n	8002dba <evt1_execute.9787+0x9a>
 8002dbc:	b672      	cpsid	i
 8002dbe:	4e20      	ldr	r6, [pc, #128]	; (8002e40 <evt1_execute.9787+0x120>)
 8002dc0:	62ee      	str	r6, [r5, #44]	; 0x2c
 8002dc2:	e7fe      	b.n	8002dc2 <evt1_execute.9787+0xa2>
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 8002dc4:	1c20      	adds	r0, r4, #0
 8002dc6:	4669      	mov	r1, sp
 8002dc8:	f7ff ff7a 	bl	8002cc0 <chEvtUnregister>
 8002dcc:	6823      	ldr	r3, [r4, #0]
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8002dce:	2002      	movs	r0, #2
 8002dd0:	1b19      	subs	r1, r3, r4
 8002dd2:	1e4b      	subs	r3, r1, #1
 8002dd4:	4199      	sbcs	r1, r3
 8002dd6:	f7fd fec3 	bl	8000b60 <_test_assert>
 8002dda:	2800      	cmp	r0, #0
 8002ddc:	d1e6      	bne.n	8002dac <evt1_execute.9787+0x8c>
  chEvtUnregister(&es1, &el2);
 8002dde:	1c20      	adds	r0, r4, #0
 8002de0:	1c39      	adds	r1, r7, #0
 8002de2:	f7ff ff6d 	bl	8002cc0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 8002de6:	6827      	ldr	r7, [r4, #0]
 8002de8:	2003      	movs	r0, #3
 8002dea:	1b39      	subs	r1, r7, r4
 8002dec:	424c      	negs	r4, r1
 8002dee:	4161      	adcs	r1, r4
 8002df0:	f7fd feb6 	bl	8000b60 <_test_assert>
 8002df4:	2800      	cmp	r0, #0
 8002df6:	d1d9      	bne.n	8002dac <evt1_execute.9787+0x8c>
  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
 8002df8:	4812      	ldr	r0, [pc, #72]	; (8002e44 <evt1_execute.9787+0x124>)
 8002dfa:	2400      	movs	r4, #0
 8002dfc:	2607      	movs	r6, #7

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8002dfe:	2701      	movs	r7, #1
      chDbgAssert(handlers[eid] != NULL, "null handler");
 8002e00:	4680      	mov	r8, r0

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8002e02:	1c31      	adds	r1, r6, #0
 8002e04:	40e1      	lsrs	r1, r4
 8002e06:	420f      	tst	r7, r1
 8002e08:	d009      	beq.n	8002e1e <evt1_execute.9787+0xfe>
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8002e0a:	00a3      	lsls	r3, r4, #2
      chDbgAssert(handlers[eid] != NULL, "null handler");
 8002e0c:	4642      	mov	r2, r8
 8002e0e:	58d1      	ldr	r1, [r2, r3]
 8002e10:	2900      	cmp	r1, #0
 8002e12:	d00c      	beq.n	8002e2e <evt1_execute.9787+0x10e>
      events &= ~EVENT_MASK(eid);
 8002e14:	1c38      	adds	r0, r7, #0
 8002e16:	40a0      	lsls	r0, r4
 8002e18:	4386      	bics	r6, r0
      handlers[eid](eid);
 8002e1a:	1c20      	adds	r0, r4, #0
 8002e1c:	4788      	blx	r1
    }
    eid++;
 8002e1e:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002e20:	2e00      	cmp	r6, #0
 8002e22:	d1ee      	bne.n	8002e02 <evt1_execute.9787+0xe2>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
 8002e24:	4908      	ldr	r1, [pc, #32]	; (8002e48 <evt1_execute.9787+0x128>)
 8002e26:	2004      	movs	r0, #4
 8002e28:	f7fd fe4a 	bl	8000ac0 <_test_assert_sequence>
 8002e2c:	e7be      	b.n	8002dac <evt1_execute.9787+0x8c>
 8002e2e:	b672      	cpsid	i
 8002e30:	4c06      	ldr	r4, [pc, #24]	; (8002e4c <evt1_execute.9787+0x12c>)
 8002e32:	62ec      	str	r4, [r5, #44]	; 0x2c
 8002e34:	e7fe      	b.n	8002e34 <evt1_execute.9787+0x114>
 8002e36:	46c0      	nop			; (mov r8, r8)
 8002e38:	200006b4 	.word	0x200006b4
 8002e3c:	20001040 	.word	0x20001040
 8002e40:	08008b50 	.word	0x08008b50
 8002e44:	08008a60 	.word	0x08008a60
 8002e48:	08008708 	.word	0x08008708
 8002e4c:	080086d0 	.word	0x080086d0

08002e50 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8002e50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002e52:	4657      	mov	r7, sl
 8002e54:	464e      	mov	r6, r9
 8002e56:	4645      	mov	r5, r8
 8002e58:	b4e0      	push	{r5, r6, r7}
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8002e5a:	1c06      	adds	r6, r0, #0
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8002e5c:	b082      	sub	sp, #8
 8002e5e:	1c07      	adds	r7, r0, #0
 8002e60:	4688      	mov	r8, r1
 8002e62:	4691      	mov	r9, r2
 8002e64:	469a      	mov	sl, r3
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8002e66:	3648      	adds	r6, #72	; 0x48
 8002e68:	1c04      	adds	r4, r0, #0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8002e6a:	25ff      	movs	r5, #255	; 0xff
 8002e6c:	7025      	strb	r5, [r4, #0]
 8002e6e:	7065      	strb	r5, [r4, #1]
 8002e70:	3402      	adds	r4, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002e72:	42a6      	cmp	r6, r4
 8002e74:	d1fa      	bne.n	8002e6c <chThdCreateStatic+0x1c>
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8002e76:	4642      	mov	r2, r8
 8002e78:	18bb      	adds	r3, r7, r2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002e7a:	429e      	cmp	r6, r3
 8002e7c:	d213      	bcs.n	8002ea6 <chThdCreateStatic+0x56>
 8002e7e:	43f1      	mvns	r1, r6
    *startp++ = v;
 8002e80:	2455      	movs	r4, #85	; 0x55
 8002e82:	185d      	adds	r5, r3, r1
 8002e84:	2001      	movs	r0, #1
 8002e86:	7034      	strb	r4, [r6, #0]
 8002e88:	3601      	adds	r6, #1
 8002e8a:	4005      	ands	r5, r0
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002e8c:	429e      	cmp	r6, r3
 8002e8e:	d00a      	beq.n	8002ea6 <chThdCreateStatic+0x56>
 8002e90:	2d00      	cmp	r5, #0
 8002e92:	d003      	beq.n	8002e9c <chThdCreateStatic+0x4c>
    *startp++ = v;
 8002e94:	7034      	strb	r4, [r6, #0]
 8002e96:	3601      	adds	r6, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002e98:	429e      	cmp	r6, r3
 8002e9a:	d004      	beq.n	8002ea6 <chThdCreateStatic+0x56>
    *startp++ = v;
 8002e9c:	7034      	strb	r4, [r6, #0]
 8002e9e:	7074      	strb	r4, [r6, #1]
 8002ea0:	3602      	adds	r6, #2
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8002ea2:	429e      	cmp	r6, r3
 8002ea4:	d1fa      	bne.n	8002e9c <chThdCreateStatic+0x4c>
 8002ea6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002ea8:	f000 fdfa 	bl	8003aa0 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002eac:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8002eae:	464a      	mov	r2, r9
 8002eb0:	4653      	mov	r3, sl
 8002eb2:	4641      	mov	r1, r8
 8002eb4:	9600      	str	r6, [sp, #0]
 8002eb6:	1c38      	adds	r0, r7, #0
 8002eb8:	f000 fafa 	bl	80034b0 <chThdCreateI>
  chSchWakeupS(tp, MSG_OK);
 8002ebc:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002ebe:	1c04      	adds	r4, r0, #0
  chSchWakeupS(tp, MSG_OK);
 8002ec0:	f7fd ffc6 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002ec4:	f000 fd54 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002ec8:	4b0a      	ldr	r3, [pc, #40]	; (8002ef4 <chThdCreateStatic+0xa4>)
 8002eca:	681a      	ldr	r2, [r3, #0]
 8002ecc:	429a      	cmp	r2, r3
 8002ece:	d004      	beq.n	8002eda <chThdCreateStatic+0x8a>
 8002ed0:	6999      	ldr	r1, [r3, #24]
 8002ed2:	6890      	ldr	r0, [r2, #8]
 8002ed4:	688d      	ldr	r5, [r1, #8]
 8002ed6:	4285      	cmp	r5, r0
 8002ed8:	d307      	bcc.n	8002eea <chThdCreateStatic+0x9a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002eda:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8002edc:	1c20      	adds	r0, r4, #0
 8002ede:	b002      	add	sp, #8
 8002ee0:	bc1c      	pop	{r2, r3, r4}
 8002ee2:	4690      	mov	r8, r2
 8002ee4:	4699      	mov	r9, r3
 8002ee6:	46a2      	mov	sl, r4
 8002ee8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002eea:	b672      	cpsid	i
 8002eec:	4f02      	ldr	r7, [pc, #8]	; (8002ef8 <chThdCreateStatic+0xa8>)
 8002eee:	62df      	str	r7, [r3, #44]	; 0x2c
 8002ef0:	e7fe      	b.n	8002ef0 <chThdCreateStatic+0xa0>
 8002ef2:	46c0      	nop			; (mov r8, r8)
 8002ef4:	20001040 	.word	0x20001040
 8002ef8:	08008b00 	.word	0x08008b00
 8002efc:	46c0      	nop			; (mov r8, r8)
 8002efe:	46c0      	nop			; (mov r8, r8)

08002f00 <sem3_execute.9034>:

static void sem3_execute(void) {
 8002f00:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002f02:	4b1b      	ldr	r3, [pc, #108]	; (8002f70 <sem3_execute.9034+0x70>)
 8002f04:	b082      	sub	sp, #8
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002f06:	6998      	ldr	r0, [r3, #24]

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002f08:	2100      	movs	r1, #0
 8002f0a:	6882      	ldr	r2, [r0, #8]
 8002f0c:	24a8      	movs	r4, #168	; 0xa8
 8002f0e:	4b19      	ldr	r3, [pc, #100]	; (8002f74 <sem3_execute.9034+0x74>)
 8002f10:	3201      	adds	r2, #1
 8002f12:	9100      	str	r1, [sp, #0]
 8002f14:	4818      	ldr	r0, [pc, #96]	; (8002f78 <sem3_execute.9034+0x78>)
 8002f16:	0061      	lsls	r1, r4, #1
 8002f18:	f7ff ff9a 	bl	8002e50 <chThdCreateStatic>
 8002f1c:	4a17      	ldr	r2, [pc, #92]	; (8002f7c <sem3_execute.9034+0x7c>)
 8002f1e:	6010      	str	r0, [r2, #0]
  chSemSignalWait(&sem1, &sem1);
 8002f20:	f000 fdd6 	bl	8003ad0 <chSemSignalWait.constprop.67>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8002f24:	4c16      	ldr	r4, [pc, #88]	; (8002f80 <sem3_execute.9034+0x80>)
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 8002f26:	2001      	movs	r0, #1
 8002f28:	6823      	ldr	r3, [r4, #0]
 8002f2a:	1b19      	subs	r1, r3, r4
 8002f2c:	424b      	negs	r3, r1
 8002f2e:	4159      	adcs	r1, r3
 8002f30:	f7fd fe16 	bl	8000b60 <_test_assert>
 8002f34:	2800      	cmp	r0, #0
 8002f36:	d001      	beq.n	8002f3c <sem3_execute.9034+0x3c>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 8002f38:	b002      	add	sp, #8
 8002f3a:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8002f3c:	68a0      	ldr	r0, [r4, #8]
 8002f3e:	4241      	negs	r1, r0
 8002f40:	4141      	adcs	r1, r0
 8002f42:	2002      	movs	r0, #2
 8002f44:	f7fd fe0c 	bl	8000b60 <_test_assert>
 8002f48:	2800      	cmp	r0, #0
 8002f4a:	d1f5      	bne.n	8002f38 <sem3_execute.9034+0x38>

  chSemSignalWait(&sem1, &sem1);
 8002f4c:	f000 fdc0 	bl	8003ad0 <chSemSignalWait.constprop.67>
 8002f50:	6821      	ldr	r1, [r4, #0]
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 8002f52:	2003      	movs	r0, #3
 8002f54:	1b09      	subs	r1, r1, r4
 8002f56:	424b      	negs	r3, r1
 8002f58:	4159      	adcs	r1, r3
 8002f5a:	f7fd fe01 	bl	8000b60 <_test_assert>
 8002f5e:	2800      	cmp	r0, #0
 8002f60:	d1ea      	bne.n	8002f38 <sem3_execute.9034+0x38>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8002f62:	68a1      	ldr	r1, [r4, #8]
 8002f64:	2004      	movs	r0, #4
 8002f66:	424b      	negs	r3, r1
 8002f68:	4159      	adcs	r1, r3
 8002f6a:	f7fd fdf9 	bl	8000b60 <_test_assert>
 8002f6e:	e7e3      	b.n	8002f38 <sem3_execute.9034+0x38>
 8002f70:	20001040 	.word	0x20001040
 8002f74:	080025a1 	.word	0x080025a1
 8002f78:	200006b8 	.word	0x200006b8
 8002f7c:	200015b8 	.word	0x200015b8
 8002f80:	200006a4 	.word	0x200006a4
 8002f84:	46c0      	nop			; (mov r8, r8)
 8002f86:	46c0      	nop			; (mov r8, r8)
 8002f88:	46c0      	nop			; (mov r8, r8)
 8002f8a:	46c0      	nop			; (mov r8, r8)
 8002f8c:	46c0      	nop			; (mov r8, r8)
 8002f8e:	46c0      	nop			; (mov r8, r8)

08002f90 <wakeup.4792>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8002f90:	b538      	push	{r3, r4, r5, lr}
 8002f92:	1c04      	adds	r4, r0, #0
 8002f94:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8002f96:	f7fd fb0b 	bl	80005b0 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8002f9a:	2320      	movs	r3, #32
 8002f9c:	5ce0      	ldrb	r0, [r4, r3]
 8002f9e:	2807      	cmp	r0, #7
 8002fa0:	d80e      	bhi.n	8002fc0 <wakeup.4792+0x30>
 8002fa2:	4a11      	ldr	r2, [pc, #68]	; (8002fe8 <wakeup.4792+0x58>)
 8002fa4:	0081      	lsls	r1, r0, #2
 8002fa6:	5855      	ldr	r5, [r2, r1]
 8002fa8:	46af      	mov	pc, r5
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8002faa:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8002fac:	f7fd fb60 	bl	8000670 <chDbgCheckClassI>

  sp->s_cnt++;
 8002fb0:	68ab      	ldr	r3, [r5, #8]
 8002fb2:	3301      	adds	r3, #1
 8002fb4:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8002fb6:	6860      	ldr	r0, [r4, #4]
 8002fb8:	6821      	ldr	r1, [r4, #0]
 8002fba:	6001      	str	r1, [r0, #0]
  tp->p_next->p_prev = tp->p_prev;
 8002fbc:	6822      	ldr	r2, [r4, #0]
 8002fbe:	6050      	str	r0, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8002fc0:	2001      	movs	r0, #1
 8002fc2:	4241      	negs	r1, r0
 8002fc4:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8002fc6:	1c20      	adds	r0, r4, #0
 8002fc8:	f7fd fbb2 	bl	8000730 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002fcc:	f7fd fb08 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002fd0:	b662      	cpsie	i
  chSysUnlockFromISR();
}
 8002fd2:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8002fd4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8002fd6:	2001      	movs	r0, #1
 8002fd8:	4241      	negs	r1, r0
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8002fda:	2300      	movs	r3, #0
 8002fdc:	602b      	str	r3, [r5, #0]
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
 8002fde:	1c20      	adds	r0, r4, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8002fe0:	6261      	str	r1, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8002fe2:	f7fd fba5 	bl	8000730 <chSchReadyI>
 8002fe6:	e7f1      	b.n	8002fcc <wakeup.4792+0x3c>
 8002fe8:	08008730 	.word	0x08008730
 8002fec:	46c0      	nop			; (mov r8, r8)
 8002fee:	46c0      	nop			; (mov r8, r8)

08002ff0 <heap1_setup.10012>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 8002ff0:	b508      	push	{r3, lr}
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002ff2:	4807      	ldr	r0, [pc, #28]	; (8003010 <heap1_setup.10012+0x20>)
  heapp->h_free.h.u.next = hp;
 8002ff4:	4b07      	ldr	r3, [pc, #28]	; (8003014 <heap1_setup.10012+0x24>)
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002ff6:	2200      	movs	r2, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8002ff8:	21d1      	movs	r1, #209	; 0xd1
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002ffa:	6002      	str	r2, [r0, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8002ffc:	60c2      	str	r2, [r0, #12]
  hp->h.u.next = NULL;
 8002ffe:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003000:	00ca      	lsls	r2, r1, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8003002:	6083      	str	r3, [r0, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003004:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8003006:	3010      	adds	r0, #16
 8003008:	f7fd fa8a 	bl	8000520 <chMtxObjectInit>

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}
 800300c:	bd08      	pop	{r3, pc}
 800300e:	46c0      	nop			; (mov r8, r8)
 8003010:	20000d58 	.word	0x20000d58
 8003014:	200006b8 	.word	0x200006b8
 8003018:	46c0      	nop			; (mov r8, r8)
 800301a:	46c0      	nop			; (mov r8, r8)
 800301c:	46c0      	nop			; (mov r8, r8)
 800301e:	46c0      	nop			; (mov r8, r8)

08003020 <dyn3_setup.10178>:
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
  return found;
}

static void dyn3_setup(void) {
 8003020:	b508      	push	{r3, lr}
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8003022:	4807      	ldr	r0, [pc, #28]	; (8003040 <dyn3_setup.10178+0x20>)
  heapp->h_free.h.u.next = hp;
 8003024:	4b07      	ldr	r3, [pc, #28]	; (8003044 <dyn3_setup.10178+0x24>)
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8003026:	2200      	movs	r2, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003028:	21d1      	movs	r1, #209	; 0xd1
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800302a:	6002      	str	r2, [r0, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 800302c:	60c2      	str	r2, [r0, #12]
  hp->h.u.next = NULL;
 800302e:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003030:	00ca      	lsls	r2, r1, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8003032:	6083      	str	r3, [r0, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003034:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8003036:	3010      	adds	r0, #16
 8003038:	f7fd fa72 	bl	8000520 <chMtxObjectInit>

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 800303c:	bd08      	pop	{r3, pc}
 800303e:	46c0      	nop			; (mov r8, r8)
 8003040:	20000d88 	.word	0x20000d88
 8003044:	200006b8 	.word	0x200006b8
 8003048:	46c0      	nop			; (mov r8, r8)
 800304a:	46c0      	nop			; (mov r8, r8)
 800304c:	46c0      	nop			; (mov r8, r8)
 800304e:	46c0      	nop			; (mov r8, r8)

08003050 <sys2_execute.10509>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 8003050:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003052:	b672      	cpsid	i
 * @special
 */
static inline void chSysSuspend(void) {

  port_suspend();
  _dbg_check_suspend();
 8003054:	f7fd fa8c 	bl	8000570 <_dbg_check_suspend>
 8003058:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_disable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800305a:	4b09      	ldr	r3, [pc, #36]	; (8003080 <sys2_execute.10509+0x30>)
 800305c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800305e:	2a00      	cmp	r2, #0
 8003060:	d102      	bne.n	8003068 <sys2_execute.10509+0x18>
 8003062:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8003064:	2800      	cmp	r0, #0
 8003066:	d003      	beq.n	8003070 <sys2_execute.10509+0x20>
 8003068:	b672      	cpsid	i
 800306a:	4906      	ldr	r1, [pc, #24]	; (8003084 <sys2_execute.10509+0x34>)
 800306c:	62d9      	str	r1, [r3, #44]	; 0x2c
 800306e:	e7fe      	b.n	800306e <sys2_execute.10509+0x1e>
 8003070:	b672      	cpsid	i
 8003072:	f7fd fa7d 	bl	8000570 <_dbg_check_suspend>
 *
 * @special
 */
static inline void chSysEnable(void) {

  _dbg_check_enable();
 8003076:	f7fd fa8b 	bl	8000590 <_dbg_check_enable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800307a:	b662      	cpsie	i

  chSysSuspend();
  chSysDisable();
  chSysSuspend();
  chSysEnable();
}
 800307c:	bd08      	pop	{r3, pc}
 800307e:	46c0      	nop			; (mov r8, r8)
 8003080:	20001040 	.word	0x20001040
 8003084:	08008840 	.word	0x08008840
 8003088:	46c0      	nop			; (mov r8, r8)
 800308a:	46c0      	nop			; (mov r8, r8)
 800308c:	46c0      	nop			; (mov r8, r8)
 800308e:	46c0      	nop			; (mov r8, r8)

08003090 <Vector7C.4314>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003090:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003092:	464e      	mov	r6, r9
 8003094:	4657      	mov	r7, sl
 8003096:	4645      	mov	r5, r8
 8003098:	b4e0      	push	{r5, r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800309a:	2680      	movs	r6, #128	; 0x80
 800309c:	05f6      	lsls	r6, r6, #23
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800309e:	46f1      	mov	r9, lr
 80030a0:	f7fd fab6 	bl	8000610 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80030a4:	6933      	ldr	r3, [r6, #16]
 80030a6:	079a      	lsls	r2, r3, #30
 80030a8:	d409      	bmi.n	80030be <Vector7C.4314+0x2e>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80030aa:	f7fd fac9 	bl	8000640 <_dbg_check_leave_isr>
 80030ae:	4648      	mov	r0, r9
 80030b0:	f7fd fe8e 	bl	8000dd0 <_port_irq_epilogue>
}
 80030b4:	bc1c      	pop	{r2, r3, r4}
 80030b6:	4690      	mov	r8, r2
 80030b8:	4699      	mov	r9, r3
 80030ba:	46a2      	mov	sl, r4
 80030bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 80030be:	2000      	movs	r0, #0
 80030c0:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80030c2:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80030c4:	f7fd fa74 	bl	80005b0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 80030c8:	f7fd fad2 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 80030cc:	f7fd fad0 	bl	8000670 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80030d0:	4c22      	ldr	r4, [pc, #136]	; (800315c <Vector7C.4314+0xcc>)
 80030d2:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80030d4:	69e5      	ldr	r5, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80030d6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80030d8:	68aa      	ldr	r2, [r5, #8]
 80030da:	1a5f      	subs	r7, r3, r1
 80030dc:	4297      	cmp	r7, r2
 80030de:	d31d      	bcc.n	800311c <Vector7C.4314+0x8c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80030e0:	231c      	movs	r3, #28
 80030e2:	1918      	adds	r0, r3, r4
 80030e4:	4680      	mov	r8, r0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80030e6:	2700      	movs	r7, #0
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80030e8:	188a      	adds	r2, r1, r2

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80030ea:	68e8      	ldr	r0, [r5, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80030ec:	6829      	ldr	r1, [r5, #0]
 80030ee:	4643      	mov	r3, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80030f0:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80030f2:	4682      	mov	sl, r0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80030f4:	604b      	str	r3, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80030f6:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80030f8:	60ef      	str	r7, [r5, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80030fa:	4541      	cmp	r1, r8
 80030fc:	d02b      	beq.n	8003156 <Vector7C.4314+0xc6>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80030fe:	f7fd fa6f 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003102:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8003104:	6928      	ldr	r0, [r5, #16]
 8003106:	47d0      	blx	sl
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003108:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800310a:	f7fd fa51 	bl	80005b0 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800310e:	69e5      	ldr	r5, [r4, #28]
 8003110:	6a73      	ldr	r3, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8003112:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003114:	68aa      	ldr	r2, [r5, #8]
 8003116:	1a58      	subs	r0, r3, r1
 8003118:	4282      	cmp	r2, r0
 800311a:	d9e5      	bls.n	80030e8 <Vector7C.4314+0x58>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800311c:	4e10      	ldr	r6, [pc, #64]	; (8003160 <Vector7C.4314+0xd0>)
 800311e:	42b5      	cmp	r5, r6
 8003120:	d013      	beq.n	800314a <Vector7C.4314+0xba>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8003122:	188f      	adds	r7, r1, r2
 8003124:	1afd      	subs	r5, r7, r3
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8003126:	2d01      	cmp	r5, #1
 8003128:	d913      	bls.n	8003152 <Vector7C.4314+0xc2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 800312a:	18ee      	adds	r6, r5, r3
 800312c:	1c30      	adds	r0, r6, #0
 800312e:	f7fd fb9f 	bl	8000870 <stSetAlarm>
 8003132:	2380      	movs	r3, #128	; 0x80
 8003134:	05da      	lsls	r2, r3, #23

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 8003136:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003138:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800313a:	1a75      	subs	r5, r6, r1
 800313c:	1a47      	subs	r7, r0, r1
 800313e:	42af      	cmp	r7, r5
 8003140:	d903      	bls.n	800314a <Vector7C.4314+0xba>
 8003142:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8003144:	4e07      	ldr	r6, [pc, #28]	; (8003164 <Vector7C.4314+0xd4>)
 8003146:	62e6      	str	r6, [r4, #44]	; 0x2c
 8003148:	e7fe      	b.n	8003148 <Vector7C.4314+0xb8>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800314a:	f7fd fa49 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800314e:	b662      	cpsie	i
 8003150:	e7ab      	b.n	80030aa <Vector7C.4314+0x1a>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003152:	2502      	movs	r5, #2
 8003154:	e7e9      	b.n	800312a <Vector7C.4314+0x9a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003156:	60f7      	str	r7, [r6, #12]
 8003158:	e7d1      	b.n	80030fe <Vector7C.4314+0x6e>
 800315a:	46c0      	nop			; (mov r8, r8)
 800315c:	20001040 	.word	0x20001040
 8003160:	2000105c 	.word	0x2000105c
 8003164:	080087a0 	.word	0x080087a0
 8003168:	46c0      	nop			; (mov r8, r8)
 800316a:	46c0      	nop			; (mov r8, r8)
 800316c:	46c0      	nop			; (mov r8, r8)
 800316e:	46c0      	nop			; (mov r8, r8)

08003170 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003170:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003172:	4647      	mov	r7, r8
 8003174:	b480      	push	{r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003176:	4825      	ldr	r0, [pc, #148]	; (800320c <__init_ram_areas+0x9c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003178:	2380      	movs	r3, #128	; 0x80
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800317a:	4684      	mov	ip, r0
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800317c:	4698      	mov	r8, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800317e:	2400      	movs	r4, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003180:	44e0      	add	r8, ip
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8003182:	4662      	mov	r2, ip
    uint32_t *p = rap->init_area;
 8003184:	6856      	ldr	r6, [r2, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8003186:	6895      	ldr	r5, [r2, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8003188:	6811      	ldr	r1, [r2, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800318a:	42ae      	cmp	r6, r5
 800318c:	d220      	bcs.n	80031d0 <__init_ram_areas+0x60>
 800318e:	43f7      	mvns	r7, r6
 8003190:	19e8      	adds	r0, r5, r7
      *p = *tp;
 8003192:	1c0a      	adds	r2, r1, #0
 8003194:	0743      	lsls	r3, r0, #29
 8003196:	ca01      	ldmia	r2!, {r0}
 8003198:	0fdf      	lsrs	r7, r3, #31
 800319a:	1c33      	adds	r3, r6, #0
 800319c:	c301      	stmia	r3!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800319e:	42ab      	cmp	r3, r5
 80031a0:	d210      	bcs.n	80031c4 <__init_ram_areas+0x54>
 80031a2:	2f00      	cmp	r7, #0
 80031a4:	d004      	beq.n	80031b0 <__init_ram_areas+0x40>
      *p = *tp;
 80031a6:	6849      	ldr	r1, [r1, #4]
 80031a8:	3204      	adds	r2, #4
 80031aa:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80031ac:	42ab      	cmp	r3, r5
 80031ae:	d209      	bcs.n	80031c4 <__init_ram_areas+0x54>
      *p = *tp;
 80031b0:	1c10      	adds	r0, r2, #0
 80031b2:	c880      	ldmia	r0!, {r7}
 80031b4:	1c19      	adds	r1, r3, #0
 80031b6:	c180      	stmia	r1!, {r7}
 80031b8:	6852      	ldr	r2, [r2, #4]
 80031ba:	605a      	str	r2, [r3, #4]
      p++;
 80031bc:	1d0b      	adds	r3, r1, #4
 80031be:	1d02      	adds	r2, r0, #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80031c0:	42ab      	cmp	r3, r5
 80031c2:	d3f5      	bcc.n	80031b0 <__init_ram_areas+0x40>
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80031c4:	43f3      	mvns	r3, r6
 80031c6:	195d      	adds	r5, r3, r5
 80031c8:	08a8      	lsrs	r0, r5, #2
 80031ca:	3001      	adds	r0, #1
 80031cc:	0087      	lsls	r7, r0, #2
 80031ce:	19f6      	adds	r6, r6, r7
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80031d0:	4661      	mov	r1, ip
 80031d2:	68cd      	ldr	r5, [r1, #12]
 80031d4:	42ae      	cmp	r6, r5
 80031d6:	d211      	bcs.n	80031fc <__init_ram_areas+0x8c>
 80031d8:	43f2      	mvns	r2, r6
 80031da:	18ab      	adds	r3, r5, r2
 80031dc:	0758      	lsls	r0, r3, #29
      *p = 0;
 80031de:	c610      	stmia	r6!, {r4}
 80031e0:	0fc7      	lsrs	r7, r0, #31
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80031e2:	42ae      	cmp	r6, r5
 80031e4:	d20a      	bcs.n	80031fc <__init_ram_areas+0x8c>
 80031e6:	2f00      	cmp	r7, #0
 80031e8:	d002      	beq.n	80031f0 <__init_ram_areas+0x80>
      *p = 0;
 80031ea:	c610      	stmia	r6!, {r4}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80031ec:	42ae      	cmp	r6, r5
 80031ee:	d205      	bcs.n	80031fc <__init_ram_areas+0x8c>
      *p = 0;
 80031f0:	1c31      	adds	r1, r6, #0
 80031f2:	c110      	stmia	r1!, {r4}
 80031f4:	6074      	str	r4, [r6, #4]
      p++;
 80031f6:	1d0e      	adds	r6, r1, #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80031f8:	42ae      	cmp	r6, r5
 80031fa:	d3f9      	bcc.n	80031f0 <__init_ram_areas+0x80>
      *p = 0;
      p++;
    }
    rap++;
 80031fc:	2510      	movs	r5, #16
 80031fe:	44ac      	add	ip, r5
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003200:	45c4      	cmp	ip, r8
 8003202:	d3be      	bcc.n	8003182 <__init_ram_areas+0x12>
#endif
}
 8003204:	bc04      	pop	{r2}
 8003206:	4690      	mov	r8, r2
 8003208:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800320a:	46c0      	nop			; (mov r8, r8)
 800320c:	080087b0 	.word	0x080087b0

08003210 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8003210:	e7fe      	b.n	8003210 <__default_exit>
 8003212:	46c0      	nop			; (mov r8, r8)
 8003214:	46c0      	nop			; (mov r8, r8)
 8003216:	46c0      	nop			; (mov r8, r8)
 8003218:	46c0      	nop			; (mov r8, r8)
 800321a:	46c0      	nop			; (mov r8, r8)
 800321c:	46c0      	nop			; (mov r8, r8)
 800321e:	46c0      	nop			; (mov r8, r8)

08003220 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003220:	4770      	bx	lr
 8003222:	46c0      	nop			; (mov r8, r8)
 8003224:	46c0      	nop			; (mov r8, r8)
 8003226:	46c0      	nop			; (mov r8, r8)
 8003228:	46c0      	nop			; (mov r8, r8)
 800322a:	46c0      	nop			; (mov r8, r8)
 800322c:	46c0      	nop			; (mov r8, r8)
 800322e:	46c0      	nop			; (mov r8, r8)

08003230 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003230:	4770      	bx	lr
 8003232:	46c0      	nop			; (mov r8, r8)
 8003234:	46c0      	nop			; (mov r8, r8)
 8003236:	46c0      	nop			; (mov r8, r8)
 8003238:	46c0      	nop			; (mov r8, r8)
 800323a:	46c0      	nop			; (mov r8, r8)
 800323c:	46c0      	nop			; (mov r8, r8)
 800323e:	46c0      	nop			; (mov r8, r8)

08003240 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8003240:	b538      	push	{r3, r4, r5, lr}
 8003242:	1c04      	adds	r4, r0, #0
  uint8_t b;

  chDbgCheckClassI();
 8003244:	f7fd fa14 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8003248:	f7fd fa12 	bl	8000670 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800324c:	69a3      	ldr	r3, [r4, #24]
 800324e:	6962      	ldr	r2, [r4, #20]
 8003250:	429a      	cmp	r2, r3
 8003252:	d01f      	beq.n	8003294 <chOQGetI+0x54>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8003254:	68a1      	ldr	r1, [r4, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8003256:	6922      	ldr	r2, [r4, #16]

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8003258:	3101      	adds	r1, #1
 800325a:	60a1      	str	r1, [r4, #8]
  b = *oqp->q_rdptr++;
 800325c:	781d      	ldrb	r5, [r3, #0]
 800325e:	3301      	adds	r3, #1
 8003260:	61a3      	str	r3, [r4, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003262:	4293      	cmp	r3, r2
 8003264:	d301      	bcc.n	800326a <chOQGetI+0x2a>
    oqp->q_rdptr = oqp->q_buffer;
 8003266:	68e3      	ldr	r3, [r4, #12]
 8003268:	61a3      	str	r3, [r4, #24]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800326a:	6820      	ldr	r0, [r4, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 800326c:	4284      	cmp	r4, r0
 800326e:	d00f      	beq.n	8003290 <chOQGetI+0x50>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003270:	6801      	ldr	r1, [r0, #0]
 8003272:	6021      	str	r1, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003274:	604c      	str	r4, [r1, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8003276:	2420      	movs	r4, #32
 8003278:	5d02      	ldrb	r2, [r0, r4]
 800327a:	2a04      	cmp	r2, #4
 800327c:	d004      	beq.n	8003288 <chOQGetI+0x48>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800327e:	b672      	cpsid	i
 8003280:	4807      	ldr	r0, [pc, #28]	; (80032a0 <chOQGetI+0x60>)
 8003282:	4d08      	ldr	r5, [pc, #32]	; (80032a4 <chOQGetI+0x64>)
 8003284:	62e8      	str	r0, [r5, #44]	; 0x2c
 8003286:	e7fe      	b.n	8003286 <chOQGetI+0x46>

  tp->p_u.rdymsg = msg;
 8003288:	2300      	movs	r3, #0
 800328a:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800328c:	f7fd fa50 	bl	8000730 <chSchReadyI>
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);

  return (msg_t)b;
 8003290:	1c28      	adds	r0, r5, #0
}
 8003292:	bd38      	pop	{r3, r4, r5, pc}
 8003294:	68a0      	ldr	r0, [r4, #8]
 8003296:	2800      	cmp	r0, #0
 8003298:	d0dc      	beq.n	8003254 <chOQGetI+0x14>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 800329a:	2103      	movs	r1, #3
 800329c:	4248      	negs	r0, r1
 800329e:	e7f8      	b.n	8003292 <chOQGetI+0x52>
 80032a0:	08008860 	.word	0x08008860
 80032a4:	20001040 	.word	0x20001040
 80032a8:	46c0      	nop			; (mov r8, r8)
 80032aa:	46c0      	nop			; (mov r8, r8)
 80032ac:	46c0      	nop			; (mov r8, r8)
 80032ae:	46c0      	nop			; (mov r8, r8)

080032b0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 80032b0:	b538      	push	{r3, r4, r5, lr}
 80032b2:	1c04      	adds	r4, r0, #0
 80032b4:	1c0d      	adds	r5, r1, #0

  chDbgCheckClassI();
 80032b6:	f7fd f9db 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80032ba:	f7fd f9d9 	bl	8000670 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80032be:	6963      	ldr	r3, [r4, #20]
 80032c0:	69a2      	ldr	r2, [r4, #24]
 80032c2:	4293      	cmp	r3, r2
 80032c4:	d01f      	beq.n	8003306 <chIQPutI+0x56>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80032c6:	68a1      	ldr	r1, [r4, #8]
 80032c8:	3101      	adds	r1, #1
 80032ca:	60a1      	str	r1, [r4, #8]
  *iqp->q_wrptr++ = b;
 80032cc:	701d      	strb	r5, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80032ce:	6925      	ldr	r5, [r4, #16]
  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
 80032d0:	3301      	adds	r3, #1
 80032d2:	6163      	str	r3, [r4, #20]
  if (iqp->q_wrptr >= iqp->q_top) {
 80032d4:	42ab      	cmp	r3, r5
 80032d6:	d301      	bcc.n	80032dc <chIQPutI+0x2c>
    iqp->q_wrptr = iqp->q_buffer;
 80032d8:	68e3      	ldr	r3, [r4, #12]
 80032da:	6163      	str	r3, [r4, #20]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80032dc:	6820      	ldr	r0, [r4, #0]
 80032de:	4284      	cmp	r4, r0
 80032e0:	d017      	beq.n	8003312 <chIQPutI+0x62>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80032e2:	6802      	ldr	r2, [r0, #0]
 80032e4:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80032e6:	6054      	str	r4, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80032e8:	2420      	movs	r4, #32
 80032ea:	5d01      	ldrb	r1, [r0, r4]
 80032ec:	2904      	cmp	r1, #4
 80032ee:	d004      	beq.n	80032fa <chIQPutI+0x4a>
 80032f0:	b672      	cpsid	i
 80032f2:	4809      	ldr	r0, [pc, #36]	; (8003318 <chIQPutI+0x68>)
 80032f4:	4b09      	ldr	r3, [pc, #36]	; (800331c <chIQPutI+0x6c>)
 80032f6:	62d8      	str	r0, [r3, #44]	; 0x2c
 80032f8:	e7fe      	b.n	80032f8 <chIQPutI+0x48>

  tp->p_u.rdymsg = msg;
 80032fa:	2500      	movs	r5, #0
 80032fc:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80032fe:	f7fd fa17 	bl	8000730 <chSchReadyI>
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8003302:	2000      	movs	r0, #0
}
 8003304:	bd38      	pop	{r3, r4, r5, pc}
 8003306:	68a0      	ldr	r0, [r4, #8]
 8003308:	2800      	cmp	r0, #0
 800330a:	d0dc      	beq.n	80032c6 <chIQPutI+0x16>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 800330c:	2204      	movs	r2, #4
 800330e:	4250      	negs	r0, r2
 8003310:	e7f8      	b.n	8003304 <chIQPutI+0x54>
    iqp->q_wrptr = iqp->q_buffer;
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8003312:	2000      	movs	r0, #0
 8003314:	e7f6      	b.n	8003304 <chIQPutI+0x54>
 8003316:	46c0      	nop			; (mov r8, r8)
 8003318:	08008860 	.word	0x08008860
 800331c:	20001040 	.word	0x20001040

08003320 <chThdDequeueAllI.constprop.72>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003320:	b570      	push	{r4, r5, r6, lr}
 8003322:	1c04      	adds	r4, r0, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003324:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 8003326:	4284      	cmp	r4, r0
 8003328:	d020      	beq.n	800336c <chThdDequeueAllI.constprop.72+0x4c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800332a:	6802      	ldr	r2, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 800332c:	2120      	movs	r1, #32
 800332e:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003330:	6054      	str	r4, [r2, #4]
 8003332:	5c43      	ldrb	r3, [r0, r1]
 8003334:	2b04      	cmp	r3, #4
 8003336:	d004      	beq.n	8003342 <chThdDequeueAllI.constprop.72+0x22>
 8003338:	b672      	cpsid	i
 800333a:	480d      	ldr	r0, [pc, #52]	; (8003370 <chThdDequeueAllI.constprop.72+0x50>)
 800333c:	4c0d      	ldr	r4, [pc, #52]	; (8003374 <chThdDequeueAllI.constprop.72+0x54>)
 800333e:	62e0      	str	r0, [r4, #44]	; 0x2c
 8003340:	e7fe      	b.n	8003340 <chThdDequeueAllI.constprop.72+0x20>

  tp->p_u.rdymsg = msg;
 8003342:	2602      	movs	r6, #2
 8003344:	4276      	negs	r6, r6
 8003346:	6246      	str	r6, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003348:	f7fd f9f2 	bl	8000730 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800334c:	6820      	ldr	r0, [r4, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 800334e:	2520      	movs	r5, #32
 8003350:	4284      	cmp	r4, r0
 8003352:	d00b      	beq.n	800336c <chThdDequeueAllI.constprop.72+0x4c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003354:	6802      	ldr	r2, [r0, #0]
 8003356:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003358:	6054      	str	r4, [r2, #4]
 800335a:	5d41      	ldrb	r1, [r0, r5]
 800335c:	2904      	cmp	r1, #4
 800335e:	d1eb      	bne.n	8003338 <chThdDequeueAllI.constprop.72+0x18>

  tp->p_u.rdymsg = msg;
 8003360:	6246      	str	r6, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003362:	f7fd f9e5 	bl	8000730 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003366:	6820      	ldr	r0, [r4, #0]
 8003368:	4284      	cmp	r4, r0
 800336a:	d1f3      	bne.n	8003354 <chThdDequeueAllI.constprop.72+0x34>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800336c:	bd70      	pop	{r4, r5, r6, pc}
 800336e:	46c0      	nop			; (mov r8, r8)
 8003370:	08008860 	.word	0x08008860
 8003374:	20001040 	.word	0x20001040
 8003378:	46c0      	nop			; (mov r8, r8)
 800337a:	46c0      	nop			; (mov r8, r8)
 800337c:	46c0      	nop			; (mov r8, r8)
 800337e:	46c0      	nop			; (mov r8, r8)

08003380 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8003380:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003382:	4647      	mov	r7, r8
  thread_t *ctp = currp;
 8003384:	4d24      	ldr	r5, [pc, #144]	; (8003418 <chMtxUnlockS+0x98>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8003386:	b480      	push	{r7}
 8003388:	1c04      	adds	r4, r0, #0
  thread_t *ctp = currp;
 800338a:	69ae      	ldr	r6, [r5, #24]
  mutex_t *lmp;

  chDbgCheckClassS();
 800338c:	f7fd fa60 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8003390:	2c00      	cmp	r4, #0
 8003392:	d009      	beq.n	80033a8 <chMtxUnlockS+0x28>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 8003394:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8003396:	2b00      	cmp	r3, #0
 8003398:	d039      	beq.n	800340e <chMtxUnlockS+0x8e>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 800339a:	689f      	ldr	r7, [r3, #8]
 800339c:	42b7      	cmp	r7, r6
 800339e:	d007      	beq.n	80033b0 <chMtxUnlockS+0x30>
 80033a0:	b672      	cpsid	i
 80033a2:	4e1e      	ldr	r6, [pc, #120]	; (800341c <chMtxUnlockS+0x9c>)
 80033a4:	62ee      	str	r6, [r5, #44]	; 0x2c
 80033a6:	e7fe      	b.n	80033a6 <chMtxUnlockS+0x26>
 80033a8:	b672      	cpsid	i
 80033aa:	4b1c      	ldr	r3, [pc, #112]	; (800341c <chMtxUnlockS+0x9c>)
 80033ac:	62eb      	str	r3, [r5, #44]	; 0x2c
 80033ae:	e7fe      	b.n	80033ae <chMtxUnlockS+0x2e>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 80033b0:	429c      	cmp	r4, r3
 80033b2:	d003      	beq.n	80033bc <chMtxUnlockS+0x3c>
 80033b4:	b672      	cpsid	i
 80033b6:	4c19      	ldr	r4, [pc, #100]	; (800341c <chMtxUnlockS+0x9c>)
 80033b8:	62ec      	str	r4, [r5, #44]	; 0x2c
 80033ba:	e7fe      	b.n	80033ba <chMtxUnlockS+0x3a>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 80033bc:	68e5      	ldr	r5, [r4, #12]
 80033be:	63fd      	str	r5, [r7, #60]	; 0x3c
 80033c0:	f7fd fa46 	bl	8000850 <chDbgCheckClassS>
 80033c4:	6826      	ldr	r6, [r4, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80033c6:	42b4      	cmp	r4, r6
 80033c8:	d01e      	beq.n	8003408 <chMtxUnlockS+0x88>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 80033ca:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80033cc:	4688      	mov	r8, r1
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80033ce:	2d00      	cmp	r5, #0
 80033d0:	d00b      	beq.n	80033ea <chMtxUnlockS+0x6a>
 80033d2:	f7fd fa3d 	bl	8000850 <chDbgCheckClassS>
 80033d6:	682a      	ldr	r2, [r5, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80033d8:	4295      	cmp	r5, r2
 80033da:	d003      	beq.n	80033e4 <chMtxUnlockS+0x64>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 80033dc:	6893      	ldr	r3, [r2, #8]
 80033de:	4598      	cmp	r8, r3
 80033e0:	d200      	bcs.n	80033e4 <chMtxUnlockS+0x64>
 80033e2:	4698      	mov	r8, r3
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 80033e4:	68ed      	ldr	r5, [r5, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80033e6:	2d00      	cmp	r5, #0
 80033e8:	d1f3      	bne.n	80033d2 <chMtxUnlockS+0x52>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80033ea:	4640      	mov	r0, r8
 80033ec:	60b8      	str	r0, [r7, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80033ee:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80033f0:	6837      	ldr	r7, [r6, #0]
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 80033f2:	1c30      	adds	r0, r6, #0
 80033f4:	6027      	str	r7, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80033f6:	607c      	str	r4, [r7, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 80033f8:	60a6      	str	r6, [r4, #8]
      mp->m_next = tp->p_mtxlist;
 80033fa:	60e1      	str	r1, [r4, #12]
      tp->p_mtxlist = mp;
 80033fc:	63f4      	str	r4, [r6, #60]	; 0x3c
      (void) chSchReadyI(tp);
 80033fe:	f7fd f997 	bl	8000730 <chSchReadyI>
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8003402:	bc04      	pop	{r2}
 8003404:	4690      	mov	r8, r2
 8003406:	bdf0      	pop	{r4, r5, r6, r7, pc}
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
    }
    else {
      mp->m_owner = NULL;
 8003408:	2000      	movs	r0, #0
 800340a:	60a0      	str	r0, [r4, #8]
 800340c:	e7f9      	b.n	8003402 <chMtxUnlockS+0x82>
 800340e:	b672      	cpsid	i
 8003410:	4a02      	ldr	r2, [pc, #8]	; (800341c <chMtxUnlockS+0x9c>)
 8003412:	62ea      	str	r2, [r5, #44]	; 0x2c
 8003414:	e7fe      	b.n	8003414 <chMtxUnlockS+0x94>
 8003416:	46c0      	nop			; (mov r8, r8)
 8003418:	20001040 	.word	0x20001040
 800341c:	08008790 	.word	0x08008790

08003420 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8003420:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp, *cp;

  otp = currp;
 8003422:	4d14      	ldr	r5, [pc, #80]	; (8003474 <chSchDoRescheduleAhead+0x54>)
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003424:	2120      	movs	r1, #32
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003426:	682a      	ldr	r2, [r5, #0]
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8003428:	69ac      	ldr	r4, [r5, #24]

  tqp->p_next = tp->p_next;
 800342a:	6813      	ldr	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800342c:	2001      	movs	r0, #1
 800342e:	5450      	strb	r0, [r2, r1]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003430:	605d      	str	r5, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003432:	61aa      	str	r2, [r5, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8003434:	2200      	movs	r2, #0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003436:	602b      	str	r3, [r5, #0]
 8003438:	5462      	strb	r2, [r4, r1]
 800343a:	68a0      	ldr	r0, [r4, #8]
 800343c:	e000      	b.n	8003440 <chSchDoRescheduleAhead+0x20>
 800343e:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8003440:	6899      	ldr	r1, [r3, #8]
 8003442:	4281      	cmp	r1, r0
 8003444:	d8fb      	bhi.n	800343e <chSchDoRescheduleAhead+0x1e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8003446:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8003448:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 800344a:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 800344c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 800344e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
 8003450:	1c20      	adds	r0, r4, #0
 8003452:	f7fd fcdd 	bl	8000e10 <_dbg_trace>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003456:	f3ef 8309 	mrs	r3, PSP
 800345a:	69e0      	ldr	r0, [r4, #28]
 800345c:	3b24      	subs	r3, #36	; 0x24
 800345e:	4298      	cmp	r0, r3
 8003460:	d804      	bhi.n	800346c <chSchDoRescheduleAhead+0x4c>
 8003462:	69a8      	ldr	r0, [r5, #24]
 8003464:	1c21      	adds	r1, r4, #0
 8003466:	f7fc feb3 	bl	80001d0 <_port_switch>
}
 800346a:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800346c:	b672      	cpsid	i
 800346e:	4c02      	ldr	r4, [pc, #8]	; (8003478 <chSchDoRescheduleAhead+0x58>)
 8003470:	62ec      	str	r4, [r5, #44]	; 0x2c
 8003472:	e7fe      	b.n	8003472 <chSchDoRescheduleAhead+0x52>
 8003474:	20001040 	.word	0x20001040
 8003478:	0800855c 	.word	0x0800855c
 800347c:	46c0      	nop			; (mov r8, r8)
 800347e:	46c0      	nop			; (mov r8, r8)

08003480 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003480:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 8003482:	f7fd f9e5 	bl	8000850 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8003486:	f7fd f8f3 	bl	8000670 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 800348a:	4b05      	ldr	r3, [pc, #20]	; (80034a0 <chSchRescheduleS+0x20>)
 800348c:	681a      	ldr	r2, [r3, #0]
 800348e:	6998      	ldr	r0, [r3, #24]

  if (chSchIsRescRequiredI()) {
 8003490:	6891      	ldr	r1, [r2, #8]
 8003492:	6883      	ldr	r3, [r0, #8]
 8003494:	4299      	cmp	r1, r3
 8003496:	d901      	bls.n	800349c <chSchRescheduleS+0x1c>
    chSchDoRescheduleAhead();
 8003498:	f7ff ffc2 	bl	8003420 <chSchDoRescheduleAhead>
  }
}
 800349c:	bd08      	pop	{r3, pc}
 800349e:	46c0      	nop			; (mov r8, r8)
 80034a0:	20001040 	.word	0x20001040
 80034a4:	46c0      	nop			; (mov r8, r8)
 80034a6:	46c0      	nop			; (mov r8, r8)
 80034a8:	46c0      	nop			; (mov r8, r8)
 80034aa:	46c0      	nop			; (mov r8, r8)
 80034ac:	46c0      	nop			; (mov r8, r8)
 80034ae:	46c0      	nop			; (mov r8, r8)

080034b0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80034b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80034b2:	1c04      	adds	r4, r0, #0
 80034b4:	1c0f      	adds	r7, r1, #0
 80034b6:	1c15      	adds	r5, r2, #0
 80034b8:	1c1e      	adds	r6, r3, #0
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
 80034ba:	f7fd f8d9 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 80034be:	2c00      	cmp	r4, #0
 80034c0:	d02c      	beq.n	800351c <chThdCreateI+0x6c>
 80034c2:	2fcf      	cmp	r7, #207	; 0xcf
 80034c4:	d92a      	bls.n	800351c <chThdCreateI+0x6c>
 80034c6:	2d7f      	cmp	r5, #127	; 0x7f
 80034c8:	d828      	bhi.n	800351c <chThdCreateI+0x6c>
 80034ca:	2e00      	cmp	r6, #0
 80034cc:	d026      	beq.n	800351c <chThdCreateI+0x6c>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80034ce:	1c39      	adds	r1, r7, #0
 80034d0:	3924      	subs	r1, #36	; 0x24
 80034d2:	1860      	adds	r0, r4, r1
 80034d4:	9b06      	ldr	r3, [sp, #24]
 80034d6:	4a14      	ldr	r2, [pc, #80]	; (8003528 <chThdCreateI+0x78>)
 80034d8:	60e0      	str	r0, [r4, #12]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80034da:	2702      	movs	r7, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80034dc:	6106      	str	r6, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80034de:	2620      	movs	r6, #32

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80034e0:	6143      	str	r3, [r0, #20]
 80034e2:	6202      	str	r2, [r0, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80034e4:	55a7      	strb	r7, [r4, r6]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80034e6:	4f11      	ldr	r7, [pc, #68]	; (800352c <chThdCreateI+0x7c>)
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80034e8:	1c26      	adds	r6, r4, #0
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80034ea:	697a      	ldr	r2, [r7, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80034ec:	2000      	movs	r0, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80034ee:	60a5      	str	r5, [r4, #8]
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80034f0:	2121      	movs	r1, #33	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80034f2:	6425      	str	r5, [r4, #64]	; 0x40
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80034f4:	2322      	movs	r3, #34	; 0x22
 80034f6:	2501      	movs	r5, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80034f8:	3628      	adds	r6, #40	; 0x28
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80034fa:	5460      	strb	r0, [r4, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80034fc:	54e5      	strb	r5, [r4, r3]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80034fe:	6127      	str	r7, [r4, #16]
 8003500:	6114      	str	r4, [r2, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8003502:	62a6      	str	r6, [r4, #40]	; 0x28
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8003504:	3604      	adds	r6, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003506:	62e6      	str	r6, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 8003508:	6326      	str	r6, [r4, #48]	; 0x30
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800350a:	361c      	adds	r6, #28
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800350c:	63e0      	str	r0, [r4, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800350e:	63a0      	str	r0, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8003510:	61a0      	str	r0, [r4, #24]
  REG_INSERT(tp);
 8003512:	6162      	str	r2, [r4, #20]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8003514:	61e6      	str	r6, [r4, #28]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003516:	617c      	str	r4, [r7, #20]
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 8003518:	1c20      	adds	r0, r4, #0
 800351a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800351c:	b672      	cpsid	i
 800351e:	4c04      	ldr	r4, [pc, #16]	; (8003530 <chThdCreateI+0x80>)
 8003520:	4802      	ldr	r0, [pc, #8]	; (800352c <chThdCreateI+0x7c>)
 8003522:	62c4      	str	r4, [r0, #44]	; 0x2c
 8003524:	e7fe      	b.n	8003524 <chThdCreateI+0x74>
 8003526:	46c0      	nop			; (mov r8, r8)
 8003528:	080001f1 	.word	0x080001f1
 800352c:	20001040 	.word	0x20001040
 8003530:	08008830 	.word	0x08008830
 8003534:	46c0      	nop			; (mov r8, r8)
 8003536:	46c0      	nop			; (mov r8, r8)
 8003538:	46c0      	nop			; (mov r8, r8)
 800353a:	46c0      	nop			; (mov r8, r8)
 800353c:	46c0      	nop			; (mov r8, r8)
 800353e:	46c0      	nop			; (mov r8, r8)

08003540 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8003540:	b538      	push	{r3, r4, r5, lr}
 8003542:	1c04      	adds	r4, r0, #0
 8003544:	1c0d      	adds	r5, r1, #0

  chDbgCheckClassS();
 8003546:	f7fd f983 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 800354a:	2c00      	cmp	r4, #0
 800354c:	d012      	beq.n	8003574 <chSemWaitTimeoutS+0x34>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800354e:	68a3      	ldr	r3, [r4, #8]
 8003550:	6822      	ldr	r2, [r4, #0]
 8003552:	2b00      	cmp	r3, #0
 8003554:	db06      	blt.n	8003564 <chSemWaitTimeoutS+0x24>
 8003556:	4294      	cmp	r4, r2
 8003558:	d006      	beq.n	8003568 <chSemWaitTimeoutS+0x28>
 800355a:	b672      	cpsid	i
 800355c:	4d11      	ldr	r5, [pc, #68]	; (80035a4 <chSemWaitTimeoutS+0x64>)
 800355e:	4912      	ldr	r1, [pc, #72]	; (80035a8 <chSemWaitTimeoutS+0x68>)
 8003560:	62cd      	str	r5, [r1, #44]	; 0x2c
 8003562:	e7fe      	b.n	8003562 <chSemWaitTimeoutS+0x22>
 8003564:	4294      	cmp	r4, r2
 8003566:	d0f8      	beq.n	800355a <chSemWaitTimeoutS+0x1a>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8003568:	1e59      	subs	r1, r3, #1
 800356a:	60a1      	str	r1, [r4, #8]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 800356c:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800356e:	2900      	cmp	r1, #0
 8003570:	db05      	blt.n	800357e <chSemWaitTimeoutS+0x3e>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8003572:	bd38      	pop	{r3, r4, r5, pc}
 8003574:	b672      	cpsid	i
 8003576:	480b      	ldr	r0, [pc, #44]	; (80035a4 <chSemWaitTimeoutS+0x64>)
 8003578:	4b0b      	ldr	r3, [pc, #44]	; (80035a8 <chSemWaitTimeoutS+0x68>)
 800357a:	62d8      	str	r0, [r3, #44]	; 0x2c
 800357c:	e7fe      	b.n	800357c <chSemWaitTimeoutS+0x3c>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 800357e:	2d00      	cmp	r5, #0
 8003580:	d00c      	beq.n	800359c <chSemWaitTimeoutS+0x5c>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8003582:	4809      	ldr	r0, [pc, #36]	; (80035a8 <chSemWaitTimeoutS+0x68>)
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8003584:	1c29      	adds	r1, r5, #0
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8003586:	6983      	ldr	r3, [r0, #24]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8003588:	2005      	movs	r0, #5
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 800358a:	625c      	str	r4, [r3, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800358c:	6862      	ldr	r2, [r4, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800358e:	601c      	str	r4, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8003590:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8003592:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8003594:	6063      	str	r3, [r4, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8003596:	f7fd fd4b 	bl	8001030 <chSchGoSleepTimeoutS>
 800359a:	e7ea      	b.n	8003572 <chSemWaitTimeoutS+0x32>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 800359c:	60a3      	str	r3, [r4, #8]

      return MSG_TIMEOUT;
 800359e:	2401      	movs	r4, #1
 80035a0:	4260      	negs	r0, r4
 80035a2:	e7e6      	b.n	8003572 <chSemWaitTimeoutS+0x32>
 80035a4:	08008750 	.word	0x08008750
 80035a8:	20001040 	.word	0x20001040
 80035ac:	46c0      	nop			; (mov r8, r8)
 80035ae:	46c0      	nop			; (mov r8, r8)

080035b0 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 80035b0:	b510      	push	{r4, lr}
 80035b2:	1c04      	adds	r4, r0, #0

  chDbgCheckClassI();
 80035b4:	f7fd f85c 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
 80035b8:	2c00      	cmp	r4, #0
 80035ba:	d011      	beq.n	80035e0 <chSemSignalI+0x30>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 80035bc:	68a3      	ldr	r3, [r4, #8]
 80035be:	6822      	ldr	r2, [r4, #0]
 80035c0:	2b00      	cmp	r3, #0
 80035c2:	db06      	blt.n	80035d2 <chSemSignalI+0x22>
 80035c4:	4294      	cmp	r4, r2
 80035c6:	d006      	beq.n	80035d6 <chSemSignalI+0x26>
 80035c8:	b672      	cpsid	i
 80035ca:	480c      	ldr	r0, [pc, #48]	; (80035fc <chSemSignalI+0x4c>)
 80035cc:	4b0c      	ldr	r3, [pc, #48]	; (8003600 <chSemSignalI+0x50>)
 80035ce:	62d8      	str	r0, [r3, #44]	; 0x2c
 80035d0:	e7fe      	b.n	80035d0 <chSemSignalI+0x20>
 80035d2:	4294      	cmp	r4, r2
 80035d4:	d0f8      	beq.n	80035c8 <chSemSignalI+0x18>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 80035d6:	3301      	adds	r3, #1
 80035d8:	60a3      	str	r3, [r4, #8]
 80035da:	2b00      	cmp	r3, #0
 80035dc:	dd05      	ble.n	80035ea <chSemSignalI+0x3a>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 80035de:	bd10      	pop	{r4, pc}
 80035e0:	b672      	cpsid	i
 80035e2:	4a06      	ldr	r2, [pc, #24]	; (80035fc <chSemSignalI+0x4c>)
 80035e4:	4906      	ldr	r1, [pc, #24]	; (8003600 <chSemSignalI+0x50>)
 80035e6:	62ca      	str	r2, [r1, #44]	; 0x2c
 80035e8:	e7fe      	b.n	80035e8 <chSemSignalI+0x38>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80035ea:	6820      	ldr	r0, [r4, #0]

  tqp->p_next = tp->p_next;
 80035ec:	6801      	ldr	r1, [r0, #0]
 80035ee:	6021      	str	r1, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80035f0:	604c      	str	r4, [r1, #4]

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 80035f2:	2400      	movs	r4, #0
 80035f4:	6244      	str	r4, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80035f6:	f7fd f89b 	bl	8000730 <chSchReadyI>
 80035fa:	e7f0      	b.n	80035de <chSemSignalI+0x2e>
 80035fc:	08008880 	.word	0x08008880
 8003600:	20001040 	.word	0x20001040
 8003604:	46c0      	nop			; (mov r8, r8)
 8003606:	46c0      	nop			; (mov r8, r8)
 8003608:	46c0      	nop			; (mov r8, r8)
 800360a:	46c0      	nop			; (mov r8, r8)
 800360c:	46c0      	nop			; (mov r8, r8)
 800360e:	46c0      	nop			; (mov r8, r8)

08003610 <chMBFetchI.constprop.29>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8003610:	b570      	push	{r4, r5, r6, lr}
 8003612:	1c05      	adds	r5, r0, #0

  chDbgCheckClassI();
 8003614:	f7fd f82c 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8003618:	2d00      	cmp	r5, #0
 800361a:	d104      	bne.n	8003626 <chMBFetchI.constprop.29+0x16>
 800361c:	b672      	cpsid	i
 800361e:	4c0f      	ldr	r4, [pc, #60]	; (800365c <chMBFetchI.constprop.29+0x4c>)
 8003620:	4e0f      	ldr	r6, [pc, #60]	; (8003660 <chMBFetchI.constprop.29+0x50>)
 8003622:	62f4      	str	r4, [r6, #44]	; 0x2c
 8003624:	e7fe      	b.n	8003624 <chMBFetchI.constprop.29+0x14>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 8003626:	f7fd f823 	bl	8000670 <chDbgCheckClassI>

  return sp->s_cnt;
 800362a:	4c0e      	ldr	r4, [pc, #56]	; (8003664 <chMBFetchI.constprop.29+0x54>)
 800362c:	69a6      	ldr	r6, [r4, #24]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 800362e:	2e00      	cmp	r6, #0
 8003630:	dd11      	ble.n	8003656 <chMBFetchI.constprop.29+0x46>
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();
 8003632:	f7fd f81d 	bl	8000670 <chDbgCheckClassI>

  sp->s_cnt--;
 8003636:	3e01      	subs	r6, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8003638:	68e3      	ldr	r3, [r4, #12]
 800363a:	61a6      	str	r6, [r4, #24]
 800363c:	cb04      	ldmia	r3!, {r2}
  if (mbp->mb_rdptr >= mbp->mb_top) {
 800363e:	6860      	ldr	r0, [r4, #4]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8003640:	602a      	str	r2, [r5, #0]
 8003642:	60e3      	str	r3, [r4, #12]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8003644:	4283      	cmp	r3, r0
 8003646:	d301      	bcc.n	800364c <chMBFetchI.constprop.29+0x3c>
    mbp->mb_rdptr = mbp->mb_buffer;
 8003648:	6821      	ldr	r1, [r4, #0]
 800364a:	60e1      	str	r1, [r4, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 800364c:	4806      	ldr	r0, [pc, #24]	; (8003668 <chMBFetchI.constprop.29+0x58>)
 800364e:	f7ff ffaf 	bl	80035b0 <chSemSignalI>

  return MSG_OK;
 8003652:	2000      	movs	r0, #0
 8003654:	e001      	b.n	800365a <chMBFetchI.constprop.29+0x4a>

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 8003656:	2501      	movs	r5, #1
 8003658:	4268      	negs	r0, r5
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);

  return MSG_OK;
}
 800365a:	bd70      	pop	{r4, r5, r6, pc}
 800365c:	08008850 	.word	0x08008850
 8003660:	20001040 	.word	0x20001040
 8003664:	20000600 	.word	0x20000600
 8003668:	2000061c 	.word	0x2000061c
 800366c:	00000000 	.word	0x00000000

08003670 <chMBPostI.constprop.35>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8003670:	b570      	push	{r4, r5, r6, lr}
 8003672:	1c06      	adds	r6, r0, #0

  chDbgCheckClassI();
 8003674:	f7fc fffc 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 8003678:	f7fc fffa 	bl	8000670 <chDbgCheckClassI>

  return sp->s_cnt;
 800367c:	4c0c      	ldr	r4, [pc, #48]	; (80036b0 <chMBPostI.constprop.35+0x40>)
 800367e:	6a65      	ldr	r5, [r4, #36]	; 0x24
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8003680:	2d00      	cmp	r5, #0
 8003682:	dd11      	ble.n	80036a8 <chMBPostI.constprop.35+0x38>
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();
 8003684:	f7fc fff4 	bl	8000670 <chDbgCheckClassI>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8003688:	68a3      	ldr	r3, [r4, #8]

  sp->s_cnt--;
 800368a:	3d01      	subs	r5, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
 800368c:	6862      	ldr	r2, [r4, #4]
 800368e:	6265      	str	r5, [r4, #36]	; 0x24
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8003690:	c340      	stmia	r3!, {r6}
 8003692:	60a3      	str	r3, [r4, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8003694:	4293      	cmp	r3, r2
 8003696:	d204      	bcs.n	80036a2 <chMBPostI.constprop.35+0x32>
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 8003698:	4806      	ldr	r0, [pc, #24]	; (80036b4 <chMBPostI.constprop.35+0x44>)
 800369a:	f7ff ff89 	bl	80035b0 <chSemSignalI>

  return MSG_OK;
 800369e:	2000      	movs	r0, #0
}
 80036a0:	bd70      	pop	{r4, r5, r6, pc}
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 80036a2:	6820      	ldr	r0, [r4, #0]
 80036a4:	60a0      	str	r0, [r4, #8]
 80036a6:	e7f7      	b.n	8003698 <chMBPostI.constprop.35+0x28>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80036a8:	2101      	movs	r1, #1
 80036aa:	4248      	negs	r0, r1
 80036ac:	e7f8      	b.n	80036a0 <chMBPostI.constprop.35+0x30>
 80036ae:	46c0      	nop			; (mov r8, r8)
 80036b0:	20000600 	.word	0x20000600
 80036b4:	20000610 	.word	0x20000610
 80036b8:	46c0      	nop			; (mov r8, r8)
 80036ba:	46c0      	nop			; (mov r8, r8)
 80036bc:	46c0      	nop			; (mov r8, r8)
 80036be:	46c0      	nop			; (mov r8, r8)

080036c0 <chMBPostAheadI.constprop.32>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80036c0:	b570      	push	{r4, r5, r6, lr}
 80036c2:	1c06      	adds	r6, r0, #0

  chDbgCheckClassI();
 80036c4:	f7fc ffd4 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 80036c8:	f7fc ffd2 	bl	8000670 <chDbgCheckClassI>

  return sp->s_cnt;
 80036cc:	4c0d      	ldr	r4, [pc, #52]	; (8003704 <chMBPostAheadI.constprop.32+0x44>)
 80036ce:	6a65      	ldr	r5, [r4, #36]	; 0x24
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 80036d0:	2d00      	cmp	r5, #0
 80036d2:	dd13      	ble.n	80036fc <chMBPostAheadI.constprop.32+0x3c>
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();
 80036d4:	f7fc ffcc 	bl	8000670 <chDbgCheckClassI>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80036d8:	68e3      	ldr	r3, [r4, #12]
 80036da:	6822      	ldr	r2, [r4, #0]

  sp->s_cnt--;
 80036dc:	3d01      	subs	r5, #1
 80036de:	3b04      	subs	r3, #4
 80036e0:	6265      	str	r5, [r4, #36]	; 0x24
 80036e2:	60e3      	str	r3, [r4, #12]
 80036e4:	4293      	cmp	r3, r2
 80036e6:	d305      	bcc.n	80036f4 <chMBPostAheadI.constprop.32+0x34>
    mbp->mb_rdptr = mbp->mb_top - 1;
  }
  *mbp->mb_rdptr = msg;
  chSemSignalI(&mbp->mb_fullsem);
 80036e8:	4807      	ldr	r0, [pc, #28]	; (8003708 <chMBPostAheadI.constprop.32+0x48>)
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    mbp->mb_rdptr = mbp->mb_top - 1;
  }
  *mbp->mb_rdptr = msg;
 80036ea:	601e      	str	r6, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 80036ec:	f7ff ff60 	bl	80035b0 <chSemSignalI>

  return MSG_OK;
 80036f0:	2000      	movs	r0, #0
}
 80036f2:	bd70      	pop	{r4, r5, r6, pc}
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    mbp->mb_rdptr = mbp->mb_top - 1;
 80036f4:	6863      	ldr	r3, [r4, #4]
 80036f6:	3b04      	subs	r3, #4
 80036f8:	60e3      	str	r3, [r4, #12]
 80036fa:	e7f5      	b.n	80036e8 <chMBPostAheadI.constprop.32+0x28>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80036fc:	2001      	movs	r0, #1
 80036fe:	4240      	negs	r0, r0
 8003700:	e7f7      	b.n	80036f2 <chMBPostAheadI.constprop.32+0x32>
 8003702:	46c0      	nop			; (mov r8, r8)
 8003704:	20000600 	.word	0x20000600
 8003708:	20000610 	.word	0x20000610
 800370c:	46c0      	nop			; (mov r8, r8)
 800370e:	46c0      	nop			; (mov r8, r8)

08003710 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8003710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003712:	1c04      	adds	r4, r0, #0
 8003714:	1c0e      	adds	r6, r1, #0
  cnt_t cnt;

  chDbgCheckClassI();
 8003716:	f7fc ffab 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 800371a:	2c00      	cmp	r4, #0
 800371c:	d03e      	beq.n	800379c <chSemResetI+0x8c>
 800371e:	2e00      	cmp	r6, #0
 8003720:	db3c      	blt.n	800379c <chSemResetI+0x8c>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 8003722:	68a5      	ldr	r5, [r4, #8]
 8003724:	6823      	ldr	r3, [r4, #0]
 8003726:	2d00      	cmp	r5, #0
 8003728:	db06      	blt.n	8003738 <chSemResetI+0x28>
 800372a:	429c      	cmp	r4, r3
 800372c:	d006      	beq.n	800373c <chSemResetI+0x2c>
 800372e:	b672      	cpsid	i
 8003730:	4c1d      	ldr	r4, [pc, #116]	; (80037a8 <chSemResetI+0x98>)
 8003732:	4d1e      	ldr	r5, [pc, #120]	; (80037ac <chSemResetI+0x9c>)
 8003734:	62ec      	str	r4, [r5, #44]	; 0x2c
 8003736:	e7fe      	b.n	8003736 <chSemResetI+0x26>
 8003738:	429c      	cmp	r4, r3
 800373a:	d0f8      	beq.n	800372e <chSemResetI+0x1e>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 800373c:	3501      	adds	r5, #1
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
 800373e:	60a6      	str	r6, [r4, #8]
  while (++cnt <= (cnt_t)0) {
 8003740:	2d00      	cmp	r5, #0
 8003742:	dc2a      	bgt.n	800379a <chSemResetI+0x8a>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8003744:	2002      	movs	r0, #2
 8003746:	4246      	negs	r6, r0

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8003748:	6860      	ldr	r0, [r4, #4]
 800374a:	2701      	movs	r7, #1

  tqp->p_prev = tp->p_prev;
 800374c:	6841      	ldr	r1, [r0, #4]
 800374e:	402f      	ands	r7, r5
 8003750:	6061      	str	r1, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8003752:	600c      	str	r4, [r1, #0]
 8003754:	f7fc ffec 	bl	8000730 <chSchReadyI>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8003758:	3501      	adds	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800375a:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 800375c:	2d01      	cmp	r5, #1
 800375e:	d01c      	beq.n	800379a <chSemResetI+0x8a>
 8003760:	2f00      	cmp	r7, #0
 8003762:	d009      	beq.n	8003778 <chSemResetI+0x68>

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8003764:	6860      	ldr	r0, [r4, #4]
 8003766:	3501      	adds	r5, #1

  tqp->p_prev = tp->p_prev;
 8003768:	6842      	ldr	r2, [r0, #4]
 800376a:	6062      	str	r2, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 800376c:	6014      	str	r4, [r2, #0]
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800376e:	f7fc ffdf 	bl	8000730 <chSchReadyI>
 8003772:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8003774:	2d01      	cmp	r5, #1
 8003776:	d010      	beq.n	800379a <chSemResetI+0x8a>

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8003778:	6860      	ldr	r0, [r4, #4]
 800377a:	3502      	adds	r5, #2

  tqp->p_prev = tp->p_prev;
 800377c:	6843      	ldr	r3, [r0, #4]
 800377e:	6063      	str	r3, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8003780:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8003782:	f7fc ffd5 	bl	8000730 <chSchReadyI>
 8003786:	6246      	str	r6, [r0, #36]	; 0x24

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8003788:	6860      	ldr	r0, [r4, #4]

  tqp->p_prev = tp->p_prev;
 800378a:	6847      	ldr	r7, [r0, #4]
 800378c:	6067      	str	r7, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 800378e:	603c      	str	r4, [r7, #0]
 8003790:	f7fc ffce 	bl	8000730 <chSchReadyI>
 8003794:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8003796:	2d01      	cmp	r5, #1
 8003798:	d1ee      	bne.n	8003778 <chSemResetI+0x68>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800379a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800379c:	b672      	cpsid	i
 800379e:	4802      	ldr	r0, [pc, #8]	; (80037a8 <chSemResetI+0x98>)
 80037a0:	4e02      	ldr	r6, [pc, #8]	; (80037ac <chSemResetI+0x9c>)
 80037a2:	62f0      	str	r0, [r6, #44]	; 0x2c
 80037a4:	e7fe      	b.n	80037a4 <chSemResetI+0x94>
 80037a6:	46c0      	nop			; (mov r8, r8)
 80037a8:	08008890 	.word	0x08008890
 80037ac:	20001040 	.word	0x20001040

080037b0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80037b0:	b570      	push	{r4, r5, r6, lr}
 80037b2:	1c06      	adds	r6, r0, #0
 80037b4:	1c0d      	adds	r5, r1, #0
  event_listener_t *elp;

  chDbgCheckClassI();
 80037b6:	f7fc ff5b 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 80037ba:	2e00      	cmp	r6, #0
 80037bc:	d012      	beq.n	80037e4 <chEvtBroadcastFlagsI+0x34>

  elp = esp->es_next;
 80037be:	6834      	ldr	r4, [r6, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80037c0:	42a6      	cmp	r6, r4
 80037c2:	d00e      	beq.n	80037e2 <chEvtBroadcastFlagsI+0x32>
  /*lint -restore*/
    elp->el_flags |= flags;
 80037c4:	68e3      	ldr	r3, [r4, #12]
 80037c6:	432b      	orrs	r3, r5
 80037c8:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80037ca:	2d00      	cmp	r5, #0
 80037cc:	d002      	beq.n	80037d4 <chEvtBroadcastFlagsI+0x24>
 80037ce:	6922      	ldr	r2, [r4, #16]
 80037d0:	421a      	tst	r2, r3
 80037d2:	d003      	beq.n	80037dc <chEvtBroadcastFlagsI+0x2c>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80037d4:	6860      	ldr	r0, [r4, #4]
 80037d6:	68a1      	ldr	r1, [r4, #8]
 80037d8:	f7fc ffda 	bl	8000790 <chEvtSignalI>
    }
    elp = elp->el_next;
 80037dc:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80037de:	42a6      	cmp	r6, r4
 80037e0:	d1f0      	bne.n	80037c4 <chEvtBroadcastFlagsI+0x14>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80037e2:	bd70      	pop	{r4, r5, r6, pc}
 80037e4:	b672      	cpsid	i
 80037e6:	4802      	ldr	r0, [pc, #8]	; (80037f0 <chEvtBroadcastFlagsI+0x40>)
 80037e8:	4902      	ldr	r1, [pc, #8]	; (80037f4 <chEvtBroadcastFlagsI+0x44>)
 80037ea:	62c8      	str	r0, [r1, #44]	; 0x2c
 80037ec:	e7fe      	b.n	80037ec <chEvtBroadcastFlagsI+0x3c>
 80037ee:	46c0      	nop			; (mov r8, r8)
 80037f0:	08008770 	.word	0x08008770
 80037f4:	20001040 	.word	0x20001040
 80037f8:	46c0      	nop			; (mov r8, r8)
 80037fa:	46c0      	nop			; (mov r8, r8)
 80037fc:	46c0      	nop			; (mov r8, r8)
 80037fe:	46c0      	nop			; (mov r8, r8)

08003800 <VectorAC.4182>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8003800:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003802:	4645      	mov	r5, r8
 8003804:	4657      	mov	r7, sl
 8003806:	464e      	mov	r6, r9
 8003808:	b4e0      	push	{r5, r6, r7}

  OSAL_IRQ_PROLOGUE();
 800380a:	46f0      	mov	r8, lr
 800380c:	f7fc ff00 	bl	8000610 <_dbg_check_enter_isr>
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8003810:	4e51      	ldr	r6, [pc, #324]	; (8003958 <VectorAC.4182+0x158>)
 8003812:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 8003814:	682f      	ldr	r7, [r5, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8003816:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 8003818:	622c      	str	r4, [r5, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800381a:	0722      	lsls	r2, r4, #28
 800381c:	d124      	bne.n	8003868 <VectorAC.4182+0x68>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800381e:	05e3      	lsls	r3, r4, #23
 8003820:	d445      	bmi.n	80038ae <VectorAC.4182+0xae>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8003822:	06a2      	lsls	r2, r4, #26
 8003824:	d450      	bmi.n	80038c8 <VectorAC.4182+0xc8>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8003826:	2380      	movs	r3, #128	; 0x80
 8003828:	423b      	tst	r3, r7
 800382a:	d001      	beq.n	8003830 <VectorAC.4182+0x30>
 800382c:	4223      	tst	r3, r4
 800382e:	d164      	bne.n	80038fa <VectorAC.4182+0xfa>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8003830:	0663      	lsls	r3, r4, #25
 8003832:	d409      	bmi.n	8003848 <VectorAC.4182+0x48>

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8003834:	f7fc ff04 	bl	8000640 <_dbg_check_leave_isr>
 8003838:	4640      	mov	r0, r8
 800383a:	f7fd fac9 	bl	8000dd0 <_port_irq_epilogue>
}
 800383e:	bc1c      	pop	{r2, r3, r4}
 8003840:	4690      	mov	r8, r2
 8003842:	4699      	mov	r9, r3
 8003844:	46a2      	mov	sl, r4
 8003846:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003848:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800384a:	f7fc feb1 	bl	80005b0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 800384e:	f7fc ff0f 	bl	8000670 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003852:	6c74      	ldr	r4, [r6, #68]	; 0x44
 8003854:	6cb2      	ldr	r2, [r6, #72]	; 0x48
 8003856:	4294      	cmp	r4, r2
 8003858:	d063      	beq.n	8003922 <VectorAC.4182+0x122>
  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800385a:	2640      	movs	r6, #64	; 0x40
 800385c:	43b7      	bics	r7, r6
 800385e:	602f      	str	r7, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003860:	f7fc febe 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003864:	b662      	cpsie	i
 8003866:	e7e5      	b.n	8003834 <VectorAC.4182+0x34>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 8003868:	0723      	lsls	r3, r4, #28
    sts |= SD_OVERRUN_ERROR;
 800386a:	0fd8      	lsrs	r0, r3, #31
 800386c:	01c1      	lsls	r1, r0, #7
 800386e:	4689      	mov	r9, r1
  if (isr & USART_ISR_PE)
 8003870:	07e3      	lsls	r3, r4, #31
 8003872:	d503      	bpl.n	800387c <VectorAC.4182+0x7c>
    sts |= SD_PARITY_ERROR;
 8003874:	2320      	movs	r3, #32
 8003876:	1c0a      	adds	r2, r1, #0
 8003878:	431a      	orrs	r2, r3
 800387a:	4691      	mov	r9, r2
  if (isr & USART_ISR_FE)
 800387c:	07a3      	lsls	r3, r4, #30
 800387e:	d503      	bpl.n	8003888 <VectorAC.4182+0x88>
    sts |= SD_FRAMING_ERROR;
 8003880:	4649      	mov	r1, r9
 8003882:	2040      	movs	r0, #64	; 0x40
 8003884:	4301      	orrs	r1, r0
 8003886:	4689      	mov	r9, r1
  if (isr & USART_ISR_NE)
 8003888:	0763      	lsls	r3, r4, #29
 800388a:	d504      	bpl.n	8003896 <VectorAC.4182+0x96>
    sts |= SD_NOISE_ERROR;
 800388c:	2380      	movs	r3, #128	; 0x80
 800388e:	464a      	mov	r2, r9
 8003890:	0058      	lsls	r0, r3, #1
 8003892:	4302      	orrs	r2, r0
 8003894:	4691      	mov	r9, r2
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003896:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003898:	f7fc fe8a 	bl	80005b0 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800389c:	482f      	ldr	r0, [pc, #188]	; (800395c <VectorAC.4182+0x15c>)
 800389e:	4649      	mov	r1, r9
 80038a0:	f7ff ff86 	bl	80037b0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80038a4:	f7fc fe9c 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038a8:	b662      	cpsie	i
  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80038aa:	05e3      	lsls	r3, r4, #23
 80038ac:	d5b9      	bpl.n	8003822 <VectorAC.4182+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038ae:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80038b0:	f7fc fe7e 	bl	80005b0 <_dbg_check_lock_from_isr>
 80038b4:	2180      	movs	r1, #128	; 0x80
 80038b6:	4829      	ldr	r0, [pc, #164]	; (800395c <VectorAC.4182+0x15c>)
 80038b8:	0089      	lsls	r1, r1, #2
 80038ba:	f7ff ff79 	bl	80037b0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80038be:	f7fc fe8f 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038c2:	b662      	cpsie	i
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 80038c4:	06a2      	lsls	r2, r4, #26
 80038c6:	d5ae      	bpl.n	8003826 <VectorAC.4182+0x26>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038c8:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80038ca:	f7fc fe71 	bl	80005b0 <_dbg_check_lock_from_isr>
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 80038ce:	8cab      	ldrh	r3, [r5, #36]	; 0x24
 80038d0:	b2d8      	uxtb	r0, r3
 80038d2:	4682      	mov	sl, r0
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 80038d4:	f7fc fecc 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80038d8:	f7fc feca 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 80038dc:	6972      	ldr	r2, [r6, #20]
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80038de:	2a00      	cmp	r2, #0
 80038e0:	d01a      	beq.n	8003918 <VectorAC.4182+0x118>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80038e2:	491f      	ldr	r1, [pc, #124]	; (8003960 <VectorAC.4182+0x160>)
 80038e4:	4689      	mov	r9, r1
 80038e6:	1c08      	adds	r0, r1, #0
 80038e8:	4651      	mov	r1, sl
 80038ea:	f7ff fce1 	bl	80032b0 <chIQPutI>
 80038ee:	2800      	cmp	r0, #0
 80038f0:	db1f      	blt.n	8003932 <VectorAC.4182+0x132>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80038f2:	f7fc fe75 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038f6:	b662      	cpsie	i
 80038f8:	e795      	b.n	8003826 <VectorAC.4182+0x26>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038fa:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80038fc:	f7fc fe58 	bl	80005b0 <_dbg_check_lock_from_isr>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8003900:	4818      	ldr	r0, [pc, #96]	; (8003964 <VectorAC.4182+0x164>)
 8003902:	4682      	mov	sl, r0
 8003904:	f7ff fc9c 	bl	8003240 <chOQGetI>
    if (b < Q_OK) {
 8003908:	2800      	cmp	r0, #0
 800390a:	db18      	blt.n	800393e <VectorAC.4182+0x13e>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 800390c:	b282      	uxth	r2, r0
 800390e:	852a      	strh	r2, [r5, #40]	; 0x28
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003910:	f7fc fe66 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003914:	b662      	cpsie	i
 8003916:	e78b      	b.n	8003830 <VectorAC.4182+0x30>
 8003918:	1d30      	adds	r0, r6, #4
 800391a:	2104      	movs	r1, #4
 800391c:	f7ff ff48 	bl	80037b0 <chEvtBroadcastFlagsI>
 8003920:	e7df      	b.n	80038e2 <VectorAC.4182+0xe2>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003922:	6bb1      	ldr	r1, [r6, #56]	; 0x38
 8003924:	2900      	cmp	r1, #0
 8003926:	d098      	beq.n	800385a <VectorAC.4182+0x5a>
 8003928:	1d30      	adds	r0, r6, #4
 800392a:	2110      	movs	r1, #16
 800392c:	f7ff ff40 	bl	80037b0 <chEvtBroadcastFlagsI>
 8003930:	e793      	b.n	800385a <VectorAC.4182+0x5a>
 8003932:	4648      	mov	r0, r9
 8003934:	3808      	subs	r0, #8
 8003936:	2180      	movs	r1, #128	; 0x80
 8003938:	f7ff ff3a 	bl	80037b0 <chEvtBroadcastFlagsI>
 800393c:	e7d9      	b.n	80038f2 <VectorAC.4182+0xf2>
 800393e:	4650      	mov	r0, sl
 8003940:	382c      	subs	r0, #44	; 0x2c
 8003942:	2108      	movs	r1, #8
 8003944:	f7ff ff34 	bl	80037b0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8003948:	21c0      	movs	r1, #192	; 0xc0
 800394a:	1c38      	adds	r0, r7, #0
 800394c:	4388      	bics	r0, r1
 800394e:	2340      	movs	r3, #64	; 0x40
 8003950:	4303      	orrs	r3, r0
 8003952:	602b      	str	r3, [r5, #0]
 8003954:	e7dc      	b.n	8003910 <VectorAC.4182+0x110>
 8003956:	46c0      	nop			; (mov r8, r8)
 8003958:	20000fc0 	.word	0x20000fc0
 800395c:	20000fc4 	.word	0x20000fc4
 8003960:	20000fcc 	.word	0x20000fcc
 8003964:	20000ff0 	.word	0x20000ff0
 8003968:	46c0      	nop			; (mov r8, r8)
 800396a:	46c0      	nop			; (mov r8, r8)
 800396c:	46c0      	nop			; (mov r8, r8)
 800396e:	46c0      	nop			; (mov r8, r8)

08003970 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003970:	4b06      	ldr	r3, [pc, #24]	; (800398c <_dbg_check_unlock+0x1c>)
 8003972:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003974:	2a00      	cmp	r2, #0
 8003976:	d104      	bne.n	8003982 <_dbg_check_unlock+0x12>
 8003978:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800397a:	2900      	cmp	r1, #0
 800397c:	dd01      	ble.n	8003982 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800397e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8003980:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003982:	b672      	cpsid	i
 8003984:	4802      	ldr	r0, [pc, #8]	; (8003990 <_dbg_check_unlock+0x20>)
 8003986:	62d8      	str	r0, [r3, #44]	; 0x2c
 8003988:	e7fe      	b.n	8003988 <_dbg_check_unlock+0x18>
 800398a:	46c0      	nop			; (mov r8, r8)
 800398c:	20001040 	.word	0x20001040
 8003990:	08008920 	.word	0x08008920
 8003994:	46c0      	nop			; (mov r8, r8)
 8003996:	46c0      	nop			; (mov r8, r8)
 8003998:	46c0      	nop			; (mov r8, r8)
 800399a:	46c0      	nop			; (mov r8, r8)
 800399c:	46c0      	nop			; (mov r8, r8)
 800399e:	46c0      	nop			; (mov r8, r8)

080039a0 <chSysRestoreStatusX.part.2.4280>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80039a0:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80039a2:	f3ef 8305 	mrs	r3, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80039a6:	05d8      	lsls	r0, r3, #23

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80039a8:	d112      	bne.n	80039d0 <chSysRestoreStatusX.part.2.4280+0x30>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 80039aa:	f7ff fd69 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80039ae:	f7ff ffdf 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80039b2:	4b09      	ldr	r3, [pc, #36]	; (80039d8 <chSysRestoreStatusX.part.2.4280+0x38>)
 80039b4:	681a      	ldr	r2, [r3, #0]
 80039b6:	429a      	cmp	r2, r3
 80039b8:	d008      	beq.n	80039cc <chSysRestoreStatusX.part.2.4280+0x2c>
 80039ba:	6999      	ldr	r1, [r3, #24]
 80039bc:	6892      	ldr	r2, [r2, #8]
 80039be:	6888      	ldr	r0, [r1, #8]
 80039c0:	4290      	cmp	r0, r2
 80039c2:	d203      	bcs.n	80039cc <chSysRestoreStatusX.part.2.4280+0x2c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80039c4:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80039c6:	4905      	ldr	r1, [pc, #20]	; (80039dc <chSysRestoreStatusX.part.2.4280+0x3c>)
 80039c8:	62d9      	str	r1, [r3, #44]	; 0x2c
 80039ca:	e7fe      	b.n	80039ca <chSysRestoreStatusX.part.2.4280+0x2a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80039cc:	b662      	cpsie	i
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
 80039ce:	bd08      	pop	{r3, pc}
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80039d0:	f7fc fe06 	bl	80005e0 <_dbg_check_unlock_from_isr>
 80039d4:	b662      	cpsie	i
 80039d6:	e7fa      	b.n	80039ce <chSysRestoreStatusX.part.2.4280+0x2e>
 80039d8:	20001040 	.word	0x20001040
 80039dc:	080088a0 	.word	0x080088a0

080039e0 <chSysUnlock.6142>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80039e0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80039e2:	f7ff ffc5 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80039e6:	4b07      	ldr	r3, [pc, #28]	; (8003a04 <chSysUnlock.6142+0x24>)
 80039e8:	681a      	ldr	r2, [r3, #0]
 80039ea:	429a      	cmp	r2, r3
 80039ec:	d004      	beq.n	80039f8 <chSysUnlock.6142+0x18>
 80039ee:	6999      	ldr	r1, [r3, #24]
 80039f0:	6892      	ldr	r2, [r2, #8]
 80039f2:	6888      	ldr	r0, [r1, #8]
 80039f4:	4290      	cmp	r0, r2
 80039f6:	d301      	bcc.n	80039fc <chSysUnlock.6142+0x1c>
 80039f8:	b662      	cpsie	i
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
}
 80039fa:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80039fc:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80039fe:	4902      	ldr	r1, [pc, #8]	; (8003a08 <chSysUnlock.6142+0x28>)
 8003a00:	62d9      	str	r1, [r3, #44]	; 0x2c
 8003a02:	e7fe      	b.n	8003a02 <chSysUnlock.6142+0x22>
 8003a04:	20001040 	.word	0x20001040
 8003a08:	08008b50 	.word	0x08008b50
 8003a0c:	46c0      	nop			; (mov r8, r8)
 8003a0e:	46c0      	nop			; (mov r8, r8)

08003a10 <chSysUnlock.6509>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003a10:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003a12:	f7ff ffad 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003a16:	4b07      	ldr	r3, [pc, #28]	; (8003a34 <chSysUnlock.6509+0x24>)
 8003a18:	681a      	ldr	r2, [r3, #0]
 8003a1a:	429a      	cmp	r2, r3
 8003a1c:	d004      	beq.n	8003a28 <chSysUnlock.6509+0x18>
 8003a1e:	6999      	ldr	r1, [r3, #24]
 8003a20:	6892      	ldr	r2, [r2, #8]
 8003a22:	6888      	ldr	r0, [r1, #8]
 8003a24:	4290      	cmp	r0, r2
 8003a26:	d301      	bcc.n	8003a2c <chSysUnlock.6509+0x1c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a28:	b662      	cpsie	i
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
}
 8003a2a:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a2c:	b672      	cpsid	i
 8003a2e:	4902      	ldr	r1, [pc, #8]	; (8003a38 <chSysUnlock.6509+0x28>)
 8003a30:	62d9      	str	r1, [r3, #44]	; 0x2c
 8003a32:	e7fe      	b.n	8003a32 <chSysUnlock.6509+0x22>
 8003a34:	20001040 	.word	0x20001040
 8003a38:	08008b10 	.word	0x08008b10
 8003a3c:	46c0      	nop			; (mov r8, r8)
 8003a3e:	46c0      	nop			; (mov r8, r8)

08003a40 <chSysUnlock.9594>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003a40:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003a42:	f7ff ff95 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003a46:	4b07      	ldr	r3, [pc, #28]	; (8003a64 <chSysUnlock.9594+0x24>)
 8003a48:	681a      	ldr	r2, [r3, #0]
 8003a4a:	429a      	cmp	r2, r3
 8003a4c:	d004      	beq.n	8003a58 <chSysUnlock.9594+0x18>
 8003a4e:	6999      	ldr	r1, [r3, #24]
 8003a50:	6892      	ldr	r2, [r2, #8]
 8003a52:	6888      	ldr	r0, [r1, #8]
 8003a54:	4290      	cmp	r0, r2
 8003a56:	d301      	bcc.n	8003a5c <chSysUnlock.9594+0x1c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a58:	b662      	cpsie	i
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
}
 8003a5a:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a5c:	b672      	cpsid	i
 8003a5e:	4902      	ldr	r1, [pc, #8]	; (8003a68 <chSysUnlock.9594+0x28>)
 8003a60:	62d9      	str	r1, [r3, #44]	; 0x2c
 8003a62:	e7fe      	b.n	8003a62 <chSysUnlock.9594+0x22>
 8003a64:	20001040 	.word	0x20001040
 8003a68:	08008ae0 	.word	0x08008ae0
 8003a6c:	46c0      	nop			; (mov r8, r8)
 8003a6e:	46c0      	nop			; (mov r8, r8)

08003a70 <chSysUnlock.10381>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003a70:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003a72:	f7ff ff7d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003a76:	4b07      	ldr	r3, [pc, #28]	; (8003a94 <chSysUnlock.10381+0x24>)
 8003a78:	681a      	ldr	r2, [r3, #0]
 8003a7a:	429a      	cmp	r2, r3
 8003a7c:	d004      	beq.n	8003a88 <chSysUnlock.10381+0x18>
 8003a7e:	6999      	ldr	r1, [r3, #24]
 8003a80:	6892      	ldr	r2, [r2, #8]
 8003a82:	6888      	ldr	r0, [r1, #8]
 8003a84:	4290      	cmp	r0, r2
 8003a86:	d301      	bcc.n	8003a8c <chSysUnlock.10381+0x1c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a88:	b662      	cpsie	i
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
}
 8003a8a:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a8c:	b672      	cpsid	i
 8003a8e:	4902      	ldr	r1, [pc, #8]	; (8003a98 <chSysUnlock.10381+0x28>)
 8003a90:	62d9      	str	r1, [r3, #44]	; 0x2c
 8003a92:	e7fe      	b.n	8003a92 <chSysUnlock.10381+0x22>
 8003a94:	20001040 	.word	0x20001040
 8003a98:	080085f0 	.word	0x080085f0
 8003a9c:	46c0      	nop			; (mov r8, r8)
 8003a9e:	46c0      	nop			; (mov r8, r8)

08003aa0 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003aa0:	4b06      	ldr	r3, [pc, #24]	; (8003abc <_dbg_check_lock+0x1c>)
 8003aa2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003aa4:	2a00      	cmp	r2, #0
 8003aa6:	d102      	bne.n	8003aae <_dbg_check_lock+0xe>
 8003aa8:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8003aaa:	2800      	cmp	r0, #0
 8003aac:	d003      	beq.n	8003ab6 <_dbg_check_lock+0x16>
 8003aae:	b672      	cpsid	i
 8003ab0:	4a03      	ldr	r2, [pc, #12]	; (8003ac0 <_dbg_check_lock+0x20>)
 8003ab2:	62da      	str	r2, [r3, #44]	; 0x2c
 8003ab4:	e7fe      	b.n	8003ab4 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8003ab6:	2101      	movs	r1, #1
 8003ab8:	6359      	str	r1, [r3, #52]	; 0x34
}
 8003aba:	4770      	bx	lr
 8003abc:	20001040 	.word	0x20001040
 8003ac0:	08008928 	.word	0x08008928
 8003ac4:	46c0      	nop			; (mov r8, r8)
 8003ac6:	46c0      	nop			; (mov r8, r8)
 8003ac8:	46c0      	nop			; (mov r8, r8)
 8003aca:	46c0      	nop			; (mov r8, r8)
 8003acc:	46c0      	nop			; (mov r8, r8)
 8003ace:	46c0      	nop			; (mov r8, r8)

08003ad0 <chSemSignalWait.constprop.67>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8003ad0:	b570      	push	{r4, r5, r6, lr}
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));
  chDbgAssert(((sps->s_cnt >= (cnt_t)0) && queue_isempty(&sps->s_queue)) ||
 8003ad2:	4c23      	ldr	r4, [pc, #140]	; (8003b60 <chSemSignalWait.constprop.67+0x90>)
 8003ad4:	68a3      	ldr	r3, [r4, #8]
 8003ad6:	2b00      	cmp	r3, #0
 8003ad8:	db07      	blt.n	8003aea <chSemSignalWait.constprop.67+0x1a>
 8003ada:	6820      	ldr	r0, [r4, #0]
 8003adc:	42a0      	cmp	r0, r4
 8003ade:	d007      	beq.n	8003af0 <chSemSignalWait.constprop.67+0x20>
 8003ae0:	b672      	cpsid	i
 8003ae2:	4d20      	ldr	r5, [pc, #128]	; (8003b64 <chSemSignalWait.constprop.67+0x94>)
 8003ae4:	4b20      	ldr	r3, [pc, #128]	; (8003b68 <chSemSignalWait.constprop.67+0x98>)
 8003ae6:	62dd      	str	r5, [r3, #44]	; 0x2c
 8003ae8:	e7fe      	b.n	8003ae8 <chSemSignalWait.constprop.67+0x18>
 8003aea:	6821      	ldr	r1, [r4, #0]
 8003aec:	42a1      	cmp	r1, r4
 8003aee:	d0f7      	beq.n	8003ae0 <chSemSignalWait.constprop.67+0x10>
 8003af0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003af2:	f7ff ffd5 	bl	8003aa0 <_dbg_check_lock>
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
 8003af6:	68a6      	ldr	r6, [r4, #8]
 8003af8:	3601      	adds	r6, #1
 8003afa:	60a6      	str	r6, [r4, #8]
 8003afc:	2e00      	cmp	r6, #0
 8003afe:	dc08      	bgt.n	8003b12 <chSemSignalWait.constprop.67+0x42>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003b00:	6820      	ldr	r0, [r4, #0]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8003b02:	2500      	movs	r5, #0

  tqp->p_next = tp->p_next;
 8003b04:	6802      	ldr	r2, [r0, #0]
 8003b06:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003b08:	6054      	str	r4, [r2, #4]
 8003b0a:	f7fc fe11 	bl	8000730 <chSchReadyI>
 8003b0e:	68a6      	ldr	r6, [r4, #8]
 8003b10:	6245      	str	r5, [r0, #36]	; 0x24
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8003b12:	3e01      	subs	r6, #1
 8003b14:	60a6      	str	r6, [r4, #8]
 8003b16:	2e00      	cmp	r6, #0
 8003b18:	db10      	blt.n	8003b3c <chSemSignalWait.constprop.67+0x6c>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8003b1a:	f7ff fcb1 	bl	8003480 <chSchRescheduleS>
 8003b1e:	4d12      	ldr	r5, [pc, #72]	; (8003b68 <chSemSignalWait.constprop.67+0x98>)
    msg = MSG_OK;
 8003b20:	2400      	movs	r4, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003b22:	f7ff ff25 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003b26:	6828      	ldr	r0, [r5, #0]
 8003b28:	42a8      	cmp	r0, r5
 8003b2a:	d004      	beq.n	8003b36 <chSemSignalWait.constprop.67+0x66>
 8003b2c:	69a9      	ldr	r1, [r5, #24]
 8003b2e:	6886      	ldr	r6, [r0, #8]
 8003b30:	688a      	ldr	r2, [r1, #8]
 8003b32:	42b2      	cmp	r2, r6
 8003b34:	d30f      	bcc.n	8003b56 <chSemSignalWait.constprop.67+0x86>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003b36:	b662      	cpsie	i
  }
  chSysUnlock();

  return msg;
}
 8003b38:	1c20      	adds	r0, r4, #0
 8003b3a:	bd70      	pop	{r4, r5, r6, pc}
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8003b3c:	4d0a      	ldr	r5, [pc, #40]	; (8003b68 <chSemSignalWait.constprop.67+0x98>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8003b3e:	6863      	ldr	r3, [r4, #4]
 8003b40:	69ae      	ldr	r6, [r5, #24]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8003b42:	2005      	movs	r0, #5
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8003b44:	6034      	str	r4, [r6, #0]
  tp->p_prev = tqp->p_prev;
 8003b46:	6073      	str	r3, [r6, #4]
  tp->p_prev->p_next = tp;
 8003b48:	601e      	str	r6, [r3, #0]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
 8003b4a:	6274      	str	r4, [r6, #36]	; 0x24
  tqp->p_prev = tp;
 8003b4c:	6066      	str	r6, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 8003b4e:	f7fd f9bf 	bl	8000ed0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8003b52:	6a74      	ldr	r4, [r6, #36]	; 0x24
 8003b54:	e7e5      	b.n	8003b22 <chSemSignalWait.constprop.67+0x52>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b56:	b672      	cpsid	i
 8003b58:	4c04      	ldr	r4, [pc, #16]	; (8003b6c <chSemSignalWait.constprop.67+0x9c>)
 8003b5a:	62ec      	str	r4, [r5, #44]	; 0x2c
 8003b5c:	e7fe      	b.n	8003b5c <chSemSignalWait.constprop.67+0x8c>
 8003b5e:	46c0      	nop			; (mov r8, r8)
 8003b60:	200006a4 	.word	0x200006a4
 8003b64:	08008900 	.word	0x08008900
 8003b68:	20001040 	.word	0x20001040
 8003b6c:	08008600 	.word	0x08008600

08003b70 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8003b70:	b510      	push	{r4, lr}
 8003b72:	1e04      	subs	r4, r0, #0

  chDbgCheck(sp != NULL);
 8003b74:	d022      	beq.n	8003bbc <chSemSignal+0x4c>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 8003b76:	6883      	ldr	r3, [r0, #8]
 8003b78:	2b00      	cmp	r3, #0
 8003b7a:	db07      	blt.n	8003b8c <chSemSignal+0x1c>
 8003b7c:	6800      	ldr	r0, [r0, #0]
 8003b7e:	4284      	cmp	r4, r0
 8003b80:	d007      	beq.n	8003b92 <chSemSignal+0x22>
 8003b82:	b672      	cpsid	i
 8003b84:	4c16      	ldr	r4, [pc, #88]	; (8003be0 <chSemSignal+0x70>)
 8003b86:	4917      	ldr	r1, [pc, #92]	; (8003be4 <chSemSignal+0x74>)
 8003b88:	62cc      	str	r4, [r1, #44]	; 0x2c
 8003b8a:	e7fe      	b.n	8003b8a <chSemSignal+0x1a>
 8003b8c:	6801      	ldr	r1, [r0, #0]
 8003b8e:	4288      	cmp	r0, r1
 8003b90:	d0f7      	beq.n	8003b82 <chSemSignal+0x12>
 8003b92:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003b94:	f7ff ff84 	bl	8003aa0 <_dbg_check_lock>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
 8003b98:	68a2      	ldr	r2, [r4, #8]
 8003b9a:	3201      	adds	r2, #1
 8003b9c:	60a2      	str	r2, [r4, #8]
 8003b9e:	2a00      	cmp	r2, #0
 8003ba0:	dd15      	ble.n	8003bce <chSemSignal+0x5e>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003ba2:	f7ff fee5 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003ba6:	4c0f      	ldr	r4, [pc, #60]	; (8003be4 <chSemSignal+0x74>)
 8003ba8:	6820      	ldr	r0, [r4, #0]
 8003baa:	42a0      	cmp	r0, r4
 8003bac:	d004      	beq.n	8003bb8 <chSemSignal+0x48>
 8003bae:	69a1      	ldr	r1, [r4, #24]
 8003bb0:	6882      	ldr	r2, [r0, #8]
 8003bb2:	688b      	ldr	r3, [r1, #8]
 8003bb4:	4293      	cmp	r3, r2
 8003bb6:	d306      	bcc.n	8003bc6 <chSemSignal+0x56>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003bb8:	b662      	cpsie	i
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
  }
  chSysUnlock();
}
 8003bba:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003bbc:	b672      	cpsid	i
 8003bbe:	4a08      	ldr	r2, [pc, #32]	; (8003be0 <chSemSignal+0x70>)
 8003bc0:	4b08      	ldr	r3, [pc, #32]	; (8003be4 <chSemSignal+0x74>)
 8003bc2:	62da      	str	r2, [r3, #44]	; 0x2c
 8003bc4:	e7fe      	b.n	8003bc4 <chSemSignal+0x54>
 8003bc6:	b672      	cpsid	i
 8003bc8:	4807      	ldr	r0, [pc, #28]	; (8003be8 <chSemSignal+0x78>)
 8003bca:	62e0      	str	r0, [r4, #44]	; 0x2c
 8003bcc:	e7fe      	b.n	8003bcc <chSemSignal+0x5c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003bce:	6820      	ldr	r0, [r4, #0]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8003bd0:	2100      	movs	r1, #0

  tqp->p_next = tp->p_next;
 8003bd2:	6803      	ldr	r3, [r0, #0]
 8003bd4:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003bd6:	605c      	str	r4, [r3, #4]
 8003bd8:	f7fd f93a 	bl	8000e50 <chSchWakeupS>
 8003bdc:	e7e1      	b.n	8003ba2 <chSemSignal+0x32>
 8003bde:	46c0      	nop			; (mov r8, r8)
 8003be0:	080088f0 	.word	0x080088f0
 8003be4:	20001040 	.word	0x20001040
 8003be8:	08008600 	.word	0x08008600
 8003bec:	46c0      	nop			; (mov r8, r8)
 8003bee:	46c0      	nop			; (mov r8, r8)

08003bf0 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8003bf0:	b538      	push	{r3, r4, r5, lr}
 8003bf2:	1c04      	adds	r4, r0, #0
 8003bf4:	1c0d      	adds	r5, r1, #0
 8003bf6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003bf8:	f7ff ff52 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
 8003bfc:	2320      	movs	r3, #32
 8003bfe:	5ce0      	ldrb	r0, [r4, r3]
 8003c00:	280d      	cmp	r0, #13
 8003c02:	d004      	beq.n	8003c0e <chMsgRelease+0x1e>
 8003c04:	b672      	cpsid	i
 8003c06:	4c0d      	ldr	r4, [pc, #52]	; (8003c3c <chMsgRelease+0x4c>)
 8003c08:	4a0d      	ldr	r2, [pc, #52]	; (8003c40 <chMsgRelease+0x50>)
 8003c0a:	62d4      	str	r4, [r2, #44]	; 0x2c
 8003c0c:	e7fe      	b.n	8003c0c <chMsgRelease+0x1c>
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();
 8003c0e:	f7fc fe1f 	bl	8000850 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
 8003c12:	1c20      	adds	r0, r4, #0
 8003c14:	1c29      	adds	r1, r5, #0
 8003c16:	f7fd f91b 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003c1a:	f7ff fea9 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003c1e:	4c08      	ldr	r4, [pc, #32]	; (8003c40 <chMsgRelease+0x50>)
 8003c20:	6822      	ldr	r2, [r4, #0]
 8003c22:	42a2      	cmp	r2, r4
 8003c24:	d004      	beq.n	8003c30 <chMsgRelease+0x40>
 8003c26:	69a1      	ldr	r1, [r4, #24]
 8003c28:	6893      	ldr	r3, [r2, #8]
 8003c2a:	688d      	ldr	r5, [r1, #8]
 8003c2c:	429d      	cmp	r5, r3
 8003c2e:	d301      	bcc.n	8003c34 <chMsgRelease+0x44>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003c30:	b662      	cpsie	i
  chMsgReleaseS(tp, msg);
  chSysUnlock();
}
 8003c32:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003c34:	b672      	cpsid	i
 8003c36:	4803      	ldr	r0, [pc, #12]	; (8003c44 <chMsgRelease+0x54>)
 8003c38:	62e0      	str	r0, [r4, #44]	; 0x2c
 8003c3a:	e7fe      	b.n	8003c3a <chMsgRelease+0x4a>
 8003c3c:	08008960 	.word	0x08008960
 8003c40:	20001040 	.word	0x20001040
 8003c44:	08008970 	.word	0x08008970
 8003c48:	46c0      	nop			; (mov r8, r8)
 8003c4a:	46c0      	nop			; (mov r8, r8)
 8003c4c:	46c0      	nop			; (mov r8, r8)
 8003c4e:	46c0      	nop			; (mov r8, r8)

08003c50 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8003c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8003c52:	4d18      	ldr	r5, [pc, #96]	; (8003cb4 <chMsgSend+0x64>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8003c54:	1c06      	adds	r6, r0, #0
 8003c56:	1c0f      	adds	r7, r1, #0
  thread_t *ctp = currp;
 8003c58:	69ac      	ldr	r4, [r5, #24]
 8003c5a:	b672      	cpsid	i

  chDbgCheck(tp != NULL);
 8003c5c:	2800      	cmp	r0, #0
 8003c5e:	d026      	beq.n	8003cae <chMsgSend+0x5e>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003c60:	f7ff ff1e 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8003c64:	1c33      	adds	r3, r6, #0
 8003c66:	332c      	adds	r3, #44	; 0x2c
 8003c68:	6263      	str	r3, [r4, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8003c6a:	6b30      	ldr	r0, [r6, #48]	; 0x30
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8003c6c:	6023      	str	r3, [r4, #0]
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 8003c6e:	6367      	str	r7, [r4, #52]	; 0x34
  tp->p_prev = tqp->p_prev;
 8003c70:	6060      	str	r0, [r4, #4]
  tp->p_prev->p_next = tp;
 8003c72:	6004      	str	r4, [r0, #0]
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8003c74:	2120      	movs	r1, #32
  tqp->p_prev = tp;
 8003c76:	6334      	str	r4, [r6, #48]	; 0x30
 8003c78:	5c72      	ldrb	r2, [r6, r1]
 8003c7a:	2a0e      	cmp	r2, #14
 8003c7c:	d102      	bne.n	8003c84 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
 8003c7e:	1c30      	adds	r0, r6, #0
 8003c80:	f7fc fd56 	bl	8000730 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8003c84:	200c      	movs	r0, #12
 8003c86:	f7fd f923 	bl	8000ed0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8003c8a:	6a66      	ldr	r6, [r4, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003c8c:	f7ff fe70 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003c90:	682f      	ldr	r7, [r5, #0]
 8003c92:	42af      	cmp	r7, r5
 8003c94:	d004      	beq.n	8003ca0 <chMsgSend+0x50>
 8003c96:	69ac      	ldr	r4, [r5, #24]
 8003c98:	68bb      	ldr	r3, [r7, #8]
 8003c9a:	68a0      	ldr	r0, [r4, #8]
 8003c9c:	4298      	cmp	r0, r3
 8003c9e:	d302      	bcc.n	8003ca6 <chMsgSend+0x56>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ca0:	b662      	cpsie	i
  chSysUnlock();

  return msg;
}
 8003ca2:	1c30      	adds	r0, r6, #0
 8003ca4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ca6:	b672      	cpsid	i
 8003ca8:	4903      	ldr	r1, [pc, #12]	; (8003cb8 <chMsgSend+0x68>)
 8003caa:	62e9      	str	r1, [r5, #44]	; 0x2c
 8003cac:	e7fe      	b.n	8003cac <chMsgSend+0x5c>
 8003cae:	4a03      	ldr	r2, [pc, #12]	; (8003cbc <chMsgSend+0x6c>)
 8003cb0:	62ea      	str	r2, [r5, #44]	; 0x2c
 8003cb2:	e7fe      	b.n	8003cb2 <chMsgSend+0x62>
 8003cb4:	20001040 	.word	0x20001040
 8003cb8:	08008970 	.word	0x08008970
 8003cbc:	08008910 	.word	0x08008910

08003cc0 <thread.9362>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8003cc0:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8003cc2:	2141      	movs	r1, #65	; 0x41
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8003cc4:	1c04      	adds	r4, r0, #0

  chMsgSend(p, 'A');
 8003cc6:	f7ff ffc3 	bl	8003c50 <chMsgSend>
  chMsgSend(p, 'B');
 8003cca:	1c20      	adds	r0, r4, #0
 8003ccc:	2142      	movs	r1, #66	; 0x42
 8003cce:	f7ff ffbf 	bl	8003c50 <chMsgSend>
  chMsgSend(p, 'C');
 8003cd2:	1c20      	adds	r0, r4, #0
 8003cd4:	2143      	movs	r1, #67	; 0x43
 8003cd6:	f7ff ffbb 	bl	8003c50 <chMsgSend>
}
 8003cda:	bd10      	pop	{r4, pc}
 8003cdc:	46c0      	nop			; (mov r8, r8)
 8003cde:	46c0      	nop			; (mov r8, r8)

08003ce0 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8003ce0:	b538      	push	{r3, r4, r5, lr}
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8003ce2:	4c3c      	ldr	r4, [pc, #240]	; (8003dd4 <test_terminate_threads+0xf4>)
 8003ce4:	6825      	ldr	r5, [r4, #0]
 8003ce6:	2d00      	cmp	r5, #0
 8003ce8:	d013      	beq.n	8003d12 <test_terminate_threads+0x32>
 8003cea:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003cec:	f7ff fed8 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 8003cf0:	2321      	movs	r3, #33	; 0x21
 8003cf2:	5ce9      	ldrb	r1, [r5, r3]
 8003cf4:	2204      	movs	r2, #4
 8003cf6:	430a      	orrs	r2, r1
 8003cf8:	54ea      	strb	r2, [r5, r3]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003cfa:	f7ff fe39 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003cfe:	4b36      	ldr	r3, [pc, #216]	; (8003dd8 <test_terminate_threads+0xf8>)
 8003d00:	6818      	ldr	r0, [r3, #0]
 8003d02:	4298      	cmp	r0, r3
 8003d04:	d004      	beq.n	8003d10 <test_terminate_threads+0x30>
 8003d06:	699d      	ldr	r5, [r3, #24]
 8003d08:	6882      	ldr	r2, [r0, #8]
 8003d0a:	68a9      	ldr	r1, [r5, #8]
 8003d0c:	4291      	cmp	r1, r2
 8003d0e:	d35d      	bcc.n	8003dcc <test_terminate_threads+0xec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d10:	b662      	cpsie	i
 8003d12:	6865      	ldr	r5, [r4, #4]
 8003d14:	2d00      	cmp	r5, #0
 8003d16:	d013      	beq.n	8003d40 <test_terminate_threads+0x60>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d18:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003d1a:	f7ff fec1 	bl	8003aa0 <_dbg_check_lock>
 8003d1e:	2321      	movs	r3, #33	; 0x21
 8003d20:	5ce8      	ldrb	r0, [r5, r3]
 8003d22:	2104      	movs	r1, #4
 8003d24:	4301      	orrs	r1, r0
 8003d26:	54e9      	strb	r1, [r5, r3]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003d28:	f7ff fe22 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003d2c:	4b2a      	ldr	r3, [pc, #168]	; (8003dd8 <test_terminate_threads+0xf8>)
 8003d2e:	681a      	ldr	r2, [r3, #0]
 8003d30:	429a      	cmp	r2, r3
 8003d32:	d004      	beq.n	8003d3e <test_terminate_threads+0x5e>
 8003d34:	699d      	ldr	r5, [r3, #24]
 8003d36:	6891      	ldr	r1, [r2, #8]
 8003d38:	68a8      	ldr	r0, [r5, #8]
 8003d3a:	4288      	cmp	r0, r1
 8003d3c:	d346      	bcc.n	8003dcc <test_terminate_threads+0xec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d3e:	b662      	cpsie	i
 8003d40:	68a5      	ldr	r5, [r4, #8]
 8003d42:	2d00      	cmp	r5, #0
 8003d44:	d013      	beq.n	8003d6e <test_terminate_threads+0x8e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d46:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003d48:	f7ff feaa 	bl	8003aa0 <_dbg_check_lock>
 8003d4c:	2321      	movs	r3, #33	; 0x21
 8003d4e:	5ce8      	ldrb	r0, [r5, r3]
 8003d50:	2204      	movs	r2, #4
 8003d52:	4302      	orrs	r2, r0
 8003d54:	54ea      	strb	r2, [r5, r3]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003d56:	f7ff fe0b 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003d5a:	4b1f      	ldr	r3, [pc, #124]	; (8003dd8 <test_terminate_threads+0xf8>)
 8003d5c:	681d      	ldr	r5, [r3, #0]
 8003d5e:	429d      	cmp	r5, r3
 8003d60:	d004      	beq.n	8003d6c <test_terminate_threads+0x8c>
 8003d62:	6999      	ldr	r1, [r3, #24]
 8003d64:	68aa      	ldr	r2, [r5, #8]
 8003d66:	6888      	ldr	r0, [r1, #8]
 8003d68:	4290      	cmp	r0, r2
 8003d6a:	d32f      	bcc.n	8003dcc <test_terminate_threads+0xec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d6c:	b662      	cpsie	i
 8003d6e:	68e5      	ldr	r5, [r4, #12]
 8003d70:	2d00      	cmp	r5, #0
 8003d72:	d013      	beq.n	8003d9c <test_terminate_threads+0xbc>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d74:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003d76:	f7ff fe93 	bl	8003aa0 <_dbg_check_lock>
 8003d7a:	2321      	movs	r3, #33	; 0x21
 8003d7c:	5ce9      	ldrb	r1, [r5, r3]
 8003d7e:	2004      	movs	r0, #4
 8003d80:	4308      	orrs	r0, r1
 8003d82:	54e8      	strb	r0, [r5, r3]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003d84:	f7ff fdf4 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003d88:	4b13      	ldr	r3, [pc, #76]	; (8003dd8 <test_terminate_threads+0xf8>)
 8003d8a:	681a      	ldr	r2, [r3, #0]
 8003d8c:	429a      	cmp	r2, r3
 8003d8e:	d004      	beq.n	8003d9a <test_terminate_threads+0xba>
 8003d90:	699d      	ldr	r5, [r3, #24]
 8003d92:	6890      	ldr	r0, [r2, #8]
 8003d94:	68a9      	ldr	r1, [r5, #8]
 8003d96:	4281      	cmp	r1, r0
 8003d98:	d318      	bcc.n	8003dcc <test_terminate_threads+0xec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d9a:	b662      	cpsie	i
 8003d9c:	6924      	ldr	r4, [r4, #16]
 8003d9e:	2c00      	cmp	r4, #0
 8003da0:	d013      	beq.n	8003dca <test_terminate_threads+0xea>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003da2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003da4:	f7ff fe7c 	bl	8003aa0 <_dbg_check_lock>
 8003da8:	2321      	movs	r3, #33	; 0x21
 8003daa:	5ce5      	ldrb	r5, [r4, r3]
 8003dac:	2204      	movs	r2, #4
 8003dae:	432a      	orrs	r2, r5
 8003db0:	54e2      	strb	r2, [r4, r3]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003db2:	f7ff fddd 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003db6:	4b08      	ldr	r3, [pc, #32]	; (8003dd8 <test_terminate_threads+0xf8>)
 8003db8:	6818      	ldr	r0, [r3, #0]
 8003dba:	4298      	cmp	r0, r3
 8003dbc:	d004      	beq.n	8003dc8 <test_terminate_threads+0xe8>
 8003dbe:	6999      	ldr	r1, [r3, #24]
 8003dc0:	6885      	ldr	r5, [r0, #8]
 8003dc2:	688c      	ldr	r4, [r1, #8]
 8003dc4:	42ac      	cmp	r4, r5
 8003dc6:	d301      	bcc.n	8003dcc <test_terminate_threads+0xec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003dc8:	b662      	cpsie	i
      chThdTerminate(threads[i]);
}
 8003dca:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003dcc:	b672      	cpsid	i
 8003dce:	4a03      	ldr	r2, [pc, #12]	; (8003ddc <test_terminate_threads+0xfc>)
 8003dd0:	62da      	str	r2, [r3, #44]	; 0x2c
 8003dd2:	e7fe      	b.n	8003dd2 <test_terminate_threads+0xf2>
 8003dd4:	200015b8 	.word	0x200015b8
 8003dd8:	20001040 	.word	0x20001040
 8003ddc:	08008b00 	.word	0x08008b00

08003de0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003de0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003de2:	4645      	mov	r5, r8
 8003de4:	4688      	mov	r8, r1
  qnotify_t nfy = oqp->q_notify;
 8003de6:	69c1      	ldr	r1, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003de8:	4657      	mov	r7, sl
 8003dea:	464e      	mov	r6, r9
 8003dec:	b4e0      	push	{r5, r6, r7}
 8003dee:	1c04      	adds	r4, r0, #0
 8003df0:	1c16      	adds	r6, r2, #0
 8003df2:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8003df4:	4689      	mov	r9, r1
 8003df6:	b672      	cpsid	i
  size_t w = 0;

  chDbgCheck(n > 0U);
 8003df8:	2a00      	cmp	r2, #0
 8003dfa:	d04f      	beq.n	8003e9c <chOQWriteTimeout+0xbc>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003dfc:	f7ff fe50 	bl	8003aa0 <_dbg_check_lock>
 8003e00:	4d2a      	ldr	r5, [pc, #168]	; (8003eac <chOQWriteTimeout+0xcc>)
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8003e02:	2700      	movs	r7, #0
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8003e04:	f7fc fc34 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8003e08:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003e0a:	2b00      	cmp	r3, #0
 8003e0c:	d02b      	beq.n	8003e66 <chOQWriteTimeout+0x86>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003e0e:	68a0      	ldr	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8003e10:	4642      	mov	r2, r8
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003e12:	3801      	subs	r0, #1
 8003e14:	60a0      	str	r0, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8003e16:	6963      	ldr	r3, [r4, #20]
 8003e18:	7811      	ldrb	r1, [r2, #0]
 8003e1a:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8003e1c:	6920      	ldr	r0, [r4, #16]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8003e1e:	3301      	adds	r3, #1
 8003e20:	6163      	str	r3, [r4, #20]
    if (oqp->q_wrptr >= oqp->q_top) {
 8003e22:	4283      	cmp	r3, r0
 8003e24:	d301      	bcc.n	8003e2a <chOQWriteTimeout+0x4a>
      oqp->q_wrptr = oqp->q_buffer;
 8003e26:	68e3      	ldr	r3, [r4, #12]
 8003e28:	6163      	str	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8003e2a:	464a      	mov	r2, r9
 8003e2c:	2a00      	cmp	r2, #0
 8003e2e:	d001      	beq.n	8003e34 <chOQWriteTimeout+0x54>
      nfy(oqp);
 8003e30:	1c20      	adds	r0, r4, #0
 8003e32:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003e34:	f7ff fd9c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003e38:	6828      	ldr	r0, [r5, #0]
 8003e3a:	42a8      	cmp	r0, r5
 8003e3c:	d004      	beq.n	8003e48 <chOQWriteTimeout+0x68>
 8003e3e:	69a9      	ldr	r1, [r5, #24]
 8003e40:	6883      	ldr	r3, [r0, #8]
 8003e42:	688a      	ldr	r2, [r1, #8]
 8003e44:	429a      	cmp	r2, r3
 8003e46:	d325      	bcc.n	8003e94 <chOQWriteTimeout+0xb4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003e48:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8003e4a:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8003e4c:	3701      	adds	r7, #1
    if (--n == 0U) {
 8003e4e:	2e00      	cmp	r6, #0
 8003e50:	d01a      	beq.n	8003e88 <chOQWriteTimeout+0xa8>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8003e52:	2001      	movs	r0, #1
 8003e54:	4480      	add	r8, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003e56:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003e58:	f7ff fe22 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8003e5c:	f7fc fc08 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8003e60:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003e62:	2b00      	cmp	r3, #0
 8003e64:	d1d3      	bne.n	8003e0e <chOQWriteTimeout+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8003e66:	1c20      	adds	r0, r4, #0
 8003e68:	4651      	mov	r1, sl
 8003e6a:	f7fd f909 	bl	8001080 <chThdEnqueueTimeoutS>
 8003e6e:	2800      	cmp	r0, #0
 8003e70:	d0c8      	beq.n	8003e04 <chOQWriteTimeout+0x24>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003e72:	f7ff fd7d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003e76:	6829      	ldr	r1, [r5, #0]
 8003e78:	42a9      	cmp	r1, r5
 8003e7a:	d004      	beq.n	8003e86 <chOQWriteTimeout+0xa6>
 8003e7c:	69aa      	ldr	r2, [r5, #24]
 8003e7e:	688b      	ldr	r3, [r1, #8]
 8003e80:	6890      	ldr	r0, [r2, #8]
 8003e82:	4298      	cmp	r0, r3
 8003e84:	d30e      	bcc.n	8003ea4 <chOQWriteTimeout+0xc4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003e86:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8003e88:	1c38      	adds	r0, r7, #0
 8003e8a:	bc1c      	pop	{r2, r3, r4}
 8003e8c:	4690      	mov	r8, r2
 8003e8e:	4699      	mov	r9, r3
 8003e90:	46a2      	mov	sl, r4
 8003e92:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003e94:	b672      	cpsid	i
 8003e96:	4c06      	ldr	r4, [pc, #24]	; (8003eb0 <chOQWriteTimeout+0xd0>)
 8003e98:	62ec      	str	r4, [r5, #44]	; 0x2c
 8003e9a:	e7fe      	b.n	8003e9a <chOQWriteTimeout+0xba>
 8003e9c:	4d05      	ldr	r5, [pc, #20]	; (8003eb4 <chOQWriteTimeout+0xd4>)
 8003e9e:	4e03      	ldr	r6, [pc, #12]	; (8003eac <chOQWriteTimeout+0xcc>)
 8003ea0:	62f5      	str	r5, [r6, #44]	; 0x2c
 8003ea2:	e7fe      	b.n	8003ea2 <chOQWriteTimeout+0xc2>
 8003ea4:	b672      	cpsid	i
 8003ea6:	4c02      	ldr	r4, [pc, #8]	; (8003eb0 <chOQWriteTimeout+0xd0>)
 8003ea8:	62ec      	str	r4, [r5, #44]	; 0x2c
 8003eaa:	e7fe      	b.n	8003eaa <chOQWriteTimeout+0xca>
 8003eac:	20001040 	.word	0x20001040
 8003eb0:	08008ad0 	.word	0x08008ad0
 8003eb4:	080088d0 	.word	0x080088d0
 8003eb8:	46c0      	nop			; (mov r8, r8)
 8003eba:	46c0      	nop			; (mov r8, r8)
 8003ebc:	46c0      	nop			; (mov r8, r8)
 8003ebe:	46c0      	nop			; (mov r8, r8)

08003ec0 <writet.7860>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8003ec0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003ec2:	3030      	adds	r0, #48	; 0x30
 8003ec4:	f7ff ff8c 	bl	8003de0 <chOQWriteTimeout>
}
 8003ec8:	bd08      	pop	{r3, pc}
 8003eca:	46c0      	nop			; (mov r8, r8)
 8003ecc:	46c0      	nop			; (mov r8, r8)
 8003ece:	46c0      	nop			; (mov r8, r8)

08003ed0 <write.7866>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8003ed0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8003ed2:	2301      	movs	r3, #1
 8003ed4:	3030      	adds	r0, #48	; 0x30
 8003ed6:	425b      	negs	r3, r3
 8003ed8:	f7ff ff82 	bl	8003de0 <chOQWriteTimeout>
                        n, TIME_INFINITE);
}
 8003edc:	bd08      	pop	{r3, pc}
 8003ede:	46c0      	nop			; (mov r8, r8)

08003ee0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8003ee0:	b570      	push	{r4, r5, r6, lr}
 8003ee2:	1c05      	adds	r5, r0, #0
 8003ee4:	b672      	cpsid	i
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 8003ee6:	287f      	cmp	r0, #127	; 0x7f
 8003ee8:	d81e      	bhi.n	8003f28 <chThdSetPriority+0x48>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003eea:	f7ff fdd9 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 8003eee:	4c10      	ldr	r4, [pc, #64]	; (8003f30 <chThdSetPriority+0x50>)
 8003ef0:	69a3      	ldr	r3, [r4, #24]
 8003ef2:	6c1e      	ldr	r6, [r3, #64]	; 0x40
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8003ef4:	689a      	ldr	r2, [r3, #8]
 8003ef6:	4296      	cmp	r6, r2
 8003ef8:	d001      	beq.n	8003efe <chThdSetPriority+0x1e>
 8003efa:	4295      	cmp	r5, r2
 8003efc:	d900      	bls.n	8003f00 <chThdSetPriority+0x20>
    currp->p_prio = newprio;
 8003efe:	609d      	str	r5, [r3, #8]
  }
  currp->p_realprio = newprio;
 8003f00:	641d      	str	r5, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 8003f02:	f7ff fabd 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003f06:	f7ff fd33 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003f0a:	6820      	ldr	r0, [r4, #0]
 8003f0c:	42a0      	cmp	r0, r4
 8003f0e:	d004      	beq.n	8003f1a <chThdSetPriority+0x3a>
 8003f10:	69a1      	ldr	r1, [r4, #24]
 8003f12:	6883      	ldr	r3, [r0, #8]
 8003f14:	688d      	ldr	r5, [r1, #8]
 8003f16:	429d      	cmp	r5, r3
 8003f18:	d302      	bcc.n	8003f20 <chThdSetPriority+0x40>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003f1a:	b662      	cpsie	i
  chSysUnlock();

  return oldprio;
}
 8003f1c:	1c30      	adds	r0, r6, #0
 8003f1e:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f20:	b672      	cpsid	i
 8003f22:	4e04      	ldr	r6, [pc, #16]	; (8003f34 <chThdSetPriority+0x54>)
 8003f24:	62e6      	str	r6, [r4, #44]	; 0x2c
 8003f26:	e7fe      	b.n	8003f26 <chThdSetPriority+0x46>
 8003f28:	4c03      	ldr	r4, [pc, #12]	; (8003f38 <chThdSetPriority+0x58>)
 8003f2a:	4a01      	ldr	r2, [pc, #4]	; (8003f30 <chThdSetPriority+0x50>)
 8003f2c:	62d4      	str	r4, [r2, #44]	; 0x2c
 8003f2e:	e7fe      	b.n	8003f2e <chThdSetPriority+0x4e>
 8003f30:	20001040 	.word	0x20001040
 8003f34:	08008b00 	.word	0x08008b00
 8003f38:	08008930 	.word	0x08008930
 8003f3c:	46c0      	nop			; (mov r8, r8)
 8003f3e:	46c0      	nop			; (mov r8, r8)

08003f40 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 8003f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8003f42:	4d1a      	ldr	r5, [pc, #104]	; (8003fac <chMtxUnlockAll+0x6c>)
 8003f44:	69ae      	ldr	r6, [r5, #24]
 8003f46:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003f48:	f7ff fdaa 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 8003f4c:	6bf4      	ldr	r4, [r6, #60]	; 0x3c
 8003f4e:	2c00      	cmp	r4, #0
 8003f50:	d01c      	beq.n	8003f8c <chMtxUnlockAll+0x4c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8003f52:	2700      	movs	r7, #0
 8003f54:	e003      	b.n	8003f5e <chMtxUnlockAll+0x1e>
 8003f56:	60a7      	str	r7, [r4, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 8003f58:	6bf4      	ldr	r4, [r6, #60]	; 0x3c
 8003f5a:	2c00      	cmp	r4, #0
 8003f5c:	d012      	beq.n	8003f84 <chMtxUnlockAll+0x44>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 8003f5e:	68e3      	ldr	r3, [r4, #12]
 8003f60:	63f3      	str	r3, [r6, #60]	; 0x3c
 8003f62:	f7fc fc75 	bl	8000850 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003f66:	6820      	ldr	r0, [r4, #0]
      if (chMtxQueueNotEmptyS(mp)) {
 8003f68:	4284      	cmp	r4, r0
 8003f6a:	d0f4      	beq.n	8003f56 <chMtxUnlockAll+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003f6c:	6801      	ldr	r1, [r0, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 8003f6e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8003f70:	6021      	str	r1, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003f72:	604c      	str	r4, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 8003f74:	60a0      	str	r0, [r4, #8]
        mp->m_next = tp->p_mtxlist;
 8003f76:	60e2      	str	r2, [r4, #12]
        tp->p_mtxlist = mp;
 8003f78:	63c4      	str	r4, [r0, #60]	; 0x3c
        (void) chSchReadyI(tp);
 8003f7a:	f7fc fbd9 	bl	8000730 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 8003f7e:	6bf4      	ldr	r4, [r6, #60]	; 0x3c
 8003f80:	2c00      	cmp	r4, #0
 8003f82:	d1ec      	bne.n	8003f5e <chMtxUnlockAll+0x1e>
    ctp->p_prio = ctp->p_realprio;
 8003f84:	6c30      	ldr	r0, [r6, #64]	; 0x40
 8003f86:	60b0      	str	r0, [r6, #8]
    chSchRescheduleS();
 8003f88:	f7ff fa7a 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003f8c:	f7ff fcf0 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003f90:	682e      	ldr	r6, [r5, #0]
 8003f92:	42ae      	cmp	r6, r5
 8003f94:	d004      	beq.n	8003fa0 <chMtxUnlockAll+0x60>
 8003f96:	69af      	ldr	r7, [r5, #24]
 8003f98:	68b3      	ldr	r3, [r6, #8]
 8003f9a:	68b9      	ldr	r1, [r7, #8]
 8003f9c:	4299      	cmp	r1, r3
 8003f9e:	d301      	bcc.n	8003fa4 <chMtxUnlockAll+0x64>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003fa0:	b662      	cpsie	i
  }
  chSysUnlock();
}
 8003fa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003fa4:	b672      	cpsid	i
 8003fa6:	4a02      	ldr	r2, [pc, #8]	; (8003fb0 <chMtxUnlockAll+0x70>)
 8003fa8:	62ea      	str	r2, [r5, #44]	; 0x2c
 8003faa:	e7fe      	b.n	8003faa <chMtxUnlockAll+0x6a>
 8003fac:	20001040 	.word	0x20001040
 8003fb0:	080089f0 	.word	0x080089f0
 8003fb4:	46c0      	nop			; (mov r8, r8)
 8003fb6:	46c0      	nop			; (mov r8, r8)
 8003fb8:	46c0      	nop			; (mov r8, r8)
 8003fba:	46c0      	nop			; (mov r8, r8)
 8003fbc:	46c0      	nop			; (mov r8, r8)
 8003fbe:	46c0      	nop			; (mov r8, r8)

08003fc0 <chCondSignal.constprop.62>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8003fc0:	b508      	push	{r3, lr}
 8003fc2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003fc4:	f7ff fd6c 	bl	8003aa0 <_dbg_check_lock>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003fc8:	4b0d      	ldr	r3, [pc, #52]	; (8004000 <chCondSignal.constprop.62+0x40>)
 8003fca:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 8003fcc:	4298      	cmp	r0, r3
 8003fce:	d005      	beq.n	8003fdc <chCondSignal.constprop.62+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003fd0:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8003fd2:	2100      	movs	r1, #0
 8003fd4:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003fd6:	6053      	str	r3, [r2, #4]
 8003fd8:	f7fc ff3a 	bl	8000e50 <chSchWakeupS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003fdc:	f7ff fcc8 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003fe0:	4808      	ldr	r0, [pc, #32]	; (8004004 <chCondSignal.constprop.62+0x44>)
 8003fe2:	6803      	ldr	r3, [r0, #0]
 8003fe4:	4283      	cmp	r3, r0
 8003fe6:	d004      	beq.n	8003ff2 <chCondSignal.constprop.62+0x32>
 8003fe8:	6981      	ldr	r1, [r0, #24]
 8003fea:	689a      	ldr	r2, [r3, #8]
 8003fec:	6889      	ldr	r1, [r1, #8]
 8003fee:	4291      	cmp	r1, r2
 8003ff0:	d301      	bcc.n	8003ff6 <chCondSignal.constprop.62+0x36>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ff2:	b662      	cpsie	i
  }
  chSysUnlock();
}
 8003ff4:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ff6:	b672      	cpsid	i
 8003ff8:	4b03      	ldr	r3, [pc, #12]	; (8004008 <chCondSignal.constprop.62+0x48>)
 8003ffa:	62c3      	str	r3, [r0, #44]	; 0x2c
 8003ffc:	e7fe      	b.n	8003ffc <chCondSignal.constprop.62+0x3c>
 8003ffe:	46c0      	nop			; (mov r8, r8)
 8004000:	20000670 	.word	0x20000670
 8004004:	20001040 	.word	0x20001040
 8004008:	08008990 	.word	0x08008990
 800400c:	46c0      	nop			; (mov r8, r8)
 800400e:	46c0      	nop			; (mov r8, r8)

08004010 <chEvtWaitAny.constprop.48>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8004010:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8004012:	4b0b      	ldr	r3, [pc, #44]	; (8004040 <chEvtWaitAny.constprop.48+0x30>)
 8004014:	699c      	ldr	r4, [r3, #24]
 8004016:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004018:	f7ff fd42 	bl	8003aa0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800401c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  if (m == (eventmask_t)0) {
 800401e:	2d00      	cmp	r5, #0
 8004020:	d106      	bne.n	8004030 <chEvtWaitAny.constprop.48+0x20>
    ctp->p_u.ewmask = events;
 8004022:	2001      	movs	r0, #1
 8004024:	4241      	negs	r1, r0
 8004026:	6261      	str	r1, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8004028:	200a      	movs	r0, #10
 800402a:	f7fc ff51 	bl	8000ed0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800402e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  }
  ctp->p_epending &= ~m;
 8004030:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8004032:	43aa      	bics	r2, r5
 8004034:	63a2      	str	r2, [r4, #56]	; 0x38
  chSysUnlock();
 8004036:	f7ff fcd3 	bl	80039e0 <chSysUnlock.6142>

  return m;
}
 800403a:	1c28      	adds	r0, r5, #0
 800403c:	bd38      	pop	{r3, r4, r5, pc}
 800403e:	46c0      	nop			; (mov r8, r8)
 8004040:	20001040 	.word	0x20001040
	...

08004050 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8004050:	b570      	push	{r4, r5, r6, lr}
 8004052:	b672      	cpsid	i
 8004054:	f7ff fd24 	bl	8003aa0 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8004058:	4c13      	ldr	r4, [pc, #76]	; (80040a8 <chMsgWait+0x58>)
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();
 800405a:	f7fc fb09 	bl	8000670 <chDbgCheckClassI>
 800405e:	69a5      	ldr	r5, [r4, #24]

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8004060:	1c2b      	adds	r3, r5, #0
 8004062:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 8004064:	332c      	adds	r3, #44	; 0x2c
 8004066:	429e      	cmp	r6, r3
 8004068:	d106      	bne.n	8004078 <chMsgWait+0x28>
    chSchGoSleepS(CH_STATE_WTMSG);
 800406a:	200e      	movs	r0, #14
 800406c:	f7fc ff30 	bl	8000ed0 <chSchGoSleepS>
 8004070:	69a5      	ldr	r5, [r4, #24]
 8004072:	1c2b      	adds	r3, r5, #0
 8004074:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 8004076:	332c      	adds	r3, #44	; 0x2c
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8004078:	6832      	ldr	r2, [r6, #0]
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 800407a:	200d      	movs	r0, #13
 800407c:	2120      	movs	r1, #32
 800407e:	62ea      	str	r2, [r5, #44]	; 0x2c
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004080:	6053      	str	r3, [r2, #4]
 8004082:	5470      	strb	r0, [r6, r1]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004084:	f7ff fc74 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004088:	6825      	ldr	r5, [r4, #0]
 800408a:	42a5      	cmp	r5, r4
 800408c:	d004      	beq.n	8004098 <chMsgWait+0x48>
 800408e:	69a3      	ldr	r3, [r4, #24]
 8004090:	68a8      	ldr	r0, [r5, #8]
 8004092:	689a      	ldr	r2, [r3, #8]
 8004094:	4282      	cmp	r2, r0
 8004096:	d302      	bcc.n	800409e <chMsgWait+0x4e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004098:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800409a:	1c30      	adds	r0, r6, #0
 800409c:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800409e:	b672      	cpsid	i
 80040a0:	4e02      	ldr	r6, [pc, #8]	; (80040ac <chMsgWait+0x5c>)
 80040a2:	62e6      	str	r6, [r4, #44]	; 0x2c
 80040a4:	e7fe      	b.n	80040a4 <chMsgWait+0x54>
 80040a6:	46c0      	nop			; (mov r8, r8)
 80040a8:	20001040 	.word	0x20001040
 80040ac:	08008970 	.word	0x08008970

080040b0 <thread2.10793>:

  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 80040b0:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 80040b2:	f7ff ffcd 	bl	8004050 <chMsgWait>
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {

  return tp->p_msg;
 80040b6:	6b44      	ldr	r4, [r0, #52]	; 0x34
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
 80040b8:	1c21      	adds	r1, r4, #0
 80040ba:	f7ff fd99 	bl	8003bf0 <chMsgRelease>
  } while (msg);
 80040be:	2c00      	cmp	r4, #0
 80040c0:	d1f7      	bne.n	80040b2 <thread2.10793+0x2>
}
 80040c2:	bd10      	pop	{r4, pc}
 80040c4:	46c0      	nop			; (mov r8, r8)
 80040c6:	46c0      	nop			; (mov r8, r8)
 80040c8:	46c0      	nop			; (mov r8, r8)
 80040ca:	46c0      	nop			; (mov r8, r8)
 80040cc:	46c0      	nop			; (mov r8, r8)
 80040ce:	46c0      	nop			; (mov r8, r8)

080040d0 <chMBFetch.constprop.30>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 80040d0:	b570      	push	{r4, r5, r6, lr}
 80040d2:	1c05      	adds	r5, r0, #0
 80040d4:	1c0c      	adds	r4, r1, #0
 80040d6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80040d8:	f7ff fce2 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 80040dc:	f7fc fbb8 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 80040e0:	2d00      	cmp	r5, #0
 80040e2:	d104      	bne.n	80040ee <chMBFetch.constprop.30+0x1e>
 80040e4:	b672      	cpsid	i
 80040e6:	4e0f      	ldr	r6, [pc, #60]	; (8004124 <chMBFetch.constprop.30+0x54>)
 80040e8:	4c0f      	ldr	r4, [pc, #60]	; (8004128 <chMBFetch.constprop.30+0x58>)
 80040ea:	62e6      	str	r6, [r4, #44]	; 0x2c
 80040ec:	e7fe      	b.n	80040ec <chMBFetch.constprop.30+0x1c>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 80040ee:	4e0f      	ldr	r6, [pc, #60]	; (800412c <chMBFetch.constprop.30+0x5c>)
 80040f0:	1c21      	adds	r1, r4, #0
 80040f2:	1c30      	adds	r0, r6, #0
 80040f4:	f7ff fa24 	bl	8003540 <chSemWaitTimeoutS>
 80040f8:	1e04      	subs	r4, r0, #0
  if (rdymsg == MSG_OK) {
 80040fa:	d10f      	bne.n	800411c <chMBFetch.constprop.30+0x4c>
    *msgp = *mbp->mb_rdptr++;
 80040fc:	1c33      	adds	r3, r6, #0
 80040fe:	3b10      	subs	r3, #16
 8004100:	68da      	ldr	r2, [r3, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8004102:	6858      	ldr	r0, [r3, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8004104:	ca02      	ldmia	r2!, {r1}
 8004106:	6029      	str	r1, [r5, #0]
 8004108:	60da      	str	r2, [r3, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 800410a:	4282      	cmp	r2, r0
 800410c:	d301      	bcc.n	8004112 <chMBFetch.constprop.30+0x42>
      mbp->mb_rdptr = mbp->mb_buffer;
 800410e:	681d      	ldr	r5, [r3, #0]
 8004110:	60dd      	str	r5, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8004112:	4807      	ldr	r0, [pc, #28]	; (8004130 <chMBFetch.constprop.30+0x60>)
 8004114:	f7ff fa4c 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 8004118:	f7ff f9b2 	bl	8003480 <chSchRescheduleS>
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();
 800411c:	f7ff fc78 	bl	8003a10 <chSysUnlock.6509>

  return rdymsg;
}
 8004120:	1c20      	adds	r0, r4, #0
 8004122:	bd70      	pop	{r4, r5, r6, pc}
 8004124:	08008950 	.word	0x08008950
 8004128:	20001040 	.word	0x20001040
 800412c:	20000610 	.word	0x20000610
 8004130:	2000061c 	.word	0x2000061c
	...

08004140 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8004140:	b510      	push	{r4, lr}
 8004142:	1c04      	adds	r4, r0, #0
 8004144:	b672      	cpsid	i
 8004146:	f7ff fcab 	bl	8003aa0 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();
 800414a:	f7fc fa91 	bl	8000670 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800414e:	4910      	ldr	r1, [pc, #64]	; (8004190 <chCoreAlloc+0x50>)
 8004150:	4810      	ldr	r0, [pc, #64]	; (8004194 <chCoreAlloc+0x54>)
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8004152:	1de2      	adds	r2, r4, #7
 8004154:	2307      	movs	r3, #7
 8004156:	439a      	bics	r2, r3
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8004158:	6804      	ldr	r4, [r0, #0]
 800415a:	680b      	ldr	r3, [r1, #0]
 800415c:	1b19      	subs	r1, r3, r4
 800415e:	428a      	cmp	r2, r1
 8004160:	d813      	bhi.n	800418a <chCoreAlloc+0x4a>
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8004162:	18a2      	adds	r2, r4, r2
 8004164:	6002      	str	r2, [r0, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004166:	f7ff fc03 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800416a:	480b      	ldr	r0, [pc, #44]	; (8004198 <chCoreAlloc+0x58>)
 800416c:	6803      	ldr	r3, [r0, #0]
 800416e:	4283      	cmp	r3, r0
 8004170:	d004      	beq.n	800417c <chCoreAlloc+0x3c>
 8004172:	6981      	ldr	r1, [r0, #24]
 8004174:	689a      	ldr	r2, [r3, #8]
 8004176:	6889      	ldr	r1, [r1, #8]
 8004178:	4291      	cmp	r1, r2
 800417a:	d302      	bcc.n	8004182 <chCoreAlloc+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800417c:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800417e:	1c20      	adds	r0, r4, #0
 8004180:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004182:	b672      	cpsid	i
 8004184:	4c05      	ldr	r4, [pc, #20]	; (800419c <chCoreAlloc+0x5c>)
 8004186:	62c4      	str	r4, [r0, #44]	; 0x2c
 8004188:	e7fe      	b.n	8004188 <chCoreAlloc+0x48>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800418a:	2400      	movs	r4, #0
 800418c:	e7eb      	b.n	8004166 <chCoreAlloc+0x26>
 800418e:	46c0      	nop			; (mov r8, r8)
 8004190:	20000fa8 	.word	0x20000fa8
 8004194:	20000fac 	.word	0x20000fac
 8004198:	20001040 	.word	0x20001040
 800419c:	080088c0 	.word	0x080088c0

080041a0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 80041a0:	b538      	push	{r3, r4, r5, lr}
 80041a2:	1c04      	adds	r4, r0, #0
 80041a4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80041a6:	f7ff fc7b 	bl	8003aa0 <_dbg_check_lock>
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
  void *objp;

  chDbgCheckClassI();
 80041aa:	f7fc fa61 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 80041ae:	2c00      	cmp	r4, #0
 80041b0:	d01d      	beq.n	80041ee <chPoolAlloc+0x4e>

  objp = mp->mp_next;
 80041b2:	6825      	ldr	r5, [r4, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80041b4:	2d00      	cmp	r5, #0
 80041b6:	d00f      	beq.n	80041d8 <chPoolAlloc+0x38>
    mp->mp_next = mp->mp_next->ph_next;
 80041b8:	6828      	ldr	r0, [r5, #0]
 80041ba:	6020      	str	r0, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80041bc:	f7ff fbd8 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80041c0:	4c0d      	ldr	r4, [pc, #52]	; (80041f8 <chPoolAlloc+0x58>)
 80041c2:	6822      	ldr	r2, [r4, #0]
 80041c4:	42a2      	cmp	r2, r4
 80041c6:	d004      	beq.n	80041d2 <chPoolAlloc+0x32>
 80041c8:	69a1      	ldr	r1, [r4, #24]
 80041ca:	6890      	ldr	r0, [r2, #8]
 80041cc:	688b      	ldr	r3, [r1, #8]
 80041ce:	4283      	cmp	r3, r0
 80041d0:	d309      	bcc.n	80041e6 <chPoolAlloc+0x46>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80041d2:	b662      	cpsie	i
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 80041d4:	1c28      	adds	r0, r5, #0
 80041d6:	bd38      	pop	{r3, r4, r5, pc}
  objp = mp->mp_next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 80041d8:	68a3      	ldr	r3, [r4, #8]
 80041da:	2b00      	cmp	r3, #0
 80041dc:	d0ee      	beq.n	80041bc <chPoolAlloc+0x1c>
    objp = mp->mp_provider(mp->mp_object_size);
 80041de:	6860      	ldr	r0, [r4, #4]
 80041e0:	4798      	blx	r3
 80041e2:	1c05      	adds	r5, r0, #0
 80041e4:	e7ea      	b.n	80041bc <chPoolAlloc+0x1c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80041e6:	b672      	cpsid	i
 80041e8:	4d04      	ldr	r5, [pc, #16]	; (80041fc <chPoolAlloc+0x5c>)
 80041ea:	62e5      	str	r5, [r4, #44]	; 0x2c
 80041ec:	e7fe      	b.n	80041ec <chPoolAlloc+0x4c>
 80041ee:	b672      	cpsid	i
 80041f0:	4c03      	ldr	r4, [pc, #12]	; (8004200 <chPoolAlloc+0x60>)
 80041f2:	4a01      	ldr	r2, [pc, #4]	; (80041f8 <chPoolAlloc+0x58>)
 80041f4:	62d4      	str	r4, [r2, #44]	; 0x2c
 80041f6:	e7fe      	b.n	80041f6 <chPoolAlloc+0x56>
 80041f8:	20001040 	.word	0x20001040
 80041fc:	08008980 	.word	0x08008980
 8004200:	080088b0 	.word	0x080088b0
 8004204:	46c0      	nop			; (mov r8, r8)
 8004206:	46c0      	nop			; (mov r8, r8)
 8004208:	46c0      	nop			; (mov r8, r8)
 800420a:	46c0      	nop			; (mov r8, r8)
 800420c:	46c0      	nop			; (mov r8, r8)
 800420e:	46c0      	nop			; (mov r8, r8)

08004210 <chVTGetSystemTime.9780>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8004210:	b510      	push	{r4, lr}
 8004212:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004214:	f7ff fc44 	bl	8003aa0 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004218:	2380      	movs	r3, #128	; 0x80
 800421a:	05d8      	lsls	r0, r3, #23
 800421c:	6a44      	ldr	r4, [r0, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800421e:	f7ff fba7 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004222:	4b08      	ldr	r3, [pc, #32]	; (8004244 <chVTGetSystemTime.9780+0x34>)
 8004224:	681a      	ldr	r2, [r3, #0]
 8004226:	429a      	cmp	r2, r3
 8004228:	d004      	beq.n	8004234 <chVTGetSystemTime.9780+0x24>
 800422a:	6999      	ldr	r1, [r3, #24]
 800422c:	6892      	ldr	r2, [r2, #8]
 800422e:	6888      	ldr	r0, [r1, #8]
 8004230:	4290      	cmp	r0, r2
 8004232:	d302      	bcc.n	800423a <chVTGetSystemTime.9780+0x2a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004234:	b662      	cpsie	i
  chSysLock();
  systime = chVTGetSystemTimeX();
  chSysUnlock();

  return systime;
}
 8004236:	1c20      	adds	r0, r4, #0
 8004238:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800423a:	b672      	cpsid	i
 800423c:	4c02      	ldr	r4, [pc, #8]	; (8004248 <chVTGetSystemTime.9780+0x38>)
 800423e:	62dc      	str	r4, [r3, #44]	; 0x2c
 8004240:	e7fe      	b.n	8004240 <chVTGetSystemTime.9780+0x30>
 8004242:	46c0      	nop			; (mov r8, r8)
 8004244:	20001040 	.word	0x20001040
 8004248:	08008b70 	.word	0x08008b70
 800424c:	46c0      	nop			; (mov r8, r8)
 800424e:	46c0      	nop			; (mov r8, r8)

08004250 <thread4.10790>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8004250:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004252:	4c0d      	ldr	r4, [pc, #52]	; (8004288 <thread4.10790+0x38>)
 8004254:	69a5      	ldr	r5, [r4, #24]
 8004256:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004258:	f7ff fc22 	bl	8003aa0 <_dbg_check_lock>
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800425c:	2003      	movs	r0, #3
 800425e:	f7fc fe37 	bl	8000ed0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 8004262:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004264:	2b00      	cmp	r3, #0
 8004266:	d0f9      	beq.n	800425c <thread4.10790+0xc>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004268:	f7ff fb82 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800426c:	6820      	ldr	r0, [r4, #0]
 800426e:	42a0      	cmp	r0, r4
 8004270:	d004      	beq.n	800427c <thread4.10790+0x2c>
 8004272:	69a2      	ldr	r2, [r4, #24]
 8004274:	6885      	ldr	r5, [r0, #8]
 8004276:	6891      	ldr	r1, [r2, #8]
 8004278:	42a9      	cmp	r1, r5
 800427a:	d301      	bcc.n	8004280 <thread4.10790+0x30>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800427c:	b662      	cpsie	i
  chSysUnlock();
}
 800427e:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004280:	b672      	cpsid	i
 8004282:	4b02      	ldr	r3, [pc, #8]	; (800428c <thread4.10790+0x3c>)
 8004284:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004286:	e7fe      	b.n	8004286 <thread4.10790+0x36>
 8004288:	20001040 	.word	0x20001040
 800428c:	08008ab0 	.word	0x08008ab0

08004290 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 8004290:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8004292:	f3ef 8410 	mrs	r4, PRIMASK

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8004296:	07e3      	lsls	r3, r4, #31
 8004298:	d407      	bmi.n	80042aa <chSysGetStatusAndLockX+0x1a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800429a:	f3ef 8305 	mrs	r3, IPSR
 800429e:	05d8      	lsls	r0, r3, #23
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042a0:	b672      	cpsid	i
    if (port_is_isr_context()) {
 80042a2:	2800      	cmp	r0, #0
 80042a4:	d103      	bne.n	80042ae <chSysGetStatusAndLockX+0x1e>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80042a6:	f7ff fbfb 	bl	8003aa0 <_dbg_check_lock>
    else {
      chSysLock();
    }
  }
  return sts;
}
 80042aa:	1c20      	adds	r0, r4, #0
 80042ac:	bd10      	pop	{r4, pc}
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80042ae:	f7fc f97f 	bl	80005b0 <_dbg_check_lock_from_isr>
 80042b2:	e7fa      	b.n	80042aa <chSysGetStatusAndLockX+0x1a>
 80042b4:	46c0      	nop			; (mov r8, r8)
 80042b6:	46c0      	nop			; (mov r8, r8)
 80042b8:	46c0      	nop			; (mov r8, r8)
 80042ba:	46c0      	nop			; (mov r8, r8)
 80042bc:	46c0      	nop			; (mov r8, r8)
 80042be:	46c0      	nop			; (mov r8, r8)

080042c0 <vtcb.10492>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 80042c0:	b508      	push	{r3, lr}
 80042c2:	b672      	cpsid	i
 80042c4:	f7fc f974 	bl	80005b0 <_dbg_check_lock_from_isr>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80042c8:	f7fc f98a 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042cc:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042ce:	b672      	cpsid	i
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80042d0:	f7fc f96e 	bl	80005b0 <_dbg_check_lock_from_isr>
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 80042d4:	f7ff ffdc 	bl	8004290 <chSysGetStatusAndLockX>
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 80042d8:	07c3      	lsls	r3, r0, #31
 80042da:	d401      	bmi.n	80042e0 <vtcb.10492+0x20>
 80042dc:	f7ff fb60 	bl	80039a0 <chSysRestoreStatusX.part.2.4280>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80042e0:	f7fc f97e 	bl	80005e0 <_dbg_check_unlock_from_isr>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042e4:	b662      	cpsie	i
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}
 80042e6:	bd08      	pop	{r3, pc}
 80042e8:	46c0      	nop			; (mov r8, r8)
 80042ea:	46c0      	nop			; (mov r8, r8)
 80042ec:	46c0      	nop			; (mov r8, r8)
 80042ee:	46c0      	nop			; (mov r8, r8)

080042f0 <chSysLock.9592>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80042f0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042f2:	b672      	cpsid	i

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80042f4:	f7ff fbd4 	bl	8003aa0 <_dbg_check_lock>
}
 80042f8:	bd08      	pop	{r3, pc}
 80042fa:	46c0      	nop			; (mov r8, r8)
 80042fc:	46c0      	nop			; (mov r8, r8)
 80042fe:	46c0      	nop			; (mov r8, r8)

08004300 <mtx8_execute.9239>:
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 8004300:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004302:	4b19      	ldr	r3, [pc, #100]	; (8004368 <mtx8_execute.9239+0x68>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004304:	4f19      	ldr	r7, [pc, #100]	; (800436c <mtx8_execute.9239+0x6c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004306:	6998      	ldr	r0, [r3, #24]
 8004308:	4c19      	ldr	r4, [pc, #100]	; (8004370 <mtx8_execute.9239+0x70>)
 800430a:	6886      	ldr	r6, [r0, #8]
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 800430c:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 800430e:	25a8      	movs	r5, #168	; 0xa8
 8004310:	0069      	lsls	r1, r5, #1
 8004312:	1c72      	adds	r2, r6, #1
 8004314:	9400      	str	r4, [sp, #0]
 8004316:	1c38      	adds	r0, r7, #0
 8004318:	4b16      	ldr	r3, [pc, #88]	; (8004374 <mtx8_execute.9239+0x74>)
 800431a:	f7fe fd99 	bl	8002e50 <chThdCreateStatic>
 800431e:	4c16      	ldr	r4, [pc, #88]	; (8004378 <mtx8_execute.9239+0x78>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004320:	4b16      	ldr	r3, [pc, #88]	; (800437c <mtx8_execute.9239+0x7c>)
 8004322:	22a8      	movs	r2, #168	; 0xa8
 8004324:	0055      	lsls	r5, r2, #1
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004326:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004328:	1cb2      	adds	r2, r6, #2
 800432a:	9300      	str	r3, [sp, #0]
 800432c:	1c29      	adds	r1, r5, #0
 800432e:	1978      	adds	r0, r7, r5
 8004330:	4b13      	ldr	r3, [pc, #76]	; (8004380 <mtx8_execute.9239+0x80>)
 8004332:	f7fe fd8d 	bl	8002e50 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8004336:	1cf2      	adds	r2, r6, #3

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004338:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800433a:	4e12      	ldr	r6, [pc, #72]	; (8004384 <mtx8_execute.9239+0x84>)
 800433c:	20a8      	movs	r0, #168	; 0xa8
 800433e:	0081      	lsls	r1, r0, #2
 8004340:	4b11      	ldr	r3, [pc, #68]	; (8004388 <mtx8_execute.9239+0x88>)
 8004342:	1878      	adds	r0, r7, r1
 8004344:	9600      	str	r6, [sp, #0]
 8004346:	1c29      	adds	r1, r5, #0
 8004348:	f7fe fd82 	bl	8002e50 <chThdCreateStatic>
 800434c:	60a0      	str	r0, [r4, #8]
  chCondSignal(&c1);
 800434e:	f7ff fe37 	bl	8003fc0 <chCondSignal.constprop.62>
  chCondSignal(&c1);
 8004352:	f7ff fe35 	bl	8003fc0 <chCondSignal.constprop.62>
  test_wait_threads();
 8004356:	f7fd fbeb 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 800435a:	490c      	ldr	r1, [pc, #48]	; (800438c <mtx8_execute.9239+0x8c>)
 800435c:	2001      	movs	r0, #1
 800435e:	f7fc fbaf 	bl	8000ac0 <_test_assert_sequence>
}
 8004362:	b003      	add	sp, #12
 8004364:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004366:	46c0      	nop			; (mov r8, r8)
 8004368:	20001040 	.word	0x20001040
 800436c:	200006b8 	.word	0x200006b8
 8004370:	08008698 	.word	0x08008698
 8004374:	08005251 	.word	0x08005251
 8004378:	200015b8 	.word	0x200015b8
 800437c:	080089a0 	.word	0x080089a0
 8004380:	080051a1 	.word	0x080051a1
 8004384:	080089a4 	.word	0x080089a4
 8004388:	08005161 	.word	0x08005161
 800438c:	08008708 	.word	0x08008708

08004390 <mtx1_execute.9261>:
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 8004390:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004392:	464f      	mov	r7, r9
 8004394:	4646      	mov	r6, r8
 8004396:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004398:	4a2f      	ldr	r2, [pc, #188]	; (8004458 <mtx1_execute.9261+0xc8>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 800439a:	4830      	ldr	r0, [pc, #192]	; (800445c <mtx1_execute.9261+0xcc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800439c:	6993      	ldr	r3, [r2, #24]
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 800439e:	b083      	sub	sp, #12
 80043a0:	689c      	ldr	r4, [r3, #8]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80043a2:	4690      	mov	r8, r2

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80043a4:	4681      	mov	r9, r0
 80043a6:	f7fe fa03 	bl	80027b0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80043aa:	4f2d      	ldr	r7, [pc, #180]	; (8004460 <mtx1_execute.9261+0xd0>)
 80043ac:	4e2d      	ldr	r6, [pc, #180]	; (8004464 <mtx1_execute.9261+0xd4>)
 80043ae:	492e      	ldr	r1, [pc, #184]	; (8004468 <mtx1_execute.9261+0xd8>)
 80043b0:	25a8      	movs	r5, #168	; 0xa8
 80043b2:	1c62      	adds	r2, r4, #1
 80043b4:	1c33      	adds	r3, r6, #0
 80043b6:	9100      	str	r1, [sp, #0]
 80043b8:	1c38      	adds	r0, r7, #0
 80043ba:	0069      	lsls	r1, r5, #1
 80043bc:	f7fe fd48 	bl	8002e50 <chThdCreateStatic>
 80043c0:	4d2a      	ldr	r5, [pc, #168]	; (800446c <mtx1_execute.9261+0xdc>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80043c2:	22a8      	movs	r2, #168	; 0xa8
 80043c4:	0053      	lsls	r3, r2, #1
 80043c6:	492a      	ldr	r1, [pc, #168]	; (8004470 <mtx1_execute.9261+0xe0>)

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80043c8:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80043ca:	18f8      	adds	r0, r7, r3
 80043cc:	23a8      	movs	r3, #168	; 0xa8
 80043ce:	1ca2      	adds	r2, r4, #2
 80043d0:	9100      	str	r1, [sp, #0]
 80043d2:	0059      	lsls	r1, r3, #1
 80043d4:	1c33      	adds	r3, r6, #0
 80043d6:	f7fe fd3b 	bl	8002e50 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80043da:	4926      	ldr	r1, [pc, #152]	; (8004474 <mtx1_execute.9261+0xe4>)
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80043dc:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80043de:	20a8      	movs	r0, #168	; 0xa8
 80043e0:	0082      	lsls	r2, r0, #2
 80043e2:	23a8      	movs	r3, #168	; 0xa8
 80043e4:	18b8      	adds	r0, r7, r2
 80043e6:	9100      	str	r1, [sp, #0]
 80043e8:	1ce2      	adds	r2, r4, #3
 80043ea:	0059      	lsls	r1, r3, #1
 80043ec:	1c33      	adds	r3, r6, #0
 80043ee:	f7fe fd2f 	bl	8002e50 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80043f2:	4921      	ldr	r1, [pc, #132]	; (8004478 <mtx1_execute.9261+0xe8>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80043f4:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80043f6:	20fc      	movs	r0, #252	; 0xfc
 80043f8:	0082      	lsls	r2, r0, #2
 80043fa:	23a8      	movs	r3, #168	; 0xa8
 80043fc:	18b8      	adds	r0, r7, r2
 80043fe:	9100      	str	r1, [sp, #0]
 8004400:	1d22      	adds	r2, r4, #4
 8004402:	0059      	lsls	r1, r3, #1
 8004404:	1c33      	adds	r3, r6, #0
 8004406:	f7fe fd23 	bl	8002e50 <chThdCreateStatic>
 800440a:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800440c:	20a8      	movs	r0, #168	; 0xa8
 800440e:	00c2      	lsls	r2, r0, #3
 8004410:	18b8      	adds	r0, r7, r2
 8004412:	4f1a      	ldr	r7, [pc, #104]	; (800447c <mtx1_execute.9261+0xec>)
 8004414:	21a8      	movs	r1, #168	; 0xa8
 8004416:	1c33      	adds	r3, r6, #0
 8004418:	1d62      	adds	r2, r4, #5
 800441a:	0049      	lsls	r1, r1, #1
 800441c:	9700      	str	r7, [sp, #0]
 800441e:	f7fe fd17 	bl	8002e50 <chThdCreateStatic>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004422:	4646      	mov	r6, r8
 8004424:	6128      	str	r0, [r5, #16]
  chMtxUnlock(&m1);
 8004426:	4648      	mov	r0, r9
 8004428:	f7fe f9e2 	bl	80027f0 <chMtxUnlock>
  test_wait_threads();
 800442c:	f7fd fb80 	bl	8001b30 <test_wait_threads>
 8004430:	69b5      	ldr	r5, [r6, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 8004432:	2001      	movs	r0, #1
 8004434:	68ab      	ldr	r3, [r5, #8]
 8004436:	1ae4      	subs	r4, r4, r3
 8004438:	4261      	negs	r1, r4
 800443a:	4161      	adcs	r1, r4
 800443c:	f7fc fb90 	bl	8000b60 <_test_assert>
 8004440:	2800      	cmp	r0, #0
 8004442:	d103      	bne.n	800444c <mtx1_execute.9261+0xbc>
  test_assert_sequence(2, "ABCDE");
 8004444:	2002      	movs	r0, #2
 8004446:	490e      	ldr	r1, [pc, #56]	; (8004480 <mtx1_execute.9261+0xf0>)
 8004448:	f7fc fb3a 	bl	8000ac0 <_test_assert_sequence>
}
 800444c:	b003      	add	sp, #12
 800444e:	bc0c      	pop	{r2, r3}
 8004450:	4690      	mov	r8, r2
 8004452:	4699      	mov	r9, r3
 8004454:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004456:	46c0      	nop			; (mov r8, r8)
 8004458:	20001040 	.word	0x20001040
 800445c:	20000694 	.word	0x20000694
 8004460:	200006b8 	.word	0x200006b8
 8004464:	08005181 	.word	0x08005181
 8004468:	080089b0 	.word	0x080089b0
 800446c:	200015b8 	.word	0x200015b8
 8004470:	080089a8 	.word	0x080089a8
 8004474:	080089a0 	.word	0x080089a0
 8004478:	080089a4 	.word	0x080089a4
 800447c:	08008698 	.word	0x08008698
 8004480:	080089ac 	.word	0x080089ac
 8004484:	46c0      	nop			; (mov r8, r8)
 8004486:	46c0      	nop			; (mov r8, r8)
 8004488:	46c0      	nop			; (mov r8, r8)
 800448a:	46c0      	nop			; (mov r8, r8)
 800448c:	46c0      	nop			; (mov r8, r8)
 800448e:	46c0      	nop			; (mov r8, r8)

08004490 <dyn1_execute.10186>:
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8004490:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004492:	4b2e      	ldr	r3, [pc, #184]	; (800454c <dyn1_execute.10186+0xbc>)
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8004494:	4d2e      	ldr	r5, [pc, #184]	; (8004550 <dyn1_execute.10186+0xc0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004496:	6998      	ldr	r0, [r3, #24]
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8004498:	b083      	sub	sp, #12
 800449a:	6886      	ldr	r6, [r0, #8]
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 800449c:	a901      	add	r1, sp, #4
 800449e:	1c28      	adds	r0, r5, #0
 80044a0:	f7fe face 	bl	8002a40 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 80044a4:	492b      	ldr	r1, [pc, #172]	; (8004554 <dyn1_execute.10186+0xc4>)
 80044a6:	1e70      	subs	r0, r6, #1
 80044a8:	f7fd fe82 	bl	80021b0 <chThdCreateFromHeap.constprop.71>
 80044ac:	4c2a      	ldr	r4, [pc, #168]	; (8004558 <dyn1_execute.10186+0xc8>)
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 80044ae:	492b      	ldr	r1, [pc, #172]	; (800455c <dyn1_execute.10186+0xcc>)
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 80044b0:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 80044b2:	1eb0      	subs	r0, r6, #2
 80044b4:	f7fd fe7c 	bl	80021b0 <chThdCreateFromHeap.constprop.71>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 80044b8:	4669      	mov	r1, sp
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 80044ba:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 80044bc:	1c28      	adds	r0, r5, #0
 80044be:	f7fe fabf 	bl	8002a40 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 80044c2:	9900      	ldr	r1, [sp, #0]
 80044c4:	1c28      	adds	r0, r5, #0
 80044c6:	f7fe fa1b 	bl	8002900 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 80044ca:	4925      	ldr	r1, [pc, #148]	; (8004560 <dyn1_execute.10186+0xd0>)
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 80044cc:	1c07      	adds	r7, r0, #0
  threads[2] = chThdCreateFromHeap(&heap1,
 80044ce:	1ef0      	subs	r0, r6, #3
 80044d0:	f7fd fe6e 	bl	80021b0 <chThdCreateFromHeap.constprop.71>
 80044d4:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 80044d6:	1c38      	adds	r0, r7, #0
 80044d8:	f7fe fa5a 	bl	8002990 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 80044dc:	6822      	ldr	r2, [r4, #0]
 80044de:	2a00      	cmp	r2, #0
 80044e0:	d02a      	beq.n	8004538 <dyn1_execute.10186+0xa8>
 80044e2:	6863      	ldr	r3, [r4, #4]
 80044e4:	2100      	movs	r1, #0
 80044e6:	2b00      	cmp	r3, #0
 80044e8:	d002      	beq.n	80044f0 <dyn1_execute.10186+0x60>
 80044ea:	68a0      	ldr	r0, [r4, #8]
 80044ec:	2800      	cmp	r0, #0
 80044ee:	d025      	beq.n	800453c <dyn1_execute.10186+0xac>
 80044f0:	2001      	movs	r0, #1
 80044f2:	f7fc fb35 	bl	8000b60 <_test_assert>
 80044f6:	2800      	cmp	r0, #0
 80044f8:	d001      	beq.n	80044fe <dyn1_execute.10186+0x6e>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 80044fa:	b003      	add	sp, #12
 80044fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 80044fe:	f7fd fb17 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8004502:	2002      	movs	r0, #2
 8004504:	4917      	ldr	r1, [pc, #92]	; (8004564 <dyn1_execute.10186+0xd4>)
 8004506:	f7fc fadb 	bl	8000ac0 <_test_assert_sequence>
 800450a:	2800      	cmp	r0, #0
 800450c:	d1f5      	bne.n	80044fa <dyn1_execute.10186+0x6a>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 800450e:	4669      	mov	r1, sp
 8004510:	1c28      	adds	r0, r5, #0
 8004512:	f7fe fa95 	bl	8002a40 <chHeapStatus>
 8004516:	1e41      	subs	r1, r0, #1
 8004518:	424b      	negs	r3, r1
 800451a:	4159      	adcs	r1, r3
 800451c:	2003      	movs	r0, #3
 800451e:	f7fc fb1f 	bl	8000b60 <_test_assert>
 8004522:	2800      	cmp	r0, #0
 8004524:	d1e9      	bne.n	80044fa <dyn1_execute.10186+0x6a>
  test_assert(4, n == sz, "heap size changed");
 8004526:	9900      	ldr	r1, [sp, #0]
 8004528:	9d01      	ldr	r5, [sp, #4]
 800452a:	2004      	movs	r0, #4
 800452c:	1b49      	subs	r1, r1, r5
 800452e:	424b      	negs	r3, r1
 8004530:	4159      	adcs	r1, r3
 8004532:	f7fc fb15 	bl	8000b60 <_test_assert>
 8004536:	e7e0      	b.n	80044fa <dyn1_execute.10186+0x6a>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 8004538:	2100      	movs	r1, #0
 800453a:	e7d9      	b.n	80044f0 <dyn1_execute.10186+0x60>
 800453c:	68e6      	ldr	r6, [r4, #12]
 800453e:	2e00      	cmp	r6, #0
 8004540:	d1d6      	bne.n	80044f0 <dyn1_execute.10186+0x60>
 8004542:	6921      	ldr	r1, [r4, #16]
 8004544:	424b      	negs	r3, r1
 8004546:	4159      	adcs	r1, r3
 8004548:	e7d2      	b.n	80044f0 <dyn1_execute.10186+0x60>
 800454a:	46c0      	nop			; (mov r8, r8)
 800454c:	20001040 	.word	0x20001040
 8004550:	20000d88 	.word	0x20000d88
 8004554:	08008698 	.word	0x08008698
 8004558:	200015b8 	.word	0x200015b8
 800455c:	080089a4 	.word	0x080089a4
 8004560:	080089a0 	.word	0x080089a0
 8004564:	080089b4 	.word	0x080089b4
 8004568:	46c0      	nop			; (mov r8, r8)
 800456a:	46c0      	nop			; (mov r8, r8)
 800456c:	46c0      	nop			; (mov r8, r8)
 800456e:	46c0      	nop			; (mov r8, r8)

08004570 <bmk8_execute.10821>:
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8004570:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004572:	464f      	mov	r7, r9
 8004574:	4646      	mov	r6, r8
 8004576:	b4c0      	push	{r6, r7}
  uint32_t n;

  n = 0;
 8004578:	2300      	movs	r3, #0
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 800457a:	b085      	sub	sp, #20
  uint32_t n;

  n = 0;
 800457c:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800457e:	f7fe f8bf 	bl	8002700 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004582:	482f      	ldr	r0, [pc, #188]	; (8004640 <bmk8_execute.10821+0xd0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8004584:	4a2f      	ldr	r2, [pc, #188]	; (8004644 <bmk8_execute.10821+0xd4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004586:	6984      	ldr	r4, [r0, #24]
 8004588:	4691      	mov	r9, r2
 800458a:	4e2f      	ldr	r6, [pc, #188]	; (8004648 <bmk8_execute.10821+0xd8>)
 800458c:	68a2      	ldr	r2, [r4, #8]
 800458e:	27a8      	movs	r7, #168	; 0xa8
 8004590:	007f      	lsls	r7, r7, #1
 8004592:	ac03      	add	r4, sp, #12
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004594:	4680      	mov	r8, r0
 8004596:	1c39      	adds	r1, r7, #0
 8004598:	1c33      	adds	r3, r6, #0
 800459a:	3a01      	subs	r2, #1
 800459c:	9400      	str	r4, [sp, #0]
 800459e:	4648      	mov	r0, r9
 80045a0:	f7fe fc56 	bl	8002e50 <chThdCreateStatic>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80045a4:	4643      	mov	r3, r8
 80045a6:	4d29      	ldr	r5, [pc, #164]	; (800464c <bmk8_execute.10821+0xdc>)
 80045a8:	699a      	ldr	r2, [r3, #24]
 80045aa:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80045ac:	6892      	ldr	r2, [r2, #8]
 80045ae:	4648      	mov	r0, r9
 80045b0:	3051      	adds	r0, #81	; 0x51
 80045b2:	1c39      	adds	r1, r7, #0
 80045b4:	1c33      	adds	r3, r6, #0
 80045b6:	3a01      	subs	r2, #1
 80045b8:	9400      	str	r4, [sp, #0]
 80045ba:	30ff      	adds	r0, #255	; 0xff
 80045bc:	f7fe fc48 	bl	8002e50 <chThdCreateStatic>
 80045c0:	4643      	mov	r3, r8
 80045c2:	699a      	ldr	r2, [r3, #24]
 80045c4:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80045c6:	20a8      	movs	r0, #168	; 0xa8
 80045c8:	6892      	ldr	r2, [r2, #8]
 80045ca:	0081      	lsls	r1, r0, #2
 80045cc:	1c08      	adds	r0, r1, #0
 80045ce:	1c33      	adds	r3, r6, #0
 80045d0:	1c39      	adds	r1, r7, #0
 80045d2:	4448      	add	r0, r9
 80045d4:	3a01      	subs	r2, #1
 80045d6:	9400      	str	r4, [sp, #0]
 80045d8:	f7fe fc3a 	bl	8002e50 <chThdCreateStatic>
 80045dc:	4643      	mov	r3, r8
 80045de:	699a      	ldr	r2, [r3, #24]
 80045e0:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80045e2:	20fc      	movs	r0, #252	; 0xfc
 80045e4:	6892      	ldr	r2, [r2, #8]
 80045e6:	0081      	lsls	r1, r0, #2
 80045e8:	1c08      	adds	r0, r1, #0
 80045ea:	1c33      	adds	r3, r6, #0
 80045ec:	1c39      	adds	r1, r7, #0
 80045ee:	4448      	add	r0, r9
 80045f0:	3a01      	subs	r2, #1
 80045f2:	9400      	str	r4, [sp, #0]
 80045f4:	f7fe fc2c 	bl	8002e50 <chThdCreateStatic>
 80045f8:	4643      	mov	r3, r8
 80045fa:	699a      	ldr	r2, [r3, #24]
 80045fc:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80045fe:	20a8      	movs	r0, #168	; 0xa8
 8004600:	6892      	ldr	r2, [r2, #8]
 8004602:	00c1      	lsls	r1, r0, #3
 8004604:	1c08      	adds	r0, r1, #0
 8004606:	3a01      	subs	r2, #1
 8004608:	1c39      	adds	r1, r7, #0
 800460a:	1c33      	adds	r3, r6, #0
 800460c:	4448      	add	r0, r9
 800460e:	9400      	str	r4, [sp, #0]
 8004610:	f7fe fc1e 	bl	8002e50 <chThdCreateStatic>
 8004614:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 8004616:	480e      	ldr	r0, [pc, #56]	; (8004650 <bmk8_execute.10821+0xe0>)
 8004618:	f7fe f84a 	bl	80026b0 <chThdSleep>
  test_terminate_threads();
 800461c:	f7ff fb60 	bl	8003ce0 <test_terminate_threads>
  test_wait_threads();
 8004620:	f7fd fa86 	bl	8001b30 <test_wait_threads>

  test_print("--- Score : ");
 8004624:	480b      	ldr	r0, [pc, #44]	; (8004654 <bmk8_execute.10821+0xe4>)
 8004626:	f7fc fad3 	bl	8000bd0 <test_print>
  test_printn(n);
 800462a:	9803      	ldr	r0, [sp, #12]
 800462c:	f7fc fae8 	bl	8000c00 <test_printn>
  test_println(" ctxswc/S");
 8004630:	4809      	ldr	r0, [pc, #36]	; (8004658 <bmk8_execute.10821+0xe8>)
 8004632:	f7fc faad 	bl	8000b90 <test_println>
}
 8004636:	b005      	add	sp, #20
 8004638:	bc0c      	pop	{r2, r3}
 800463a:	4690      	mov	r8, r2
 800463c:	4699      	mov	r9, r3
 800463e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004640:	20001040 	.word	0x20001040
 8004644:	200006b8 	.word	0x200006b8
 8004648:	08002681 	.word	0x08002681
 800464c:	200015b8 	.word	0x200015b8
 8004650:	00002710 	.word	0x00002710
 8004654:	08008650 	.word	0x08008650
 8004658:	08008674 	.word	0x08008674
 800465c:	46c0      	nop			; (mov r8, r8)
 800465e:	46c0      	nop			; (mov r8, r8)

08004660 <sem2_execute.9038>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static void sem2_execute(void) {
 8004660:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004662:	4647      	mov	r7, r8
 8004664:	b480      	push	{r7}
 8004666:	b082      	sub	sp, #8
 8004668:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800466a:	f7ff fa19 	bl	8003aa0 <_dbg_check_lock>
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 800466e:	4dce      	ldr	r5, [pc, #824]	; (80049a8 <sem2_execute.9038+0x348>)
 8004670:	2100      	movs	r1, #0
 8004672:	1c28      	adds	r0, r5, #0
 8004674:	f7fe ff64 	bl	8003540 <chSemWaitTimeoutS>
 8004678:	1c06      	adds	r6, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800467a:	f7ff f979 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800467e:	4ccb      	ldr	r4, [pc, #812]	; (80049ac <sem2_execute.9038+0x34c>)
 8004680:	6823      	ldr	r3, [r4, #0]
 8004682:	42a3      	cmp	r3, r4
 8004684:	d004      	beq.n	8004690 <sem2_execute.9038+0x30>
 8004686:	69a2      	ldr	r2, [r4, #24]
 8004688:	6899      	ldr	r1, [r3, #8]
 800468a:	6890      	ldr	r0, [r2, #8]
 800468c:	4288      	cmp	r0, r1
 800468e:	d30c      	bcc.n	80046aa <sem2_execute.9038+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004690:	b662      	cpsie	i

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 8004692:	1c71      	adds	r1, r6, #1
 8004694:	424e      	negs	r6, r1
 8004696:	4171      	adcs	r1, r6
 8004698:	2001      	movs	r0, #1
 800469a:	f7fc fa61 	bl	8000b60 <_test_assert>
 800469e:	2800      	cmp	r0, #0
 80046a0:	d007      	beq.n	80046b2 <sem2_execute.9038+0x52>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 80046a2:	b002      	add	sp, #8
 80046a4:	bc04      	pop	{r2}
 80046a6:	4690      	mov	r8, r2
 80046a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80046aa:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80046ac:	4ac0      	ldr	r2, [pc, #768]	; (80049b0 <sem2_execute.9038+0x350>)
 80046ae:	62e2      	str	r2, [r4, #44]	; 0x2c
 80046b0:	e7fe      	b.n	80046b0 <sem2_execute.9038+0x50>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 80046b2:	682f      	ldr	r7, [r5, #0]
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 80046b4:	2002      	movs	r0, #2
 80046b6:	1b79      	subs	r1, r7, r5
 80046b8:	424b      	negs	r3, r1
 80046ba:	4159      	adcs	r1, r3
 80046bc:	f7fc fa50 	bl	8000b60 <_test_assert>
 80046c0:	2800      	cmp	r0, #0
 80046c2:	d1ee      	bne.n	80046a2 <sem2_execute.9038+0x42>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 80046c4:	68ae      	ldr	r6, [r5, #8]
 80046c6:	2003      	movs	r0, #3
 80046c8:	4271      	negs	r1, r6
 80046ca:	4171      	adcs	r1, r6
 80046cc:	f7fc fa48 	bl	8000b60 <_test_assert>
 80046d0:	2800      	cmp	r0, #0
 80046d2:	d1e6      	bne.n	80046a2 <sem2_execute.9038+0x42>
 80046d4:	69a3      	ldr	r3, [r4, #24]

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80046d6:	21a8      	movs	r1, #168	; 0xa8
 80046d8:	689a      	ldr	r2, [r3, #8]
 80046da:	0049      	lsls	r1, r1, #1
 80046dc:	9000      	str	r0, [sp, #0]
 80046de:	3a01      	subs	r2, #1
 80046e0:	4bb4      	ldr	r3, [pc, #720]	; (80049b4 <sem2_execute.9038+0x354>)
 80046e2:	48b5      	ldr	r0, [pc, #724]	; (80049b8 <sem2_execute.9038+0x358>)
 80046e4:	f7fe fbb4 	bl	8002e50 <chThdCreateStatic>
 80046e8:	4ab4      	ldr	r2, [pc, #720]	; (80049bc <sem2_execute.9038+0x35c>)
 80046ea:	6010      	str	r0, [r2, #0]
 80046ec:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80046ee:	f7ff f9d7 	bl	8003aa0 <_dbg_check_lock>
 80046f2:	49b3      	ldr	r1, [pc, #716]	; (80049c0 <sem2_execute.9038+0x360>)
 80046f4:	1c28      	adds	r0, r5, #0
 80046f6:	f7fe ff23 	bl	8003540 <chSemWaitTimeoutS>
 80046fa:	1c07      	adds	r7, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80046fc:	f7ff f938 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004700:	6820      	ldr	r0, [r4, #0]
 8004702:	42a0      	cmp	r0, r4
 8004704:	d005      	beq.n	8004712 <sem2_execute.9038+0xb2>
 8004706:	69a6      	ldr	r6, [r4, #24]
 8004708:	6883      	ldr	r3, [r0, #8]
 800470a:	68b1      	ldr	r1, [r6, #8]
 800470c:	4299      	cmp	r1, r3
 800470e:	d200      	bcs.n	8004712 <sem2_execute.9038+0xb2>
 8004710:	e15e      	b.n	80049d0 <sem2_execute.9038+0x370>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004712:	b662      	cpsie	i
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
  test_wait_threads();
 8004714:	f7fd fa0c 	bl	8001b30 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 8004718:	4279      	negs	r1, r7
 800471a:	4179      	adcs	r1, r7
 800471c:	2004      	movs	r0, #4
 800471e:	f7fc fa1f 	bl	8000b60 <_test_assert>
 8004722:	2800      	cmp	r0, #0
 8004724:	d1bd      	bne.n	80046a2 <sem2_execute.9038+0x42>
 8004726:	682a      	ldr	r2, [r5, #0]
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 8004728:	2005      	movs	r0, #5
 800472a:	1b51      	subs	r1, r2, r5
 800472c:	424b      	negs	r3, r1
 800472e:	4159      	adcs	r1, r3
 8004730:	f7fc fa16 	bl	8000b60 <_test_assert>
 8004734:	2800      	cmp	r0, #0
 8004736:	d1b4      	bne.n	80046a2 <sem2_execute.9038+0x42>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 8004738:	68af      	ldr	r7, [r5, #8]
 800473a:	2006      	movs	r0, #6
 800473c:	4279      	negs	r1, r7
 800473e:	4179      	adcs	r1, r7
 8004740:	f7fc fa0e 	bl	8000b60 <_test_assert>
 8004744:	2800      	cmp	r0, #0
 8004746:	d1ac      	bne.n	80046a2 <sem2_execute.9038+0x42>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 8004748:	f7fd ffda 	bl	8002700 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800474c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800474e:	f7ff f9a7 	bl	8003aa0 <_dbg_check_lock>
 8004752:	2080      	movs	r0, #128	; 0x80
 8004754:	05c6      	lsls	r6, r0, #23
 8004756:	6a76      	ldr	r6, [r6, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004758:	f7ff f90a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800475c:	6821      	ldr	r1, [r4, #0]
 800475e:	42a1      	cmp	r1, r4
 8004760:	d005      	beq.n	800476e <sem2_execute.9038+0x10e>
 8004762:	69a3      	ldr	r3, [r4, #24]
 8004764:	688f      	ldr	r7, [r1, #8]
 8004766:	689a      	ldr	r2, [r3, #8]
 8004768:	42ba      	cmp	r2, r7
 800476a:	d200      	bcs.n	800476e <sem2_execute.9038+0x10e>
 800476c:	e134      	b.n	80049d8 <sem2_execute.9038+0x378>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800476e:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 8004770:	4894      	ldr	r0, [pc, #592]	; (80049c4 <sem2_execute.9038+0x364>)
 8004772:	1837      	adds	r7, r6, r0
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 8004774:	2041      	movs	r0, #65	; 0x41
 8004776:	f000 fcb3 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800477a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800477c:	f7ff f990 	bl	8003aa0 <_dbg_check_lock>
 8004780:	21fa      	movs	r1, #250	; 0xfa
 8004782:	0049      	lsls	r1, r1, #1
 8004784:	1c28      	adds	r0, r5, #0
 8004786:	f7fe fedb 	bl	8003540 <chSemWaitTimeoutS>
 800478a:	4680      	mov	r8, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800478c:	f7ff f8f0 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004790:	6823      	ldr	r3, [r4, #0]
 8004792:	42a3      	cmp	r3, r4
 8004794:	d005      	beq.n	80047a2 <sem2_execute.9038+0x142>
 8004796:	69a2      	ldr	r2, [r4, #24]
 8004798:	6899      	ldr	r1, [r3, #8]
 800479a:	6890      	ldr	r0, [r2, #8]
 800479c:	4288      	cmp	r0, r1
 800479e:	d200      	bcs.n	80047a2 <sem2_execute.9038+0x142>
 80047a0:	e0fd      	b.n	800499e <sem2_execute.9038+0x33e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80047a2:	b662      	cpsie	i
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 80047a4:	4641      	mov	r1, r8
 80047a6:	3101      	adds	r1, #1
 80047a8:	424b      	negs	r3, r1
 80047aa:	4159      	adcs	r1, r3
 80047ac:	2007      	movs	r0, #7
 80047ae:	f7fc f9d7 	bl	8000b60 <_test_assert>
 80047b2:	2800      	cmp	r0, #0
 80047b4:	d000      	beq.n	80047b8 <sem2_execute.9038+0x158>
 80047b6:	e774      	b.n	80046a2 <sem2_execute.9038+0x42>
 80047b8:	682b      	ldr	r3, [r5, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 80047ba:	2008      	movs	r0, #8
 80047bc:	1b59      	subs	r1, r3, r5
 80047be:	424b      	negs	r3, r1
 80047c0:	4159      	adcs	r1, r3
 80047c2:	f7fc f9cd 	bl	8000b60 <_test_assert>
 80047c6:	2800      	cmp	r0, #0
 80047c8:	d000      	beq.n	80047cc <sem2_execute.9038+0x16c>
 80047ca:	e76a      	b.n	80046a2 <sem2_execute.9038+0x42>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 80047cc:	68aa      	ldr	r2, [r5, #8]
 80047ce:	2009      	movs	r0, #9
 80047d0:	4251      	negs	r1, r2
 80047d2:	4151      	adcs	r1, r2
 80047d4:	f7fc f9c4 	bl	8000b60 <_test_assert>
 80047d8:	2800      	cmp	r0, #0
 80047da:	d000      	beq.n	80047de <sem2_execute.9038+0x17e>
 80047dc:	e761      	b.n	80046a2 <sem2_execute.9038+0x42>
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 80047de:	2042      	movs	r0, #66	; 0x42
 80047e0:	f000 fc7e 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047e4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80047e6:	f7ff f95b 	bl	8003aa0 <_dbg_check_lock>
 80047ea:	21fa      	movs	r1, #250	; 0xfa
 80047ec:	0049      	lsls	r1, r1, #1
 80047ee:	1c28      	adds	r0, r5, #0
 80047f0:	f7fe fea6 	bl	8003540 <chSemWaitTimeoutS>
 80047f4:	4680      	mov	r8, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80047f6:	f7ff f8bb 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80047fa:	6820      	ldr	r0, [r4, #0]
 80047fc:	42a0      	cmp	r0, r4
 80047fe:	d005      	beq.n	800480c <sem2_execute.9038+0x1ac>
 8004800:	69a3      	ldr	r3, [r4, #24]
 8004802:	6881      	ldr	r1, [r0, #8]
 8004804:	689a      	ldr	r2, [r3, #8]
 8004806:	428a      	cmp	r2, r1
 8004808:	d200      	bcs.n	800480c <sem2_execute.9038+0x1ac>
 800480a:	e0c8      	b.n	800499e <sem2_execute.9038+0x33e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800480c:	b662      	cpsie	i
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 800480e:	4641      	mov	r1, r8
 8004810:	3101      	adds	r1, #1
 8004812:	424b      	negs	r3, r1
 8004814:	4159      	adcs	r1, r3
 8004816:	2007      	movs	r0, #7
 8004818:	f7fc f9a2 	bl	8000b60 <_test_assert>
 800481c:	2800      	cmp	r0, #0
 800481e:	d000      	beq.n	8004822 <sem2_execute.9038+0x1c2>
 8004820:	e73f      	b.n	80046a2 <sem2_execute.9038+0x42>
 8004822:	6828      	ldr	r0, [r5, #0]
 8004824:	1b41      	subs	r1, r0, r5
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 8004826:	424b      	negs	r3, r1
 8004828:	4159      	adcs	r1, r3
 800482a:	2008      	movs	r0, #8
 800482c:	f7fc f998 	bl	8000b60 <_test_assert>
 8004830:	2800      	cmp	r0, #0
 8004832:	d000      	beq.n	8004836 <sem2_execute.9038+0x1d6>
 8004834:	e735      	b.n	80046a2 <sem2_execute.9038+0x42>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8004836:	68ab      	ldr	r3, [r5, #8]
 8004838:	2009      	movs	r0, #9
 800483a:	4259      	negs	r1, r3
 800483c:	4159      	adcs	r1, r3
 800483e:	f7fc f98f 	bl	8000b60 <_test_assert>
 8004842:	2800      	cmp	r0, #0
 8004844:	d000      	beq.n	8004848 <sem2_execute.9038+0x1e8>
 8004846:	e72c      	b.n	80046a2 <sem2_execute.9038+0x42>
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 8004848:	2043      	movs	r0, #67	; 0x43
 800484a:	f000 fc49 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800484e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004850:	f7ff f926 	bl	8003aa0 <_dbg_check_lock>
 8004854:	22fa      	movs	r2, #250	; 0xfa
 8004856:	0051      	lsls	r1, r2, #1
 8004858:	1c28      	adds	r0, r5, #0
 800485a:	f7fe fe71 	bl	8003540 <chSemWaitTimeoutS>
 800485e:	4680      	mov	r8, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004860:	f7ff f886 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004864:	6821      	ldr	r1, [r4, #0]
 8004866:	42a1      	cmp	r1, r4
 8004868:	d005      	beq.n	8004876 <sem2_execute.9038+0x216>
 800486a:	69a0      	ldr	r0, [r4, #24]
 800486c:	688b      	ldr	r3, [r1, #8]
 800486e:	6882      	ldr	r2, [r0, #8]
 8004870:	429a      	cmp	r2, r3
 8004872:	d200      	bcs.n	8004876 <sem2_execute.9038+0x216>
 8004874:	e093      	b.n	800499e <sem2_execute.9038+0x33e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004876:	b662      	cpsie	i
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8004878:	4641      	mov	r1, r8
 800487a:	3101      	adds	r1, #1
 800487c:	424b      	negs	r3, r1
 800487e:	4159      	adcs	r1, r3
 8004880:	2007      	movs	r0, #7
 8004882:	f7fc f96d 	bl	8000b60 <_test_assert>
 8004886:	2800      	cmp	r0, #0
 8004888:	d000      	beq.n	800488c <sem2_execute.9038+0x22c>
 800488a:	e70a      	b.n	80046a2 <sem2_execute.9038+0x42>
 800488c:	6829      	ldr	r1, [r5, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800488e:	2008      	movs	r0, #8
 8004890:	1b49      	subs	r1, r1, r5
 8004892:	424b      	negs	r3, r1
 8004894:	4159      	adcs	r1, r3
 8004896:	f7fc f963 	bl	8000b60 <_test_assert>
 800489a:	2800      	cmp	r0, #0
 800489c:	d000      	beq.n	80048a0 <sem2_execute.9038+0x240>
 800489e:	e700      	b.n	80046a2 <sem2_execute.9038+0x42>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 80048a0:	68a8      	ldr	r0, [r5, #8]
 80048a2:	4241      	negs	r1, r0
 80048a4:	4141      	adcs	r1, r0
 80048a6:	2009      	movs	r0, #9
 80048a8:	f7fc f95a 	bl	8000b60 <_test_assert>
 80048ac:	2800      	cmp	r0, #0
 80048ae:	d000      	beq.n	80048b2 <sem2_execute.9038+0x252>
 80048b0:	e6f7      	b.n	80046a2 <sem2_execute.9038+0x42>
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 80048b2:	2044      	movs	r0, #68	; 0x44
 80048b4:	f000 fc14 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80048b8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80048ba:	f7ff f8f1 	bl	8003aa0 <_dbg_check_lock>
 80048be:	22fa      	movs	r2, #250	; 0xfa
 80048c0:	0051      	lsls	r1, r2, #1
 80048c2:	1c28      	adds	r0, r5, #0
 80048c4:	f7fe fe3c 	bl	8003540 <chSemWaitTimeoutS>
 80048c8:	4680      	mov	r8, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80048ca:	f7ff f851 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80048ce:	6823      	ldr	r3, [r4, #0]
 80048d0:	42a3      	cmp	r3, r4
 80048d2:	d004      	beq.n	80048de <sem2_execute.9038+0x27e>
 80048d4:	69a1      	ldr	r1, [r4, #24]
 80048d6:	689a      	ldr	r2, [r3, #8]
 80048d8:	6888      	ldr	r0, [r1, #8]
 80048da:	4290      	cmp	r0, r2
 80048dc:	d35f      	bcc.n	800499e <sem2_execute.9038+0x33e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80048de:	b662      	cpsie	i
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 80048e0:	4641      	mov	r1, r8
 80048e2:	3101      	adds	r1, #1
 80048e4:	424b      	negs	r3, r1
 80048e6:	4159      	adcs	r1, r3
 80048e8:	2007      	movs	r0, #7
 80048ea:	f7fc f939 	bl	8000b60 <_test_assert>
 80048ee:	2800      	cmp	r0, #0
 80048f0:	d000      	beq.n	80048f4 <sem2_execute.9038+0x294>
 80048f2:	e6d6      	b.n	80046a2 <sem2_execute.9038+0x42>
 80048f4:	682b      	ldr	r3, [r5, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 80048f6:	2008      	movs	r0, #8
 80048f8:	1b59      	subs	r1, r3, r5
 80048fa:	424b      	negs	r3, r1
 80048fc:	4159      	adcs	r1, r3
 80048fe:	f7fc f92f 	bl	8000b60 <_test_assert>
 8004902:	2800      	cmp	r0, #0
 8004904:	d000      	beq.n	8004908 <sem2_execute.9038+0x2a8>
 8004906:	e6cc      	b.n	80046a2 <sem2_execute.9038+0x42>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8004908:	68a8      	ldr	r0, [r5, #8]
 800490a:	4241      	negs	r1, r0
 800490c:	4141      	adcs	r1, r0
 800490e:	2009      	movs	r0, #9
 8004910:	f7fc f926 	bl	8000b60 <_test_assert>
 8004914:	2800      	cmp	r0, #0
 8004916:	d000      	beq.n	800491a <sem2_execute.9038+0x2ba>
 8004918:	e6c3      	b.n	80046a2 <sem2_execute.9038+0x42>
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 800491a:	2045      	movs	r0, #69	; 0x45
 800491c:	f000 fbe0 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004920:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004922:	f7ff f8bd 	bl	8003aa0 <_dbg_check_lock>
 8004926:	21fa      	movs	r1, #250	; 0xfa
 8004928:	0049      	lsls	r1, r1, #1
 800492a:	1c28      	adds	r0, r5, #0
 800492c:	f7fe fe08 	bl	8003540 <chSemWaitTimeoutS>
 8004930:	4680      	mov	r8, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004932:	f7ff f81d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004936:	6823      	ldr	r3, [r4, #0]
 8004938:	42a3      	cmp	r3, r4
 800493a:	d004      	beq.n	8004946 <sem2_execute.9038+0x2e6>
 800493c:	69a2      	ldr	r2, [r4, #24]
 800493e:	6899      	ldr	r1, [r3, #8]
 8004940:	6890      	ldr	r0, [r2, #8]
 8004942:	4288      	cmp	r0, r1
 8004944:	d32b      	bcc.n	800499e <sem2_execute.9038+0x33e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004946:	b662      	cpsie	i
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8004948:	4641      	mov	r1, r8
 800494a:	3101      	adds	r1, #1
 800494c:	424b      	negs	r3, r1
 800494e:	4159      	adcs	r1, r3
 8004950:	2007      	movs	r0, #7
 8004952:	f7fc f905 	bl	8000b60 <_test_assert>
 8004956:	2800      	cmp	r0, #0
 8004958:	d000      	beq.n	800495c <sem2_execute.9038+0x2fc>
 800495a:	e6a2      	b.n	80046a2 <sem2_execute.9038+0x42>
 800495c:	682c      	ldr	r4, [r5, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800495e:	2008      	movs	r0, #8
 8004960:	1b61      	subs	r1, r4, r5
 8004962:	424b      	negs	r3, r1
 8004964:	4159      	adcs	r1, r3
 8004966:	f7fc f8fb 	bl	8000b60 <_test_assert>
 800496a:	2800      	cmp	r0, #0
 800496c:	d000      	beq.n	8004970 <sem2_execute.9038+0x310>
 800496e:	e698      	b.n	80046a2 <sem2_execute.9038+0x42>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8004970:	68a9      	ldr	r1, [r5, #8]
 8004972:	2009      	movs	r0, #9
 8004974:	424b      	negs	r3, r1
 8004976:	4159      	adcs	r1, r3
 8004978:	f7fc f8f2 	bl	8000b60 <_test_assert>
 800497c:	2800      	cmp	r0, #0
 800497e:	d000      	beq.n	8004982 <sem2_execute.9038+0x322>
 8004980:	e68f      	b.n	80046a2 <sem2_execute.9038+0x42>
  }
  test_assert_sequence(10, "ABCDE");
 8004982:	200a      	movs	r0, #10
 8004984:	4910      	ldr	r1, [pc, #64]	; (80049c8 <sem2_execute.9038+0x368>)
 8004986:	f7fc f89b 	bl	8000ac0 <_test_assert_sequence>
 800498a:	2800      	cmp	r0, #0
 800498c:	d000      	beq.n	8004990 <sem2_execute.9038+0x330>
 800498e:	e688      	b.n	80046a2 <sem2_execute.9038+0x42>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8004990:	4d0e      	ldr	r5, [pc, #56]	; (80049cc <sem2_execute.9038+0x36c>)
 8004992:	1c39      	adds	r1, r7, #0
 8004994:	1972      	adds	r2, r6, r5
 8004996:	200b      	movs	r0, #11
 8004998:	f000 fb6a 	bl	8005070 <_test_assert_time_window>
 800499c:	e681      	b.n	80046a2 <sem2_execute.9038+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800499e:	b672      	cpsid	i
 80049a0:	4e03      	ldr	r6, [pc, #12]	; (80049b0 <sem2_execute.9038+0x350>)
 80049a2:	62e6      	str	r6, [r4, #44]	; 0x2c
 80049a4:	e7fe      	b.n	80049a4 <sem2_execute.9038+0x344>
 80049a6:	46c0      	nop			; (mov r8, r8)
 80049a8:	200006a4 	.word	0x200006a4
 80049ac:	20001040 	.word	0x20001040
 80049b0:	08008600 	.word	0x08008600
 80049b4:	080053d1 	.word	0x080053d1
 80049b8:	200006b8 	.word	0x200006b8
 80049bc:	200015b8 	.word	0x200015b8
 80049c0:	00001388 	.word	0x00001388
 80049c4:	000009c4 	.word	0x000009c4
 80049c8:	080089ac 	.word	0x080089ac
 80049cc:	000009d8 	.word	0x000009d8
 80049d0:	b672      	cpsid	i
 80049d2:	4b03      	ldr	r3, [pc, #12]	; (80049e0 <sem2_execute.9038+0x380>)
 80049d4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80049d6:	e7fe      	b.n	80049d6 <sem2_execute.9038+0x376>
 80049d8:	b672      	cpsid	i
 80049da:	4f02      	ldr	r7, [pc, #8]	; (80049e4 <sem2_execute.9038+0x384>)
 80049dc:	62e7      	str	r7, [r4, #44]	; 0x2c
 80049de:	e7fe      	b.n	80049de <sem2_execute.9038+0x37e>
 80049e0:	08008600 	.word	0x08008600
 80049e4:	080085d0 	.word	0x080085d0
 80049e8:	46c0      	nop			; (mov r8, r8)
 80049ea:	46c0      	nop			; (mov r8, r8)
 80049ec:	46c0      	nop			; (mov r8, r8)
 80049ee:	46c0      	nop			; (mov r8, r8)

080049f0 <mtx7_execute.9253>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 80049f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80049f2:	4647      	mov	r7, r8
 80049f4:	b480      	push	{r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80049f6:	4d38      	ldr	r5, [pc, #224]	; (8004ad8 <mtx7_execute.9253+0xe8>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80049f8:	4e38      	ldr	r6, [pc, #224]	; (8004adc <mtx7_execute.9253+0xec>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80049fa:	69ab      	ldr	r3, [r5, #24]
 80049fc:	4938      	ldr	r1, [pc, #224]	; (8004ae0 <mtx7_execute.9253+0xf0>)
 80049fe:	689f      	ldr	r7, [r3, #8]

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8004a00:	b082      	sub	sp, #8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004a02:	4838      	ldr	r0, [pc, #224]	; (8004ae4 <mtx7_execute.9253+0xf4>)
 8004a04:	24a8      	movs	r4, #168	; 0xa8
 8004a06:	1c7a      	adds	r2, r7, #1
 8004a08:	9100      	str	r1, [sp, #0]
 8004a0a:	1c33      	adds	r3, r6, #0
 8004a0c:	0061      	lsls	r1, r4, #1
 8004a0e:	4680      	mov	r8, r0
 8004a10:	f7fe fa1e 	bl	8002e50 <chThdCreateStatic>
 8004a14:	4c34      	ldr	r4, [pc, #208]	; (8004ae8 <mtx7_execute.9253+0xf8>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004a16:	4b35      	ldr	r3, [pc, #212]	; (8004aec <mtx7_execute.9253+0xfc>)
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004a18:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004a1a:	4640      	mov	r0, r8
 8004a1c:	3051      	adds	r0, #81	; 0x51
 8004a1e:	21a8      	movs	r1, #168	; 0xa8
 8004a20:	1cba      	adds	r2, r7, #2
 8004a22:	9300      	str	r3, [sp, #0]
 8004a24:	0049      	lsls	r1, r1, #1
 8004a26:	1c33      	adds	r3, r6, #0
 8004a28:	30ff      	adds	r0, #255	; 0xff
 8004a2a:	f7fe fa11 	bl	8002e50 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004a2e:	4b30      	ldr	r3, [pc, #192]	; (8004af0 <mtx7_execute.9253+0x100>)
 8004a30:	22a8      	movs	r2, #168	; 0xa8

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004a32:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004a34:	21a8      	movs	r1, #168	; 0xa8
 8004a36:	0090      	lsls	r0, r2, #2
 8004a38:	9300      	str	r3, [sp, #0]
 8004a3a:	1cfa      	adds	r2, r7, #3
 8004a3c:	1c33      	adds	r3, r6, #0
 8004a3e:	4440      	add	r0, r8
 8004a40:	0049      	lsls	r1, r1, #1
 8004a42:	f7fe fa05 	bl	8002e50 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004a46:	4b2b      	ldr	r3, [pc, #172]	; (8004af4 <mtx7_execute.9253+0x104>)
 8004a48:	22fc      	movs	r2, #252	; 0xfc
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004a4a:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004a4c:	21a8      	movs	r1, #168	; 0xa8
 8004a4e:	0090      	lsls	r0, r2, #2
 8004a50:	9300      	str	r3, [sp, #0]
 8004a52:	1d3a      	adds	r2, r7, #4
 8004a54:	1c33      	adds	r3, r6, #0
 8004a56:	4440      	add	r0, r8
 8004a58:	0049      	lsls	r1, r1, #1
 8004a5a:	f7fe f9f9 	bl	8002e50 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004a5e:	22a8      	movs	r2, #168	; 0xa8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004a60:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004a62:	00d0      	lsls	r0, r2, #3
 8004a64:	1d7a      	adds	r2, r7, #5
 8004a66:	4f24      	ldr	r7, [pc, #144]	; (8004af8 <mtx7_execute.9253+0x108>)
 8004a68:	23a8      	movs	r3, #168	; 0xa8
 8004a6a:	0059      	lsls	r1, r3, #1
 8004a6c:	4440      	add	r0, r8
 8004a6e:	9700      	str	r7, [sp, #0]
 8004a70:	1c33      	adds	r3, r6, #0
 8004a72:	f7fe f9ed 	bl	8002e50 <chThdCreateStatic>
 8004a76:	6120      	str	r0, [r4, #16]
 8004a78:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004a7a:	f7ff f811 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {

  chDbgCheckClassI();
 8004a7e:	f7fb fdf7 	bl	8000670 <chDbgCheckClassI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004a82:	4c1e      	ldr	r4, [pc, #120]	; (8004afc <mtx7_execute.9253+0x10c>)

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8004a84:	2602      	movs	r6, #2
 8004a86:	6820      	ldr	r0, [r4, #0]
 8004a88:	4277      	negs	r7, r6
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8004a8a:	42a0      	cmp	r0, r4
 8004a8c:	d008      	beq.n	8004aa0 <mtx7_execute.9253+0xb0>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8004a8e:	6801      	ldr	r1, [r0, #0]
 8004a90:	6021      	str	r1, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004a92:	604c      	str	r4, [r1, #4]
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8004a94:	f7fb fe4c 	bl	8000730 <chSchReadyI>
 8004a98:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004a9a:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8004a9c:	42a0      	cmp	r0, r4
 8004a9e:	d1f6      	bne.n	8004a8e <mtx7_execute.9253+0x9e>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8004aa0:	f7fe fcee 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004aa4:	f7fe ff64 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004aa8:	6828      	ldr	r0, [r5, #0]
 8004aaa:	42a8      	cmp	r0, r5
 8004aac:	d004      	beq.n	8004ab8 <mtx7_execute.9253+0xc8>
 8004aae:	69aa      	ldr	r2, [r5, #24]
 8004ab0:	6883      	ldr	r3, [r0, #8]
 8004ab2:	6894      	ldr	r4, [r2, #8]
 8004ab4:	429c      	cmp	r4, r3
 8004ab6:	d30a      	bcc.n	8004ace <mtx7_execute.9253+0xde>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004ab8:	b662      	cpsie	i
  chCondBroadcast(&c1);
  test_wait_threads();
 8004aba:	f7fd f839 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004abe:	4910      	ldr	r1, [pc, #64]	; (8004b00 <mtx7_execute.9253+0x110>)
 8004ac0:	2001      	movs	r0, #1
 8004ac2:	f7fb fffd 	bl	8000ac0 <_test_assert_sequence>
}
 8004ac6:	b002      	add	sp, #8
 8004ac8:	bc04      	pop	{r2}
 8004aca:	4690      	mov	r8, r2
 8004acc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004ace:	b672      	cpsid	i
 8004ad0:	4e0c      	ldr	r6, [pc, #48]	; (8004b04 <mtx7_execute.9253+0x114>)
 8004ad2:	62ee      	str	r6, [r5, #44]	; 0x2c
 8004ad4:	e7fe      	b.n	8004ad4 <mtx7_execute.9253+0xe4>
 8004ad6:	46c0      	nop			; (mov r8, r8)
 8004ad8:	20001040 	.word	0x20001040
 8004adc:	080051a1 	.word	0x080051a1
 8004ae0:	080089b0 	.word	0x080089b0
 8004ae4:	200006b8 	.word	0x200006b8
 8004ae8:	200015b8 	.word	0x200015b8
 8004aec:	080089a8 	.word	0x080089a8
 8004af0:	080089a0 	.word	0x080089a0
 8004af4:	080089a4 	.word	0x080089a4
 8004af8:	08008698 	.word	0x08008698
 8004afc:	20000670 	.word	0x20000670
 8004b00:	080089ac 	.word	0x080089ac
 8004b04:	08008990 	.word	0x08008990
 8004b08:	46c0      	nop			; (mov r8, r8)
 8004b0a:	46c0      	nop			; (mov r8, r8)
 8004b0c:	46c0      	nop			; (mov r8, r8)
 8004b0e:	46c0      	nop			; (mov r8, r8)

08004b10 <mtx6_execute.9259>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8004b10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004b12:	4647      	mov	r7, r8
 8004b14:	b480      	push	{r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004b16:	4c34      	ldr	r4, [pc, #208]	; (8004be8 <mtx6_execute.9259+0xd8>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004b18:	4e34      	ldr	r6, [pc, #208]	; (8004bec <mtx6_execute.9259+0xdc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004b1a:	69a3      	ldr	r3, [r4, #24]
 8004b1c:	4934      	ldr	r1, [pc, #208]	; (8004bf0 <mtx6_execute.9259+0xe0>)
 8004b1e:	689f      	ldr	r7, [r3, #8]
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8004b20:	b082      	sub	sp, #8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004b22:	4834      	ldr	r0, [pc, #208]	; (8004bf4 <mtx6_execute.9259+0xe4>)
 8004b24:	25a8      	movs	r5, #168	; 0xa8
 8004b26:	1c7a      	adds	r2, r7, #1
 8004b28:	9100      	str	r1, [sp, #0]
 8004b2a:	1c33      	adds	r3, r6, #0
 8004b2c:	0069      	lsls	r1, r5, #1
 8004b2e:	4680      	mov	r8, r0
 8004b30:	f7fe f98e 	bl	8002e50 <chThdCreateStatic>
 8004b34:	4d30      	ldr	r5, [pc, #192]	; (8004bf8 <mtx6_execute.9259+0xe8>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004b36:	4b31      	ldr	r3, [pc, #196]	; (8004bfc <mtx6_execute.9259+0xec>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004b38:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004b3a:	4640      	mov	r0, r8
 8004b3c:	3051      	adds	r0, #81	; 0x51
 8004b3e:	21a8      	movs	r1, #168	; 0xa8
 8004b40:	1cba      	adds	r2, r7, #2
 8004b42:	9300      	str	r3, [sp, #0]
 8004b44:	0049      	lsls	r1, r1, #1
 8004b46:	1c33      	adds	r3, r6, #0
 8004b48:	30ff      	adds	r0, #255	; 0xff
 8004b4a:	f7fe f981 	bl	8002e50 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004b4e:	4b2c      	ldr	r3, [pc, #176]	; (8004c00 <mtx6_execute.9259+0xf0>)
 8004b50:	22a8      	movs	r2, #168	; 0xa8

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004b52:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004b54:	21a8      	movs	r1, #168	; 0xa8
 8004b56:	0090      	lsls	r0, r2, #2
 8004b58:	9300      	str	r3, [sp, #0]
 8004b5a:	1cfa      	adds	r2, r7, #3
 8004b5c:	1c33      	adds	r3, r6, #0
 8004b5e:	4440      	add	r0, r8
 8004b60:	0049      	lsls	r1, r1, #1
 8004b62:	f7fe f975 	bl	8002e50 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004b66:	4b27      	ldr	r3, [pc, #156]	; (8004c04 <mtx6_execute.9259+0xf4>)
 8004b68:	22fc      	movs	r2, #252	; 0xfc
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004b6a:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004b6c:	21a8      	movs	r1, #168	; 0xa8
 8004b6e:	0090      	lsls	r0, r2, #2
 8004b70:	9300      	str	r3, [sp, #0]
 8004b72:	1d3a      	adds	r2, r7, #4
 8004b74:	1c33      	adds	r3, r6, #0
 8004b76:	4440      	add	r0, r8
 8004b78:	0049      	lsls	r1, r1, #1
 8004b7a:	f7fe f969 	bl	8002e50 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004b7e:	22a8      	movs	r2, #168	; 0xa8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004b80:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004b82:	00d0      	lsls	r0, r2, #3
 8004b84:	1d7a      	adds	r2, r7, #5
 8004b86:	4f20      	ldr	r7, [pc, #128]	; (8004c08 <mtx6_execute.9259+0xf8>)
 8004b88:	23a8      	movs	r3, #168	; 0xa8
 8004b8a:	0059      	lsls	r1, r3, #1
 8004b8c:	4440      	add	r0, r8
 8004b8e:	9700      	str	r7, [sp, #0]
 8004b90:	1c33      	adds	r3, r6, #0
 8004b92:	f7fe f95d 	bl	8002e50 <chThdCreateStatic>
 8004b96:	6128      	str	r0, [r5, #16]
 8004b98:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004b9a:	f7fe ff81 	bl	8003aa0 <_dbg_check_lock>
  chSysLock();
  chCondSignalI(&c1);
 8004b9e:	f7fb fe27 	bl	80007f0 <chCondSignalI.constprop.61>
  chCondSignalI(&c1);
 8004ba2:	f7fb fe25 	bl	80007f0 <chCondSignalI.constprop.61>
  chCondSignalI(&c1);
 8004ba6:	f7fb fe23 	bl	80007f0 <chCondSignalI.constprop.61>
  chCondSignalI(&c1);
 8004baa:	f7fb fe21 	bl	80007f0 <chCondSignalI.constprop.61>
  chCondSignalI(&c1);
 8004bae:	f7fb fe1f 	bl	80007f0 <chCondSignalI.constprop.61>
  chSchRescheduleS();
 8004bb2:	f7fe fc65 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004bb6:	f7fe fedb 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004bba:	6826      	ldr	r6, [r4, #0]
 8004bbc:	42a6      	cmp	r6, r4
 8004bbe:	d004      	beq.n	8004bca <mtx6_execute.9259+0xba>
 8004bc0:	69a5      	ldr	r5, [r4, #24]
 8004bc2:	68b2      	ldr	r2, [r6, #8]
 8004bc4:	68a9      	ldr	r1, [r5, #8]
 8004bc6:	4291      	cmp	r1, r2
 8004bc8:	d30a      	bcc.n	8004be0 <mtx6_execute.9259+0xd0>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004bca:	b662      	cpsie	i
  chSysUnlock();
  test_wait_threads();
 8004bcc:	f7fc ffb0 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004bd0:	490e      	ldr	r1, [pc, #56]	; (8004c0c <mtx6_execute.9259+0xfc>)
 8004bd2:	2001      	movs	r0, #1
 8004bd4:	f7fb ff74 	bl	8000ac0 <_test_assert_sequence>
}
 8004bd8:	b002      	add	sp, #8
 8004bda:	bc04      	pop	{r2}
 8004bdc:	4690      	mov	r8, r2
 8004bde:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004be0:	b672      	cpsid	i
 8004be2:	480b      	ldr	r0, [pc, #44]	; (8004c10 <mtx6_execute.9259+0x100>)
 8004be4:	62e0      	str	r0, [r4, #44]	; 0x2c
 8004be6:	e7fe      	b.n	8004be6 <mtx6_execute.9259+0xd6>
 8004be8:	20001040 	.word	0x20001040
 8004bec:	080051a1 	.word	0x080051a1
 8004bf0:	080089b0 	.word	0x080089b0
 8004bf4:	200006b8 	.word	0x200006b8
 8004bf8:	200015b8 	.word	0x200015b8
 8004bfc:	080089a8 	.word	0x080089a8
 8004c00:	080089a0 	.word	0x080089a0
 8004c04:	080089a4 	.word	0x080089a4
 8004c08:	08008698 	.word	0x08008698
 8004c0c:	080089ac 	.word	0x080089ac
 8004c10:	08008b20 	.word	0x08008b20
 8004c14:	46c0      	nop			; (mov r8, r8)
 8004c16:	46c0      	nop			; (mov r8, r8)
 8004c18:	46c0      	nop			; (mov r8, r8)
 8004c1a:	46c0      	nop			; (mov r8, r8)
 8004c1c:	46c0      	nop			; (mov r8, r8)
 8004c1e:	46c0      	nop			; (mov r8, r8)

08004c20 <mtx4_execute.9265>:
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8004c20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c22:	465f      	mov	r7, fp
 8004c24:	4656      	mov	r6, sl
 8004c26:	464d      	mov	r5, r9
 8004c28:	4644      	mov	r4, r8
 8004c2a:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004c2c:	4d91      	ldr	r5, [pc, #580]	; (8004e74 <mtx4_execute.9265+0x254>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8004c2e:	4a92      	ldr	r2, [pc, #584]	; (8004e78 <mtx4_execute.9265+0x258>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004c30:	69ab      	ldr	r3, [r5, #24]
 8004c32:	4f92      	ldr	r7, [pc, #584]	; (8004e7c <mtx4_execute.9265+0x25c>)
 8004c34:	689c      	ldr	r4, [r3, #8]
 8004c36:	4e92      	ldr	r6, [pc, #584]	; (8004e80 <mtx4_execute.9265+0x260>)

static void mtx4_execute(void) {
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8004c38:	1c60      	adds	r0, r4, #1
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8004c3a:	b083      	sub	sp, #12
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8004c3c:	4680      	mov	r8, r0
  p2 = p + 2;
 8004c3e:	1ca1      	adds	r1, r4, #2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8004c40:	4693      	mov	fp, r2
 8004c42:	23a8      	movs	r3, #168	; 0xa8
static void mtx4_execute(void) {
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
 8004c44:	4689      	mov	r9, r1
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8004c46:	9600      	str	r6, [sp, #0]
 8004c48:	0059      	lsls	r1, r3, #1
 8004c4a:	4642      	mov	r2, r8
 8004c4c:	465b      	mov	r3, fp
 8004c4e:	1c38      	adds	r0, r7, #0
 8004c50:	f7fe f8fe 	bl	8002e50 <chThdCreateStatic>
 8004c54:	4e8b      	ldr	r6, [pc, #556]	; (8004e84 <mtx4_execute.9265+0x264>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8004c56:	4b8c      	ldr	r3, [pc, #560]	; (8004e88 <mtx4_execute.9265+0x268>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8004c58:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8004c5a:	20a8      	movs	r0, #168	; 0xa8
 8004c5c:	0041      	lsls	r1, r0, #1
 8004c5e:	19ca      	adds	r2, r1, r7
 8004c60:	21a8      	movs	r1, #168	; 0xa8
 8004c62:	0049      	lsls	r1, r1, #1
 8004c64:	9300      	str	r3, [sp, #0]
 8004c66:	1c10      	adds	r0, r2, #0
 8004c68:	4b88      	ldr	r3, [pc, #544]	; (8004e8c <mtx4_execute.9265+0x26c>)
 8004c6a:	4692      	mov	sl, r2
 8004c6c:	464a      	mov	r2, r9
 8004c6e:	f7fe f8ef 	bl	8002e50 <chThdCreateStatic>
 8004c72:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 8004c74:	4886      	ldr	r0, [pc, #536]	; (8004e90 <mtx4_execute.9265+0x270>)
 8004c76:	f7fd fd9b 	bl	80027b0 <chMtxLock>
 8004c7a:	69a8      	ldr	r0, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 8004c7c:	6882      	ldr	r2, [r0, #8]
 8004c7e:	2001      	movs	r0, #1
 8004c80:	1aa1      	subs	r1, r4, r2
 8004c82:	424b      	negs	r3, r1
 8004c84:	4159      	adcs	r1, r3
 8004c86:	f7fb ff6b 	bl	8000b60 <_test_assert>
 8004c8a:	2800      	cmp	r0, #0
 8004c8c:	d006      	beq.n	8004c9c <mtx4_execute.9265+0x7c>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 8004c8e:	b003      	add	sp, #12
 8004c90:	bc3c      	pop	{r2, r3, r4, r5}
 8004c92:	4690      	mov	r8, r2
 8004c94:	4699      	mov	r9, r3
 8004c96:	46a2      	mov	sl, r4
 8004c98:	46ab      	mov	fp, r5
 8004c9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 8004c9c:	23fa      	movs	r3, #250	; 0xfa
 8004c9e:	0098      	lsls	r0, r3, #2
 8004ca0:	f7fd fd06 	bl	80026b0 <chThdSleep>
 8004ca4:	69a9      	ldr	r1, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 8004ca6:	4642      	mov	r2, r8
 8004ca8:	6888      	ldr	r0, [r1, #8]
 8004caa:	1a11      	subs	r1, r2, r0
 8004cac:	424b      	negs	r3, r1
 8004cae:	4159      	adcs	r1, r3
 8004cb0:	2002      	movs	r0, #2
 8004cb2:	f7fb ff55 	bl	8000b60 <_test_assert>
 8004cb6:	2800      	cmp	r0, #0
 8004cb8:	d1e9      	bne.n	8004c8e <mtx4_execute.9265+0x6e>
  chMtxLock(&m1);
 8004cba:	4876      	ldr	r0, [pc, #472]	; (8004e94 <mtx4_execute.9265+0x274>)
 8004cbc:	f7fd fd78 	bl	80027b0 <chMtxLock>
 8004cc0:	69ab      	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8004cc2:	4640      	mov	r0, r8
 8004cc4:	6899      	ldr	r1, [r3, #8]
 8004cc6:	1a41      	subs	r1, r0, r1
 8004cc8:	424b      	negs	r3, r1
 8004cca:	4159      	adcs	r1, r3
 8004ccc:	2003      	movs	r0, #3
 8004cce:	f7fb ff47 	bl	8000b60 <_test_assert>
 8004cd2:	2800      	cmp	r0, #0
 8004cd4:	d1db      	bne.n	8004c8e <mtx4_execute.9265+0x6e>
  chThdSleepMilliseconds(100);
 8004cd6:	22fa      	movs	r2, #250	; 0xfa
 8004cd8:	0090      	lsls	r0, r2, #2
 8004cda:	f7fd fce9 	bl	80026b0 <chThdSleep>
 8004cde:	69ab      	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 8004ce0:	4648      	mov	r0, r9
 8004ce2:	6899      	ldr	r1, [r3, #8]
 8004ce4:	1a41      	subs	r1, r0, r1
 8004ce6:	424b      	negs	r3, r1
 8004ce8:	4159      	adcs	r1, r3
 8004cea:	2004      	movs	r0, #4
 8004cec:	f7fb ff38 	bl	8000b60 <_test_assert>
 8004cf0:	2800      	cmp	r0, #0
 8004cf2:	d1cc      	bne.n	8004c8e <mtx4_execute.9265+0x6e>
  chMtxUnlock(&m1);
 8004cf4:	4867      	ldr	r0, [pc, #412]	; (8004e94 <mtx4_execute.9265+0x274>)
 8004cf6:	f7fd fd7b 	bl	80027f0 <chMtxUnlock>
 8004cfa:	69aa      	ldr	r2, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 8004cfc:	4643      	mov	r3, r8
 8004cfe:	6891      	ldr	r1, [r2, #8]
 8004d00:	2005      	movs	r0, #5
 8004d02:	1a59      	subs	r1, r3, r1
 8004d04:	424b      	negs	r3, r1
 8004d06:	4159      	adcs	r1, r3
 8004d08:	f7fb ff2a 	bl	8000b60 <_test_assert>
 8004d0c:	2800      	cmp	r0, #0
 8004d0e:	d1be      	bne.n	8004c8e <mtx4_execute.9265+0x6e>
  chThdSleepMilliseconds(100);
 8004d10:	20fa      	movs	r0, #250	; 0xfa
 8004d12:	0080      	lsls	r0, r0, #2
 8004d14:	f7fd fccc 	bl	80026b0 <chThdSleep>
 8004d18:	69aa      	ldr	r2, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 8004d1a:	4643      	mov	r3, r8
 8004d1c:	6891      	ldr	r1, [r2, #8]
 8004d1e:	2006      	movs	r0, #6
 8004d20:	1a59      	subs	r1, r3, r1
 8004d22:	424b      	negs	r3, r1
 8004d24:	4159      	adcs	r1, r3
 8004d26:	f7fb ff1b 	bl	8000b60 <_test_assert>
 8004d2a:	2800      	cmp	r0, #0
 8004d2c:	d1af      	bne.n	8004c8e <mtx4_execute.9265+0x6e>
  chMtxUnlockAll();
 8004d2e:	f7ff f907 	bl	8003f40 <chMtxUnlockAll>
 8004d32:	69a8      	ldr	r0, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 8004d34:	6882      	ldr	r2, [r0, #8]
 8004d36:	2007      	movs	r0, #7
 8004d38:	1aa1      	subs	r1, r4, r2
 8004d3a:	424b      	negs	r3, r1
 8004d3c:	4159      	adcs	r1, r3
 8004d3e:	f7fb ff0f 	bl	8000b60 <_test_assert>
 8004d42:	2800      	cmp	r0, #0
 8004d44:	d1a3      	bne.n	8004c8e <mtx4_execute.9265+0x6e>
  test_wait_threads();
 8004d46:	f7fc fef3 	bl	8001b30 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8004d4a:	4953      	ldr	r1, [pc, #332]	; (8004e98 <mtx4_execute.9265+0x278>)
 8004d4c:	1c38      	adds	r0, r7, #0
 8004d4e:	27a8      	movs	r7, #168	; 0xa8
 8004d50:	9100      	str	r1, [sp, #0]
 8004d52:	4642      	mov	r2, r8
 8004d54:	0079      	lsls	r1, r7, #1
 8004d56:	465b      	mov	r3, fp
 8004d58:	f7fe f87a 	bl	8002e50 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8004d5c:	4b4f      	ldr	r3, [pc, #316]	; (8004e9c <mtx4_execute.9265+0x27c>)
 8004d5e:	22a8      	movs	r2, #168	; 0xa8
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8004d60:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8004d62:	0051      	lsls	r1, r2, #1
 8004d64:	9300      	str	r3, [sp, #0]
 8004d66:	464a      	mov	r2, r9
 8004d68:	4b48      	ldr	r3, [pc, #288]	; (8004e8c <mtx4_execute.9265+0x26c>)
 8004d6a:	4650      	mov	r0, sl
 8004d6c:	f7fe f870 	bl	8002e50 <chThdCreateStatic>
 8004d70:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 8004d72:	4847      	ldr	r0, [pc, #284]	; (8004e90 <mtx4_execute.9265+0x270>)
 8004d74:	f7fd fd1c 	bl	80027b0 <chMtxLock>
 8004d78:	69ae      	ldr	r6, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8004d7a:	68b0      	ldr	r0, [r6, #8]
 8004d7c:	1a21      	subs	r1, r4, r0
 8004d7e:	424b      	negs	r3, r1
 8004d80:	4159      	adcs	r1, r3
 8004d82:	2008      	movs	r0, #8
 8004d84:	f7fb feec 	bl	8000b60 <_test_assert>
 8004d88:	2800      	cmp	r0, #0
 8004d8a:	d000      	beq.n	8004d8e <mtx4_execute.9265+0x16e>
 8004d8c:	e77f      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  chThdSleepMilliseconds(100);
 8004d8e:	21fa      	movs	r1, #250	; 0xfa
 8004d90:	0088      	lsls	r0, r1, #2
 8004d92:	f7fd fc8d 	bl	80026b0 <chThdSleep>
 8004d96:	69af      	ldr	r7, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 8004d98:	4643      	mov	r3, r8
 8004d9a:	68ba      	ldr	r2, [r7, #8]
 8004d9c:	2009      	movs	r0, #9
 8004d9e:	1a99      	subs	r1, r3, r2
 8004da0:	424b      	negs	r3, r1
 8004da2:	4159      	adcs	r1, r3
 8004da4:	f7fb fedc 	bl	8000b60 <_test_assert>
 8004da8:	2800      	cmp	r0, #0
 8004daa:	d000      	beq.n	8004dae <mtx4_execute.9265+0x18e>
 8004dac:	e76f      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  chMtxLock(&m1);
 8004dae:	4839      	ldr	r0, [pc, #228]	; (8004e94 <mtx4_execute.9265+0x274>)
 8004db0:	f7fd fcfe 	bl	80027b0 <chMtxLock>
 8004db4:	69ae      	ldr	r6, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 8004db6:	4641      	mov	r1, r8
 8004db8:	68b0      	ldr	r0, [r6, #8]
 8004dba:	1a09      	subs	r1, r1, r0
 8004dbc:	424b      	negs	r3, r1
 8004dbe:	4159      	adcs	r1, r3
 8004dc0:	200a      	movs	r0, #10
 8004dc2:	f7fb fecd 	bl	8000b60 <_test_assert>
 8004dc6:	2800      	cmp	r0, #0
 8004dc8:	d000      	beq.n	8004dcc <mtx4_execute.9265+0x1ac>
 8004dca:	e760      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  chThdSleepMilliseconds(100);
 8004dcc:	27fa      	movs	r7, #250	; 0xfa
 8004dce:	00b8      	lsls	r0, r7, #2
 8004dd0:	f7fd fc6e 	bl	80026b0 <chThdSleep>
 8004dd4:	69aa      	ldr	r2, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 8004dd6:	464b      	mov	r3, r9
 8004dd8:	6896      	ldr	r6, [r2, #8]
 8004dda:	200b      	movs	r0, #11
 8004ddc:	1b99      	subs	r1, r3, r6
 8004dde:	424b      	negs	r3, r1
 8004de0:	4159      	adcs	r1, r3
 8004de2:	f7fb febd 	bl	8000b60 <_test_assert>
 8004de6:	2800      	cmp	r0, #0
 8004de8:	d000      	beq.n	8004dec <mtx4_execute.9265+0x1cc>
 8004dea:	e750      	b.n	8004c8e <mtx4_execute.9265+0x6e>
 8004dec:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004dee:	f7fe fe57 	bl	8003aa0 <_dbg_check_lock>
  chSysLock();
  chMtxUnlockS(&m1);
 8004df2:	4828      	ldr	r0, [pc, #160]	; (8004e94 <mtx4_execute.9265+0x274>)
 8004df4:	f7fe fac4 	bl	8003380 <chMtxUnlockS>
  chSchRescheduleS();
 8004df8:	f7fe fb42 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004dfc:	f7fe fdb8 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004e00:	6828      	ldr	r0, [r5, #0]
 8004e02:	42a8      	cmp	r0, r5
 8004e04:	d004      	beq.n	8004e10 <mtx4_execute.9265+0x1f0>
 8004e06:	69a9      	ldr	r1, [r5, #24]
 8004e08:	6882      	ldr	r2, [r0, #8]
 8004e0a:	688f      	ldr	r7, [r1, #8]
 8004e0c:	4297      	cmp	r7, r2
 8004e0e:	d32c      	bcc.n	8004e6a <mtx4_execute.9265+0x24a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004e10:	b662      	cpsie	i
 8004e12:	69ae      	ldr	r6, [r5, #24]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 8004e14:	4643      	mov	r3, r8
 8004e16:	68b0      	ldr	r0, [r6, #8]
 8004e18:	1a19      	subs	r1, r3, r0
 8004e1a:	424b      	negs	r3, r1
 8004e1c:	4159      	adcs	r1, r3
 8004e1e:	200c      	movs	r0, #12
 8004e20:	f7fb fe9e 	bl	8000b60 <_test_assert>
 8004e24:	2800      	cmp	r0, #0
 8004e26:	d000      	beq.n	8004e2a <mtx4_execute.9265+0x20a>
 8004e28:	e731      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  chThdSleepMilliseconds(100);
 8004e2a:	21fa      	movs	r1, #250	; 0xfa
 8004e2c:	0088      	lsls	r0, r1, #2
 8004e2e:	f7fd fc3f 	bl	80026b0 <chThdSleep>
 8004e32:	69af      	ldr	r7, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8004e34:	4646      	mov	r6, r8
 8004e36:	68ba      	ldr	r2, [r7, #8]
 8004e38:	200d      	movs	r0, #13
 8004e3a:	1ab1      	subs	r1, r6, r2
 8004e3c:	424b      	negs	r3, r1
 8004e3e:	4159      	adcs	r1, r3
 8004e40:	f7fb fe8e 	bl	8000b60 <_test_assert>
 8004e44:	2800      	cmp	r0, #0
 8004e46:	d000      	beq.n	8004e4a <mtx4_execute.9265+0x22a>
 8004e48:	e721      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  chMtxUnlockAll();
 8004e4a:	f7ff f879 	bl	8003f40 <chMtxUnlockAll>
 8004e4e:	69ad      	ldr	r5, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8004e50:	68a8      	ldr	r0, [r5, #8]
 8004e52:	1a21      	subs	r1, r4, r0
 8004e54:	424c      	negs	r4, r1
 8004e56:	4161      	adcs	r1, r4
 8004e58:	200e      	movs	r0, #14
 8004e5a:	f7fb fe81 	bl	8000b60 <_test_assert>
 8004e5e:	2800      	cmp	r0, #0
 8004e60:	d000      	beq.n	8004e64 <mtx4_execute.9265+0x244>
 8004e62:	e714      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  test_wait_threads();
 8004e64:	f7fc fe64 	bl	8001b30 <test_wait_threads>
 8004e68:	e711      	b.n	8004c8e <mtx4_execute.9265+0x6e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004e6a:	b672      	cpsid	i
 8004e6c:	4c0c      	ldr	r4, [pc, #48]	; (8004ea0 <mtx4_execute.9265+0x280>)
 8004e6e:	62ec      	str	r4, [r5, #44]	; 0x2c
 8004e70:	e7fe      	b.n	8004e70 <mtx4_execute.9265+0x250>
 8004e72:	46c0      	nop			; (mov r8, r8)
 8004e74:	20001040 	.word	0x20001040
 8004e78:	080028e1 	.word	0x080028e1
 8004e7c:	200006b8 	.word	0x200006b8
 8004e80:	080089a4 	.word	0x080089a4
 8004e84:	200015b8 	.word	0x200015b8
 8004e88:	08008698 	.word	0x08008698
 8004e8c:	080028c1 	.word	0x080028c1
 8004e90:	20000678 	.word	0x20000678
 8004e94:	20000694 	.word	0x20000694
 8004e98:	080089a8 	.word	0x080089a8
 8004e9c:	080089a0 	.word	0x080089a0
 8004ea0:	08008b20 	.word	0x08008b20
 8004ea4:	46c0      	nop			; (mov r8, r8)
 8004ea6:	46c0      	nop			; (mov r8, r8)
 8004ea8:	46c0      	nop			; (mov r8, r8)
 8004eaa:	46c0      	nop			; (mov r8, r8)
 8004eac:	46c0      	nop			; (mov r8, r8)
 8004eae:	46c0      	nop			; (mov r8, r8)

08004eb0 <dyn2_execute.10182>:
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 8004eb0:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004eb2:	4c61      	ldr	r4, [pc, #388]	; (8005038 <dyn2_execute.10182+0x188>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004eb4:	69a3      	ldr	r3, [r4, #24]
 8004eb6:	689e      	ldr	r6, [r3, #8]
 8004eb8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004eba:	f7fe fdf1 	bl	8003aa0 <_dbg_check_lock>
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);
 8004ebe:	4d5f      	ldr	r5, [pc, #380]	; (800503c <dyn2_execute.10182+0x18c>)
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 8004ec0:	495f      	ldr	r1, [pc, #380]	; (8005040 <dyn2_execute.10182+0x190>)
 8004ec2:	1c28      	adds	r0, r5, #0
 8004ec4:	f7fb fcac 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004ec8:	f7fe fd52 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004ecc:	6820      	ldr	r0, [r4, #0]
 8004ece:	42a0      	cmp	r0, r4
 8004ed0:	d005      	beq.n	8004ede <dyn2_execute.10182+0x2e>
 8004ed2:	69a2      	ldr	r2, [r4, #24]
 8004ed4:	6883      	ldr	r3, [r0, #8]
 8004ed6:	6891      	ldr	r1, [r2, #8]
 8004ed8:	4299      	cmp	r1, r3
 8004eda:	d200      	bcs.n	8004ede <dyn2_execute.10182+0x2e>
 8004edc:	e0a1      	b.n	8005022 <dyn2_execute.10182+0x172>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004ede:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004ee0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004ee2:	f7fe fddd 	bl	8003aa0 <_dbg_check_lock>
 8004ee6:	1c28      	adds	r0, r5, #0
 8004ee8:	4956      	ldr	r1, [pc, #344]	; (8005044 <dyn2_execute.10182+0x194>)
 8004eea:	f7fb fc99 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004eee:	f7fe fd3f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004ef2:	6820      	ldr	r0, [r4, #0]
 8004ef4:	42a0      	cmp	r0, r4
 8004ef6:	d005      	beq.n	8004f04 <dyn2_execute.10182+0x54>
 8004ef8:	69a2      	ldr	r2, [r4, #24]
 8004efa:	6883      	ldr	r3, [r0, #8]
 8004efc:	6891      	ldr	r1, [r2, #8]
 8004efe:	4299      	cmp	r1, r3
 8004f00:	d200      	bcs.n	8004f04 <dyn2_execute.10182+0x54>
 8004f02:	e08e      	b.n	8005022 <dyn2_execute.10182+0x172>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004f04:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004f06:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004f08:	f7fe fdca 	bl	8003aa0 <_dbg_check_lock>
 8004f0c:	1c28      	adds	r0, r5, #0
 8004f0e:	494e      	ldr	r1, [pc, #312]	; (8005048 <dyn2_execute.10182+0x198>)
 8004f10:	f7fb fc86 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004f14:	f7fe fd2c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004f18:	6820      	ldr	r0, [r4, #0]
 8004f1a:	42a0      	cmp	r0, r4
 8004f1c:	d004      	beq.n	8004f28 <dyn2_execute.10182+0x78>
 8004f1e:	69a2      	ldr	r2, [r4, #24]
 8004f20:	6883      	ldr	r3, [r0, #8]
 8004f22:	6891      	ldr	r1, [r2, #8]
 8004f24:	4299      	cmp	r1, r3
 8004f26:	d37c      	bcc.n	8005022 <dyn2_execute.10182+0x172>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004f28:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004f2a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004f2c:	f7fe fdb8 	bl	8003aa0 <_dbg_check_lock>
 8004f30:	1c28      	adds	r0, r5, #0
 8004f32:	4946      	ldr	r1, [pc, #280]	; (800504c <dyn2_execute.10182+0x19c>)
 8004f34:	f7fb fc74 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004f38:	f7fe fd1a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004f3c:	6820      	ldr	r0, [r4, #0]
 8004f3e:	42a0      	cmp	r0, r4
 8004f40:	d004      	beq.n	8004f4c <dyn2_execute.10182+0x9c>
 8004f42:	69a2      	ldr	r2, [r4, #24]
 8004f44:	6883      	ldr	r3, [r0, #8]
 8004f46:	6891      	ldr	r1, [r2, #8]
 8004f48:	4299      	cmp	r1, r3
 8004f4a:	d36a      	bcc.n	8005022 <dyn2_execute.10182+0x172>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004f4c:	b662      	cpsie	i

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8004f4e:	4940      	ldr	r1, [pc, #256]	; (8005050 <dyn2_execute.10182+0x1a0>)
 8004f50:	1e70      	subs	r0, r6, #1
 8004f52:	f7fd f8cd 	bl	80020f0 <chThdCreateFromMemoryPool.constprop.70>
 8004f56:	4c3f      	ldr	r4, [pc, #252]	; (8005054 <dyn2_execute.10182+0x1a4>)
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8004f58:	493f      	ldr	r1, [pc, #252]	; (8005058 <dyn2_execute.10182+0x1a8>)
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8004f5a:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8004f5c:	1eb0      	subs	r0, r6, #2
 8004f5e:	f7fd f8c7 	bl	80020f0 <chThdCreateFromMemoryPool.constprop.70>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8004f62:	493e      	ldr	r1, [pc, #248]	; (800505c <dyn2_execute.10182+0x1ac>)
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8004f64:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8004f66:	1ef0      	subs	r0, r6, #3
 8004f68:	f7fd f8c2 	bl	80020f0 <chThdCreateFromMemoryPool.constprop.70>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8004f6c:	493c      	ldr	r1, [pc, #240]	; (8005060 <dyn2_execute.10182+0x1b0>)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8004f6e:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8004f70:	1f30      	subs	r0, r6, #4
 8004f72:	f7fd f8bd 	bl	80020f0 <chThdCreateFromMemoryPool.constprop.70>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8004f76:	493b      	ldr	r1, [pc, #236]	; (8005064 <dyn2_execute.10182+0x1b4>)

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8004f78:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8004f7a:	1f70      	subs	r0, r6, #5
 8004f7c:	f7fd f8b8 	bl	80020f0 <chThdCreateFromMemoryPool.constprop.70>

  test_assert(1, (threads[0] != NULL) &&
 8004f80:	6826      	ldr	r6, [r4, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8004f82:	6120      	str	r0, [r4, #16]

  test_assert(1, (threads[0] != NULL) &&
 8004f84:	2e00      	cmp	r6, #0
 8004f86:	d050      	beq.n	800502a <dyn2_execute.10182+0x17a>
 8004f88:	6862      	ldr	r2, [r4, #4]
 8004f8a:	2a00      	cmp	r2, #0
 8004f8c:	d04d      	beq.n	800502a <dyn2_execute.10182+0x17a>
 8004f8e:	68a1      	ldr	r1, [r4, #8]
 8004f90:	2900      	cmp	r1, #0
 8004f92:	d04a      	beq.n	800502a <dyn2_execute.10182+0x17a>
 8004f94:	68e3      	ldr	r3, [r4, #12]
 8004f96:	2b00      	cmp	r3, #0
 8004f98:	d047      	beq.n	800502a <dyn2_execute.10182+0x17a>
 8004f9a:	4241      	negs	r1, r0
 8004f9c:	4141      	adcs	r1, r0
 8004f9e:	2001      	movs	r0, #1
 8004fa0:	f7fb fdde 	bl	8000b60 <_test_assert>
 8004fa4:	2800      	cmp	r0, #0
 8004fa6:	d146      	bne.n	8005036 <dyn2_execute.10182+0x186>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8004fa8:	f7fc fdc2 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8004fac:	2002      	movs	r0, #2
 8004fae:	492e      	ldr	r1, [pc, #184]	; (8005068 <dyn2_execute.10182+0x1b8>)
 8004fb0:	f7fb fd86 	bl	8000ac0 <_test_assert_sequence>
 8004fb4:	2800      	cmp	r0, #0
 8004fb6:	d13e      	bne.n	8005036 <dyn2_execute.10182+0x186>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8004fb8:	1c28      	adds	r0, r5, #0
 8004fba:	f7ff f8f1 	bl	80041a0 <chPoolAlloc>
 8004fbe:	1c01      	adds	r1, r0, #0
 8004fc0:	1e48      	subs	r0, r1, #1
 8004fc2:	4181      	sbcs	r1, r0
 8004fc4:	2003      	movs	r0, #3
 8004fc6:	f7fb fdcb 	bl	8000b60 <_test_assert>
 8004fca:	2800      	cmp	r0, #0
 8004fcc:	d133      	bne.n	8005036 <dyn2_execute.10182+0x186>
 8004fce:	1c28      	adds	r0, r5, #0
 8004fd0:	f7ff f8e6 	bl	80041a0 <chPoolAlloc>
 8004fd4:	1c01      	adds	r1, r0, #0
 8004fd6:	1e48      	subs	r0, r1, #1
 8004fd8:	4181      	sbcs	r1, r0
 8004fda:	2003      	movs	r0, #3
 8004fdc:	f7fb fdc0 	bl	8000b60 <_test_assert>
 8004fe0:	2800      	cmp	r0, #0
 8004fe2:	d128      	bne.n	8005036 <dyn2_execute.10182+0x186>
 8004fe4:	1c28      	adds	r0, r5, #0
 8004fe6:	f7ff f8db 	bl	80041a0 <chPoolAlloc>
 8004fea:	1c01      	adds	r1, r0, #0
 8004fec:	1e48      	subs	r0, r1, #1
 8004fee:	4181      	sbcs	r1, r0
 8004ff0:	2003      	movs	r0, #3
 8004ff2:	f7fb fdb5 	bl	8000b60 <_test_assert>
 8004ff6:	2800      	cmp	r0, #0
 8004ff8:	d11d      	bne.n	8005036 <dyn2_execute.10182+0x186>
 8004ffa:	1c28      	adds	r0, r5, #0
 8004ffc:	f7ff f8d0 	bl	80041a0 <chPoolAlloc>
 8005000:	1c01      	adds	r1, r0, #0
 8005002:	1e48      	subs	r0, r1, #1
 8005004:	4181      	sbcs	r1, r0
 8005006:	2003      	movs	r0, #3
 8005008:	f7fb fdaa 	bl	8000b60 <_test_assert>
 800500c:	2800      	cmp	r0, #0
 800500e:	d112      	bne.n	8005036 <dyn2_execute.10182+0x186>
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8005010:	1c28      	adds	r0, r5, #0
 8005012:	f7ff f8c5 	bl	80041a0 <chPoolAlloc>
 8005016:	4241      	negs	r1, r0
 8005018:	4141      	adcs	r1, r0
 800501a:	2004      	movs	r0, #4
 800501c:	f7fb fda0 	bl	8000b60 <_test_assert>
 8005020:	e009      	b.n	8005036 <dyn2_execute.10182+0x186>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005022:	b672      	cpsid	i
 8005024:	4d11      	ldr	r5, [pc, #68]	; (800506c <dyn2_execute.10182+0x1bc>)
 8005026:	62e5      	str	r5, [r4, #44]	; 0x2c
 8005028:	e7fe      	b.n	8005028 <dyn2_execute.10182+0x178>
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");

  test_assert(1, (threads[0] != NULL) &&
 800502a:	2100      	movs	r1, #0
 800502c:	2001      	movs	r0, #1
 800502e:	f7fb fd97 	bl	8000b60 <_test_assert>
 8005032:	2800      	cmp	r0, #0
 8005034:	d0b8      	beq.n	8004fa8 <dyn2_execute.10182+0xf8>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
}
 8005036:	bd70      	pop	{r4, r5, r6, pc}
 8005038:	20001040 	.word	0x20001040
 800503c:	20000d78 	.word	0x20000d78
 8005040:	200006b8 	.word	0x200006b8
 8005044:	20000808 	.word	0x20000808
 8005048:	20000958 	.word	0x20000958
 800504c:	20000aa8 	.word	0x20000aa8
 8005050:	08008698 	.word	0x08008698
 8005054:	200015b8 	.word	0x200015b8
 8005058:	080089a4 	.word	0x080089a4
 800505c:	080089a0 	.word	0x080089a0
 8005060:	080089a8 	.word	0x080089a8
 8005064:	080089b0 	.word	0x080089b0
 8005068:	080085e0 	.word	0x080085e0
 800506c:	08008980 	.word	0x08008980

08005070 <_test_assert_time_window>:
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 8005070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005072:	1c05      	adds	r5, r0, #0
 8005074:	1c0c      	adds	r4, r1, #0
 8005076:	1c16      	adds	r6, r2, #0
 8005078:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800507a:	f7fe fd11 	bl	8003aa0 <_dbg_check_lock>
 800507e:	2380      	movs	r3, #128	; 0x80
 8005080:	05d8      	lsls	r0, r3, #23
 8005082:	6a47      	ldr	r7, [r0, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005084:	f7fe fc74 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005088:	4b0d      	ldr	r3, [pc, #52]	; (80050c0 <_test_assert_time_window+0x50>)
 800508a:	6819      	ldr	r1, [r3, #0]
 800508c:	4299      	cmp	r1, r3
 800508e:	d004      	beq.n	800509a <_test_assert_time_window+0x2a>
 8005090:	699a      	ldr	r2, [r3, #24]
 8005092:	6889      	ldr	r1, [r1, #8]
 8005094:	6890      	ldr	r0, [r2, #8]
 8005096:	4288      	cmp	r0, r1
 8005098:	d30e      	bcc.n	80050b8 <_test_assert_time_window+0x48>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800509a:	b662      	cpsie	i

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 800509c:	2000      	movs	r0, #0
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800509e:	1b3f      	subs	r7, r7, r4
 80050a0:	1b34      	subs	r4, r6, r4
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 80050a2:	42a7      	cmp	r7, r4
 80050a4:	d307      	bcc.n	80050b6 <_test_assert_time_window+0x46>
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
  failpoint = point;
 80050a6:	4807      	ldr	r0, [pc, #28]	; (80050c4 <_test_assert_time_window+0x54>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 80050a8:	4b07      	ldr	r3, [pc, #28]	; (80050c8 <_test_assert_time_window+0x58>)
  local_fail = TRUE;
 80050aa:	4a08      	ldr	r2, [pc, #32]	; (80050cc <_test_assert_time_window+0x5c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 80050ac:	2601      	movs	r6, #1
  local_fail = TRUE;
  failpoint = point;
 80050ae:	6005      	str	r5, [r0, #0]
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 80050b0:	701e      	strb	r6, [r3, #0]
  local_fail = TRUE;
 80050b2:	7016      	strb	r6, [r2, #0]
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
 80050b4:	2001      	movs	r0, #1
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 80050b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80050b8:	b672      	cpsid	i
 80050ba:	4d05      	ldr	r5, [pc, #20]	; (80050d0 <_test_assert_time_window+0x60>)
 80050bc:	62dd      	str	r5, [r3, #44]	; 0x2c
 80050be:	e7fe      	b.n	80050be <_test_assert_time_window+0x4e>
 80050c0:	20001040 	.word	0x20001040
 80050c4:	20000fb4 	.word	0x20000fb4
 80050c8:	20000fb0 	.word	0x20000fb0
 80050cc:	20000f80 	.word	0x20000f80
 80050d0:	08008a00 	.word	0x08008a00
 80050d4:	46c0      	nop			; (mov r8, r8)
 80050d6:	46c0      	nop			; (mov r8, r8)
 80050d8:	46c0      	nop			; (mov r8, r8)
 80050da:	46c0      	nop			; (mov r8, r8)
 80050dc:	46c0      	nop			; (mov r8, r8)
 80050de:	46c0      	nop			; (mov r8, r8)

080050e0 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 80050e0:	b510      	push	{r4, lr}
 80050e2:	1c04      	adds	r4, r0, #0
 80050e4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80050e6:	f7fe fcdb 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  *tokp++ = token;
 80050ea:	4b0b      	ldr	r3, [pc, #44]	; (8005118 <test_emit_token+0x38>)
 80050ec:	681a      	ldr	r2, [r3, #0]
 80050ee:	7014      	strb	r4, [r2, #0]
 80050f0:	3201      	adds	r2, #1
 80050f2:	601a      	str	r2, [r3, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80050f4:	f7fe fc3c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80050f8:	4808      	ldr	r0, [pc, #32]	; (800511c <test_emit_token+0x3c>)
 80050fa:	6804      	ldr	r4, [r0, #0]
 80050fc:	4284      	cmp	r4, r0
 80050fe:	d004      	beq.n	800510a <test_emit_token+0x2a>
 8005100:	6981      	ldr	r1, [r0, #24]
 8005102:	68a2      	ldr	r2, [r4, #8]
 8005104:	688b      	ldr	r3, [r1, #8]
 8005106:	4293      	cmp	r3, r2
 8005108:	d301      	bcc.n	800510e <test_emit_token+0x2e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800510a:	b662      	cpsie	i
  chSysUnlock();
}
 800510c:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800510e:	b672      	cpsid	i
 8005110:	4c03      	ldr	r4, [pc, #12]	; (8005120 <test_emit_token+0x40>)
 8005112:	62c4      	str	r4, [r0, #44]	; 0x2c
 8005114:	e7fe      	b.n	8005114 <test_emit_token+0x34>
 8005116:	46c0      	nop			; (mov r8, r8)
 8005118:	20000fb8 	.word	0x20000fb8
 800511c:	20001040 	.word	0x20001040
 8005120:	08008a00 	.word	0x08008a00
 8005124:	46c0      	nop			; (mov r8, r8)
 8005126:	46c0      	nop			; (mov r8, r8)
 8005128:	46c0      	nop			; (mov r8, r8)
 800512a:	46c0      	nop			; (mov r8, r8)
 800512c:	46c0      	nop			; (mov r8, r8)
 800512e:	46c0      	nop			; (mov r8, r8)

08005130 <thread.8719>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 8005130:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8005132:	7800      	ldrb	r0, [r0, #0]
 8005134:	f7ff ffd4 	bl	80050e0 <test_emit_token>
}
 8005138:	bd08      	pop	{r3, pc}
 800513a:	46c0      	nop			; (mov r8, r8)
 800513c:	46c0      	nop			; (mov r8, r8)
 800513e:	46c0      	nop			; (mov r8, r8)

08005140 <thread1.8986>:
static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread1, p) {
 8005140:	b510      	push	{r4, lr}
 8005142:	1c04      	adds	r4, r0, #0

  chSemWait(&sem1);
 8005144:	4803      	ldr	r0, [pc, #12]	; (8005154 <thread1.8986+0x14>)
 8005146:	f7fd f9e3 	bl	8002510 <chSemWait>
  test_emit_token(*(char *)p);
 800514a:	7820      	ldrb	r0, [r4, #0]
 800514c:	f7ff ffc8 	bl	80050e0 <test_emit_token>
}
 8005150:	bd10      	pop	{r4, pc}
 8005152:	46c0      	nop			; (mov r8, r8)
 8005154:	200006a4 	.word	0x200006a4
 8005158:	46c0      	nop			; (mov r8, r8)
 800515a:	46c0      	nop			; (mov r8, r8)
 800515c:	46c0      	nop			; (mov r8, r8)
 800515e:	46c0      	nop			; (mov r8, r8)

08005160 <thread12.9221>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 8005160:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 8005162:	4c06      	ldr	r4, [pc, #24]	; (800517c <thread12.9221+0x1c>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 8005164:	1c05      	adds	r5, r0, #0

  chMtxLock(&m2);
 8005166:	1c20      	adds	r0, r4, #0
 8005168:	f7fd fb22 	bl	80027b0 <chMtxLock>
  test_emit_token(*(char *)p);
 800516c:	7828      	ldrb	r0, [r5, #0]
 800516e:	f7ff ffb7 	bl	80050e0 <test_emit_token>
  chMtxUnlock(&m2);
 8005172:	1c20      	adds	r0, r4, #0
 8005174:	f7fd fb3c 	bl	80027f0 <chMtxUnlock>
}
 8005178:	bd38      	pop	{r3, r4, r5, pc}
 800517a:	46c0      	nop			; (mov r8, r8)
 800517c:	20000678 	.word	0x20000678

08005180 <thread1.9230>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8005180:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8005182:	4c06      	ldr	r4, [pc, #24]	; (800519c <thread1.9230+0x1c>)
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8005184:	1c05      	adds	r5, r0, #0

  chMtxLock(&m1);
 8005186:	1c20      	adds	r0, r4, #0
 8005188:	f7fd fb12 	bl	80027b0 <chMtxLock>
  test_emit_token(*(char *)p);
 800518c:	7828      	ldrb	r0, [r5, #0]
 800518e:	f7ff ffa7 	bl	80050e0 <test_emit_token>
  chMtxUnlock(&m1);
 8005192:	1c20      	adds	r0, r4, #0
 8005194:	f7fd fb2c 	bl	80027f0 <chMtxUnlock>
}
 8005198:	bd38      	pop	{r3, r4, r5, pc}
 800519a:	46c0      	nop			; (mov r8, r8)
 800519c:	20000694 	.word	0x20000694

080051a0 <thread10.9224>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 80051a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80051a2:	4647      	mov	r7, r8
 80051a4:	b480      	push	{r7}

  chMtxLock(&m1);
 80051a6:	4f22      	ldr	r7, [pc, #136]	; (8005230 <thread10.9224+0x90>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 80051a8:	4680      	mov	r8, r0

  chMtxLock(&m1);
 80051aa:	1c38      	adds	r0, r7, #0
 80051ac:	f7fd fb00 	bl	80027b0 <chMtxLock>
 80051b0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80051b2:	f7fe fc75 	bl	8003aa0 <_dbg_check_lock>
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 80051b6:	4d1f      	ldr	r5, [pc, #124]	; (8005234 <thread10.9224+0x94>)
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 80051b8:	f7fb fb4a 	bl	8000850 <chDbgCheckClassS>
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 80051bc:	69ac      	ldr	r4, [r5, #24]
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");
 80051be:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 80051c0:	2e00      	cmp	r6, #0
 80051c2:	d030      	beq.n	8005226 <thread10.9224+0x86>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 80051c4:	1c30      	adds	r0, r6, #0
 80051c6:	f7fe f8db 	bl	8003380 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 80051ca:	4a1b      	ldr	r2, [pc, #108]	; (8005238 <thread10.9224+0x98>)
 80051cc:	6262      	str	r2, [r4, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80051ce:	1c13      	adds	r3, r2, #0
  do {
    cp = cp->p_next;
 80051d0:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80051d2:	4293      	cmp	r3, r2
 80051d4:	d003      	beq.n	80051de <thread10.9224+0x3e>
 80051d6:	6898      	ldr	r0, [r3, #8]
 80051d8:	68a1      	ldr	r1, [r4, #8]
 80051da:	4288      	cmp	r0, r1
 80051dc:	d2f8      	bcs.n	80051d0 <thread10.9224+0x30>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80051de:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80051e0:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 80051e2:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 80051e4:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80051e6:	605c      	str	r4, [r3, #4]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 80051e8:	2007      	movs	r0, #7
 80051ea:	f7fb fe71 	bl	8000ed0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
  chMtxLockS(mp);
 80051ee:	1c30      	adds	r0, r6, #0
 80051f0:	f7fb fe96 	bl	8000f20 <chMtxLockS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80051f4:	f7fe fbbc 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80051f8:	682c      	ldr	r4, [r5, #0]
 80051fa:	42ac      	cmp	r4, r5
 80051fc:	d004      	beq.n	8005208 <thread10.9224+0x68>
 80051fe:	69ae      	ldr	r6, [r5, #24]
 8005200:	68a3      	ldr	r3, [r4, #8]
 8005202:	68b0      	ldr	r0, [r6, #8]
 8005204:	4298      	cmp	r0, r3
 8005206:	d30a      	bcc.n	800521e <thread10.9224+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005208:	b662      	cpsie	i
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 800520a:	4645      	mov	r5, r8
 800520c:	7828      	ldrb	r0, [r5, #0]
 800520e:	f7ff ff67 	bl	80050e0 <test_emit_token>
  chMtxUnlock(&m1);
 8005212:	1c38      	adds	r0, r7, #0
 8005214:	f7fd faec 	bl	80027f0 <chMtxUnlock>
}
 8005218:	bc04      	pop	{r2}
 800521a:	4690      	mov	r8, r2
 800521c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800521e:	b672      	cpsid	i
 8005220:	4f06      	ldr	r7, [pc, #24]	; (800523c <thread10.9224+0x9c>)
 8005222:	62ef      	str	r7, [r5, #44]	; 0x2c
 8005224:	e7fe      	b.n	8005224 <thread10.9224+0x84>
 8005226:	b672      	cpsid	i
 8005228:	4905      	ldr	r1, [pc, #20]	; (8005240 <thread10.9224+0xa0>)
 800522a:	62e9      	str	r1, [r5, #44]	; 0x2c
 800522c:	e7fe      	b.n	800522c <thread10.9224+0x8c>
 800522e:	46c0      	nop			; (mov r8, r8)
 8005230:	20000694 	.word	0x20000694
 8005234:	20001040 	.word	0x20001040
 8005238:	20000670 	.word	0x20000670
 800523c:	08008990 	.word	0x08008990
 8005240:	080089c0 	.word	0x080089c0
 8005244:	46c0      	nop			; (mov r8, r8)
 8005246:	46c0      	nop			; (mov r8, r8)
 8005248:	46c0      	nop			; (mov r8, r8)
 800524a:	46c0      	nop			; (mov r8, r8)
 800524c:	46c0      	nop			; (mov r8, r8)
 800524e:	46c0      	nop			; (mov r8, r8)

08005250 <thread11.9227>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8005250:	b5f0      	push	{r4, r5, r6, r7, lr}

  chMtxLock(&m2);
 8005252:	4e29      	ldr	r6, [pc, #164]	; (80052f8 <thread11.9227+0xa8>)
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8005254:	4647      	mov	r7, r8
 8005256:	b480      	push	{r7}
 8005258:	4680      	mov	r8, r0

  chMtxLock(&m2);
 800525a:	1c30      	adds	r0, r6, #0
 800525c:	f7fd faa8 	bl	80027b0 <chMtxLock>
  chMtxLock(&m1);
 8005260:	4f26      	ldr	r7, [pc, #152]	; (80052fc <thread11.9227+0xac>)
 8005262:	1c38      	adds	r0, r7, #0
 8005264:	f7fd faa4 	bl	80027b0 <chMtxLock>
 8005268:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800526a:	f7fe fc19 	bl	8003aa0 <_dbg_check_lock>
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 800526e:	f7fb faef 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");
 8005272:	4c23      	ldr	r4, [pc, #140]	; (8005300 <thread11.9227+0xb0>)
 8005274:	69a3      	ldr	r3, [r4, #24]
 8005276:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8005278:	2d00      	cmp	r5, #0
 800527a:	d039      	beq.n	80052f0 <thread11.9227+0xa0>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 800527c:	1c28      	adds	r0, r5, #0
 800527e:	f7fe f87f 	bl	8003380 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8005282:	4820      	ldr	r0, [pc, #128]	; (8005304 <thread11.9227+0xb4>)
 8005284:	69a2      	ldr	r2, [r4, #24]
 8005286:	4684      	mov	ip, r0
 8005288:	6250      	str	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800528a:	1c03      	adds	r3, r0, #0
  do {
    cp = cp->p_next;
 800528c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800528e:	4563      	cmp	r3, ip
 8005290:	d003      	beq.n	800529a <thread11.9227+0x4a>
 8005292:	6898      	ldr	r0, [r3, #8]
 8005294:	6891      	ldr	r1, [r2, #8]
 8005296:	4288      	cmp	r0, r1
 8005298:	d2f8      	bcs.n	800528c <thread11.9227+0x3c>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800529a:	6858      	ldr	r0, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800529c:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 800529e:	6050      	str	r0, [r2, #4]
  tp->p_prev->p_next = tp;
 80052a0:	6002      	str	r2, [r0, #0]
  cp->p_prev = tp;
 80052a2:	605a      	str	r2, [r3, #4]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 80052a4:	2201      	movs	r2, #1
 80052a6:	2007      	movs	r0, #7
 80052a8:	4251      	negs	r1, r2
 80052aa:	f7fb fec1 	bl	8001030 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 80052ae:	3001      	adds	r0, #1
 80052b0:	d002      	beq.n	80052b8 <thread11.9227+0x68>
    chMtxLockS(mp);
 80052b2:	1c28      	adds	r0, r5, #0
 80052b4:	f7fb fe34 	bl	8000f20 <chMtxLockS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80052b8:	f7fe fb5a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80052bc:	6825      	ldr	r5, [r4, #0]
 80052be:	42a5      	cmp	r5, r4
 80052c0:	d004      	beq.n	80052cc <thread11.9227+0x7c>
 80052c2:	69a3      	ldr	r3, [r4, #24]
 80052c4:	68a8      	ldr	r0, [r5, #8]
 80052c6:	6899      	ldr	r1, [r3, #8]
 80052c8:	4281      	cmp	r1, r0
 80052ca:	d30d      	bcc.n	80052e8 <thread11.9227+0x98>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80052cc:	b662      	cpsie	i
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 80052ce:	4644      	mov	r4, r8
 80052d0:	7820      	ldrb	r0, [r4, #0]
 80052d2:	f7ff ff05 	bl	80050e0 <test_emit_token>
  chMtxUnlock(&m1);
 80052d6:	1c38      	adds	r0, r7, #0
 80052d8:	f7fd fa8a 	bl	80027f0 <chMtxUnlock>
  chMtxUnlock(&m2);
 80052dc:	1c30      	adds	r0, r6, #0
 80052de:	f7fd fa87 	bl	80027f0 <chMtxUnlock>
}
 80052e2:	bc04      	pop	{r2}
 80052e4:	4690      	mov	r8, r2
 80052e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80052e8:	b672      	cpsid	i
 80052ea:	4e07      	ldr	r6, [pc, #28]	; (8005308 <thread11.9227+0xb8>)
 80052ec:	62e6      	str	r6, [r4, #44]	; 0x2c
 80052ee:	e7fe      	b.n	80052ee <thread11.9227+0x9e>
 80052f0:	b672      	cpsid	i
 80052f2:	4f06      	ldr	r7, [pc, #24]	; (800530c <thread11.9227+0xbc>)
 80052f4:	62e7      	str	r7, [r4, #44]	; 0x2c
 80052f6:	e7fe      	b.n	80052f6 <thread11.9227+0xa6>
 80052f8:	20000678 	.word	0x20000678
 80052fc:	20000694 	.word	0x20000694
 8005300:	20001040 	.word	0x20001040
 8005304:	20000670 	.word	0x20000670
 8005308:	08008990 	.word	0x08008990
 800530c:	080089d0 	.word	0x080089d0

08005310 <msg1_execute.9365>:

static void msg1_execute(void) {
 8005310:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005312:	4b17      	ldr	r3, [pc, #92]	; (8005370 <msg1_execute.9365+0x60>)
 8005314:	b082      	sub	sp, #8
 8005316:	6998      	ldr	r0, [r3, #24]
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005318:	21a8      	movs	r1, #168	; 0xa8
 800531a:	6882      	ldr	r2, [r0, #8]
 800531c:	4b15      	ldr	r3, [pc, #84]	; (8005374 <msg1_execute.9365+0x64>)
 800531e:	9000      	str	r0, [sp, #0]
 8005320:	0049      	lsls	r1, r1, #1
 8005322:	3201      	adds	r2, #1
 8005324:	4814      	ldr	r0, [pc, #80]	; (8005378 <msg1_execute.9365+0x68>)
 8005326:	f7fd fd93 	bl	8002e50 <chThdCreateStatic>
 800532a:	4a14      	ldr	r2, [pc, #80]	; (800537c <msg1_execute.9365+0x6c>)
 800532c:	6010      	str	r0, [r2, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800532e:	f7fe fe8f 	bl	8004050 <chMsgWait>
 8005332:	6b44      	ldr	r4, [r0, #52]	; 0x34
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8005334:	1c21      	adds	r1, r4, #0
 8005336:	f7fe fc5b 	bl	8003bf0 <chMsgRelease>
  test_emit_token(msg);
 800533a:	b2e0      	uxtb	r0, r4
 800533c:	f7ff fed0 	bl	80050e0 <test_emit_token>
  tp = chMsgWait();
 8005340:	f7fe fe86 	bl	8004050 <chMsgWait>
 8005344:	6b44      	ldr	r4, [r0, #52]	; 0x34
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8005346:	1c21      	adds	r1, r4, #0
 8005348:	f7fe fc52 	bl	8003bf0 <chMsgRelease>
  test_emit_token(msg);
 800534c:	b2e0      	uxtb	r0, r4
 800534e:	f7ff fec7 	bl	80050e0 <test_emit_token>
  tp = chMsgWait();
 8005352:	f7fe fe7d 	bl	8004050 <chMsgWait>
 8005356:	6b44      	ldr	r4, [r0, #52]	; 0x34
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8005358:	1c21      	adds	r1, r4, #0
 800535a:	f7fe fc49 	bl	8003bf0 <chMsgRelease>
  test_emit_token(msg);
 800535e:	b2e0      	uxtb	r0, r4
 8005360:	f7ff febe 	bl	80050e0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 8005364:	4906      	ldr	r1, [pc, #24]	; (8005380 <msg1_execute.9365+0x70>)
 8005366:	2001      	movs	r0, #1
 8005368:	f7fb fbaa 	bl	8000ac0 <_test_assert_sequence>
}
 800536c:	b002      	add	sp, #8
 800536e:	bd10      	pop	{r4, pc}
 8005370:	20001040 	.word	0x20001040
 8005374:	08003cc1 	.word	0x08003cc1
 8005378:	200006b8 	.word	0x200006b8
 800537c:	200015b8 	.word	0x200015b8
 8005380:	08008708 	.word	0x08008708
 8005384:	46c0      	nop			; (mov r8, r8)
 8005386:	46c0      	nop			; (mov r8, r8)
 8005388:	46c0      	nop			; (mov r8, r8)
 800538a:	46c0      	nop			; (mov r8, r8)
 800538c:	46c0      	nop			; (mov r8, r8)
 800538e:	46c0      	nop			; (mov r8, r8)

08005390 <h3.9789>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8005390:	b508      	push	{r3, lr}
 8005392:	2043      	movs	r0, #67	; 0x43
 8005394:	f7ff fea4 	bl	80050e0 <test_emit_token>
 8005398:	bd08      	pop	{r3, pc}
 800539a:	46c0      	nop			; (mov r8, r8)
 800539c:	46c0      	nop			; (mov r8, r8)
 800539e:	46c0      	nop			; (mov r8, r8)

080053a0 <h2.9792>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 80053a0:	b508      	push	{r3, lr}
 80053a2:	2042      	movs	r0, #66	; 0x42
 80053a4:	f7ff fe9c 	bl	80050e0 <test_emit_token>
 80053a8:	bd08      	pop	{r3, pc}
 80053aa:	46c0      	nop			; (mov r8, r8)
 80053ac:	46c0      	nop			; (mov r8, r8)
 80053ae:	46c0      	nop			; (mov r8, r8)

080053b0 <h1.9795>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80053b0:	b508      	push	{r3, lr}
 80053b2:	2041      	movs	r0, #65	; 0x41
 80053b4:	f7ff fe94 	bl	80050e0 <test_emit_token>
 80053b8:	bd08      	pop	{r3, pc}
 80053ba:	46c0      	nop			; (mov r8, r8)
 80053bc:	46c0      	nop			; (mov r8, r8)
 80053be:	46c0      	nop			; (mov r8, r8)

080053c0 <thread.10169>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 80053c0:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 80053c2:	7800      	ldrb	r0, [r0, #0]
 80053c4:	f7ff fe8c 	bl	80050e0 <test_emit_token>
}
 80053c8:	bd08      	pop	{r3, pc}
 80053ca:	46c0      	nop			; (mov r8, r8)
 80053cc:	46c0      	nop			; (mov r8, r8)
 80053ce:	46c0      	nop			; (mov r8, r8)

080053d0 <thread2.8992>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 80053d0:	20fa      	movs	r0, #250	; 0xfa
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread2, p) {
 80053d2:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 80053d4:	0040      	lsls	r0, r0, #1
 80053d6:	f7fd f96b 	bl	80026b0 <chThdSleep>
 80053da:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80053dc:	f7fe fb60 	bl	8003aa0 <_dbg_check_lock>
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 80053e0:	480a      	ldr	r0, [pc, #40]	; (800540c <thread2.8992+0x3c>)
 80053e2:	f7fe f8e5 	bl	80035b0 <chSemSignalI>
  chSchRescheduleS();
 80053e6:	f7fe f84b 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80053ea:	f7fe fac1 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80053ee:	4b08      	ldr	r3, [pc, #32]	; (8005410 <thread2.8992+0x40>)
 80053f0:	681a      	ldr	r2, [r3, #0]
 80053f2:	429a      	cmp	r2, r3
 80053f4:	d004      	beq.n	8005400 <thread2.8992+0x30>
 80053f6:	6999      	ldr	r1, [r3, #24]
 80053f8:	6892      	ldr	r2, [r2, #8]
 80053fa:	6888      	ldr	r0, [r1, #8]
 80053fc:	4290      	cmp	r0, r2
 80053fe:	d301      	bcc.n	8005404 <thread2.8992+0x34>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005400:	b662      	cpsie	i
  chSysUnlock();
}
 8005402:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005404:	b672      	cpsid	i
 8005406:	4903      	ldr	r1, [pc, #12]	; (8005414 <thread2.8992+0x44>)
 8005408:	62d9      	str	r1, [r3, #44]	; 0x2c
 800540a:	e7fe      	b.n	800540a <thread2.8992+0x3a>
 800540c:	200006a4 	.word	0x200006a4
 8005410:	20001040 	.word	0x20001040
 8005414:	080085d0 	.word	0x080085d0
 8005418:	46c0      	nop			; (mov r8, r8)
 800541a:	46c0      	nop			; (mov r8, r8)
 800541c:	46c0      	nop			; (mov r8, r8)
 800541e:	46c0      	nop			; (mov r8, r8)

08005420 <chMtxTryLock.constprop.64>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8005420:	b538      	push	{r3, r4, r5, lr}
 8005422:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005424:	f7fe fb3c 	bl	8003aa0 <_dbg_check_lock>
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
 8005428:	f7fb fa12 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 800542c:	4b0f      	ldr	r3, [pc, #60]	; (800546c <chMtxTryLock.constprop.64+0x4c>)
 800542e:	6899      	ldr	r1, [r3, #8]
 8005430:	2900      	cmp	r1, #0
 8005432:	d00e      	beq.n	8005452 <chMtxTryLock.constprop.64+0x32>
 8005434:	4c0e      	ldr	r4, [pc, #56]	; (8005470 <chMtxTryLock.constprop.64+0x50>)
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 8005436:	2500      	movs	r5, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005438:	f7fe fa9a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800543c:	6823      	ldr	r3, [r4, #0]
 800543e:	42a3      	cmp	r3, r4
 8005440:	d004      	beq.n	800544c <chMtxTryLock.constprop.64+0x2c>
 8005442:	69a1      	ldr	r1, [r4, #24]
 8005444:	6898      	ldr	r0, [r3, #8]
 8005446:	688a      	ldr	r2, [r1, #8]
 8005448:	4282      	cmp	r2, r0
 800544a:	d30a      	bcc.n	8005462 <chMtxTryLock.constprop.64+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800544c:	b662      	cpsie	i
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 800544e:	1c28      	adds	r0, r5, #0
 8005450:	bd38      	pop	{r3, r4, r5, pc}

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8005452:	4c07      	ldr	r4, [pc, #28]	; (8005470 <chMtxTryLock.constprop.64+0x50>)
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
 8005454:	2501      	movs	r5, #1

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8005456:	69a2      	ldr	r2, [r4, #24]
  mp->m_next = currp->p_mtxlist;
 8005458:	6bd0      	ldr	r0, [r2, #60]	; 0x3c

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 800545a:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 800545c:	60d8      	str	r0, [r3, #12]
  currp->p_mtxlist = mp;
 800545e:	63d3      	str	r3, [r2, #60]	; 0x3c
 8005460:	e7ea      	b.n	8005438 <chMtxTryLock.constprop.64+0x18>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005462:	b672      	cpsid	i
 8005464:	4d03      	ldr	r5, [pc, #12]	; (8005474 <chMtxTryLock.constprop.64+0x54>)
 8005466:	62e5      	str	r5, [r4, #44]	; 0x2c
 8005468:	e7fe      	b.n	8005468 <chMtxTryLock.constprop.64+0x48>
 800546a:	46c0      	nop			; (mov r8, r8)
 800546c:	20000694 	.word	0x20000694
 8005470:	20001040 	.word	0x20001040
 8005474:	080089f0 	.word	0x080089f0
 8005478:	46c0      	nop			; (mov r8, r8)
 800547a:	46c0      	nop			; (mov r8, r8)
 800547c:	46c0      	nop			; (mov r8, r8)
 800547e:	46c0      	nop			; (mov r8, r8)

08005480 <chEvtGetAndClearEvents.constprop.53>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8005480:	b538      	push	{r3, r4, r5, lr}
 8005482:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005484:	f7fe fb0c 	bl	8003aa0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 8005488:	4c0a      	ldr	r4, [pc, #40]	; (80054b4 <chEvtGetAndClearEvents.constprop.53+0x34>)
  currp->p_epending &= ~events;
 800548a:	2200      	movs	r2, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 800548c:	69a3      	ldr	r3, [r4, #24]
 800548e:	6b9d      	ldr	r5, [r3, #56]	; 0x38
  currp->p_epending &= ~events;
 8005490:	639a      	str	r2, [r3, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005492:	f7fe fa6d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005496:	6820      	ldr	r0, [r4, #0]
 8005498:	42a0      	cmp	r0, r4
 800549a:	d004      	beq.n	80054a6 <chEvtGetAndClearEvents.constprop.53+0x26>
 800549c:	69a1      	ldr	r1, [r4, #24]
 800549e:	6883      	ldr	r3, [r0, #8]
 80054a0:	688a      	ldr	r2, [r1, #8]
 80054a2:	429a      	cmp	r2, r3
 80054a4:	d302      	bcc.n	80054ac <chEvtGetAndClearEvents.constprop.53+0x2c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80054a6:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 80054a8:	1c28      	adds	r0, r5, #0
 80054aa:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054ac:	b672      	cpsid	i
 80054ae:	4d02      	ldr	r5, [pc, #8]	; (80054b8 <chEvtGetAndClearEvents.constprop.53+0x38>)
 80054b0:	62e5      	str	r5, [r4, #44]	; 0x2c
 80054b2:	e7fe      	b.n	80054b2 <chEvtGetAndClearEvents.constprop.53+0x32>
 80054b4:	20001040 	.word	0x20001040
 80054b8:	08008b50 	.word	0x08008b50
 80054bc:	46c0      	nop			; (mov r8, r8)
 80054be:	46c0      	nop			; (mov r8, r8)

080054c0 <evt1_setup.9769>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 80054c0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 80054c2:	f7ff ffdd 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
}
 80054c6:	bd08      	pop	{r3, pc}
 80054c8:	46c0      	nop			; (mov r8, r8)
 80054ca:	46c0      	nop			; (mov r8, r8)
 80054cc:	46c0      	nop			; (mov r8, r8)
 80054ce:	46c0      	nop			; (mov r8, r8)

080054d0 <evt2_setup.9767>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 80054d0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 80054d2:	f7ff ffd5 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
}
 80054d6:	bd08      	pop	{r3, pc}
 80054d8:	46c0      	nop			; (mov r8, r8)
 80054da:	46c0      	nop			; (mov r8, r8)
 80054dc:	46c0      	nop			; (mov r8, r8)
 80054de:	46c0      	nop			; (mov r8, r8)

080054e0 <evt3_setup.9765>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 80054e0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 80054e2:	f7ff ffcd 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
}
 80054e6:	bd08      	pop	{r3, pc}
 80054e8:	46c0      	nop			; (mov r8, r8)
 80054ea:	46c0      	nop			; (mov r8, r8)
 80054ec:	46c0      	nop			; (mov r8, r8)
 80054ee:	46c0      	nop			; (mov r8, r8)

080054f0 <pools1_execute.10047>:
static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void pools1_execute(void) {
 80054f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80054f2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80054f4:	f7fe fad4 	bl	8003aa0 <_dbg_check_lock>
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 80054f8:	4db0      	ldr	r5, [pc, #704]	; (80057bc <pools1_execute.10047+0x2cc>)
 80054fa:	4eb1      	ldr	r6, [pc, #708]	; (80057c0 <pools1_execute.10047+0x2d0>)
 80054fc:	1c28      	adds	r0, r5, #0
 80054fe:	1c31      	adds	r1, r6, #0
 8005500:	f7fb f98e 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005504:	f7fe fa34 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005508:	4cae      	ldr	r4, [pc, #696]	; (80057c4 <pools1_execute.10047+0x2d4>)
 800550a:	6823      	ldr	r3, [r4, #0]
 800550c:	42a3      	cmp	r3, r4
 800550e:	d005      	beq.n	800551c <pools1_execute.10047+0x2c>
 8005510:	69a2      	ldr	r2, [r4, #24]
 8005512:	6899      	ldr	r1, [r3, #8]
 8005514:	6890      	ldr	r0, [r2, #8]
 8005516:	4281      	cmp	r1, r0
 8005518:	d900      	bls.n	800551c <pools1_execute.10047+0x2c>
 800551a:	e147      	b.n	80057ac <pools1_execute.10047+0x2bc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800551c:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 800551e:	686f      	ldr	r7, [r5, #4]
 8005520:	19f7      	adds	r7, r6, r7
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005522:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005524:	f7fe fabc 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 8005528:	1c28      	adds	r0, r5, #0
 800552a:	1c39      	adds	r1, r7, #0
 800552c:	f7fb f978 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005530:	f7fe fa1e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005534:	6823      	ldr	r3, [r4, #0]
 8005536:	42a3      	cmp	r3, r4
 8005538:	d005      	beq.n	8005546 <pools1_execute.10047+0x56>
 800553a:	69a2      	ldr	r2, [r4, #24]
 800553c:	6898      	ldr	r0, [r3, #8]
 800553e:	6891      	ldr	r1, [r2, #8]
 8005540:	4281      	cmp	r1, r0
 8005542:	d200      	bcs.n	8005546 <pools1_execute.10047+0x56>
 8005544:	e132      	b.n	80057ac <pools1_execute.10047+0x2bc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005546:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8005548:	686b      	ldr	r3, [r5, #4]
 800554a:	18ff      	adds	r7, r7, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800554c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800554e:	f7fe faa7 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 8005552:	1c39      	adds	r1, r7, #0
 8005554:	1c28      	adds	r0, r5, #0
 8005556:	f7fb f963 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800555a:	f7fe fa09 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800555e:	6821      	ldr	r1, [r4, #0]
 8005560:	42a1      	cmp	r1, r4
 8005562:	d005      	beq.n	8005570 <pools1_execute.10047+0x80>
 8005564:	69a2      	ldr	r2, [r4, #24]
 8005566:	688b      	ldr	r3, [r1, #8]
 8005568:	6890      	ldr	r0, [r2, #8]
 800556a:	4298      	cmp	r0, r3
 800556c:	d200      	bcs.n	8005570 <pools1_execute.10047+0x80>
 800556e:	e11d      	b.n	80057ac <pools1_execute.10047+0x2bc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005570:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8005572:	6869      	ldr	r1, [r5, #4]
 8005574:	187f      	adds	r7, r7, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005576:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005578:	f7fe fa92 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 800557c:	1c28      	adds	r0, r5, #0
 800557e:	1c39      	adds	r1, r7, #0
 8005580:	f7fb f94e 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005584:	f7fe f9f4 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005588:	6820      	ldr	r0, [r4, #0]
 800558a:	42a0      	cmp	r0, r4
 800558c:	d005      	beq.n	800559a <pools1_execute.10047+0xaa>
 800558e:	69a2      	ldr	r2, [r4, #24]
 8005590:	6883      	ldr	r3, [r0, #8]
 8005592:	6891      	ldr	r1, [r2, #8]
 8005594:	4299      	cmp	r1, r3
 8005596:	d200      	bcs.n	800559a <pools1_execute.10047+0xaa>
 8005598:	e108      	b.n	80057ac <pools1_execute.10047+0x2bc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800559a:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 800559c:	6868      	ldr	r0, [r5, #4]
 800559e:	183f      	adds	r7, r7, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80055a0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80055a2:	f7fe fa7d 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 80055a6:	1c39      	adds	r1, r7, #0
 80055a8:	1c28      	adds	r0, r5, #0
 80055aa:	f7fb f939 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80055ae:	f7fe f9df 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80055b2:	6821      	ldr	r1, [r4, #0]
 80055b4:	42a1      	cmp	r1, r4
 80055b6:	d005      	beq.n	80055c4 <pools1_execute.10047+0xd4>
 80055b8:	69a2      	ldr	r2, [r4, #24]
 80055ba:	688b      	ldr	r3, [r1, #8]
 80055bc:	6890      	ldr	r0, [r2, #8]
 80055be:	4298      	cmp	r0, r3
 80055c0:	d200      	bcs.n	80055c4 <pools1_execute.10047+0xd4>
 80055c2:	e0f3      	b.n	80057ac <pools1_execute.10047+0x2bc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80055c4:	b662      	cpsie	i

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 80055c6:	1c28      	adds	r0, r5, #0
 80055c8:	f7fe fdea 	bl	80041a0 <chPoolAlloc>
 80055cc:	1c01      	adds	r1, r0, #0
 80055ce:	1e48      	subs	r0, r1, #1
 80055d0:	4181      	sbcs	r1, r0
 80055d2:	2001      	movs	r0, #1
 80055d4:	f7fb fac4 	bl	8000b60 <_test_assert>
 80055d8:	2800      	cmp	r0, #0
 80055da:	d000      	beq.n	80055de <pools1_execute.10047+0xee>
 80055dc:	e0e5      	b.n	80057aa <pools1_execute.10047+0x2ba>
 80055de:	1c28      	adds	r0, r5, #0
 80055e0:	f7fe fdde 	bl	80041a0 <chPoolAlloc>
 80055e4:	1c01      	adds	r1, r0, #0
 80055e6:	1e48      	subs	r0, r1, #1
 80055e8:	4181      	sbcs	r1, r0
 80055ea:	2001      	movs	r0, #1
 80055ec:	f7fb fab8 	bl	8000b60 <_test_assert>
 80055f0:	2800      	cmp	r0, #0
 80055f2:	d000      	beq.n	80055f6 <pools1_execute.10047+0x106>
 80055f4:	e0d9      	b.n	80057aa <pools1_execute.10047+0x2ba>
 80055f6:	1c28      	adds	r0, r5, #0
 80055f8:	f7fe fdd2 	bl	80041a0 <chPoolAlloc>
 80055fc:	1c01      	adds	r1, r0, #0
 80055fe:	1e48      	subs	r0, r1, #1
 8005600:	4181      	sbcs	r1, r0
 8005602:	2001      	movs	r0, #1
 8005604:	f7fb faac 	bl	8000b60 <_test_assert>
 8005608:	2800      	cmp	r0, #0
 800560a:	d000      	beq.n	800560e <pools1_execute.10047+0x11e>
 800560c:	e0cd      	b.n	80057aa <pools1_execute.10047+0x2ba>
 800560e:	1c28      	adds	r0, r5, #0
 8005610:	f7fe fdc6 	bl	80041a0 <chPoolAlloc>
 8005614:	1c01      	adds	r1, r0, #0
 8005616:	1e48      	subs	r0, r1, #1
 8005618:	4181      	sbcs	r1, r0
 800561a:	2001      	movs	r0, #1
 800561c:	f7fb faa0 	bl	8000b60 <_test_assert>
 8005620:	2800      	cmp	r0, #0
 8005622:	d000      	beq.n	8005626 <pools1_execute.10047+0x136>
 8005624:	e0c1      	b.n	80057aa <pools1_execute.10047+0x2ba>
 8005626:	1c28      	adds	r0, r5, #0
 8005628:	f7fe fdba 	bl	80041a0 <chPoolAlloc>
 800562c:	1c01      	adds	r1, r0, #0
 800562e:	1e48      	subs	r0, r1, #1
 8005630:	4181      	sbcs	r1, r0
 8005632:	2001      	movs	r0, #1
 8005634:	f7fb fa94 	bl	8000b60 <_test_assert>
 8005638:	2800      	cmp	r0, #0
 800563a:	d000      	beq.n	800563e <pools1_execute.10047+0x14e>
 800563c:	e0b5      	b.n	80057aa <pools1_execute.10047+0x2ba>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 800563e:	1c28      	adds	r0, r5, #0
 8005640:	f7fe fdae 	bl	80041a0 <chPoolAlloc>
 8005644:	4241      	negs	r1, r0
 8005646:	4141      	adcs	r1, r0
 8005648:	2002      	movs	r0, #2
 800564a:	f7fb fa89 	bl	8000b60 <_test_assert>
 800564e:	2800      	cmp	r0, #0
 8005650:	d000      	beq.n	8005654 <pools1_execute.10047+0x164>
 8005652:	e0aa      	b.n	80057aa <pools1_execute.10047+0x2ba>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005654:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005656:	f7fe fa23 	bl	8003aa0 <_dbg_check_lock>
 800565a:	1c31      	adds	r1, r6, #0
 800565c:	1c28      	adds	r0, r5, #0
 800565e:	f7fb f8df 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005662:	f7fe f985 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005666:	6826      	ldr	r6, [r4, #0]
 8005668:	42a6      	cmp	r6, r4
 800566a:	d005      	beq.n	8005678 <pools1_execute.10047+0x188>
 800566c:	69a7      	ldr	r7, [r4, #24]
 800566e:	68b2      	ldr	r2, [r6, #8]
 8005670:	68b9      	ldr	r1, [r7, #8]
 8005672:	4291      	cmp	r1, r2
 8005674:	d200      	bcs.n	8005678 <pools1_execute.10047+0x188>
 8005676:	e09d      	b.n	80057b4 <pools1_execute.10047+0x2c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005678:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800567a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800567c:	f7fe fa10 	bl	8003aa0 <_dbg_check_lock>
 8005680:	1c28      	adds	r0, r5, #0
 8005682:	4951      	ldr	r1, [pc, #324]	; (80057c8 <pools1_execute.10047+0x2d8>)
 8005684:	f7fb f8cc 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005688:	f7fe f972 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800568c:	6820      	ldr	r0, [r4, #0]
 800568e:	42a0      	cmp	r0, r4
 8005690:	d005      	beq.n	800569e <pools1_execute.10047+0x1ae>
 8005692:	69a3      	ldr	r3, [r4, #24]
 8005694:	6887      	ldr	r7, [r0, #8]
 8005696:	689e      	ldr	r6, [r3, #8]
 8005698:	42be      	cmp	r6, r7
 800569a:	d200      	bcs.n	800569e <pools1_execute.10047+0x1ae>
 800569c:	e08a      	b.n	80057b4 <pools1_execute.10047+0x2c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800569e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80056a0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80056a2:	f7fe f9fd 	bl	8003aa0 <_dbg_check_lock>
 80056a6:	4949      	ldr	r1, [pc, #292]	; (80057cc <pools1_execute.10047+0x2dc>)
 80056a8:	1c28      	adds	r0, r5, #0
 80056aa:	f7fb f8b9 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80056ae:	f7fe f95f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80056b2:	6821      	ldr	r1, [r4, #0]
 80056b4:	42a1      	cmp	r1, r4
 80056b6:	d005      	beq.n	80056c4 <pools1_execute.10047+0x1d4>
 80056b8:	69a2      	ldr	r2, [r4, #24]
 80056ba:	688b      	ldr	r3, [r1, #8]
 80056bc:	6890      	ldr	r0, [r2, #8]
 80056be:	4298      	cmp	r0, r3
 80056c0:	d200      	bcs.n	80056c4 <pools1_execute.10047+0x1d4>
 80056c2:	e077      	b.n	80057b4 <pools1_execute.10047+0x2c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80056c4:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80056c6:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80056c8:	f7fe f9ea 	bl	8003aa0 <_dbg_check_lock>
 80056cc:	1c28      	adds	r0, r5, #0
 80056ce:	4940      	ldr	r1, [pc, #256]	; (80057d0 <pools1_execute.10047+0x2e0>)
 80056d0:	f7fb f8a6 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80056d4:	f7fe f94c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80056d8:	6826      	ldr	r6, [r4, #0]
 80056da:	42a6      	cmp	r6, r4
 80056dc:	d004      	beq.n	80056e8 <pools1_execute.10047+0x1f8>
 80056de:	69a7      	ldr	r7, [r4, #24]
 80056e0:	68b2      	ldr	r2, [r6, #8]
 80056e2:	68b9      	ldr	r1, [r7, #8]
 80056e4:	4291      	cmp	r1, r2
 80056e6:	d365      	bcc.n	80057b4 <pools1_execute.10047+0x2c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80056e8:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80056ea:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80056ec:	f7fe f9d8 	bl	8003aa0 <_dbg_check_lock>
 80056f0:	1c28      	adds	r0, r5, #0
 80056f2:	4938      	ldr	r1, [pc, #224]	; (80057d4 <pools1_execute.10047+0x2e4>)
 80056f4:	f7fb f894 	bl	8000820 <chPoolFreeI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80056f8:	f7fe f93a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80056fc:	6820      	ldr	r0, [r4, #0]
 80056fe:	42a0      	cmp	r0, r4
 8005700:	d004      	beq.n	800570c <pools1_execute.10047+0x21c>
 8005702:	69a3      	ldr	r3, [r4, #24]
 8005704:	6887      	ldr	r7, [r0, #8]
 8005706:	689e      	ldr	r6, [r3, #8]
 8005708:	42be      	cmp	r6, r7
 800570a:	d353      	bcc.n	80057b4 <pools1_execute.10047+0x2c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800570c:	b662      	cpsie	i
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 800570e:	1c28      	adds	r0, r5, #0
 8005710:	f7fe fd46 	bl	80041a0 <chPoolAlloc>
 8005714:	1c01      	adds	r1, r0, #0
 8005716:	1e48      	subs	r0, r1, #1
 8005718:	4181      	sbcs	r1, r0
 800571a:	2003      	movs	r0, #3
 800571c:	f7fb fa20 	bl	8000b60 <_test_assert>
 8005720:	2800      	cmp	r0, #0
 8005722:	d142      	bne.n	80057aa <pools1_execute.10047+0x2ba>
 8005724:	1c28      	adds	r0, r5, #0
 8005726:	f7fe fd3b 	bl	80041a0 <chPoolAlloc>
 800572a:	1c01      	adds	r1, r0, #0
 800572c:	1e48      	subs	r0, r1, #1
 800572e:	4181      	sbcs	r1, r0
 8005730:	2003      	movs	r0, #3
 8005732:	f7fb fa15 	bl	8000b60 <_test_assert>
 8005736:	2800      	cmp	r0, #0
 8005738:	d137      	bne.n	80057aa <pools1_execute.10047+0x2ba>
 800573a:	1c28      	adds	r0, r5, #0
 800573c:	f7fe fd30 	bl	80041a0 <chPoolAlloc>
 8005740:	1c01      	adds	r1, r0, #0
 8005742:	1e48      	subs	r0, r1, #1
 8005744:	4181      	sbcs	r1, r0
 8005746:	2003      	movs	r0, #3
 8005748:	f7fb fa0a 	bl	8000b60 <_test_assert>
 800574c:	2800      	cmp	r0, #0
 800574e:	d12c      	bne.n	80057aa <pools1_execute.10047+0x2ba>
 8005750:	1c28      	adds	r0, r5, #0
 8005752:	f7fe fd25 	bl	80041a0 <chPoolAlloc>
 8005756:	1c01      	adds	r1, r0, #0
 8005758:	1e48      	subs	r0, r1, #1
 800575a:	4181      	sbcs	r1, r0
 800575c:	2003      	movs	r0, #3
 800575e:	f7fb f9ff 	bl	8000b60 <_test_assert>
 8005762:	2800      	cmp	r0, #0
 8005764:	d121      	bne.n	80057aa <pools1_execute.10047+0x2ba>
 8005766:	1c28      	adds	r0, r5, #0
 8005768:	f7fe fd1a 	bl	80041a0 <chPoolAlloc>
 800576c:	1c01      	adds	r1, r0, #0
 800576e:	1e48      	subs	r0, r1, #1
 8005770:	4181      	sbcs	r1, r0
 8005772:	2003      	movs	r0, #3
 8005774:	f7fb f9f4 	bl	8000b60 <_test_assert>
 8005778:	2800      	cmp	r0, #0
 800577a:	d116      	bne.n	80057aa <pools1_execute.10047+0x2ba>

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 800577c:	1c28      	adds	r0, r5, #0
 800577e:	f7fe fd0f 	bl	80041a0 <chPoolAlloc>
 8005782:	4241      	negs	r1, r0
 8005784:	4141      	adcs	r1, r0
 8005786:	2004      	movs	r0, #4
 8005788:	f7fb f9ea 	bl	8000b60 <_test_assert>
 800578c:	2800      	cmp	r0, #0
 800578e:	d10c      	bne.n	80057aa <pools1_execute.10047+0x2ba>

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
  mp->mp_provider = provider;
 8005790:	4911      	ldr	r1, [pc, #68]	; (80057d8 <pools1_execute.10047+0x2e8>)
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8005792:	6028      	str	r0, [r5, #0]
  mp->mp_object_size = size;
 8005794:	2410      	movs	r4, #16

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8005796:	1c28      	adds	r0, r5, #0
  mp->mp_provider = provider;
 8005798:	60a9      	str	r1, [r5, #8]
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 800579a:	606c      	str	r4, [r5, #4]
 800579c:	f7fe fd00 	bl	80041a0 <chPoolAlloc>
 80057a0:	4241      	negs	r1, r0
 80057a2:	4141      	adcs	r1, r0
 80057a4:	2005      	movs	r0, #5
 80057a6:	f7fb f9db 	bl	8000b60 <_test_assert>
}
 80057aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80057ac:	b672      	cpsid	i
 80057ae:	4a0b      	ldr	r2, [pc, #44]	; (80057dc <pools1_execute.10047+0x2ec>)
 80057b0:	62e2      	str	r2, [r4, #44]	; 0x2c
 80057b2:	e7fe      	b.n	80057b2 <pools1_execute.10047+0x2c2>
 80057b4:	b672      	cpsid	i
 80057b6:	4d09      	ldr	r5, [pc, #36]	; (80057dc <pools1_execute.10047+0x2ec>)
 80057b8:	62e5      	str	r5, [r4, #44]	; 0x2c
 80057ba:	e7fe      	b.n	80057ba <pools1_execute.10047+0x2ca>
 80057bc:	20000688 	.word	0x20000688
 80057c0:	200006b8 	.word	0x200006b8
 80057c4:	20001040 	.word	0x20001040
 80057c8:	20000808 	.word	0x20000808
 80057cc:	20000958 	.word	0x20000958
 80057d0:	20000aa8 	.word	0x20000aa8
 80057d4:	20000bf8 	.word	0x20000bf8
 80057d8:	080004d1 	.word	0x080004d1
 80057dc:	08008980 	.word	0x08008980

080057e0 <chEvtRegisterMaskWithFlags.constprop.54>:
 *                      the event source is broadcasted
 * @param[in] wflags    mask of flags the listening thread is interested in
 *
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
 80057e0:	b570      	push	{r4, r5, r6, lr}
 80057e2:	1c05      	adds	r5, r0, #0
 80057e4:	1c0c      	adds	r4, r1, #0
 80057e6:	1c16      	adds	r6, r2, #0
 80057e8:	b672      	cpsid	i
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));
 80057ea:	2800      	cmp	r0, #0
 80057ec:	d01f      	beq.n	800582e <chEvtRegisterMaskWithFlags.constprop.54+0x4e>
 80057ee:	2900      	cmp	r1, #0
 80057f0:	d01d      	beq.n	800582e <chEvtRegisterMaskWithFlags.constprop.54+0x4e>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80057f2:	f7fe f955 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  elp->el_next     = esp->es_next;
 80057f6:	682b      	ldr	r3, [r5, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80057f8:	2201      	movs	r2, #1
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80057fa:	6023      	str	r3, [r4, #0]
  esp->es_next     = elp;
 80057fc:	602c      	str	r4, [r5, #0]
  elp->el_listener = currp;
 80057fe:	4d0e      	ldr	r5, [pc, #56]	; (8005838 <chEvtRegisterMaskWithFlags.constprop.54+0x58>)
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8005800:	2100      	movs	r1, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8005802:	69a8      	ldr	r0, [r5, #24]
  elp->el_events   = events;
 8005804:	60a6      	str	r6, [r4, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8005806:	4256      	negs	r6, r2
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8005808:	6060      	str	r0, [r4, #4]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 800580a:	60e1      	str	r1, [r4, #12]
  elp->el_wflags   = wflags;
 800580c:	6126      	str	r6, [r4, #16]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800580e:	f7fe f8af 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005812:	682c      	ldr	r4, [r5, #0]
 8005814:	42ac      	cmp	r4, r5
 8005816:	d004      	beq.n	8005822 <chEvtRegisterMaskWithFlags.constprop.54+0x42>
 8005818:	69ab      	ldr	r3, [r5, #24]
 800581a:	68a1      	ldr	r1, [r4, #8]
 800581c:	6898      	ldr	r0, [r3, #8]
 800581e:	4288      	cmp	r0, r1
 8005820:	d301      	bcc.n	8005826 <chEvtRegisterMaskWithFlags.constprop.54+0x46>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005822:	b662      	cpsie	i
  chSysUnlock();
}
 8005824:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005826:	b672      	cpsid	i
 8005828:	4a04      	ldr	r2, [pc, #16]	; (800583c <chEvtRegisterMaskWithFlags.constprop.54+0x5c>)
 800582a:	62ea      	str	r2, [r5, #44]	; 0x2c
 800582c:	e7fe      	b.n	800582c <chEvtRegisterMaskWithFlags.constprop.54+0x4c>
 800582e:	4d04      	ldr	r5, [pc, #16]	; (8005840 <chEvtRegisterMaskWithFlags.constprop.54+0x60>)
 8005830:	4e01      	ldr	r6, [pc, #4]	; (8005838 <chEvtRegisterMaskWithFlags.constprop.54+0x58>)
 8005832:	62f5      	str	r5, [r6, #44]	; 0x2c
 8005834:	e7fe      	b.n	8005834 <chEvtRegisterMaskWithFlags.constprop.54+0x54>
 8005836:	46c0      	nop			; (mov r8, r8)
 8005838:	20001040 	.word	0x20001040
 800583c:	08008b50 	.word	0x08008b50
 8005840:	08008a10 	.word	0x08008a10
 8005844:	46c0      	nop			; (mov r8, r8)
 8005846:	46c0      	nop			; (mov r8, r8)
 8005848:	46c0      	nop			; (mov r8, r8)
 800584a:	46c0      	nop			; (mov r8, r8)
 800584c:	46c0      	nop			; (mov r8, r8)
 800584e:	46c0      	nop			; (mov r8, r8)

08005850 <thread1.9762>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static THD_FUNCTION(thread1, p) {
 8005850:	b510      	push	{r4, lr}
 8005852:	1c04      	adds	r4, r0, #0

  chThdSleepMilliseconds(50);
 8005854:	20fa      	movs	r0, #250	; 0xfa
 8005856:	0040      	lsls	r0, r0, #1
 8005858:	f7fc ff2a 	bl	80026b0 <chThdSleep>
 800585c:	b672      	cpsid	i
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);
 800585e:	2c00      	cmp	r4, #0
 8005860:	d018      	beq.n	8005894 <thread1.9762+0x44>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005862:	f7fe f91d 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  chEvtSignalI(tp, events);
 8005866:	1c20      	adds	r0, r4, #0
 8005868:	2101      	movs	r1, #1
 800586a:	f7fa ff91 	bl	8000790 <chEvtSignalI>
  chSchRescheduleS();
 800586e:	f7fd fe07 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005872:	f7fe f87d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005876:	4b09      	ldr	r3, [pc, #36]	; (800589c <thread1.9762+0x4c>)
 8005878:	681a      	ldr	r2, [r3, #0]
 800587a:	429a      	cmp	r2, r3
 800587c:	d004      	beq.n	8005888 <thread1.9762+0x38>
 800587e:	6999      	ldr	r1, [r3, #24]
 8005880:	6890      	ldr	r0, [r2, #8]
 8005882:	688c      	ldr	r4, [r1, #8]
 8005884:	4284      	cmp	r4, r0
 8005886:	d301      	bcc.n	800588c <thread1.9762+0x3c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005888:	b662      	cpsie	i
  chEvtSignal((thread_t *)p, 1);
}
 800588a:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800588c:	b672      	cpsid	i
 800588e:	4a04      	ldr	r2, [pc, #16]	; (80058a0 <thread1.9762+0x50>)
 8005890:	62da      	str	r2, [r3, #44]	; 0x2c
 8005892:	e7fe      	b.n	8005892 <thread1.9762+0x42>
 8005894:	4903      	ldr	r1, [pc, #12]	; (80058a4 <thread1.9762+0x54>)
 8005896:	4b01      	ldr	r3, [pc, #4]	; (800589c <thread1.9762+0x4c>)
 8005898:	62d9      	str	r1, [r3, #44]	; 0x2c
 800589a:	e7fe      	b.n	800589a <thread1.9762+0x4a>
 800589c:	20001040 	.word	0x20001040
 80058a0:	08008b50 	.word	0x08008b50
 80058a4:	08008a70 	.word	0x08008a70
 80058a8:	46c0      	nop			; (mov r8, r8)
 80058aa:	46c0      	nop			; (mov r8, r8)
 80058ac:	46c0      	nop			; (mov r8, r8)
 80058ae:	46c0      	nop			; (mov r8, r8)

080058b0 <thread2.9759>:

static THD_FUNCTION(thread2, p) {
 80058b0:	b510      	push	{r4, lr}
 80058b2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80058b4:	f7fe f8f4 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80058b8:	4819      	ldr	r0, [pc, #100]	; (8005920 <thread2.9759+0x70>)
 80058ba:	2100      	movs	r1, #0
 80058bc:	f7fd ff78 	bl	80037b0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80058c0:	f7fd fdde 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80058c4:	f7fe f854 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80058c8:	4c16      	ldr	r4, [pc, #88]	; (8005924 <thread2.9759+0x74>)
 80058ca:	6823      	ldr	r3, [r4, #0]
 80058cc:	42a3      	cmp	r3, r4
 80058ce:	d004      	beq.n	80058da <thread2.9759+0x2a>
 80058d0:	69a2      	ldr	r2, [r4, #24]
 80058d2:	6899      	ldr	r1, [r3, #8]
 80058d4:	6890      	ldr	r0, [r2, #8]
 80058d6:	4288      	cmp	r0, r1
 80058d8:	d319      	bcc.n	800590e <thread2.9759+0x5e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80058da:	b662      	cpsie	i

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 80058dc:	23fa      	movs	r3, #250	; 0xfa
 80058de:	0058      	lsls	r0, r3, #1
 80058e0:	f7fc fee6 	bl	80026b0 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80058e4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80058e6:	f7fe f8db 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80058ea:	480f      	ldr	r0, [pc, #60]	; (8005928 <thread2.9759+0x78>)
 80058ec:	2100      	movs	r1, #0
 80058ee:	f7fd ff5f 	bl	80037b0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80058f2:	f7fd fdc5 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80058f6:	f7fe f83b 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80058fa:	6820      	ldr	r0, [r4, #0]
 80058fc:	42a0      	cmp	r0, r4
 80058fe:	d004      	beq.n	800590a <thread2.9759+0x5a>
 8005900:	69a2      	ldr	r2, [r4, #24]
 8005902:	6883      	ldr	r3, [r0, #8]
 8005904:	6891      	ldr	r1, [r2, #8]
 8005906:	4299      	cmp	r1, r3
 8005908:	d305      	bcc.n	8005916 <thread2.9759+0x66>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800590a:	b662      	cpsie	i
  chEvtBroadcast(&es2);
}
 800590c:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800590e:	b672      	cpsid	i
 8005910:	4a06      	ldr	r2, [pc, #24]	; (800592c <thread2.9759+0x7c>)
 8005912:	62e2      	str	r2, [r4, #44]	; 0x2c
 8005914:	e7fe      	b.n	8005914 <thread2.9759+0x64>
 8005916:	b672      	cpsid	i
 8005918:	4804      	ldr	r0, [pc, #16]	; (800592c <thread2.9759+0x7c>)
 800591a:	62e0      	str	r0, [r4, #44]	; 0x2c
 800591c:	e7fe      	b.n	800591c <thread2.9759+0x6c>
 800591e:	46c0      	nop			; (mov r8, r8)
 8005920:	200006b4 	.word	0x200006b4
 8005924:	20001040 	.word	0x20001040
 8005928:	200006b0 	.word	0x200006b0
 800592c:	08008b50 	.word	0x08008b50

08005930 <test_start_timer.constprop.11>:
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 8005930:	4b13      	ldr	r3, [pc, #76]	; (8005980 <test_start_timer.constprop.11+0x50>)
 8005932:	2200      	movs	r2, #0
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8005934:	b510      	push	{r4, lr}

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 8005936:	701a      	strb	r2, [r3, #0]
 8005938:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800593a:	f7fe f8b1 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800593e:	f7fa fe97 	bl	8000670 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 8005942:	4c10      	ldr	r4, [pc, #64]	; (8005984 <test_start_timer.constprop.11+0x54>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8005944:	68e0      	ldr	r0, [r4, #12]
 8005946:	2800      	cmp	r0, #0
 8005948:	d002      	beq.n	8005950 <test_start_timer.constprop.11+0x20>
    chVTDoResetI(vtp);
 800594a:	1c20      	adds	r0, r4, #0
 800594c:	f7fa ffa0 	bl	8000890 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8005950:	4a0d      	ldr	r2, [pc, #52]	; (8005988 <test_start_timer.constprop.11+0x58>)
 8005952:	2300      	movs	r3, #0
 8005954:	1c20      	adds	r0, r4, #0
 8005956:	490d      	ldr	r1, [pc, #52]	; (800598c <test_start_timer.constprop.11+0x5c>)
 8005958:	f7fa ffea 	bl	8000930 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800595c:	f7fe f808 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005960:	4b0b      	ldr	r3, [pc, #44]	; (8005990 <test_start_timer.constprop.11+0x60>)
 8005962:	681a      	ldr	r2, [r3, #0]
 8005964:	429a      	cmp	r2, r3
 8005966:	d004      	beq.n	8005972 <test_start_timer.constprop.11+0x42>
 8005968:	6999      	ldr	r1, [r3, #24]
 800596a:	6890      	ldr	r0, [r2, #8]
 800596c:	688c      	ldr	r4, [r1, #8]
 800596e:	4284      	cmp	r4, r0
 8005970:	d301      	bcc.n	8005976 <test_start_timer.constprop.11+0x46>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005972:	b662      	cpsie	i
  chVTSet(&vt, duration, tmr, NULL);
}
 8005974:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005976:	b672      	cpsid	i
 8005978:	4a06      	ldr	r2, [pc, #24]	; (8005994 <test_start_timer.constprop.11+0x64>)
 800597a:	62da      	str	r2, [r3, #44]	; 0x2c
 800597c:	e7fe      	b.n	800597c <test_start_timer.constprop.11+0x4c>
 800597e:	46c0      	nop			; (mov r8, r8)
 8005980:	20000e18 	.word	0x20000e18
 8005984:	20000da8 	.word	0x20000da8
 8005988:	080004e1 	.word	0x080004e1
 800598c:	00002710 	.word	0x00002710
 8005990:	20001040 	.word	0x20001040
 8005994:	08008a00 	.word	0x08008a00
 8005998:	46c0      	nop			; (mov r8, r8)
 800599a:	46c0      	nop			; (mov r8, r8)
 800599c:	46c0      	nop			; (mov r8, r8)
 800599e:	46c0      	nop			; (mov r8, r8)

080059a0 <msg_loop_test.10829>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80059a0:	b570      	push	{r4, r5, r6, lr}
 80059a2:	1c05      	adds	r5, r0, #0

  uint32_t n = 0;
  test_wait_tick();
 80059a4:	f7fc feac 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 80059a8:	f7ff ffc2 	bl	8005930 <test_start_timer.constprop.11>
 80059ac:	4e07      	ldr	r6, [pc, #28]	; (80059cc <msg_loop_test.10829+0x2c>)
#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {

  uint32_t n = 0;
 80059ae:	2400      	movs	r4, #0
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
 80059b0:	1c28      	adds	r0, r5, #0
 80059b2:	2101      	movs	r1, #1
 80059b4:	f7fe f94c 	bl	8003c50 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80059b8:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 80059ba:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80059bc:	2b00      	cmp	r3, #0
 80059be:	d0f7      	beq.n	80059b0 <msg_loop_test.10829+0x10>
  (void)chMsgSend(tp, 0);
 80059c0:	1c28      	adds	r0, r5, #0
 80059c2:	2100      	movs	r1, #0
 80059c4:	f7fe f944 	bl	8003c50 <chMsgSend>
  return n;
}
 80059c8:	1c20      	adds	r0, r4, #0
 80059ca:	bd70      	pop	{r4, r5, r6, pc}
 80059cc:	20000e18 	.word	0x20000e18

080059d0 <bmk6_execute.10819>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80059d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80059d2:	4b16      	ldr	r3, [pc, #88]	; (8005a2c <bmk6_execute.10819+0x5c>)
 80059d4:	464f      	mov	r7, r9
 80059d6:	4646      	mov	r6, r8
 80059d8:	b4c0      	push	{r6, r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80059da:	6998      	ldr	r0, [r3, #24]
 80059dc:	b083      	sub	sp, #12

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 80059de:	6881      	ldr	r1, [r0, #8]
 * a second of continuous operations.
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
 80059e0:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 80059e2:	3101      	adds	r1, #1
 80059e4:	4689      	mov	r9, r1
  test_wait_tick();
 80059e6:	f7fc fe8b 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 80059ea:	f7ff ffa1 	bl	8005930 <test_start_timer.constprop.11>
 80059ee:	4a10      	ldr	r2, [pc, #64]	; (8005a30 <bmk6_execute.10819+0x60>)
 80059f0:	4f10      	ldr	r7, [pc, #64]	; (8005a34 <bmk6_execute.10819+0x64>)
 80059f2:	4e11      	ldr	r6, [pc, #68]	; (8005a38 <bmk6_execute.10819+0x68>)
 80059f4:	4690      	mov	r8, r2
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 80059f6:	2500      	movs	r5, #0
 80059f8:	23a8      	movs	r3, #168	; 0xa8
 80059fa:	0059      	lsls	r1, r3, #1
 80059fc:	9500      	str	r5, [sp, #0]
 80059fe:	4640      	mov	r0, r8
 8005a00:	464a      	mov	r2, r9
 8005a02:	1c3b      	adds	r3, r7, #0
 8005a04:	f7fd fa24 	bl	8002e50 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005a08:	7830      	ldrb	r0, [r6, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 8005a0a:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005a0c:	2800      	cmp	r0, #0
 8005a0e:	d0f3      	beq.n	80059f8 <bmk6_execute.10819+0x28>
  test_print("--- Score : ");
 8005a10:	480a      	ldr	r0, [pc, #40]	; (8005a3c <bmk6_execute.10819+0x6c>)
 8005a12:	f7fb f8dd 	bl	8000bd0 <test_print>
  test_printn(n);
 8005a16:	1c20      	adds	r0, r4, #0
 8005a18:	f7fb f8f2 	bl	8000c00 <test_printn>
  test_println(" threads/S");
 8005a1c:	4808      	ldr	r0, [pc, #32]	; (8005a40 <bmk6_execute.10819+0x70>)
 8005a1e:	f7fb f8b7 	bl	8000b90 <test_println>
}
 8005a22:	b003      	add	sp, #12
 8005a24:	bc0c      	pop	{r2, r3}
 8005a26:	4690      	mov	r8, r2
 8005a28:	4699      	mov	r9, r3
 8005a2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005a2c:	20001040 	.word	0x20001040
 8005a30:	200006b8 	.word	0x200006b8
 8005a34:	080011d1 	.word	0x080011d1
 8005a38:	20000e18 	.word	0x20000e18
 8005a3c:	08008650 	.word	0x08008650
 8005a40:	0800868c 	.word	0x0800868c
 8005a44:	46c0      	nop			; (mov r8, r8)
 8005a46:	46c0      	nop			; (mov r8, r8)
 8005a48:	46c0      	nop			; (mov r8, r8)
 8005a4a:	46c0      	nop			; (mov r8, r8)
 8005a4c:	46c0      	nop			; (mov r8, r8)
 8005a4e:	46c0      	nop			; (mov r8, r8)

08005a50 <bmk10_execute.10812>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 8005a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a52:	464f      	mov	r7, r9
 8005a54:	4646      	mov	r6, r8
 8005a56:	b4c0      	push	{r6, r7}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 8005a58:	f7fc fe52 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 8005a5c:	f7ff ff68 	bl	8005930 <test_start_timer.constprop.11>
 8005a60:	4a1e      	ldr	r2, [pc, #120]	; (8005adc <bmk10_execute.10812+0x8c>)
 8005a62:	4b1f      	ldr	r3, [pc, #124]	; (8005ae0 <bmk10_execute.10812+0x90>)
 8005a64:	4f1f      	ldr	r7, [pc, #124]	; (8005ae4 <bmk10_execute.10812+0x94>)
 8005a66:	4e20      	ldr	r6, [pc, #128]	; (8005ae8 <bmk10_execute.10812+0x98>)
 8005a68:	4c20      	ldr	r4, [pc, #128]	; (8005aec <bmk10_execute.10812+0x9c>)

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8005a6a:	2500      	movs	r5, #0
 8005a6c:	4690      	mov	r8, r2
 8005a6e:	4699      	mov	r9, r3
 8005a70:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005a72:	f7fe f815 	bl	8003aa0 <_dbg_check_lock>

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8005a76:	4640      	mov	r0, r8
 8005a78:	2101      	movs	r1, #1
 8005a7a:	1c3a      	adds	r2, r7, #0
 8005a7c:	2300      	movs	r3, #0
 8005a7e:	f7fa ff57 	bl	8000930 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8005a82:	491b      	ldr	r1, [pc, #108]	; (8005af0 <bmk10_execute.10812+0xa0>)
 8005a84:	1c3a      	adds	r2, r7, #0
 8005a86:	2300      	movs	r3, #0
 8005a88:	1c30      	adds	r0, r6, #0
 8005a8a:	f7fa ff51 	bl	8000930 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8005a8e:	4640      	mov	r0, r8
 8005a90:	f7fa fefe 	bl	8000890 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8005a94:	1c30      	adds	r0, r6, #0
 8005a96:	f7fa fefb 	bl	8000890 <chVTDoResetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005a9a:	f7fd ff69 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005a9e:	6820      	ldr	r0, [r4, #0]
 8005aa0:	42a0      	cmp	r0, r4
 8005aa2:	d004      	beq.n	8005aae <bmk10_execute.10812+0x5e>
 8005aa4:	69a1      	ldr	r1, [r4, #24]
 8005aa6:	6883      	ldr	r3, [r0, #8]
 8005aa8:	688a      	ldr	r2, [r1, #8]
 8005aaa:	429a      	cmp	r2, r3
 8005aac:	d312      	bcc.n	8005ad4 <bmk10_execute.10812+0x84>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005aae:	b662      	cpsie	i
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005ab0:	4648      	mov	r0, r9
 8005ab2:	7801      	ldrb	r1, [r0, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 8005ab4:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005ab6:	2900      	cmp	r1, #0
 8005ab8:	d0da      	beq.n	8005a70 <bmk10_execute.10812+0x20>
  test_print("--- Score : ");
 8005aba:	480e      	ldr	r0, [pc, #56]	; (8005af4 <bmk10_execute.10812+0xa4>)
 8005abc:	f7fb f888 	bl	8000bd0 <test_print>
  test_printn(n * 2);
 8005ac0:	0068      	lsls	r0, r5, #1
 8005ac2:	f7fb f89d 	bl	8000c00 <test_printn>
  test_println(" timers/S");
 8005ac6:	480c      	ldr	r0, [pc, #48]	; (8005af8 <bmk10_execute.10812+0xa8>)
 8005ac8:	f7fb f862 	bl	8000b90 <test_println>
}
 8005acc:	bc0c      	pop	{r2, r3}
 8005ace:	4690      	mov	r8, r2
 8005ad0:	4699      	mov	r9, r3
 8005ad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005ad4:	b672      	cpsid	i
 8005ad6:	4d09      	ldr	r5, [pc, #36]	; (8005afc <bmk10_execute.10812+0xac>)
 8005ad8:	62e5      	str	r5, [r4, #44]	; 0x2c
 8005ada:	e7fe      	b.n	8005ada <bmk10_execute.10812+0x8a>
 8005adc:	20000dd0 	.word	0x20000dd0
 8005ae0:	20000e18 	.word	0x20000e18
 8005ae4:	080004c1 	.word	0x080004c1
 8005ae8:	20000dbc 	.word	0x20000dbc
 8005aec:	20001040 	.word	0x20001040
 8005af0:	00002710 	.word	0x00002710
 8005af4:	08008650 	.word	0x08008650
 8005af8:	08008a30 	.word	0x08008a30
 8005afc:	08008ab0 	.word	0x08008ab0

08005b00 <bmk11_execute.10802>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 8005b00:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = 0;

  test_wait_tick();
 8005b02:	f7fc fdfd 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 8005b06:	f7ff ff13 	bl	8005930 <test_start_timer.constprop.11>
 8005b0a:	4c14      	ldr	r4, [pc, #80]	; (8005b5c <bmk11_execute.10802+0x5c>)
 8005b0c:	4e14      	ldr	r6, [pc, #80]	; (8005b60 <bmk11_execute.10802+0x60>)

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
  uint32_t n = 0;
 8005b0e:	2500      	movs	r5, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemWait(&sem1);
 8005b10:	1c20      	adds	r0, r4, #0
 8005b12:	f7fc fcfd 	bl	8002510 <chSemWait>
    chSemSignal(&sem1);
 8005b16:	1c20      	adds	r0, r4, #0
 8005b18:	f7fe f82a 	bl	8003b70 <chSemSignal>
    chSemWait(&sem1);
 8005b1c:	1c20      	adds	r0, r4, #0
 8005b1e:	f7fc fcf7 	bl	8002510 <chSemWait>
    chSemSignal(&sem1);
 8005b22:	1c20      	adds	r0, r4, #0
 8005b24:	f7fe f824 	bl	8003b70 <chSemSignal>
    chSemWait(&sem1);
 8005b28:	1c20      	adds	r0, r4, #0
 8005b2a:	f7fc fcf1 	bl	8002510 <chSemWait>
    chSemSignal(&sem1);
 8005b2e:	1c20      	adds	r0, r4, #0
 8005b30:	f7fe f81e 	bl	8003b70 <chSemSignal>
    chSemWait(&sem1);
 8005b34:	1c20      	adds	r0, r4, #0
 8005b36:	f7fc fceb 	bl	8002510 <chSemWait>
    chSemSignal(&sem1);
 8005b3a:	1c20      	adds	r0, r4, #0
 8005b3c:	f7fe f818 	bl	8003b70 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005b40:	7833      	ldrb	r3, [r6, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 8005b42:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005b44:	2b00      	cmp	r3, #0
 8005b46:	d0e3      	beq.n	8005b10 <bmk11_execute.10802+0x10>
  test_print("--- Score : ");
 8005b48:	4806      	ldr	r0, [pc, #24]	; (8005b64 <bmk11_execute.10802+0x64>)
 8005b4a:	f7fb f841 	bl	8000bd0 <test_print>
  test_printn(n * 4);
 8005b4e:	00a8      	lsls	r0, r5, #2
 8005b50:	f7fb f856 	bl	8000c00 <test_printn>
  test_println(" wait+signal/S");
 8005b54:	4804      	ldr	r0, [pc, #16]	; (8005b68 <bmk11_execute.10802+0x68>)
 8005b56:	f7fb f81b 	bl	8000b90 <test_println>
}
 8005b5a:	bd70      	pop	{r4, r5, r6, pc}
 8005b5c:	20000d48 	.word	0x20000d48
 8005b60:	20000e18 	.word	0x20000e18
 8005b64:	08008650 	.word	0x08008650
 8005b68:	08008a3c 	.word	0x08008a3c
 8005b6c:	46c0      	nop			; (mov r8, r8)
 8005b6e:	46c0      	nop			; (mov r8, r8)

08005b70 <bmk12_execute.10798>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 8005b70:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = 0;

  test_wait_tick();
 8005b72:	f7fc fdc5 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 8005b76:	f7ff fedb 	bl	8005930 <test_start_timer.constprop.11>
 8005b7a:	4c14      	ldr	r4, [pc, #80]	; (8005bcc <bmk12_execute.10798+0x5c>)
 8005b7c:	4e14      	ldr	r6, [pc, #80]	; (8005bd0 <bmk12_execute.10798+0x60>)

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
  uint32_t n = 0;
 8005b7e:	2500      	movs	r5, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chMtxLock(&mtx1);
 8005b80:	1c20      	adds	r0, r4, #0
 8005b82:	f7fc fe15 	bl	80027b0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8005b86:	1c20      	adds	r0, r4, #0
 8005b88:	f7fc fe32 	bl	80027f0 <chMtxUnlock>
    chMtxLock(&mtx1);
 8005b8c:	1c20      	adds	r0, r4, #0
 8005b8e:	f7fc fe0f 	bl	80027b0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8005b92:	1c20      	adds	r0, r4, #0
 8005b94:	f7fc fe2c 	bl	80027f0 <chMtxUnlock>
    chMtxLock(&mtx1);
 8005b98:	1c20      	adds	r0, r4, #0
 8005b9a:	f7fc fe09 	bl	80027b0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8005b9e:	1c20      	adds	r0, r4, #0
 8005ba0:	f7fc fe26 	bl	80027f0 <chMtxUnlock>
    chMtxLock(&mtx1);
 8005ba4:	1c20      	adds	r0, r4, #0
 8005ba6:	f7fc fe03 	bl	80027b0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8005baa:	1c20      	adds	r0, r4, #0
 8005bac:	f7fc fe20 	bl	80027f0 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005bb0:	7833      	ldrb	r3, [r6, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 8005bb2:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8005bb4:	2b00      	cmp	r3, #0
 8005bb6:	d0e3      	beq.n	8005b80 <bmk12_execute.10798+0x10>
  test_print("--- Score : ");
 8005bb8:	4806      	ldr	r0, [pc, #24]	; (8005bd4 <bmk12_execute.10798+0x64>)
 8005bba:	f7fb f809 	bl	8000bd0 <test_print>
  test_printn(n * 4);
 8005bbe:	00a8      	lsls	r0, r5, #2
 8005bc0:	f7fb f81e 	bl	8000c00 <test_printn>
  test_println(" lock+unlock/S");
 8005bc4:	4804      	ldr	r0, [pc, #16]	; (8005bd8 <bmk12_execute.10798+0x68>)
 8005bc6:	f7fa ffe3 	bl	8000b90 <test_println>
}
 8005bca:	bd70      	pop	{r4, r5, r6, pc}
 8005bcc:	20000de4 	.word	0x20000de4
 8005bd0:	20000e18 	.word	0x20000e18
 8005bd4:	08008650 	.word	0x08008650
 8005bd8:	08008a4c 	.word	0x08008a4c
 8005bdc:	46c0      	nop			; (mov r8, r8)
 8005bde:	46c0      	nop			; (mov r8, r8)

08005be0 <thd1_execute.8734>:

static void thd1_execute(void) {
 8005be0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005be2:	4647      	mov	r7, r8
 8005be4:	b480      	push	{r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005be6:	4f2a      	ldr	r7, [pc, #168]	; (8005c90 <thd1_execute.8734+0xb0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005be8:	4d2a      	ldr	r5, [pc, #168]	; (8005c94 <thd1_execute.8734+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005bea:	69b8      	ldr	r0, [r7, #24]
 8005bec:	4b2a      	ldr	r3, [pc, #168]	; (8005c98 <thd1_execute.8734+0xb8>)
 8005bee:	6882      	ldr	r2, [r0, #8]
 8005bf0:	492a      	ldr	r1, [pc, #168]	; (8005c9c <thd1_execute.8734+0xbc>)
 8005bf2:	26a8      	movs	r6, #168	; 0xa8
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 8005bf4:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005bf6:	0076      	lsls	r6, r6, #1
 8005bf8:	4698      	mov	r8, r3
 8005bfa:	9100      	str	r1, [sp, #0]
 8005bfc:	3a05      	subs	r2, #5
 8005bfe:	1c31      	adds	r1, r6, #0
 8005c00:	1c18      	adds	r0, r3, #0
 8005c02:	1c2b      	adds	r3, r5, #0
 8005c04:	f7fd f924 	bl	8002e50 <chThdCreateStatic>
 8005c08:	4c25      	ldr	r4, [pc, #148]	; (8005ca0 <thd1_execute.8734+0xc0>)
 8005c0a:	69ba      	ldr	r2, [r7, #24]
 8005c0c:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005c0e:	6892      	ldr	r2, [r2, #8]
 8005c10:	4b24      	ldr	r3, [pc, #144]	; (8005ca4 <thd1_execute.8734+0xc4>)
 8005c12:	4640      	mov	r0, r8
 8005c14:	3051      	adds	r0, #81	; 0x51
 8005c16:	9300      	str	r3, [sp, #0]
 8005c18:	1c31      	adds	r1, r6, #0
 8005c1a:	1c2b      	adds	r3, r5, #0
 8005c1c:	3a04      	subs	r2, #4
 8005c1e:	30ff      	adds	r0, #255	; 0xff
 8005c20:	f7fd f916 	bl	8002e50 <chThdCreateStatic>
 8005c24:	69ba      	ldr	r2, [r7, #24]
 8005c26:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005c28:	20a8      	movs	r0, #168	; 0xa8
 8005c2a:	6892      	ldr	r2, [r2, #8]
 8005c2c:	4b1e      	ldr	r3, [pc, #120]	; (8005ca8 <thd1_execute.8734+0xc8>)
 8005c2e:	0081      	lsls	r1, r0, #2
 8005c30:	1c08      	adds	r0, r1, #0
 8005c32:	9300      	str	r3, [sp, #0]
 8005c34:	1c31      	adds	r1, r6, #0
 8005c36:	1c2b      	adds	r3, r5, #0
 8005c38:	4440      	add	r0, r8
 8005c3a:	3a03      	subs	r2, #3
 8005c3c:	f7fd f908 	bl	8002e50 <chThdCreateStatic>
 8005c40:	69ba      	ldr	r2, [r7, #24]
 8005c42:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005c44:	20fc      	movs	r0, #252	; 0xfc
 8005c46:	6892      	ldr	r2, [r2, #8]
 8005c48:	4b18      	ldr	r3, [pc, #96]	; (8005cac <thd1_execute.8734+0xcc>)
 8005c4a:	0081      	lsls	r1, r0, #2
 8005c4c:	1c08      	adds	r0, r1, #0
 8005c4e:	9300      	str	r3, [sp, #0]
 8005c50:	1c31      	adds	r1, r6, #0
 8005c52:	1c2b      	adds	r3, r5, #0
 8005c54:	4440      	add	r0, r8
 8005c56:	3a02      	subs	r2, #2
 8005c58:	f7fd f8fa 	bl	8002e50 <chThdCreateStatic>
 8005c5c:	69bf      	ldr	r7, [r7, #24]
 8005c5e:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005c60:	20a8      	movs	r0, #168	; 0xa8
 8005c62:	68ba      	ldr	r2, [r7, #8]
 8005c64:	4b12      	ldr	r3, [pc, #72]	; (8005cb0 <thd1_execute.8734+0xd0>)
 8005c66:	00c1      	lsls	r1, r0, #3
 8005c68:	1c08      	adds	r0, r1, #0
 8005c6a:	3a01      	subs	r2, #1
 8005c6c:	1c31      	adds	r1, r6, #0
 8005c6e:	9300      	str	r3, [sp, #0]
 8005c70:	4440      	add	r0, r8
 8005c72:	1c2b      	adds	r3, r5, #0
 8005c74:	f7fd f8ec 	bl	8002e50 <chThdCreateStatic>
 8005c78:	6120      	str	r0, [r4, #16]
  test_wait_threads();
 8005c7a:	f7fb ff59 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8005c7e:	490d      	ldr	r1, [pc, #52]	; (8005cb4 <thd1_execute.8734+0xd4>)
 8005c80:	2001      	movs	r0, #1
 8005c82:	f7fa ff1d 	bl	8000ac0 <_test_assert_sequence>
}
 8005c86:	b002      	add	sp, #8
 8005c88:	bc04      	pop	{r2}
 8005c8a:	4690      	mov	r8, r2
 8005c8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005c8e:	46c0      	nop			; (mov r8, r8)
 8005c90:	20001040 	.word	0x20001040
 8005c94:	08005131 	.word	0x08005131
 8005c98:	200006b8 	.word	0x200006b8
 8005c9c:	080089b0 	.word	0x080089b0
 8005ca0:	200015b8 	.word	0x200015b8
 8005ca4:	080089a8 	.word	0x080089a8
 8005ca8:	080089a0 	.word	0x080089a0
 8005cac:	080089a4 	.word	0x080089a4
 8005cb0:	08008698 	.word	0x08008698
 8005cb4:	080089ac 	.word	0x080089ac
 8005cb8:	46c0      	nop			; (mov r8, r8)
 8005cba:	46c0      	nop			; (mov r8, r8)
 8005cbc:	46c0      	nop			; (mov r8, r8)
 8005cbe:	46c0      	nop			; (mov r8, r8)

08005cc0 <sys1_execute.10538>:

static void sys1_execute(void) {
 8005cc0:	b530      	push	{r4, r5, lr}
 8005cc2:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8005cc4:	f7fe fae4 	bl	8004290 <chSysGetStatusAndLockX>
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 8005cc8:	07c2      	lsls	r2, r0, #31
 8005cca:	d401      	bmi.n	8005cd0 <sys1_execute.10538+0x10>
 8005ccc:	f7fd fe68 	bl	80039a0 <chSysRestoreStatusX.part.2.4280>
 8005cd0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005cd2:	f7fd fee5 	bl	8003aa0 <_dbg_check_lock>
  chSysRestoreStatusX(sts);

  /* Reentrant case.*/
  chSysLock();
  sts = chSysGetStatusAndLockX();
 8005cd6:	f7fe fadb 	bl	8004290 <chSysGetStatusAndLockX>
 8005cda:	07c3      	lsls	r3, r0, #31
 8005cdc:	d401      	bmi.n	8005ce2 <sys1_execute.10538+0x22>
 8005cde:	f7fd fe5f 	bl	80039a0 <chSysRestoreStatusX.part.2.4280>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005ce2:	f7fd fe45 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005ce6:	4c4b      	ldr	r4, [pc, #300]	; (8005e14 <sys1_execute.10538+0x154>)
 8005ce8:	6823      	ldr	r3, [r4, #0]
 8005cea:	42a3      	cmp	r3, r4
 8005cec:	d004      	beq.n	8005cf8 <sys1_execute.10538+0x38>
 8005cee:	69a2      	ldr	r2, [r4, #24]
 8005cf0:	6899      	ldr	r1, [r3, #8]
 8005cf2:	6890      	ldr	r0, [r2, #8]
 8005cf4:	4288      	cmp	r0, r1
 8005cf6:	d35d      	bcc.n	8005db4 <sys1_execute.10538+0xf4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005cf8:	b662      	cpsie	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8005cfa:	f3ef 8510 	mrs	r5, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8005cfe:	07ea      	lsls	r2, r5, #31
 8005d00:	d402      	bmi.n	8005d08 <sys1_execute.10538+0x48>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005d02:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005d04:	f7fd fecc 	bl	8003aa0 <_dbg_check_lock>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8005d08:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8005d0c:	07da      	lsls	r2, r3, #31
 8005d0e:	d402      	bmi.n	8005d16 <sys1_execute.10538+0x56>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005d10:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005d12:	f7fd fec5 	bl	8003aa0 <_dbg_check_lock>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005d16:	f7fd fe2b 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005d1a:	6820      	ldr	r0, [r4, #0]
 8005d1c:	42a0      	cmp	r0, r4
 8005d1e:	d004      	beq.n	8005d2a <sys1_execute.10538+0x6a>
 8005d20:	69a2      	ldr	r2, [r4, #24]
 8005d22:	6885      	ldr	r5, [r0, #8]
 8005d24:	6891      	ldr	r1, [r2, #8]
 8005d26:	42a9      	cmp	r1, r5
 8005d28:	d348      	bcc.n	8005dbc <sys1_execute.10538+0xfc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005d2a:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005d2c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005d2e:	f7fd feb7 	bl	8003aa0 <_dbg_check_lock>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8005d32:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8005d36:	07da      	lsls	r2, r3, #31
 8005d38:	d458      	bmi.n	8005dec <sys1_execute.10538+0x12c>
 8005d3a:	f3ef 8310 	mrs	r3, PRIMASK
 8005d3e:	07da      	lsls	r2, r3, #31
 8005d40:	d444      	bmi.n	8005dcc <sys1_execute.10538+0x10c>
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 8005d42:	2300      	movs	r3, #0
 8005d44:	9304      	str	r3, [sp, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005d46:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005d48:	f7fd feaa 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8005d4c:	f7fa fc90 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8005d50:	9804      	ldr	r0, [sp, #16]
 8005d52:	2800      	cmp	r0, #0
 8005d54:	d002      	beq.n	8005d5c <sys1_execute.10538+0x9c>
    chVTDoResetI(vtp);
 8005d56:	a801      	add	r0, sp, #4
 8005d58:	f7fa fd9a 	bl	8000890 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8005d5c:	2101      	movs	r1, #1
 8005d5e:	a801      	add	r0, sp, #4
 8005d60:	4a2d      	ldr	r2, [pc, #180]	; (8005e18 <sys1_execute.10538+0x158>)
 8005d62:	2300      	movs	r3, #0
 8005d64:	f7fa fde4 	bl	8000930 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005d68:	f7fd fe02 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005d6c:	6821      	ldr	r1, [r4, #0]
 8005d6e:	42a1      	cmp	r1, r4
 8005d70:	d004      	beq.n	8005d7c <sys1_execute.10538+0xbc>
 8005d72:	69a2      	ldr	r2, [r4, #24]
 8005d74:	688b      	ldr	r3, [r1, #8]
 8005d76:	6895      	ldr	r5, [r2, #8]
 8005d78:	429d      	cmp	r5, r3
 8005d7a:	d323      	bcc.n	8005dc4 <sys1_execute.10538+0x104>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005d7c:	b662      	cpsie	i
  chSysUnconditionalUnlock();

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
  chVTSet(&vt, 1, vtcb, NULL);
  chThdSleep(10);
 8005d7e:	200a      	movs	r0, #10
 8005d80:	f7fc fc96 	bl	80026b0 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005d84:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005d86:	f7fd fe8b 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8005d8a:	f7fa fc71 	bl	8000670 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 8005d8e:	9d04      	ldr	r5, [sp, #16]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005d90:	f7fd fdee 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005d94:	6820      	ldr	r0, [r4, #0]
 8005d96:	42a0      	cmp	r0, r4
 8005d98:	d004      	beq.n	8005da4 <sys1_execute.10538+0xe4>
 8005d9a:	69a1      	ldr	r1, [r4, #24]
 8005d9c:	6883      	ldr	r3, [r0, #8]
 8005d9e:	688a      	ldr	r2, [r1, #8]
 8005da0:	429a      	cmp	r2, r3
 8005da2:	d32f      	bcc.n	8005e04 <sys1_execute.10538+0x144>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005da4:	b662      	cpsie	i

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8005da6:	2001      	movs	r0, #1
 8005da8:	4269      	negs	r1, r5
 8005daa:	4169      	adcs	r1, r5
 8005dac:	f7fa fed8 	bl	8000b60 <_test_assert>
}
 8005db0:	b007      	add	sp, #28
 8005db2:	bd30      	pop	{r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005db4:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8005db6:	4d19      	ldr	r5, [pc, #100]	; (8005e1c <sys1_execute.10538+0x15c>)
 8005db8:	62e5      	str	r5, [r4, #44]	; 0x2c
 8005dba:	e7fe      	b.n	8005dba <sys1_execute.10538+0xfa>
 8005dbc:	b672      	cpsid	i
 8005dbe:	4b17      	ldr	r3, [pc, #92]	; (8005e1c <sys1_execute.10538+0x15c>)
 8005dc0:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005dc2:	e7fe      	b.n	8005dc2 <sys1_execute.10538+0x102>
 8005dc4:	b672      	cpsid	i
 8005dc6:	4815      	ldr	r0, [pc, #84]	; (8005e1c <sys1_execute.10538+0x15c>)
 8005dc8:	62e0      	str	r0, [r4, #44]	; 0x2c
 8005dca:	e7fe      	b.n	8005dca <sys1_execute.10538+0x10a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005dcc:	f7fd fdd0 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005dd0:	6820      	ldr	r0, [r4, #0]
 8005dd2:	42a0      	cmp	r0, r4
 8005dd4:	d004      	beq.n	8005de0 <sys1_execute.10538+0x120>
 8005dd6:	69a2      	ldr	r2, [r4, #24]
 8005dd8:	6885      	ldr	r5, [r0, #8]
 8005dda:	6891      	ldr	r1, [r2, #8]
 8005ddc:	42a9      	cmp	r1, r5
 8005dde:	d301      	bcc.n	8005de4 <sys1_execute.10538+0x124>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005de0:	b662      	cpsie	i
 8005de2:	e7ae      	b.n	8005d42 <sys1_execute.10538+0x82>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005de4:	b672      	cpsid	i
 8005de6:	490d      	ldr	r1, [pc, #52]	; (8005e1c <sys1_execute.10538+0x15c>)
 8005de8:	62e1      	str	r1, [r4, #44]	; 0x2c
 8005dea:	e7fe      	b.n	8005dea <sys1_execute.10538+0x12a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005dec:	f7fd fdc0 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005df0:	6820      	ldr	r0, [r4, #0]
 8005df2:	42a0      	cmp	r0, r4
 8005df4:	d004      	beq.n	8005e00 <sys1_execute.10538+0x140>
 8005df6:	69a2      	ldr	r2, [r4, #24]
 8005df8:	6885      	ldr	r5, [r0, #8]
 8005dfa:	6891      	ldr	r1, [r2, #8]
 8005dfc:	42a9      	cmp	r1, r5
 8005dfe:	d305      	bcc.n	8005e0c <sys1_execute.10538+0x14c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005e00:	b662      	cpsie	i
 8005e02:	e79a      	b.n	8005d3a <sys1_execute.10538+0x7a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005e04:	b672      	cpsid	i
 8005e06:	4d05      	ldr	r5, [pc, #20]	; (8005e1c <sys1_execute.10538+0x15c>)
 8005e08:	62e5      	str	r5, [r4, #44]	; 0x2c
 8005e0a:	e7fe      	b.n	8005e0a <sys1_execute.10538+0x14a>
 8005e0c:	b672      	cpsid	i
 8005e0e:	4a03      	ldr	r2, [pc, #12]	; (8005e1c <sys1_execute.10538+0x15c>)
 8005e10:	62e2      	str	r2, [r4, #44]	; 0x2c
 8005e12:	e7fe      	b.n	8005e12 <sys1_execute.10538+0x152>
 8005e14:	20001040 	.word	0x20001040
 8005e18:	080042c1 	.word	0x080042c1
 8005e1c:	08008a80 	.word	0x08008a80

08005e20 <sys3_execute.10546>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 8005e20:	b538      	push	{r3, r4, r5, lr}
 8005e22:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005e24:	f7fd fe3c 	bl	8003aa0 <_dbg_check_lock>
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8005e28:	2001      	movs	r0, #1
 8005e2a:	f7fa fc31 	bl	8000690 <chSysIntegrityCheckI>
 8005e2e:	1c05      	adds	r5, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005e30:	f7fd fd9e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005e34:	4c37      	ldr	r4, [pc, #220]	; (8005f14 <sys3_execute.10546+0xf4>)
 8005e36:	6823      	ldr	r3, [r4, #0]
 8005e38:	42a3      	cmp	r3, r4
 8005e3a:	d004      	beq.n	8005e46 <sys3_execute.10546+0x26>
 8005e3c:	69a2      	ldr	r2, [r4, #24]
 8005e3e:	6899      	ldr	r1, [r3, #8]
 8005e40:	6890      	ldr	r0, [r2, #8]
 8005e42:	4288      	cmp	r0, r1
 8005e44:	d309      	bcc.n	8005e5a <sys3_execute.10546+0x3a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005e46:	b662      	cpsie	i
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
 8005e48:	2301      	movs	r3, #1
 8005e4a:	406b      	eors	r3, r5
 8005e4c:	b2d9      	uxtb	r1, r3
 8005e4e:	2001      	movs	r0, #1
 8005e50:	f7fa fe86 	bl	8000b60 <_test_assert>
 8005e54:	2800      	cmp	r0, #0
 8005e56:	d004      	beq.n	8005e62 <sys3_execute.10546+0x42>

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
}
 8005e58:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005e5a:	b672      	cpsid	i
 8005e5c:	492e      	ldr	r1, [pc, #184]	; (8005f18 <sys3_execute.10546+0xf8>)
 8005e5e:	62e1      	str	r1, [r4, #44]	; 0x2c
 8005e60:	e7fe      	b.n	8005e60 <sys3_execute.10546+0x40>
 8005e62:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005e64:	f7fd fe1c 	bl	8003aa0 <_dbg_check_lock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8005e68:	2002      	movs	r0, #2
 8005e6a:	f7fa fc11 	bl	8000690 <chSysIntegrityCheckI>
 8005e6e:	1c05      	adds	r5, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005e70:	f7fd fd7e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005e74:	6820      	ldr	r0, [r4, #0]
 8005e76:	42a0      	cmp	r0, r4
 8005e78:	d004      	beq.n	8005e84 <sys3_execute.10546+0x64>
 8005e7a:	69a2      	ldr	r2, [r4, #24]
 8005e7c:	6883      	ldr	r3, [r0, #8]
 8005e7e:	6891      	ldr	r1, [r2, #8]
 8005e80:	4299      	cmp	r1, r3
 8005e82:	d33b      	bcc.n	8005efc <sys3_execute.10546+0xdc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005e84:	b662      	cpsie	i
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
 8005e86:	2001      	movs	r0, #1
 8005e88:	4068      	eors	r0, r5
 8005e8a:	b2c1      	uxtb	r1, r0
 8005e8c:	2002      	movs	r0, #2
 8005e8e:	f7fa fe67 	bl	8000b60 <_test_assert>
 8005e92:	2800      	cmp	r0, #0
 8005e94:	d1e0      	bne.n	8005e58 <sys3_execute.10546+0x38>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005e96:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005e98:	f7fd fe02 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8005e9c:	2004      	movs	r0, #4
 8005e9e:	f7fa fbf7 	bl	8000690 <chSysIntegrityCheckI>
 8005ea2:	1c05      	adds	r5, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005ea4:	f7fd fd64 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005ea8:	6821      	ldr	r1, [r4, #0]
 8005eaa:	42a1      	cmp	r1, r4
 8005eac:	d004      	beq.n	8005eb8 <sys3_execute.10546+0x98>
 8005eae:	69a2      	ldr	r2, [r4, #24]
 8005eb0:	688b      	ldr	r3, [r1, #8]
 8005eb2:	6890      	ldr	r0, [r2, #8]
 8005eb4:	4298      	cmp	r0, r3
 8005eb6:	d325      	bcc.n	8005f04 <sys3_execute.10546+0xe4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005eb8:	b662      	cpsie	i
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
 8005eba:	2101      	movs	r1, #1
 8005ebc:	4069      	eors	r1, r5
 8005ebe:	b2c9      	uxtb	r1, r1
 8005ec0:	2003      	movs	r0, #3
 8005ec2:	f7fa fe4d 	bl	8000b60 <_test_assert>
 8005ec6:	2800      	cmp	r0, #0
 8005ec8:	d1c6      	bne.n	8005e58 <sys3_execute.10546+0x38>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005eca:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005ecc:	f7fd fde8 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8005ed0:	2008      	movs	r0, #8
 8005ed2:	f7fa fbdd 	bl	8000690 <chSysIntegrityCheckI>
 8005ed6:	1c05      	adds	r5, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005ed8:	f7fd fd4a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005edc:	6820      	ldr	r0, [r4, #0]
 8005ede:	42a0      	cmp	r0, r4
 8005ee0:	d004      	beq.n	8005eec <sys3_execute.10546+0xcc>
 8005ee2:	69a2      	ldr	r2, [r4, #24]
 8005ee4:	6883      	ldr	r3, [r0, #8]
 8005ee6:	6891      	ldr	r1, [r2, #8]
 8005ee8:	4299      	cmp	r1, r3
 8005eea:	d30f      	bcc.n	8005f0c <sys3_execute.10546+0xec>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005eec:	b662      	cpsie	i
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 8005eee:	2401      	movs	r4, #1
 8005ef0:	406c      	eors	r4, r5
 8005ef2:	b2e1      	uxtb	r1, r4
 8005ef4:	2004      	movs	r0, #4
 8005ef6:	f7fa fe33 	bl	8000b60 <_test_assert>
 8005efa:	e7ad      	b.n	8005e58 <sys3_execute.10546+0x38>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005efc:	b672      	cpsid	i
 8005efe:	4a06      	ldr	r2, [pc, #24]	; (8005f18 <sys3_execute.10546+0xf8>)
 8005f00:	62e2      	str	r2, [r4, #44]	; 0x2c
 8005f02:	e7fe      	b.n	8005f02 <sys3_execute.10546+0xe2>
 8005f04:	b672      	cpsid	i
 8005f06:	4804      	ldr	r0, [pc, #16]	; (8005f18 <sys3_execute.10546+0xf8>)
 8005f08:	62e0      	str	r0, [r4, #44]	; 0x2c
 8005f0a:	e7fe      	b.n	8005f0a <sys3_execute.10546+0xea>
 8005f0c:	b672      	cpsid	i
 8005f0e:	4d02      	ldr	r5, [pc, #8]	; (8005f18 <sys3_execute.10546+0xf8>)
 8005f10:	62e5      	str	r5, [r4, #44]	; 0x2c
 8005f12:	e7fe      	b.n	8005f12 <sys3_execute.10546+0xf2>
 8005f14:	20001040 	.word	0x20001040
 8005f18:	08008a80 	.word	0x08008a80
 8005f1c:	46c0      	nop			; (mov r8, r8)
 8005f1e:	46c0      	nop			; (mov r8, r8)

08005f20 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8005f20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005f22:	464e      	mov	r6, r9
 8005f24:	4645      	mov	r5, r8
 8005f26:	4657      	mov	r7, sl
 8005f28:	b4e0      	push	{r5, r6, r7}
 8005f2a:	1c15      	adds	r5, r2, #0
  qnotify_t nfy = iqp->q_notify;
 8005f2c:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8005f2e:	1c04      	adds	r4, r0, #0
 8005f30:	1c0e      	adds	r6, r1, #0
 8005f32:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8005f34:	4690      	mov	r8, r2
 8005f36:	b672      	cpsid	i
  size_t r = 0;

  chDbgCheck(n > 0U);
 8005f38:	2d00      	cmp	r5, #0
 8005f3a:	d04b      	beq.n	8005fd4 <chIQReadTimeout+0xb4>
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
 8005f3c:	3d01      	subs	r5, #1
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005f3e:	f7fd fdaf 	bl	8003aa0 <_dbg_check_lock>
 8005f42:	19a8      	adds	r0, r5, r6
 8005f44:	4d27      	ldr	r5, [pc, #156]	; (8005fe4 <chIQReadTimeout+0xc4>)
 8005f46:	4682      	mov	sl, r0
                       size_t n, systime_t timeout) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8005f48:	2700      	movs	r7, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8005f4a:	4643      	mov	r3, r8
 8005f4c:	2b00      	cmp	r3, #0
 8005f4e:	d001      	beq.n	8005f54 <chIQReadTimeout+0x34>
      nfy(iqp);
 8005f50:	1c20      	adds	r0, r4, #0
 8005f52:	47c0      	blx	r8
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8005f54:	f7fa fb8c 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8005f58:	68a1      	ldr	r1, [r4, #8]
    }

    while (chIQIsEmptyI(iqp)) {
 8005f5a:	2900      	cmp	r1, #0
 8005f5c:	d11a      	bne.n	8005f94 <chIQReadTimeout+0x74>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8005f5e:	1c20      	adds	r0, r4, #0
 8005f60:	4649      	mov	r1, r9
 8005f62:	f7fb f88d 	bl	8001080 <chThdEnqueueTimeoutS>
 8005f66:	2800      	cmp	r0, #0
 8005f68:	d0f4      	beq.n	8005f54 <chIQReadTimeout+0x34>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005f6a:	f7fd fd01 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005f6e:	6828      	ldr	r0, [r5, #0]
 8005f70:	42a8      	cmp	r0, r5
 8005f72:	d004      	beq.n	8005f7e <chIQReadTimeout+0x5e>
 8005f74:	69ab      	ldr	r3, [r5, #24]
 8005f76:	6882      	ldr	r2, [r0, #8]
 8005f78:	6899      	ldr	r1, [r3, #8]
 8005f7a:	4291      	cmp	r1, r2
 8005f7c:	d306      	bcc.n	8005f8c <chIQReadTimeout+0x6c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005f7e:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 8005f80:	1c38      	adds	r0, r7, #0
 8005f82:	bc1c      	pop	{r2, r3, r4}
 8005f84:	4690      	mov	r8, r2
 8005f86:	4699      	mov	r9, r3
 8005f88:	46a2      	mov	sl, r4
 8005f8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005f8c:	b672      	cpsid	i
 8005f8e:	4c16      	ldr	r4, [pc, #88]	; (8005fe8 <chIQReadTimeout+0xc8>)
 8005f90:	62ec      	str	r4, [r5, #44]	; 0x2c
 8005f92:	e7fe      	b.n	8005f92 <chIQReadTimeout+0x72>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8005f94:	68a2      	ldr	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8005f96:	69a0      	ldr	r0, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8005f98:	3a01      	subs	r2, #1
 8005f9a:	60a2      	str	r2, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8005f9c:	7803      	ldrb	r3, [r0, #0]
 8005f9e:	3001      	adds	r0, #1
 8005fa0:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8005fa2:	6921      	ldr	r1, [r4, #16]
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8005fa4:	61a0      	str	r0, [r4, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 8005fa6:	4288      	cmp	r0, r1
 8005fa8:	d301      	bcc.n	8005fae <chIQReadTimeout+0x8e>
      iqp->q_rdptr = iqp->q_buffer;
 8005faa:	68e2      	ldr	r2, [r4, #12]
 8005fac:	61a2      	str	r2, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005fae:	f7fd fcdf 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005fb2:	6828      	ldr	r0, [r5, #0]
 8005fb4:	42a8      	cmp	r0, r5
 8005fb6:	d004      	beq.n	8005fc2 <chIQReadTimeout+0xa2>
 8005fb8:	69ab      	ldr	r3, [r5, #24]
 8005fba:	6882      	ldr	r2, [r0, #8]
 8005fbc:	6899      	ldr	r1, [r3, #8]
 8005fbe:	4291      	cmp	r1, r2
 8005fc0:	d30c      	bcc.n	8005fdc <chIQReadTimeout+0xbc>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005fc2:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8005fc4:	3701      	adds	r7, #1
    if (--n == 0U) {
 8005fc6:	4556      	cmp	r6, sl
 8005fc8:	d0da      	beq.n	8005f80 <chIQReadTimeout+0x60>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8005fca:	3601      	adds	r6, #1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005fcc:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005fce:	f7fd fd67 	bl	8003aa0 <_dbg_check_lock>
 8005fd2:	e7ba      	b.n	8005f4a <chIQReadTimeout+0x2a>
 8005fd4:	4d05      	ldr	r5, [pc, #20]	; (8005fec <chIQReadTimeout+0xcc>)
 8005fd6:	4e03      	ldr	r6, [pc, #12]	; (8005fe4 <chIQReadTimeout+0xc4>)
 8005fd8:	62f5      	str	r5, [r6, #44]	; 0x2c
 8005fda:	e7fe      	b.n	8005fda <chIQReadTimeout+0xba>
 8005fdc:	b672      	cpsid	i
 8005fde:	4c02      	ldr	r4, [pc, #8]	; (8005fe8 <chIQReadTimeout+0xc8>)
 8005fe0:	62ec      	str	r4, [r5, #44]	; 0x2c
 8005fe2:	e7fe      	b.n	8005fe2 <chIQReadTimeout+0xc2>
 8005fe4:	20001040 	.word	0x20001040
 8005fe8:	08008ad0 	.word	0x08008ad0
 8005fec:	08008aa0 	.word	0x08008aa0

08005ff0 <readt.7849>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8005ff0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8005ff2:	300c      	adds	r0, #12
 8005ff4:	f7ff ff94 	bl	8005f20 <chIQReadTimeout>
}
 8005ff8:	bd08      	pop	{r3, pc}
 8005ffa:	46c0      	nop			; (mov r8, r8)
 8005ffc:	46c0      	nop			; (mov r8, r8)
 8005ffe:	46c0      	nop			; (mov r8, r8)

08006000 <read.7855>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8006000:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8006002:	2301      	movs	r3, #1
 8006004:	300c      	adds	r0, #12
 8006006:	425b      	negs	r3, r3
 8006008:	f7ff ff8a 	bl	8005f20 <chIQReadTimeout>
                       n, TIME_INFINITE);
}
 800600c:	bd08      	pop	{r3, pc}
 800600e:	46c0      	nop			; (mov r8, r8)

08006010 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8006010:	b570      	push	{r4, r5, r6, lr}
 8006012:	1c04      	adds	r4, r0, #0
 8006014:	1c0e      	adds	r6, r1, #0
 8006016:	b672      	cpsid	i
 8006018:	f7fd fd42 	bl	8003aa0 <_dbg_check_lock>
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800601c:	69e3      	ldr	r3, [r4, #28]
 800601e:	2b00      	cmp	r3, #0
 8006020:	d001      	beq.n	8006026 <chIQGetTimeout+0x16>
    iqp->q_notify(iqp);
 8006022:	1c20      	adds	r0, r4, #0
 8006024:	4798      	blx	r3
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8006026:	f7fa fb23 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800602a:	68a0      	ldr	r0, [r4, #8]
  }

  while (chIQIsEmptyI(iqp)) {
 800602c:	2800      	cmp	r0, #0
 800602e:	d113      	bne.n	8006058 <chIQGetTimeout+0x48>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8006030:	1c20      	adds	r0, r4, #0
 8006032:	1c31      	adds	r1, r6, #0
 8006034:	f7fb f824 	bl	8001080 <chThdEnqueueTimeoutS>
 8006038:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 800603a:	daf4      	bge.n	8006026 <chIQGetTimeout+0x16>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800603c:	f7fd fc98 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006040:	4b15      	ldr	r3, [pc, #84]	; (8006098 <chIQGetTimeout+0x88>)
 8006042:	6818      	ldr	r0, [r3, #0]
 8006044:	4298      	cmp	r0, r3
 8006046:	d004      	beq.n	8006052 <chIQGetTimeout+0x42>
 8006048:	6999      	ldr	r1, [r3, #24]
 800604a:	6882      	ldr	r2, [r0, #8]
 800604c:	688c      	ldr	r4, [r1, #8]
 800604e:	4294      	cmp	r4, r2
 8006050:	d31d      	bcc.n	800608e <chIQGetTimeout+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006052:	b662      	cpsie	i
    iqp->q_rdptr = iqp->q_buffer;
  }
  chSysUnlock();

  return (msg_t)b;
}
 8006054:	1c28      	adds	r0, r5, #0
 8006056:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8006058:	68a1      	ldr	r1, [r4, #8]
  b = *iqp->q_rdptr++;
 800605a:	69a6      	ldr	r6, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800605c:	3901      	subs	r1, #1
 800605e:	60a1      	str	r1, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8006060:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8006062:	7835      	ldrb	r5, [r6, #0]
 8006064:	3601      	adds	r6, #1
 8006066:	61a6      	str	r6, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8006068:	4296      	cmp	r6, r2
 800606a:	d301      	bcc.n	8006070 <chIQGetTimeout+0x60>
    iqp->q_rdptr = iqp->q_buffer;
 800606c:	68e3      	ldr	r3, [r4, #12]
 800606e:	61a3      	str	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006070:	f7fd fc7e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006074:	4c08      	ldr	r4, [pc, #32]	; (8006098 <chIQGetTimeout+0x88>)
 8006076:	6820      	ldr	r0, [r4, #0]
 8006078:	42a0      	cmp	r0, r4
 800607a:	d0ea      	beq.n	8006052 <chIQGetTimeout+0x42>
 800607c:	69a1      	ldr	r1, [r4, #24]
 800607e:	6882      	ldr	r2, [r0, #8]
 8006080:	688e      	ldr	r6, [r1, #8]
 8006082:	4296      	cmp	r6, r2
 8006084:	d2e5      	bcs.n	8006052 <chIQGetTimeout+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006086:	b672      	cpsid	i
 8006088:	4d04      	ldr	r5, [pc, #16]	; (800609c <chIQGetTimeout+0x8c>)
 800608a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800608c:	e7fe      	b.n	800608c <chIQGetTimeout+0x7c>
 800608e:	b672      	cpsid	i
 8006090:	4d02      	ldr	r5, [pc, #8]	; (800609c <chIQGetTimeout+0x8c>)
 8006092:	62dd      	str	r5, [r3, #44]	; 0x2c
 8006094:	e7fe      	b.n	8006094 <chIQGetTimeout+0x84>
 8006096:	46c0      	nop			; (mov r8, r8)
 8006098:	20001040 	.word	0x20001040
 800609c:	08008ad0 	.word	0x08008ad0

080060a0 <bmk9_execute.10817>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 80060a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80060a2:	4c2c      	ldr	r4, [pc, #176]	; (8006154 <bmk9_execute.10817+0xb4>)
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80060a4:	4b2c      	ldr	r3, [pc, #176]	; (8006158 <bmk9_execute.10817+0xb8>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80060a6:	2200      	movs	r2, #0
  iqp->q_buffer  = bp;
 80060a8:	60e3      	str	r3, [r4, #12]
  iqp->q_rdptr   = bp;
 80060aa:	61a3      	str	r3, [r4, #24]
  iqp->q_wrptr   = bp;
 80060ac:	6163      	str	r3, [r4, #20]
 80060ae:	6024      	str	r4, [r4, #0]
  iqp->q_top     = bp + size;
 80060b0:	3310      	adds	r3, #16
  tqp->p_prev = (thread_t *)tqp;
 80060b2:	6064      	str	r4, [r4, #4]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80060b4:	60a2      	str	r2, [r4, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80060b6:	6123      	str	r3, [r4, #16]
  iqp->q_notify  = infy;
 80060b8:	61e2      	str	r2, [r4, #28]
  iqp->q_link    = link;
 80060ba:	6222      	str	r2, [r4, #32]
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
  test_wait_tick();
 80060bc:	f7fc fb20 	bl	8002700 <test_wait_tick>
  test_start_timer(1000);
 80060c0:	f7ff fc36 	bl	8005930 <test_start_timer.constprop.11>
 80060c4:	4d25      	ldr	r5, [pc, #148]	; (800615c <bmk9_execute.10817+0xbc>)
 80060c6:	4f26      	ldr	r7, [pc, #152]	; (8006160 <bmk9_execute.10817+0xc0>)
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
 80060c8:	2600      	movs	r6, #0
 80060ca:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80060cc:	f7fd fce8 	bl	8003aa0 <_dbg_check_lock>
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 80060d0:	2100      	movs	r1, #0
 80060d2:	1c20      	adds	r0, r4, #0
 80060d4:	f7fd f8ec 	bl	80032b0 <chIQPutI>
    chIQPutI(&iq, 1);
 80060d8:	2101      	movs	r1, #1
 80060da:	1c20      	adds	r0, r4, #0
 80060dc:	f7fd f8e8 	bl	80032b0 <chIQPutI>
    chIQPutI(&iq, 2);
 80060e0:	2102      	movs	r1, #2
 80060e2:	1c20      	adds	r0, r4, #0
 80060e4:	f7fd f8e4 	bl	80032b0 <chIQPutI>
    chIQPutI(&iq, 3);
 80060e8:	2103      	movs	r1, #3
 80060ea:	1c20      	adds	r0, r4, #0
 80060ec:	f7fd f8e0 	bl	80032b0 <chIQPutI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80060f0:	f7fd fc3e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80060f4:	6828      	ldr	r0, [r5, #0]
 80060f6:	42a8      	cmp	r0, r5
 80060f8:	d004      	beq.n	8006104 <bmk9_execute.10817+0x64>
 80060fa:	69a9      	ldr	r1, [r5, #24]
 80060fc:	6883      	ldr	r3, [r0, #8]
 80060fe:	688a      	ldr	r2, [r1, #8]
 8006100:	429a      	cmp	r2, r3
 8006102:	d322      	bcc.n	800614a <bmk9_execute.10817+0xaa>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006104:	b662      	cpsie	i
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8006106:	2101      	movs	r1, #1
 8006108:	4249      	negs	r1, r1
 800610a:	1c20      	adds	r0, r4, #0
 800610c:	f7ff ff80 	bl	8006010 <chIQGetTimeout>
 8006110:	2201      	movs	r2, #1
 8006112:	4251      	negs	r1, r2
 8006114:	1c20      	adds	r0, r4, #0
 8006116:	f7ff ff7b 	bl	8006010 <chIQGetTimeout>
 800611a:	2301      	movs	r3, #1
 800611c:	4259      	negs	r1, r3
 800611e:	1c20      	adds	r0, r4, #0
 8006120:	f7ff ff76 	bl	8006010 <chIQGetTimeout>
 8006124:	2101      	movs	r1, #1
 8006126:	1c20      	adds	r0, r4, #0
 8006128:	4249      	negs	r1, r1
 800612a:	f7ff ff71 	bl	8006010 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800612e:	7838      	ldrb	r0, [r7, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 8006130:	3601      	adds	r6, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006132:	2800      	cmp	r0, #0
 8006134:	d0c9      	beq.n	80060ca <bmk9_execute.10817+0x2a>
  test_print("--- Score : ");
 8006136:	480b      	ldr	r0, [pc, #44]	; (8006164 <bmk9_execute.10817+0xc4>)
 8006138:	f7fa fd4a 	bl	8000bd0 <test_print>
  test_printn(n * 4);
 800613c:	00b0      	lsls	r0, r6, #2
 800613e:	f7fa fd5f 	bl	8000c00 <test_printn>
  test_println(" bytes/S");
 8006142:	4809      	ldr	r0, [pc, #36]	; (8006168 <bmk9_execute.10817+0xc8>)
 8006144:	f7fa fd24 	bl	8000b90 <test_println>
}
 8006148:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800614a:	b672      	cpsid	i
 800614c:	4c07      	ldr	r4, [pc, #28]	; (800616c <bmk9_execute.10817+0xcc>)
 800614e:	62ec      	str	r4, [r5, #44]	; 0x2c
 8006150:	e7fe      	b.n	8006150 <bmk9_execute.10817+0xb0>
 8006152:	46c0      	nop			; (mov r8, r8)
 8006154:	20000df4 	.word	0x20000df4
 8006158:	20000e1c 	.word	0x20000e1c
 800615c:	20001040 	.word	0x20001040
 8006160:	20000e18 	.word	0x20000e18
 8006164:	08008650 	.word	0x08008650
 8006168:	08008ac0 	.word	0x08008ac0
 800616c:	08008ab0 	.word	0x08008ab0

08006170 <gett.7871>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 8006170:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8006172:	300c      	adds	r0, #12
 8006174:	f7ff ff4c 	bl	8006010 <chIQGetTimeout>
}
 8006178:	bd08      	pop	{r3, pc}
 800617a:	46c0      	nop			; (mov r8, r8)
 800617c:	46c0      	nop			; (mov r8, r8)
 800617e:	46c0      	nop			; (mov r8, r8)

08006180 <get.7875>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 8006180:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8006182:	2101      	movs	r1, #1
 8006184:	300c      	adds	r0, #12
 8006186:	4249      	negs	r1, r1
 8006188:	f7ff ff42 	bl	8006010 <chIQGetTimeout>
}
 800618c:	bd08      	pop	{r3, pc}
 800618e:	46c0      	nop			; (mov r8, r8)

08006190 <thread1.10362>:
static void queues1_setup(void) {

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static THD_FUNCTION(thread1, p) {
 8006190:	b508      	push	{r3, lr}

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8006192:	21fa      	movs	r1, #250	; 0xfa
 8006194:	4802      	ldr	r0, [pc, #8]	; (80061a0 <thread1.10362+0x10>)
 8006196:	00c9      	lsls	r1, r1, #3
 8006198:	f7ff ff3a 	bl	8006010 <chIQGetTimeout>
}
 800619c:	bd08      	pop	{r3, pc}
 800619e:	46c0      	nop			; (mov r8, r8)
 80061a0:	2000064c 	.word	0x2000064c
 80061a4:	46c0      	nop			; (mov r8, r8)
 80061a6:	46c0      	nop			; (mov r8, r8)
 80061a8:	46c0      	nop			; (mov r8, r8)
 80061aa:	46c0      	nop			; (mov r8, r8)
 80061ac:	46c0      	nop			; (mov r8, r8)
 80061ae:	46c0      	nop			; (mov r8, r8)

080061b0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80061b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80061b2:	1c04      	adds	r4, r0, #0
 80061b4:	1c0f      	adds	r7, r1, #0
 80061b6:	1c16      	adds	r6, r2, #0
 80061b8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80061ba:	f7fd fc71 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 80061be:	f7fa fa57 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 80061c2:	68a3      	ldr	r3, [r4, #8]

  chSysLock();
  while (chOQIsFullI(oqp)) {
 80061c4:	2b00      	cmp	r3, #0
 80061c6:	d113      	bne.n	80061f0 <chOQPutTimeout+0x40>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80061c8:	1c20      	adds	r0, r4, #0
 80061ca:	1c31      	adds	r1, r6, #0
 80061cc:	f7fa ff58 	bl	8001080 <chThdEnqueueTimeoutS>
 80061d0:	1e05      	subs	r5, r0, #0
    if (msg < Q_OK) {
 80061d2:	daf4      	bge.n	80061be <chOQPutTimeout+0xe>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80061d4:	f7fd fbcc 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80061d8:	4b19      	ldr	r3, [pc, #100]	; (8006240 <chOQPutTimeout+0x90>)
 80061da:	6818      	ldr	r0, [r3, #0]
 80061dc:	4298      	cmp	r0, r3
 80061de:	d004      	beq.n	80061ea <chOQPutTimeout+0x3a>
 80061e0:	6999      	ldr	r1, [r3, #24]
 80061e2:	6882      	ldr	r2, [r0, #8]
 80061e4:	688c      	ldr	r4, [r1, #8]
 80061e6:	4294      	cmp	r4, r2
 80061e8:	d321      	bcc.n	800622e <chOQPutTimeout+0x7e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80061ea:	b662      	cpsie	i
    oqp->q_notify(oqp);
  }
  chSysUnlock();

  return Q_OK;
}
 80061ec:	1c28      	adds	r0, r5, #0
 80061ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80061f0:	68a0      	ldr	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 80061f2:	6961      	ldr	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80061f4:	3801      	subs	r0, #1
 80061f6:	60a0      	str	r0, [r4, #8]
  *oqp->q_wrptr++ = b;
 80061f8:	700f      	strb	r7, [r1, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80061fa:	6922      	ldr	r2, [r4, #16]
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80061fc:	3101      	adds	r1, #1
 80061fe:	6161      	str	r1, [r4, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 8006200:	4291      	cmp	r1, r2
 8006202:	d301      	bcc.n	8006208 <chOQPutTimeout+0x58>
    oqp->q_wrptr = oqp->q_buffer;
 8006204:	68e5      	ldr	r5, [r4, #12]
 8006206:	6165      	str	r5, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8006208:	69e6      	ldr	r6, [r4, #28]
 800620a:	2e00      	cmp	r6, #0
 800620c:	d001      	beq.n	8006212 <chOQPutTimeout+0x62>
    oqp->q_notify(oqp);
 800620e:	1c20      	adds	r0, r4, #0
 8006210:	47b0      	blx	r6
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006212:	f7fd fbad 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006216:	4c0a      	ldr	r4, [pc, #40]	; (8006240 <chOQPutTimeout+0x90>)
 8006218:	6827      	ldr	r7, [r4, #0]
 800621a:	42a7      	cmp	r7, r4
 800621c:	d004      	beq.n	8006228 <chOQPutTimeout+0x78>
 800621e:	69a3      	ldr	r3, [r4, #24]
 8006220:	68b9      	ldr	r1, [r7, #8]
 8006222:	6898      	ldr	r0, [r3, #8]
 8006224:	4288      	cmp	r0, r1
 8006226:	d306      	bcc.n	8006236 <chOQPutTimeout+0x86>
 8006228:	b662      	cpsie	i
 800622a:	2500      	movs	r5, #0
 800622c:	e7de      	b.n	80061ec <chOQPutTimeout+0x3c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800622e:	b672      	cpsid	i
 8006230:	4d04      	ldr	r5, [pc, #16]	; (8006244 <chOQPutTimeout+0x94>)
 8006232:	62dd      	str	r5, [r3, #44]	; 0x2c
 8006234:	e7fe      	b.n	8006234 <chOQPutTimeout+0x84>
 8006236:	b672      	cpsid	i
 8006238:	4a02      	ldr	r2, [pc, #8]	; (8006244 <chOQPutTimeout+0x94>)
 800623a:	62e2      	str	r2, [r4, #44]	; 0x2c
 800623c:	e7fe      	b.n	800623c <chOQPutTimeout+0x8c>
 800623e:	46c0      	nop			; (mov r8, r8)
 8006240:	20001040 	.word	0x20001040
 8006244:	08008ad0 	.word	0x08008ad0
 8006248:	46c0      	nop			; (mov r8, r8)
 800624a:	46c0      	nop			; (mov r8, r8)
 800624c:	46c0      	nop			; (mov r8, r8)
 800624e:	46c0      	nop			; (mov r8, r8)

08006250 <putt.7878>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8006250:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8006252:	3030      	adds	r0, #48	; 0x30
 8006254:	f7ff ffac 	bl	80061b0 <chOQPutTimeout>
}
 8006258:	bd08      	pop	{r3, pc}
 800625a:	46c0      	nop			; (mov r8, r8)
 800625c:	46c0      	nop			; (mov r8, r8)
 800625e:	46c0      	nop			; (mov r8, r8)

08006260 <put.7883>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8006260:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8006262:	2201      	movs	r2, #1
 8006264:	3030      	adds	r0, #48	; 0x30
 8006266:	4252      	negs	r2, r2
 8006268:	f7ff ffa2 	bl	80061b0 <chOQPutTimeout>
}
 800626c:	bd08      	pop	{r3, pc}
 800626e:	46c0      	nop			; (mov r8, r8)

08006270 <thread2.10359>:
static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static THD_FUNCTION(thread2, p) {
 8006270:	b508      	push	{r3, lr}

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 8006272:	22fa      	movs	r2, #250	; 0xfa
 8006274:	4802      	ldr	r0, [pc, #8]	; (8006280 <thread2.10359+0x10>)
 8006276:	2100      	movs	r1, #0
 8006278:	00d2      	lsls	r2, r2, #3
 800627a:	f7ff ff99 	bl	80061b0 <chOQPutTimeout>
}
 800627e:	bd08      	pop	{r3, pc}
 8006280:	20000628 	.word	0x20000628
 8006284:	46c0      	nop			; (mov r8, r8)
 8006286:	46c0      	nop			; (mov r8, r8)
 8006288:	46c0      	nop			; (mov r8, r8)
 800628a:	46c0      	nop			; (mov r8, r8)
 800628c:	46c0      	nop			; (mov r8, r8)
 800628e:	46c0      	nop			; (mov r8, r8)

08006290 <thd2_execute.8732>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8006290:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006292:	4c40      	ldr	r4, [pc, #256]	; (8006394 <thd2_execute.8732+0x104>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8006294:	4f40      	ldr	r7, [pc, #256]	; (8006398 <thd2_execute.8732+0x108>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006296:	69a3      	ldr	r3, [r4, #24]
 8006298:	4e40      	ldr	r6, [pc, #256]	; (800639c <thd2_execute.8732+0x10c>)
 800629a:	689a      	ldr	r2, [r3, #8]
 800629c:	4840      	ldr	r0, [pc, #256]	; (80063a0 <thd2_execute.8732+0x110>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 800629e:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80062a0:	21a8      	movs	r1, #168	; 0xa8
 80062a2:	9000      	str	r0, [sp, #0]
 80062a4:	1c33      	adds	r3, r6, #0
 80062a6:	3a04      	subs	r2, #4
 80062a8:	1c38      	adds	r0, r7, #0
 80062aa:	0049      	lsls	r1, r1, #1
 80062ac:	f7fc fdd0 	bl	8002e50 <chThdCreateStatic>
 80062b0:	4d3c      	ldr	r5, [pc, #240]	; (80063a4 <thd2_execute.8732+0x114>)
 80062b2:	69a3      	ldr	r3, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80062b4:	4a3c      	ldr	r2, [pc, #240]	; (80063a8 <thd2_execute.8732+0x118>)
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80062b6:	6068      	str	r0, [r5, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80062b8:	493c      	ldr	r1, [pc, #240]	; (80063ac <thd2_execute.8732+0x11c>)
 80062ba:	18b8      	adds	r0, r7, r2
 80062bc:	689a      	ldr	r2, [r3, #8]
 80062be:	23a8      	movs	r3, #168	; 0xa8
 80062c0:	9100      	str	r1, [sp, #0]
 80062c2:	3a05      	subs	r2, #5
 80062c4:	0059      	lsls	r1, r3, #1
 80062c6:	1c33      	adds	r3, r6, #0
 80062c8:	f7fc fdc2 	bl	8002e50 <chThdCreateStatic>
 80062cc:	69a1      	ldr	r1, [r4, #24]
 80062ce:	6028      	str	r0, [r5, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80062d0:	20fc      	movs	r0, #252	; 0xfc
 80062d2:	0082      	lsls	r2, r0, #2
 80062d4:	18b8      	adds	r0, r7, r2
 80062d6:	4b36      	ldr	r3, [pc, #216]	; (80063b0 <thd2_execute.8732+0x120>)
 80062d8:	688a      	ldr	r2, [r1, #8]
 80062da:	21a8      	movs	r1, #168	; 0xa8
 80062dc:	9300      	str	r3, [sp, #0]
 80062de:	3a01      	subs	r2, #1
 80062e0:	1c33      	adds	r3, r6, #0
 80062e2:	0049      	lsls	r1, r1, #1
 80062e4:	f7fc fdb4 	bl	8002e50 <chThdCreateStatic>
 80062e8:	69a3      	ldr	r3, [r4, #24]
 80062ea:	6128      	str	r0, [r5, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80062ec:	20a8      	movs	r0, #168	; 0xa8
 80062ee:	0082      	lsls	r2, r0, #2
 80062f0:	18b8      	adds	r0, r7, r2
 80062f2:	4930      	ldr	r1, [pc, #192]	; (80063b4 <thd2_execute.8732+0x124>)
 80062f4:	689a      	ldr	r2, [r3, #8]
 80062f6:	23a8      	movs	r3, #168	; 0xa8
 80062f8:	9100      	str	r1, [sp, #0]
 80062fa:	3a02      	subs	r2, #2
 80062fc:	0059      	lsls	r1, r3, #1
 80062fe:	1c33      	adds	r3, r6, #0
 8006300:	f7fc fda6 	bl	8002e50 <chThdCreateStatic>
 8006304:	60e8      	str	r0, [r5, #12]
 8006306:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006308:	f7fd fbca 	bl	8003aa0 <_dbg_check_lock>
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800630c:	20a8      	movs	r0, #168	; 0xa8
 800630e:	0042      	lsls	r2, r0, #1
 8006310:	18b8      	adds	r0, r7, r2
 8006312:	69a7      	ldr	r7, [r4, #24]
 8006314:	4928      	ldr	r1, [pc, #160]	; (80063b8 <thd2_execute.8732+0x128>)
 8006316:	68ba      	ldr	r2, [r7, #8]
 8006318:	23a8      	movs	r3, #168	; 0xa8
 800631a:	3a03      	subs	r2, #3
 800631c:	9100      	str	r1, [sp, #0]
 800631e:	0059      	lsls	r1, r3, #1
 8006320:	1c33      	adds	r3, r6, #0
 8006322:	f7fd f8c5 	bl	80034b0 <chThdCreateI>
 8006326:	60a8      	str	r0, [r5, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006328:	f7fd fb22 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800632c:	6826      	ldr	r6, [r4, #0]
 800632e:	42a6      	cmp	r6, r4
 8006330:	d004      	beq.n	800633c <thd2_execute.8732+0xac>
 8006332:	69a0      	ldr	r0, [r4, #24]
 8006334:	68b7      	ldr	r7, [r6, #8]
 8006336:	6882      	ldr	r2, [r0, #8]
 8006338:	42ba      	cmp	r2, r7
 800633a:	d322      	bcc.n	8006382 <thd2_execute.8732+0xf2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800633c:	b662      	cpsie	i
  chSysUnlock();
  chThdStart(threads[2]);
 800633e:	68ad      	ldr	r5, [r5, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006340:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006342:	f7fd fbad 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");
 8006346:	2120      	movs	r1, #32
 8006348:	5c6b      	ldrb	r3, [r5, r1]
 800634a:	2b02      	cmp	r3, #2
 800634c:	d003      	beq.n	8006356 <thd2_execute.8732+0xc6>
 800634e:	b672      	cpsid	i
 8006350:	491a      	ldr	r1, [pc, #104]	; (80063bc <thd2_execute.8732+0x12c>)
 8006352:	62e1      	str	r1, [r4, #44]	; 0x2c
 8006354:	e7fe      	b.n	8006354 <thd2_execute.8732+0xc4>

  return chSchReadyI(tp);
 8006356:	1c28      	adds	r0, r5, #0
 8006358:	f7fa f9ea 	bl	8000730 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800635c:	f7fd fb08 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006360:	6826      	ldr	r6, [r4, #0]
 8006362:	42a6      	cmp	r6, r4
 8006364:	d004      	beq.n	8006370 <thd2_execute.8732+0xe0>
 8006366:	69a0      	ldr	r0, [r4, #24]
 8006368:	68b7      	ldr	r7, [r6, #8]
 800636a:	6882      	ldr	r2, [r0, #8]
 800636c:	42ba      	cmp	r2, r7
 800636e:	d30c      	bcc.n	800638a <thd2_execute.8732+0xfa>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006370:	b662      	cpsie	i
  test_wait_threads();
 8006372:	f7fb fbdd 	bl	8001b30 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006376:	4912      	ldr	r1, [pc, #72]	; (80063c0 <thd2_execute.8732+0x130>)
 8006378:	2001      	movs	r0, #1
 800637a:	f7fa fba1 	bl	8000ac0 <_test_assert_sequence>
}
 800637e:	b003      	add	sp, #12
 8006380:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006382:	b672      	cpsid	i
 8006384:	4b0f      	ldr	r3, [pc, #60]	; (80063c4 <thd2_execute.8732+0x134>)
 8006386:	62e3      	str	r3, [r4, #44]	; 0x2c
 8006388:	e7fe      	b.n	8006388 <thd2_execute.8732+0xf8>
 800638a:	b672      	cpsid	i
 800638c:	4d0e      	ldr	r5, [pc, #56]	; (80063c8 <thd2_execute.8732+0x138>)
 800638e:	62e5      	str	r5, [r4, #44]	; 0x2c
 8006390:	e7fe      	b.n	8006390 <thd2_execute.8732+0x100>
 8006392:	46c0      	nop			; (mov r8, r8)
 8006394:	20001040 	.word	0x20001040
 8006398:	20000808 	.word	0x20000808
 800639c:	08005131 	.word	0x08005131
 80063a0:	080089a8 	.word	0x080089a8
 80063a4:	200015b8 	.word	0x200015b8
 80063a8:	fffffeb0 	.word	0xfffffeb0
 80063ac:	080089b0 	.word	0x080089b0
 80063b0:	08008698 	.word	0x08008698
 80063b4:	080089a4 	.word	0x080089a4
 80063b8:	080089a0 	.word	0x080089a0
 80063bc:	08008a90 	.word	0x08008a90
 80063c0:	080089ac 	.word	0x080089ac
 80063c4:	08008b60 	.word	0x08008b60
 80063c8:	08008b00 	.word	0x08008b00
 80063cc:	46c0      	nop			; (mov r8, r8)
 80063ce:	46c0      	nop			; (mov r8, r8)

080063d0 <mbox1_execute.9596>:

static void mbox1_execute(void) {
 80063d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80063d2:	b083      	sub	sp, #12
 80063d4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80063d6:	f7fd fb63 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 80063da:	f7fa f949 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 80063de:	f7fa f947 	bl	8000670 <chDbgCheckClassI>

  return sp->s_cnt;
 80063e2:	4c0d      	ldr	r4, [pc, #52]	; (8006418 <mbox1_execute.9596+0x48>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80063e4:	2001      	movs	r0, #1
 80063e6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80063e8:	3905      	subs	r1, #5
 80063ea:	424b      	negs	r3, r1
 80063ec:	4159      	adcs	r1, r3
 80063ee:	f7fa fbb7 	bl	8000b60 <_test_assert>
 80063f2:	2800      	cmp	r0, #0
 80063f4:	d014      	beq.n	8006420 <mbox1_execute.9596+0x50>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80063f6:	f7fd fabb 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80063fa:	4d08      	ldr	r5, [pc, #32]	; (800641c <mbox1_execute.9596+0x4c>)
 80063fc:	6828      	ldr	r0, [r5, #0]
 80063fe:	42a8      	cmp	r0, r5
 8006400:	d006      	beq.n	8006410 <mbox1_execute.9596+0x40>
 8006402:	69a9      	ldr	r1, [r5, #24]
 8006404:	6886      	ldr	r6, [r0, #8]
 8006406:	688c      	ldr	r4, [r1, #8]
 8006408:	42b4      	cmp	r4, r6
 800640a:	d201      	bcs.n	8006410 <mbox1_execute.9596+0x40>
 800640c:	f000 fc67 	bl	8006cde <mbox1_execute.9596+0x90e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006410:	b662      	cpsie	i
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 8006412:	b003      	add	sp, #12
 8006414:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006416:	46c0      	nop			; (mov r8, r8)
 8006418:	20000600 	.word	0x20000600
 800641c:	20001040 	.word	0x20001040
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006420:	f7fd faa6 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006424:	4ddb      	ldr	r5, [pc, #876]	; (8006794 <mbox1_execute.9596+0x3c4>)
 8006426:	682b      	ldr	r3, [r5, #0]
 8006428:	42ab      	cmp	r3, r5
 800642a:	d006      	beq.n	800643a <mbox1_execute.9596+0x6a>
 800642c:	69aa      	ldr	r2, [r5, #24]
 800642e:	6899      	ldr	r1, [r3, #8]
 8006430:	6890      	ldr	r0, [r2, #8]
 8006432:	4288      	cmp	r0, r1
 8006434:	d201      	bcs.n	800643a <mbox1_execute.9596+0x6a>
 8006436:	f000 fc4e 	bl	8006cd6 <mbox1_execute.9596+0x906>
 800643a:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800643c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800643e:	f7fd fb2f 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 8006442:	f7fa fa05 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8006446:	4ed4      	ldr	r6, [pc, #848]	; (8006798 <mbox1_execute.9596+0x3c8>)
 8006448:	2701      	movs	r7, #1
 800644a:	4279      	negs	r1, r7
 800644c:	1c30      	adds	r0, r6, #0
 800644e:	f7fd f877 	bl	8003540 <chSemWaitTimeoutS>
 8006452:	1e07      	subs	r7, r0, #0
  if (rdymsg == MSG_OK) {
 8006454:	d10f      	bne.n	8006476 <mbox1_execute.9596+0xa6>
    *mbp->mb_wrptr++ = msg;
 8006456:	1c33      	adds	r3, r6, #0
 8006458:	3b1c      	subs	r3, #28
 800645a:	689a      	ldr	r2, [r3, #8]
 800645c:	2042      	movs	r0, #66	; 0x42
    if (mbp->mb_wrptr >= mbp->mb_top) {
 800645e:	6859      	ldr	r1, [r3, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8006460:	c201      	stmia	r2!, {r0}
 8006462:	609a      	str	r2, [r3, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8006464:	4291      	cmp	r1, r2
 8006466:	d801      	bhi.n	800646c <mbox1_execute.9596+0x9c>
      mbp->mb_wrptr = mbp->mb_buffer;
 8006468:	681a      	ldr	r2, [r3, #0]
 800646a:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800646c:	48cb      	ldr	r0, [pc, #812]	; (800679c <mbox1_execute.9596+0x3cc>)
 800646e:	f7fd f89f 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 8006472:	f7fd f805 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006476:	f7fd fa7b 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800647a:	682b      	ldr	r3, [r5, #0]
 800647c:	42ab      	cmp	r3, r5
 800647e:	d006      	beq.n	800648e <mbox1_execute.9596+0xbe>
 8006480:	69a8      	ldr	r0, [r5, #24]
 8006482:	6899      	ldr	r1, [r3, #8]
 8006484:	6882      	ldr	r2, [r0, #8]
 8006486:	4291      	cmp	r1, r2
 8006488:	d901      	bls.n	800648e <mbox1_execute.9596+0xbe>
 800648a:	f000 fc2c 	bl	8006ce6 <mbox1_execute.9596+0x916>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800648e:	b662      	cpsie	i
  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 8006490:	2002      	movs	r0, #2
 8006492:	4279      	negs	r1, r7
 8006494:	4179      	adcs	r1, r7
 8006496:	f7fa fb63 	bl	8000b60 <_test_assert>
 800649a:	2800      	cmp	r0, #0
 800649c:	d1b9      	bne.n	8006412 <mbox1_execute.9596+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800649e:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80064a0:	2701      	movs	r7, #1
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80064a2:	f7fd fafd 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 80064a6:	f7fa f9d3 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80064aa:	4279      	negs	r1, r7
 80064ac:	1c30      	adds	r0, r6, #0
 80064ae:	f7fd f847 	bl	8003540 <chSemWaitTimeoutS>
 80064b2:	1e07      	subs	r7, r0, #0
  if (rdymsg == MSG_OK) {
 80064b4:	d10f      	bne.n	80064d6 <mbox1_execute.9596+0x106>
    *mbp->mb_wrptr++ = msg;
 80064b6:	1c33      	adds	r3, r6, #0
 80064b8:	3b1c      	subs	r3, #28
 80064ba:	6898      	ldr	r0, [r3, #8]
 80064bc:	2143      	movs	r1, #67	; 0x43
    if (mbp->mb_wrptr >= mbp->mb_top) {
 80064be:	685a      	ldr	r2, [r3, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 80064c0:	c002      	stmia	r0!, {r1}
 80064c2:	6098      	str	r0, [r3, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 80064c4:	4290      	cmp	r0, r2
 80064c6:	d301      	bcc.n	80064cc <mbox1_execute.9596+0xfc>
      mbp->mb_wrptr = mbp->mb_buffer;
 80064c8:	6818      	ldr	r0, [r3, #0]
 80064ca:	6098      	str	r0, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 80064cc:	48b3      	ldr	r0, [pc, #716]	; (800679c <mbox1_execute.9596+0x3cc>)
 80064ce:	f7fd f86f 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 80064d2:	f7fc ffd5 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80064d6:	f7fd fa4b 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80064da:	682b      	ldr	r3, [r5, #0]
 80064dc:	42ab      	cmp	r3, r5
 80064de:	d006      	beq.n	80064ee <mbox1_execute.9596+0x11e>
 80064e0:	69a9      	ldr	r1, [r5, #24]
 80064e2:	6898      	ldr	r0, [r3, #8]
 80064e4:	688a      	ldr	r2, [r1, #8]
 80064e6:	4282      	cmp	r2, r0
 80064e8:	d201      	bcs.n	80064ee <mbox1_execute.9596+0x11e>
 80064ea:	f000 fbfc 	bl	8006ce6 <mbox1_execute.9596+0x916>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80064ee:	b662      	cpsie	i
 80064f0:	2002      	movs	r0, #2
 80064f2:	4279      	negs	r1, r7
 80064f4:	4179      	adcs	r1, r7
 80064f6:	f7fa fb33 	bl	8000b60 <_test_assert>
 80064fa:	2800      	cmp	r0, #0
 80064fc:	d000      	beq.n	8006500 <mbox1_execute.9596+0x130>
 80064fe:	e788      	b.n	8006412 <mbox1_execute.9596+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006500:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8006502:	2701      	movs	r7, #1
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006504:	f7fd facc 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 8006508:	f7fa f9a2 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800650c:	4279      	negs	r1, r7
 800650e:	1c30      	adds	r0, r6, #0
 8006510:	f7fd f816 	bl	8003540 <chSemWaitTimeoutS>
 8006514:	1e07      	subs	r7, r0, #0
  if (rdymsg == MSG_OK) {
 8006516:	d10f      	bne.n	8006538 <mbox1_execute.9596+0x168>
    *mbp->mb_wrptr++ = msg;
 8006518:	1c33      	adds	r3, r6, #0
 800651a:	3b1c      	subs	r3, #28
 800651c:	689a      	ldr	r2, [r3, #8]
 800651e:	2144      	movs	r1, #68	; 0x44
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8006520:	6858      	ldr	r0, [r3, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8006522:	c202      	stmia	r2!, {r1}
 8006524:	609a      	str	r2, [r3, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8006526:	4282      	cmp	r2, r0
 8006528:	d301      	bcc.n	800652e <mbox1_execute.9596+0x15e>
      mbp->mb_wrptr = mbp->mb_buffer;
 800652a:	681a      	ldr	r2, [r3, #0]
 800652c:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800652e:	489b      	ldr	r0, [pc, #620]	; (800679c <mbox1_execute.9596+0x3cc>)
 8006530:	f7fd f83e 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 8006534:	f7fc ffa4 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006538:	f7fd fa1a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800653c:	682b      	ldr	r3, [r5, #0]
 800653e:	42ab      	cmp	r3, r5
 8006540:	d005      	beq.n	800654e <mbox1_execute.9596+0x17e>
 8006542:	69a9      	ldr	r1, [r5, #24]
 8006544:	689a      	ldr	r2, [r3, #8]
 8006546:	6888      	ldr	r0, [r1, #8]
 8006548:	4290      	cmp	r0, r2
 800654a:	d200      	bcs.n	800654e <mbox1_execute.9596+0x17e>
 800654c:	e3cb      	b.n	8006ce6 <mbox1_execute.9596+0x916>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800654e:	b662      	cpsie	i
 8006550:	2002      	movs	r0, #2
 8006552:	4279      	negs	r1, r7
 8006554:	4179      	adcs	r1, r7
 8006556:	f7fa fb03 	bl	8000b60 <_test_assert>
 800655a:	2800      	cmp	r0, #0
 800655c:	d000      	beq.n	8006560 <mbox1_execute.9596+0x190>
 800655e:	e758      	b.n	8006412 <mbox1_execute.9596+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006560:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8006562:	2701      	movs	r7, #1
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006564:	f7fd fa9c 	bl	8003aa0 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 8006568:	f7fa f972 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800656c:	4279      	negs	r1, r7
 800656e:	1c30      	adds	r0, r6, #0
 8006570:	f7fc ffe6 	bl	8003540 <chSemWaitTimeoutS>
 8006574:	1e07      	subs	r7, r0, #0
  if (rdymsg == MSG_OK) {
 8006576:	d10e      	bne.n	8006596 <mbox1_execute.9596+0x1c6>
    *mbp->mb_wrptr++ = msg;
 8006578:	3e1c      	subs	r6, #28
 800657a:	68b3      	ldr	r3, [r6, #8]
 800657c:	2145      	movs	r1, #69	; 0x45
    if (mbp->mb_wrptr >= mbp->mb_top) {
 800657e:	6870      	ldr	r0, [r6, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8006580:	c302      	stmia	r3!, {r1}
 8006582:	60b3      	str	r3, [r6, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8006584:	4283      	cmp	r3, r0
 8006586:	d301      	bcc.n	800658c <mbox1_execute.9596+0x1bc>
      mbp->mb_wrptr = mbp->mb_buffer;
 8006588:	6832      	ldr	r2, [r6, #0]
 800658a:	60b2      	str	r2, [r6, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800658c:	4883      	ldr	r0, [pc, #524]	; (800679c <mbox1_execute.9596+0x3cc>)
 800658e:	f7fd f80f 	bl	80035b0 <chSemSignalI>
    chSchRescheduleS();
 8006592:	f7fc ff75 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006596:	f7fd f9eb 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800659a:	682e      	ldr	r6, [r5, #0]
 800659c:	42ae      	cmp	r6, r5
 800659e:	d005      	beq.n	80065ac <mbox1_execute.9596+0x1dc>
 80065a0:	69ab      	ldr	r3, [r5, #24]
 80065a2:	68b0      	ldr	r0, [r6, #8]
 80065a4:	6899      	ldr	r1, [r3, #8]
 80065a6:	4281      	cmp	r1, r0
 80065a8:	d200      	bcs.n	80065ac <mbox1_execute.9596+0x1dc>
 80065aa:	e39c      	b.n	8006ce6 <mbox1_execute.9596+0x916>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80065ac:	b662      	cpsie	i
 80065ae:	2002      	movs	r0, #2
 80065b0:	4279      	negs	r1, r7
 80065b2:	4179      	adcs	r1, r7
 80065b4:	f7fa fad4 	bl	8000b60 <_test_assert>
 80065b8:	2800      	cmp	r0, #0
 80065ba:	d000      	beq.n	80065be <mbox1_execute.9596+0x1ee>
 80065bc:	e729      	b.n	8006412 <mbox1_execute.9596+0x42>
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 80065be:	2701      	movs	r7, #1
 80065c0:	4279      	negs	r1, r7
 80065c2:	2041      	movs	r0, #65	; 0x41
 80065c4:	f7fb ff64 	bl	8002490 <chMBPostAhead.constprop.33>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 80065c8:	4241      	negs	r1, r0
 80065ca:	4141      	adcs	r1, r0
 80065cc:	2003      	movs	r0, #3
 80065ce:	f7fa fac7 	bl	8000b60 <_test_assert>
 80065d2:	2800      	cmp	r0, #0
 80065d4:	d000      	beq.n	80065d8 <mbox1_execute.9596+0x208>
 80065d6:	e71c      	b.n	8006412 <mbox1_execute.9596+0x42>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 80065d8:	2101      	movs	r1, #1
 80065da:	2058      	movs	r0, #88	; 0x58
 80065dc:	f7fb ff20 	bl	8002420 <chMBPost.constprop.36>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80065e0:	1c41      	adds	r1, r0, #1
 80065e2:	424b      	negs	r3, r1
 80065e4:	4159      	adcs	r1, r3
 80065e6:	2004      	movs	r0, #4
 80065e8:	f7fa faba 	bl	8000b60 <_test_assert>
 80065ec:	2800      	cmp	r0, #0
 80065ee:	d000      	beq.n	80065f2 <mbox1_execute.9596+0x222>
 80065f0:	e70f      	b.n	8006412 <mbox1_execute.9596+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80065f2:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80065f4:	f7fd fa54 	bl	8003aa0 <_dbg_check_lock>
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 80065f8:	2058      	movs	r0, #88	; 0x58
 80065fa:	f7fd f839 	bl	8003670 <chMBPostI.constprop.35>
 80065fe:	1c06      	adds	r6, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006600:	f7fd f9b6 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006604:	682b      	ldr	r3, [r5, #0]
 8006606:	42ab      	cmp	r3, r5
 8006608:	d005      	beq.n	8006616 <mbox1_execute.9596+0x246>
 800660a:	69aa      	ldr	r2, [r5, #24]
 800660c:	6898      	ldr	r0, [r3, #8]
 800660e:	6891      	ldr	r1, [r2, #8]
 8006610:	4281      	cmp	r1, r0
 8006612:	d200      	bcs.n	8006616 <mbox1_execute.9596+0x246>
 8006614:	e36b      	b.n	8006cee <mbox1_execute.9596+0x91e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006616:	b662      	cpsie	i
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8006618:	1c71      	adds	r1, r6, #1
 800661a:	424e      	negs	r6, r1
 800661c:	4171      	adcs	r1, r6
 800661e:	2005      	movs	r0, #5
 8006620:	f7fa fa9e 	bl	8000b60 <_test_assert>
 8006624:	2800      	cmp	r0, #0
 8006626:	d000      	beq.n	800662a <mbox1_execute.9596+0x25a>
 8006628:	e6f3      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 800662a:	2101      	movs	r1, #1
 800662c:	2058      	movs	r0, #88	; 0x58
 800662e:	f7fb ff2f 	bl	8002490 <chMBPostAhead.constprop.33>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8006632:	1c41      	adds	r1, r0, #1
 8006634:	424b      	negs	r3, r1
 8006636:	4159      	adcs	r1, r3
 8006638:	2006      	movs	r0, #6
 800663a:	f7fa fa91 	bl	8000b60 <_test_assert>
 800663e:	2800      	cmp	r0, #0
 8006640:	d000      	beq.n	8006644 <mbox1_execute.9596+0x274>
 8006642:	e6e6      	b.n	8006412 <mbox1_execute.9596+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006644:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006646:	f7fd fa2b 	bl	8003aa0 <_dbg_check_lock>
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 800664a:	2058      	movs	r0, #88	; 0x58
 800664c:	f7fd f838 	bl	80036c0 <chMBPostAheadI.constprop.32>
 8006650:	1c07      	adds	r7, r0, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006652:	f7fd f98d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006656:	682e      	ldr	r6, [r5, #0]
 8006658:	42ae      	cmp	r6, r5
 800665a:	d005      	beq.n	8006668 <mbox1_execute.9596+0x298>
 800665c:	69ab      	ldr	r3, [r5, #24]
 800665e:	68b1      	ldr	r1, [r6, #8]
 8006660:	689a      	ldr	r2, [r3, #8]
 8006662:	428a      	cmp	r2, r1
 8006664:	d200      	bcs.n	8006668 <mbox1_execute.9596+0x298>
 8006666:	e346      	b.n	8006cf6 <mbox1_execute.9596+0x926>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006668:	b662      	cpsie	i
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800666a:	1c79      	adds	r1, r7, #1
 800666c:	424e      	negs	r6, r1
 800666e:	4171      	adcs	r1, r6
 8006670:	2007      	movs	r0, #7
 8006672:	f7fa fa75 	bl	8000b60 <_test_assert>
 8006676:	2800      	cmp	r0, #0
 8006678:	d000      	beq.n	800667c <mbox1_execute.9596+0x2ac>
 800667a:	e6ca      	b.n	8006412 <mbox1_execute.9596+0x42>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800667c:	f7fd fe38 	bl	80042f0 <chSysLock.9592>
 8006680:	f7f9 fff6 	bl	8000670 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 8006684:	f7f9 fff4 	bl	8000670 <chDbgCheckClassI>
 8006688:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800668a:	2008      	movs	r0, #8
 800668c:	4269      	negs	r1, r5
 800668e:	4169      	adcs	r1, r5
 8006690:	f7fa fa66 	bl	8000b60 <_test_assert>
 8006694:	2800      	cmp	r0, #0
 8006696:	d000      	beq.n	800669a <mbox1_execute.9596+0x2ca>
 8006698:	e319      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 800669a:	f7fd f9d1 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800669e:	f7fd fe27 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 80066a2:	f7f9 ffe5 	bl	8000670 <chDbgCheckClassI>
 80066a6:	f7f9 ffe3 	bl	8000670 <chDbgCheckClassI>
 80066aa:	69a1      	ldr	r1, [r4, #24]
 80066ac:	2009      	movs	r0, #9
 80066ae:	3905      	subs	r1, #5
 80066b0:	424b      	negs	r3, r1
 80066b2:	4159      	adcs	r1, r3
 80066b4:	f7fa fa54 	bl	8000b60 <_test_assert>
 80066b8:	2800      	cmp	r0, #0
 80066ba:	d000      	beq.n	80066be <mbox1_execute.9596+0x2ee>
 80066bc:	e307      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 80066be:	f7fd f9bf 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80066c2:	f7fd fe15 	bl	80042f0 <chSysLock.9592>
 80066c6:	68e0      	ldr	r0, [r4, #12]
 80066c8:	68a7      	ldr	r7, [r4, #8]
 80066ca:	1bc1      	subs	r1, r0, r7
 80066cc:	424b      	negs	r3, r1
 80066ce:	4159      	adcs	r1, r3
 80066d0:	200a      	movs	r0, #10
 80066d2:	f7fa fa45 	bl	8000b60 <_test_assert>
 80066d6:	2800      	cmp	r0, #0
 80066d8:	d000      	beq.n	80066dc <mbox1_execute.9596+0x30c>
 80066da:	e2f8      	b.n	8006cce <mbox1_execute.9596+0x8fe>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80066dc:	2601      	movs	r6, #1
  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80066de:	f7fd f9af 	bl	8003a40 <chSysUnlock.9594>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80066e2:	4271      	negs	r1, r6
 80066e4:	a801      	add	r0, sp, #4
 80066e6:	f7fd fcf3 	bl	80040d0 <chMBFetch.constprop.30>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 80066ea:	4241      	negs	r1, r0
 80066ec:	4141      	adcs	r1, r0
 80066ee:	200b      	movs	r0, #11
 80066f0:	f7fa fa36 	bl	8000b60 <_test_assert>
 80066f4:	2800      	cmp	r0, #0
 80066f6:	d000      	beq.n	80066fa <mbox1_execute.9596+0x32a>
 80066f8:	e68b      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 80066fa:	466b      	mov	r3, sp
 80066fc:	7918      	ldrb	r0, [r3, #4]
 80066fe:	f7fe fcef 	bl	80050e0 <test_emit_token>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8006702:	2201      	movs	r2, #1
 8006704:	4251      	negs	r1, r2
 8006706:	a801      	add	r0, sp, #4
 8006708:	f7fd fce2 	bl	80040d0 <chMBFetch.constprop.30>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800670c:	4241      	negs	r1, r0
 800670e:	4141      	adcs	r1, r0
 8006710:	200b      	movs	r0, #11
 8006712:	f7fa fa25 	bl	8000b60 <_test_assert>
 8006716:	2800      	cmp	r0, #0
 8006718:	d000      	beq.n	800671c <mbox1_execute.9596+0x34c>
 800671a:	e67a      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 800671c:	4669      	mov	r1, sp
 800671e:	7908      	ldrb	r0, [r1, #4]

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8006720:	2501      	movs	r5, #1
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 8006722:	f7fe fcdd 	bl	80050e0 <test_emit_token>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8006726:	4269      	negs	r1, r5
 8006728:	a801      	add	r0, sp, #4
 800672a:	f7fd fcd1 	bl	80040d0 <chMBFetch.constprop.30>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800672e:	4241      	negs	r1, r0
 8006730:	4141      	adcs	r1, r0
 8006732:	200b      	movs	r0, #11
 8006734:	f7fa fa14 	bl	8000b60 <_test_assert>
 8006738:	2800      	cmp	r0, #0
 800673a:	d000      	beq.n	800673e <mbox1_execute.9596+0x36e>
 800673c:	e669      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 800673e:	4668      	mov	r0, sp
 8006740:	7900      	ldrb	r0, [r0, #4]

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8006742:	2701      	movs	r7, #1
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 8006744:	f7fe fccc 	bl	80050e0 <test_emit_token>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8006748:	4279      	negs	r1, r7
 800674a:	a801      	add	r0, sp, #4
 800674c:	f7fd fcc0 	bl	80040d0 <chMBFetch.constprop.30>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 8006750:	4241      	negs	r1, r0
 8006752:	4141      	adcs	r1, r0
 8006754:	200b      	movs	r0, #11
 8006756:	f7fa fa03 	bl	8000b60 <_test_assert>
 800675a:	2800      	cmp	r0, #0
 800675c:	d000      	beq.n	8006760 <mbox1_execute.9596+0x390>
 800675e:	e658      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006760:	466e      	mov	r6, sp
 8006762:	7930      	ldrb	r0, [r6, #4]
 8006764:	f7fe fcbc 	bl	80050e0 <test_emit_token>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8006768:	2301      	movs	r3, #1
 800676a:	4259      	negs	r1, r3
 800676c:	a801      	add	r0, sp, #4
 800676e:	f7fd fcaf 	bl	80040d0 <chMBFetch.constprop.30>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 8006772:	4241      	negs	r1, r0
 8006774:	4141      	adcs	r1, r0
 8006776:	200b      	movs	r0, #11
 8006778:	f7fa f9f2 	bl	8000b60 <_test_assert>
 800677c:	2800      	cmp	r0, #0
 800677e:	d000      	beq.n	8006782 <mbox1_execute.9596+0x3b2>
 8006780:	e647      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006782:	7930      	ldrb	r0, [r6, #4]
 8006784:	f7fe fcac 	bl	80050e0 <test_emit_token>
  }
  test_assert_sequence(12, "ABCDE");
 8006788:	4d05      	ldr	r5, [pc, #20]	; (80067a0 <mbox1_execute.9596+0x3d0>)
 800678a:	200c      	movs	r0, #12
 800678c:	1c29      	adds	r1, r5, #0
 800678e:	f7fa f997 	bl	8000ac0 <_test_assert_sequence>
 8006792:	e007      	b.n	80067a4 <mbox1_execute.9596+0x3d4>
 8006794:	20001040 	.word	0x20001040
 8006798:	2000061c 	.word	0x2000061c
 800679c:	20000610 	.word	0x20000610
 80067a0:	080089ac 	.word	0x080089ac
 80067a4:	2800      	cmp	r0, #0
 80067a6:	d000      	beq.n	80067aa <mbox1_execute.9596+0x3da>
 80067a8:	e633      	b.n	8006412 <mbox1_execute.9596+0x42>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80067aa:	2101      	movs	r1, #1
 80067ac:	4249      	negs	r1, r1
 80067ae:	2047      	movs	r0, #71	; 0x47
 80067b0:	f7fb fe36 	bl	8002420 <chMBPost.constprop.36>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 80067b4:	4241      	negs	r1, r0
 80067b6:	4141      	adcs	r1, r0
 80067b8:	200d      	movs	r0, #13
 80067ba:	f7fa f9d1 	bl	8000b60 <_test_assert>
 80067be:	2800      	cmp	r0, #0
 80067c0:	d000      	beq.n	80067c4 <mbox1_execute.9596+0x3f4>
 80067c2:	e626      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80067c4:	2701      	movs	r7, #1
 80067c6:	4279      	negs	r1, r7
 80067c8:	a801      	add	r0, sp, #4
 80067ca:	f7fd fc81 	bl	80040d0 <chMBFetch.constprop.30>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 80067ce:	4241      	negs	r1, r0
 80067d0:	4141      	adcs	r1, r0
 80067d2:	200e      	movs	r0, #14
 80067d4:	f7fa f9c4 	bl	8000b60 <_test_assert>
 80067d8:	2800      	cmp	r0, #0
 80067da:	d000      	beq.n	80067de <mbox1_execute.9596+0x40e>
 80067dc:	e619      	b.n	8006412 <mbox1_execute.9596+0x42>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80067de:	6820      	ldr	r0, [r4, #0]
 80067e0:	68a6      	ldr	r6, [r4, #8]
 80067e2:	1b81      	subs	r1, r0, r6
 80067e4:	424b      	negs	r3, r1
 80067e6:	4159      	adcs	r1, r3
 80067e8:	200f      	movs	r0, #15
 80067ea:	f7fa f9b9 	bl	8000b60 <_test_assert>
 80067ee:	2800      	cmp	r0, #0
 80067f0:	d000      	beq.n	80067f4 <mbox1_execute.9596+0x424>
 80067f2:	e60e      	b.n	8006412 <mbox1_execute.9596+0x42>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 80067f4:	68e3      	ldr	r3, [r4, #12]
 80067f6:	6822      	ldr	r2, [r4, #0]
 80067f8:	2010      	movs	r0, #16
 80067fa:	1ad1      	subs	r1, r2, r3
 80067fc:	424b      	negs	r3, r1
 80067fe:	4159      	adcs	r1, r3
 8006800:	f7fa f9ae 	bl	8000b60 <_test_assert>
 8006804:	2800      	cmp	r0, #0
 8006806:	d000      	beq.n	800680a <mbox1_execute.9596+0x43a>
 8006808:	e603      	b.n	8006412 <mbox1_execute.9596+0x42>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 800680a:	2101      	movs	r1, #1
 800680c:	a801      	add	r0, sp, #4
 800680e:	f7fd fc5f 	bl	80040d0 <chMBFetch.constprop.30>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8006812:	1c41      	adds	r1, r0, #1
 8006814:	424b      	negs	r3, r1
 8006816:	4159      	adcs	r1, r3
 8006818:	2011      	movs	r0, #17
 800681a:	f7fa f9a1 	bl	8000b60 <_test_assert>
 800681e:	2800      	cmp	r0, #0
 8006820:	d000      	beq.n	8006824 <mbox1_execute.9596+0x454>
 8006822:	e5f6      	b.n	8006412 <mbox1_execute.9596+0x42>
  chSysLock();
 8006824:	f7fd fd64 	bl	80042f0 <chSysLock.9592>
  msg1 = chMBFetchI(&mb1, &msg2);
 8006828:	a801      	add	r0, sp, #4
 800682a:	f7fc fef1 	bl	8003610 <chMBFetchI.constprop.29>
 800682e:	1c07      	adds	r7, r0, #0
  chSysUnlock();
 8006830:	f7fd f906 	bl	8003a40 <chSysUnlock.9594>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8006834:	1c79      	adds	r1, r7, #1
 8006836:	424e      	negs	r6, r1
 8006838:	4171      	adcs	r1, r6
 800683a:	2012      	movs	r0, #18
 800683c:	f7fa f990 	bl	8000b60 <_test_assert>
 8006840:	2800      	cmp	r0, #0
 8006842:	d000      	beq.n	8006846 <mbox1_execute.9596+0x476>
 8006844:	e5e5      	b.n	8006412 <mbox1_execute.9596+0x42>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8006846:	f7fd fd53 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 800684a:	f7f9 ff11 	bl	8000670 <chDbgCheckClassI>
 800684e:	f7f9 ff0f 	bl	8000670 <chDbgCheckClassI>
 8006852:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006854:	2013      	movs	r0, #19
 8006856:	3905      	subs	r1, #5
 8006858:	424b      	negs	r3, r1
 800685a:	4159      	adcs	r1, r3
 800685c:	f7fa f980 	bl	8000b60 <_test_assert>
 8006860:	2800      	cmp	r0, #0
 8006862:	d000      	beq.n	8006866 <mbox1_execute.9596+0x496>
 8006864:	e233      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 8006866:	f7fd f8eb 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 800686a:	f7fd fd41 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 800686e:	f7f9 feff 	bl	8000670 <chDbgCheckClassI>
 8006872:	f7f9 fefd 	bl	8000670 <chDbgCheckClassI>
 8006876:	69a0      	ldr	r0, [r4, #24]
 8006878:	4241      	negs	r1, r0
 800687a:	4141      	adcs	r1, r0
 800687c:	2014      	movs	r0, #20
 800687e:	f7fa f96f 	bl	8000b60 <_test_assert>
 8006882:	2800      	cmp	r0, #0
 8006884:	d000      	beq.n	8006888 <mbox1_execute.9596+0x4b8>
 8006886:	e222      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 8006888:	f7fd f8da 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800688c:	f7fd fd30 	bl	80042f0 <chSysLock.9592>
 8006890:	68e1      	ldr	r1, [r4, #12]
 8006892:	68a6      	ldr	r6, [r4, #8]
 8006894:	2015      	movs	r0, #21
 8006896:	1b89      	subs	r1, r1, r6
 8006898:	424b      	negs	r3, r1
 800689a:	4159      	adcs	r1, r3
 800689c:	f7fa f960 	bl	8000b60 <_test_assert>
 80068a0:	2800      	cmp	r0, #0
 80068a2:	d000      	beq.n	80068a6 <mbox1_execute.9596+0x4d6>
 80068a4:	e213      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 80068a6:	f7fd f8cb 	bl	8003a40 <chSysUnlock.9594>

  /*
   * Testing I-Class.
   */
  chSysLock();
 80068aa:	f7fd fd21 	bl	80042f0 <chSysLock.9592>
  msg1 = chMBPostI(&mb1, 'A');
 80068ae:	2041      	movs	r0, #65	; 0x41
 80068b0:	f7fc fede 	bl	8003670 <chMBPostI.constprop.35>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 80068b4:	4241      	negs	r1, r0
 80068b6:	4141      	adcs	r1, r0
 80068b8:	2016      	movs	r0, #22
 80068ba:	f7fa f951 	bl	8000b60 <_test_assert>
 80068be:	2800      	cmp	r0, #0
 80068c0:	d000      	beq.n	80068c4 <mbox1_execute.9596+0x4f4>
 80068c2:	e5a6      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostI(&mb1, 'B');
 80068c4:	2042      	movs	r0, #66	; 0x42
 80068c6:	f7fc fed3 	bl	8003670 <chMBPostI.constprop.35>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 80068ca:	4241      	negs	r1, r0
 80068cc:	4141      	adcs	r1, r0
 80068ce:	2017      	movs	r0, #23
 80068d0:	f7fa f946 	bl	8000b60 <_test_assert>
 80068d4:	2800      	cmp	r0, #0
 80068d6:	d000      	beq.n	80068da <mbox1_execute.9596+0x50a>
 80068d8:	e59b      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostI(&mb1, 'C');
 80068da:	2043      	movs	r0, #67	; 0x43
 80068dc:	f7fc fec8 	bl	8003670 <chMBPostI.constprop.35>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 80068e0:	4241      	negs	r1, r0
 80068e2:	4141      	adcs	r1, r0
 80068e4:	2018      	movs	r0, #24
 80068e6:	f7fa f93b 	bl	8000b60 <_test_assert>
 80068ea:	2800      	cmp	r0, #0
 80068ec:	d000      	beq.n	80068f0 <mbox1_execute.9596+0x520>
 80068ee:	e590      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostI(&mb1, 'D');
 80068f0:	2044      	movs	r0, #68	; 0x44
 80068f2:	f7fc febd 	bl	8003670 <chMBPostI.constprop.35>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 80068f6:	4241      	negs	r1, r0
 80068f8:	4141      	adcs	r1, r0
 80068fa:	2019      	movs	r0, #25
 80068fc:	f7fa f930 	bl	8000b60 <_test_assert>
 8006900:	2800      	cmp	r0, #0
 8006902:	d000      	beq.n	8006906 <mbox1_execute.9596+0x536>
 8006904:	e585      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostI(&mb1, 'E');
 8006906:	2045      	movs	r0, #69	; 0x45
 8006908:	f7fc feb2 	bl	8003670 <chMBPostI.constprop.35>
 800690c:	1c07      	adds	r7, r0, #0
  chSysUnlock();
 800690e:	f7fd f897 	bl	8003a40 <chSysUnlock.9594>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 8006912:	4279      	negs	r1, r7
 8006914:	4179      	adcs	r1, r7
 8006916:	201a      	movs	r0, #26
 8006918:	f7fa f922 	bl	8000b60 <_test_assert>
 800691c:	2800      	cmp	r0, #0
 800691e:	d000      	beq.n	8006922 <mbox1_execute.9596+0x552>
 8006920:	e577      	b.n	8006412 <mbox1_execute.9596+0x42>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8006922:	68e3      	ldr	r3, [r4, #12]
 8006924:	68a2      	ldr	r2, [r4, #8]
 8006926:	201b      	movs	r0, #27
 8006928:	1a99      	subs	r1, r3, r2
 800692a:	424b      	negs	r3, r1
 800692c:	4159      	adcs	r1, r3
 800692e:	f7fa f917 	bl	8000b60 <_test_assert>
 8006932:	2800      	cmp	r0, #0
 8006934:	d000      	beq.n	8006938 <mbox1_execute.9596+0x568>
 8006936:	e56c      	b.n	8006412 <mbox1_execute.9596+0x42>
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006938:	f7fd fcda 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 800693c:	a801      	add	r0, sp, #4
 800693e:	f7fc fe67 	bl	8003610 <chMBFetchI.constprop.29>
 8006942:	1c06      	adds	r6, r0, #0
    chSysUnlock();
 8006944:	f7fd f87c 	bl	8003a40 <chSysUnlock.9594>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 8006948:	4271      	negs	r1, r6
 800694a:	4171      	adcs	r1, r6
 800694c:	201c      	movs	r0, #28
 800694e:	f7fa f907 	bl	8000b60 <_test_assert>
 8006952:	2800      	cmp	r0, #0
 8006954:	d000      	beq.n	8006958 <mbox1_execute.9596+0x588>
 8006956:	e55c      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006958:	4668      	mov	r0, sp
 800695a:	7900      	ldrb	r0, [r0, #4]
 800695c:	f7fe fbc0 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006960:	f7fd fcc6 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 8006964:	a801      	add	r0, sp, #4
 8006966:	f7fc fe53 	bl	8003610 <chMBFetchI.constprop.29>
 800696a:	1c07      	adds	r7, r0, #0
    chSysUnlock();
 800696c:	f7fd f868 	bl	8003a40 <chSysUnlock.9594>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 8006970:	4279      	negs	r1, r7
 8006972:	4179      	adcs	r1, r7
 8006974:	201c      	movs	r0, #28
 8006976:	f7fa f8f3 	bl	8000b60 <_test_assert>
 800697a:	2800      	cmp	r0, #0
 800697c:	d000      	beq.n	8006980 <mbox1_execute.9596+0x5b0>
 800697e:	e548      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006980:	4669      	mov	r1, sp
 8006982:	7908      	ldrb	r0, [r1, #4]
 8006984:	f7fe fbac 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006988:	f7fd fcb2 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 800698c:	a801      	add	r0, sp, #4
 800698e:	f7fc fe3f 	bl	8003610 <chMBFetchI.constprop.29>
 8006992:	1c06      	adds	r6, r0, #0
    chSysUnlock();
 8006994:	f7fd f854 	bl	8003a40 <chSysUnlock.9594>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 8006998:	4271      	negs	r1, r6
 800699a:	4171      	adcs	r1, r6
 800699c:	201c      	movs	r0, #28
 800699e:	f7fa f8df 	bl	8000b60 <_test_assert>
 80069a2:	2800      	cmp	r0, #0
 80069a4:	d000      	beq.n	80069a8 <mbox1_execute.9596+0x5d8>
 80069a6:	e534      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 80069a8:	466b      	mov	r3, sp
 80069aa:	7918      	ldrb	r0, [r3, #4]
 80069ac:	f7fe fb98 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 80069b0:	f7fd fc9e 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 80069b4:	a801      	add	r0, sp, #4
 80069b6:	f7fc fe2b 	bl	8003610 <chMBFetchI.constprop.29>
 80069ba:	1c07      	adds	r7, r0, #0
    chSysUnlock();
 80069bc:	f7fd f840 	bl	8003a40 <chSysUnlock.9594>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 80069c0:	4279      	negs	r1, r7
 80069c2:	4179      	adcs	r1, r7
 80069c4:	201c      	movs	r0, #28
 80069c6:	f7fa f8cb 	bl	8000b60 <_test_assert>
 80069ca:	2800      	cmp	r0, #0
 80069cc:	d000      	beq.n	80069d0 <mbox1_execute.9596+0x600>
 80069ce:	e520      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 80069d0:	466a      	mov	r2, sp
 80069d2:	7910      	ldrb	r0, [r2, #4]
 80069d4:	f7fe fb84 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 80069d8:	f7fd fc8a 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 80069dc:	a801      	add	r0, sp, #4
 80069de:	f7fc fe17 	bl	8003610 <chMBFetchI.constprop.29>
 80069e2:	1c06      	adds	r6, r0, #0
    chSysUnlock();
 80069e4:	f7fd f82c 	bl	8003a40 <chSysUnlock.9594>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 80069e8:	4271      	negs	r1, r6
 80069ea:	4171      	adcs	r1, r6
 80069ec:	201c      	movs	r0, #28
 80069ee:	f7fa f8b7 	bl	8000b60 <_test_assert>
 80069f2:	2800      	cmp	r0, #0
 80069f4:	d000      	beq.n	80069f8 <mbox1_execute.9596+0x628>
 80069f6:	e50c      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 80069f8:	4668      	mov	r0, sp
 80069fa:	7900      	ldrb	r0, [r0, #4]
 80069fc:	f7fe fb70 	bl	80050e0 <test_emit_token>
  }
  test_assert_sequence(29, "ABCDE");
 8006a00:	201d      	movs	r0, #29
 8006a02:	1c29      	adds	r1, r5, #0
 8006a04:	f7fa f85c 	bl	8000ac0 <_test_assert_sequence>
 8006a08:	2800      	cmp	r0, #0
 8006a0a:	d000      	beq.n	8006a0e <mbox1_execute.9596+0x63e>
 8006a0c:	e501      	b.n	8006412 <mbox1_execute.9596+0x42>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8006a0e:	f7fd fc6f 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006a12:	f7f9 fe2d 	bl	8000670 <chDbgCheckClassI>
 8006a16:	f7f9 fe2b 	bl	8000670 <chDbgCheckClassI>
 8006a1a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006a1c:	201e      	movs	r0, #30
 8006a1e:	3905      	subs	r1, #5
 8006a20:	424b      	negs	r3, r1
 8006a22:	4159      	adcs	r1, r3
 8006a24:	f7fa f89c 	bl	8000b60 <_test_assert>
 8006a28:	2800      	cmp	r0, #0
 8006a2a:	d000      	beq.n	8006a2e <mbox1_execute.9596+0x65e>
 8006a2c:	e14f      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 8006a2e:	f7fd f807 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 8006a32:	f7fd fc5d 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006a36:	f7f9 fe1b 	bl	8000670 <chDbgCheckClassI>
 8006a3a:	f7f9 fe19 	bl	8000670 <chDbgCheckClassI>
 8006a3e:	69a3      	ldr	r3, [r4, #24]
 8006a40:	201f      	movs	r0, #31
 8006a42:	4259      	negs	r1, r3
 8006a44:	4159      	adcs	r1, r3
 8006a46:	f7fa f88b 	bl	8000b60 <_test_assert>
 8006a4a:	2800      	cmp	r0, #0
 8006a4c:	d000      	beq.n	8006a50 <mbox1_execute.9596+0x680>
 8006a4e:	e13e      	b.n	8006cce <mbox1_execute.9596+0x8fe>
 8006a50:	f7fc fff6 	bl	8003a40 <chSysUnlock.9594>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8006a54:	68e1      	ldr	r1, [r4, #12]
 8006a56:	68a7      	ldr	r7, [r4, #8]
 8006a58:	2020      	movs	r0, #32
 8006a5a:	1bc9      	subs	r1, r1, r7
 8006a5c:	424b      	negs	r3, r1
 8006a5e:	4159      	adcs	r1, r3
 8006a60:	f7fa f87e 	bl	8000b60 <_test_assert>
 8006a64:	2800      	cmp	r0, #0
 8006a66:	d000      	beq.n	8006a6a <mbox1_execute.9596+0x69a>
 8006a68:	e4d3      	b.n	8006412 <mbox1_execute.9596+0x42>

  chSysLock();
 8006a6a:	f7fd fc41 	bl	80042f0 <chSysLock.9592>
  msg1 = chMBPostAheadI(&mb1, 'E');
 8006a6e:	2045      	movs	r0, #69	; 0x45
 8006a70:	f7fc fe26 	bl	80036c0 <chMBPostAheadI.constprop.32>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 8006a74:	4241      	negs	r1, r0
 8006a76:	4141      	adcs	r1, r0
 8006a78:	2021      	movs	r0, #33	; 0x21
 8006a7a:	f7fa f871 	bl	8000b60 <_test_assert>
 8006a7e:	2800      	cmp	r0, #0
 8006a80:	d000      	beq.n	8006a84 <mbox1_execute.9596+0x6b4>
 8006a82:	e4c6      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8006a84:	2044      	movs	r0, #68	; 0x44
 8006a86:	f7fc fe1b 	bl	80036c0 <chMBPostAheadI.constprop.32>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 8006a8a:	4241      	negs	r1, r0
 8006a8c:	4141      	adcs	r1, r0
 8006a8e:	2022      	movs	r0, #34	; 0x22
 8006a90:	f7fa f866 	bl	8000b60 <_test_assert>
 8006a94:	2800      	cmp	r0, #0
 8006a96:	d000      	beq.n	8006a9a <mbox1_execute.9596+0x6ca>
 8006a98:	e4bb      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostAheadI(&mb1, 'C');
 8006a9a:	2043      	movs	r0, #67	; 0x43
 8006a9c:	f7fc fe10 	bl	80036c0 <chMBPostAheadI.constprop.32>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 8006aa0:	4241      	negs	r1, r0
 8006aa2:	4141      	adcs	r1, r0
 8006aa4:	2023      	movs	r0, #35	; 0x23
 8006aa6:	f7fa f85b 	bl	8000b60 <_test_assert>
 8006aaa:	2800      	cmp	r0, #0
 8006aac:	d000      	beq.n	8006ab0 <mbox1_execute.9596+0x6e0>
 8006aae:	e4b0      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostAheadI(&mb1, 'B');
 8006ab0:	2042      	movs	r0, #66	; 0x42
 8006ab2:	f7fc fe05 	bl	80036c0 <chMBPostAheadI.constprop.32>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 8006ab6:	4241      	negs	r1, r0
 8006ab8:	4141      	adcs	r1, r0
 8006aba:	2024      	movs	r0, #36	; 0x24
 8006abc:	f7fa f850 	bl	8000b60 <_test_assert>
 8006ac0:	2800      	cmp	r0, #0
 8006ac2:	d000      	beq.n	8006ac6 <mbox1_execute.9596+0x6f6>
 8006ac4:	e4a5      	b.n	8006412 <mbox1_execute.9596+0x42>
  msg1 = chMBPostAheadI(&mb1, 'A');
 8006ac6:	2041      	movs	r0, #65	; 0x41
 8006ac8:	f7fc fdfa 	bl	80036c0 <chMBPostAheadI.constprop.32>
 8006acc:	1c06      	adds	r6, r0, #0
  chSysUnlock();
 8006ace:	f7fc ffb7 	bl	8003a40 <chSysUnlock.9594>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 8006ad2:	4271      	negs	r1, r6
 8006ad4:	4171      	adcs	r1, r6
 8006ad6:	2025      	movs	r0, #37	; 0x25
 8006ad8:	f7fa f842 	bl	8000b60 <_test_assert>
 8006adc:	2800      	cmp	r0, #0
 8006ade:	d000      	beq.n	8006ae2 <mbox1_execute.9596+0x712>
 8006ae0:	e497      	b.n	8006412 <mbox1_execute.9596+0x42>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8006ae2:	68e0      	ldr	r0, [r4, #12]
 8006ae4:	68a2      	ldr	r2, [r4, #8]
 8006ae6:	1a81      	subs	r1, r0, r2
 8006ae8:	424b      	negs	r3, r1
 8006aea:	4159      	adcs	r1, r3
 8006aec:	2026      	movs	r0, #38	; 0x26
 8006aee:	f7fa f837 	bl	8000b60 <_test_assert>
 8006af2:	2800      	cmp	r0, #0
 8006af4:	d000      	beq.n	8006af8 <mbox1_execute.9596+0x728>
 8006af6:	e48c      	b.n	8006412 <mbox1_execute.9596+0x42>
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006af8:	f7fd fbfa 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 8006afc:	a801      	add	r0, sp, #4
 8006afe:	f7fc fd87 	bl	8003610 <chMBFetchI.constprop.29>
 8006b02:	1c07      	adds	r7, r0, #0
    chSysUnlock();
 8006b04:	f7fc ff9c 	bl	8003a40 <chSysUnlock.9594>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8006b08:	4279      	negs	r1, r7
 8006b0a:	4179      	adcs	r1, r7
 8006b0c:	2027      	movs	r0, #39	; 0x27
 8006b0e:	f7fa f827 	bl	8000b60 <_test_assert>
 8006b12:	2800      	cmp	r0, #0
 8006b14:	d000      	beq.n	8006b18 <mbox1_execute.9596+0x748>
 8006b16:	e47c      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006b18:	466b      	mov	r3, sp
 8006b1a:	7918      	ldrb	r0, [r3, #4]
 8006b1c:	f7fe fae0 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006b20:	f7fd fbe6 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 8006b24:	a801      	add	r0, sp, #4
 8006b26:	f7fc fd73 	bl	8003610 <chMBFetchI.constprop.29>
 8006b2a:	1c06      	adds	r6, r0, #0
    chSysUnlock();
 8006b2c:	f7fc ff88 	bl	8003a40 <chSysUnlock.9594>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8006b30:	4271      	negs	r1, r6
 8006b32:	4171      	adcs	r1, r6
 8006b34:	2027      	movs	r0, #39	; 0x27
 8006b36:	f7fa f813 	bl	8000b60 <_test_assert>
 8006b3a:	2800      	cmp	r0, #0
 8006b3c:	d000      	beq.n	8006b40 <mbox1_execute.9596+0x770>
 8006b3e:	e468      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006b40:	4669      	mov	r1, sp
 8006b42:	7908      	ldrb	r0, [r1, #4]
 8006b44:	f7fe facc 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006b48:	f7fd fbd2 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 8006b4c:	a801      	add	r0, sp, #4
 8006b4e:	f7fc fd5f 	bl	8003610 <chMBFetchI.constprop.29>
 8006b52:	1c07      	adds	r7, r0, #0
    chSysUnlock();
 8006b54:	f7fc ff74 	bl	8003a40 <chSysUnlock.9594>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8006b58:	4279      	negs	r1, r7
 8006b5a:	4179      	adcs	r1, r7
 8006b5c:	2027      	movs	r0, #39	; 0x27
 8006b5e:	f7f9 ffff 	bl	8000b60 <_test_assert>
 8006b62:	2800      	cmp	r0, #0
 8006b64:	d000      	beq.n	8006b68 <mbox1_execute.9596+0x798>
 8006b66:	e454      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006b68:	4668      	mov	r0, sp
 8006b6a:	7900      	ldrb	r0, [r0, #4]
 8006b6c:	f7fe fab8 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006b70:	f7fd fbbe 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 8006b74:	a801      	add	r0, sp, #4
 8006b76:	f7fc fd4b 	bl	8003610 <chMBFetchI.constprop.29>
 8006b7a:	1c06      	adds	r6, r0, #0
    chSysUnlock();
 8006b7c:	f7fc ff60 	bl	8003a40 <chSysUnlock.9594>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8006b80:	4271      	negs	r1, r6
 8006b82:	4171      	adcs	r1, r6
 8006b84:	2027      	movs	r0, #39	; 0x27
 8006b86:	f7f9 ffeb 	bl	8000b60 <_test_assert>
 8006b8a:	2800      	cmp	r0, #0
 8006b8c:	d000      	beq.n	8006b90 <mbox1_execute.9596+0x7c0>
 8006b8e:	e440      	b.n	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006b90:	466a      	mov	r2, sp
 8006b92:	7910      	ldrb	r0, [r2, #4]
 8006b94:	f7fe faa4 	bl	80050e0 <test_emit_token>
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
 8006b98:	f7fd fbaa 	bl	80042f0 <chSysLock.9592>
    msg1 = chMBFetchI(&mb1, &msg2);
 8006b9c:	a801      	add	r0, sp, #4
 8006b9e:	f7fc fd37 	bl	8003610 <chMBFetchI.constprop.29>
 8006ba2:	1c07      	adds	r7, r0, #0
    chSysUnlock();
 8006ba4:	f7fc ff4c 	bl	8003a40 <chSysUnlock.9594>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8006ba8:	4279      	negs	r1, r7
 8006baa:	4179      	adcs	r1, r7
 8006bac:	2027      	movs	r0, #39	; 0x27
 8006bae:	f7f9 ffd7 	bl	8000b60 <_test_assert>
 8006bb2:	2800      	cmp	r0, #0
 8006bb4:	d001      	beq.n	8006bba <mbox1_execute.9596+0x7ea>
 8006bb6:	f7ff fc2c 	bl	8006412 <mbox1_execute.9596+0x42>
    test_emit_token(msg2);
 8006bba:	466b      	mov	r3, sp
 8006bbc:	7918      	ldrb	r0, [r3, #4]
 8006bbe:	f7fe fa8f 	bl	80050e0 <test_emit_token>
  }
  test_assert_sequence(40, "ABCDE");
 8006bc2:	2028      	movs	r0, #40	; 0x28
 8006bc4:	1c29      	adds	r1, r5, #0
 8006bc6:	f7f9 ff7b 	bl	8000ac0 <_test_assert_sequence>
 8006bca:	2800      	cmp	r0, #0
 8006bcc:	d001      	beq.n	8006bd2 <mbox1_execute.9596+0x802>
 8006bce:	f7ff fc20 	bl	8006412 <mbox1_execute.9596+0x42>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8006bd2:	f7fd fb8d 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006bd6:	f7f9 fd4b 	bl	8000670 <chDbgCheckClassI>
 8006bda:	f7f9 fd49 	bl	8000670 <chDbgCheckClassI>
 8006bde:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006be0:	2029      	movs	r0, #41	; 0x29
 8006be2:	3905      	subs	r1, #5
 8006be4:	424b      	negs	r3, r1
 8006be6:	4159      	adcs	r1, r3
 8006be8:	f7f9 ffba 	bl	8000b60 <_test_assert>
 8006bec:	2800      	cmp	r0, #0
 8006bee:	d16e      	bne.n	8006cce <mbox1_execute.9596+0x8fe>
 8006bf0:	f7fc ff26 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 8006bf4:	f7fd fb7c 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006bf8:	f7f9 fd3a 	bl	8000670 <chDbgCheckClassI>
 8006bfc:	f7f9 fd38 	bl	8000670 <chDbgCheckClassI>
 8006c00:	69a5      	ldr	r5, [r4, #24]
 8006c02:	202a      	movs	r0, #42	; 0x2a
 8006c04:	4269      	negs	r1, r5
 8006c06:	4169      	adcs	r1, r5
 8006c08:	f7f9 ffaa 	bl	8000b60 <_test_assert>
 8006c0c:	2800      	cmp	r0, #0
 8006c0e:	d15e      	bne.n	8006cce <mbox1_execute.9596+0x8fe>
 8006c10:	f7fc ff16 	bl	8003a40 <chSysUnlock.9594>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8006c14:	68a0      	ldr	r0, [r4, #8]
 8006c16:	68e1      	ldr	r1, [r4, #12]
 8006c18:	1a09      	subs	r1, r1, r0
 8006c1a:	424b      	negs	r3, r1
 8006c1c:	4159      	adcs	r1, r3
 8006c1e:	202b      	movs	r0, #43	; 0x2b
 8006c20:	f7f9 ff9e 	bl	8000b60 <_test_assert>
 8006c24:	2800      	cmp	r0, #0
 8006c26:	d001      	beq.n	8006c2c <mbox1_execute.9596+0x85c>
 8006c28:	f7ff fbf3 	bl	8006412 <mbox1_execute.9596+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006c2c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006c2e:	f7fc ff37 	bl	8003aa0 <_dbg_check_lock>
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006c32:	f7f9 fd1d 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8006c36:	6862      	ldr	r2, [r4, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8006c38:	6826      	ldr	r6, [r4, #0]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8006c3a:	1c20      	adds	r0, r4, #0
 8006c3c:	1b97      	subs	r7, r2, r6
 8006c3e:	301c      	adds	r0, #28
 8006c40:	10b9      	asrs	r1, r7, #2
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8006c42:	60a6      	str	r6, [r4, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8006c44:	60e6      	str	r6, [r4, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8006c46:	f7fc fd63 	bl	8003710 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8006c4a:	1c20      	adds	r0, r4, #0
 8006c4c:	3010      	adds	r0, #16
 8006c4e:	2100      	movs	r1, #0
 8006c50:	f7fc fd5e 	bl	8003710 <chSemResetI>
 */
void chMBReset(mailbox_t *mbp) {

  chSysLock();
  chMBResetI(mbp);
  chSchRescheduleS();
 8006c54:	f7fc fc14 	bl	8003480 <chSchRescheduleS>
  chSysUnlock();
 8006c58:	f7fc feda 	bl	8003a10 <chSysUnlock.6509>
  chMBReset(&mb1);

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8006c5c:	f7fd fb48 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006c60:	f7f9 fd06 	bl	8000670 <chDbgCheckClassI>
 8006c64:	f7f9 fd04 	bl	8000670 <chDbgCheckClassI>
 8006c68:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006c6a:	202c      	movs	r0, #44	; 0x2c
 8006c6c:	3905      	subs	r1, #5
 8006c6e:	424b      	negs	r3, r1
 8006c70:	4159      	adcs	r1, r3
 8006c72:	f7f9 ff75 	bl	8000b60 <_test_assert>
 8006c76:	2800      	cmp	r0, #0
 8006c78:	d129      	bne.n	8006cce <mbox1_execute.9596+0x8fe>
 8006c7a:	f7fc fee1 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 8006c7e:	f7fd fb37 	bl	80042f0 <chSysLock.9592>
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
 8006c82:	f7f9 fcf5 	bl	8000670 <chDbgCheckClassI>
 8006c86:	f7f9 fcf3 	bl	8000670 <chDbgCheckClassI>
 8006c8a:	69a3      	ldr	r3, [r4, #24]
 8006c8c:	202d      	movs	r0, #45	; 0x2d
 8006c8e:	4259      	negs	r1, r3
 8006c90:	4159      	adcs	r1, r3
 8006c92:	f7f9 ff65 	bl	8000b60 <_test_assert>
 8006c96:	2800      	cmp	r0, #0
 8006c98:	d119      	bne.n	8006cce <mbox1_execute.9596+0x8fe>
 8006c9a:	f7fc fed1 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8006c9e:	f7fd fb27 	bl	80042f0 <chSysLock.9592>
 8006ca2:	6825      	ldr	r5, [r4, #0]
 8006ca4:	68a1      	ldr	r1, [r4, #8]
 8006ca6:	202e      	movs	r0, #46	; 0x2e
 8006ca8:	1a69      	subs	r1, r5, r1
 8006caa:	424b      	negs	r3, r1
 8006cac:	4159      	adcs	r1, r3
 8006cae:	f7f9 ff57 	bl	8000b60 <_test_assert>
 8006cb2:	2800      	cmp	r0, #0
 8006cb4:	d10b      	bne.n	8006cce <mbox1_execute.9596+0x8fe>
 8006cb6:	f7fc fec3 	bl	8003a40 <chSysUnlock.9594>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8006cba:	f7fd fb19 	bl	80042f0 <chSysLock.9592>
 8006cbe:	6820      	ldr	r0, [r4, #0]
 8006cc0:	68e4      	ldr	r4, [r4, #12]
 8006cc2:	1b01      	subs	r1, r0, r4
 8006cc4:	424b      	negs	r3, r1
 8006cc6:	4159      	adcs	r1, r3
 8006cc8:	202f      	movs	r0, #47	; 0x2f
 8006cca:	f7f9 ff49 	bl	8000b60 <_test_assert>
 8006cce:	f7fc feb7 	bl	8003a40 <chSysUnlock.9594>
 8006cd2:	f7ff fb9e 	bl	8006412 <mbox1_execute.9596+0x42>
 8006cd6:	b672      	cpsid	i
 8006cd8:	4b09      	ldr	r3, [pc, #36]	; (8006d00 <mbox1_execute.9596+0x930>)
 8006cda:	62eb      	str	r3, [r5, #44]	; 0x2c
 8006cdc:	e7fe      	b.n	8006cdc <mbox1_execute.9596+0x90c>
 8006cde:	b672      	cpsid	i
 8006ce0:	4a07      	ldr	r2, [pc, #28]	; (8006d00 <mbox1_execute.9596+0x930>)
 8006ce2:	62ea      	str	r2, [r5, #44]	; 0x2c
 8006ce4:	e7fe      	b.n	8006ce4 <mbox1_execute.9596+0x914>
 8006ce6:	b672      	cpsid	i
 8006ce8:	4f06      	ldr	r7, [pc, #24]	; (8006d04 <mbox1_execute.9596+0x934>)
 8006cea:	62ef      	str	r7, [r5, #44]	; 0x2c
 8006cec:	e7fe      	b.n	8006cec <mbox1_execute.9596+0x91c>
 8006cee:	b672      	cpsid	i
 8006cf0:	4a03      	ldr	r2, [pc, #12]	; (8006d00 <mbox1_execute.9596+0x930>)
 8006cf2:	62ea      	str	r2, [r5, #44]	; 0x2c
 8006cf4:	e7fe      	b.n	8006cf4 <mbox1_execute.9596+0x924>
 8006cf6:	b672      	cpsid	i
 8006cf8:	4e01      	ldr	r6, [pc, #4]	; (8006d00 <mbox1_execute.9596+0x930>)
 8006cfa:	62ee      	str	r6, [r5, #44]	; 0x2c
 8006cfc:	e7fe      	b.n	8006cfc <mbox1_execute.9596+0x92c>
 8006cfe:	46c0      	nop			; (mov r8, r8)
 8006d00:	08008ae0 	.word	0x08008ae0
 8006d04:	08008b10 	.word	0x08008b10
 8006d08:	46c0      	nop			; (mov r8, r8)
 8006d0a:	46c0      	nop			; (mov r8, r8)
 8006d0c:	46c0      	nop			; (mov r8, r8)
 8006d0e:	46c0      	nop			; (mov r8, r8)

08006d10 <thread4.8983>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 8006d10:	b510      	push	{r4, lr}
 8006d12:	1c04      	adds	r4, r0, #0
 8006d14:	b672      	cpsid	i
 8006d16:	f7fc fec3 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 8006d1a:	f7f9 fca9 	bl	8000670 <chDbgCheckClassI>

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8006d1e:	68a3      	ldr	r3, [r4, #8]
 8006d20:	2b00      	cmp	r3, #0
 8006d22:	dc02      	bgt.n	8006d2a <thread4.8983+0x1a>
    chSemSignalI(&bsp->bs_sem);
 8006d24:	1c20      	adds	r0, r4, #0
 8006d26:	f7fc fc43 	bl	80035b0 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8006d2a:	f7fc fba9 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006d2e:	f7fc fe1f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006d32:	4807      	ldr	r0, [pc, #28]	; (8006d50 <thread4.8983+0x40>)
 8006d34:	6802      	ldr	r2, [r0, #0]
 8006d36:	4282      	cmp	r2, r0
 8006d38:	d004      	beq.n	8006d44 <thread4.8983+0x34>
 8006d3a:	6981      	ldr	r1, [r0, #24]
 8006d3c:	6893      	ldr	r3, [r2, #8]
 8006d3e:	688c      	ldr	r4, [r1, #8]
 8006d40:	429c      	cmp	r4, r3
 8006d42:	d301      	bcc.n	8006d48 <thread4.8983+0x38>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006d44:	b662      	cpsie	i

  chBSemSignal((binary_semaphore_t *)p);
}
 8006d46:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006d48:	b672      	cpsid	i
 8006d4a:	4a02      	ldr	r2, [pc, #8]	; (8006d54 <thread4.8983+0x44>)
 8006d4c:	62c2      	str	r2, [r0, #44]	; 0x2c
 8006d4e:	e7fe      	b.n	8006d4e <thread4.8983+0x3e>
 8006d50:	20001040 	.word	0x20001040
 8006d54:	080085d0 	.word	0x080085d0
 8006d58:	46c0      	nop			; (mov r8, r8)
 8006d5a:	46c0      	nop			; (mov r8, r8)
 8006d5c:	46c0      	nop			; (mov r8, r8)
 8006d5e:	46c0      	nop			; (mov r8, r8)

08006d60 <thd4_execute.8738>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8006d60:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
 8006d62:	f7fb fccd 	bl	8002700 <test_wait_tick>
 8006d66:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006d68:	f7fc fe9a 	bl	8003aa0 <_dbg_check_lock>
 8006d6c:	2380      	movs	r3, #128	; 0x80
 8006d6e:	05d8      	lsls	r0, r3, #23
 8006d70:	6a45      	ldr	r5, [r0, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006d72:	f7fc fdfd 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006d76:	4c4d      	ldr	r4, [pc, #308]	; (8006eac <thd4_execute.8738+0x14c>)
 8006d78:	6821      	ldr	r1, [r4, #0]
 8006d7a:	42a1      	cmp	r1, r4
 8006d7c:	d004      	beq.n	8006d88 <thd4_execute.8738+0x28>
 8006d7e:	69a2      	ldr	r2, [r4, #24]
 8006d80:	688b      	ldr	r3, [r1, #8]
 8006d82:	6896      	ldr	r6, [r2, #8]
 8006d84:	429e      	cmp	r6, r3
 8006d86:	d30f      	bcc.n	8006da8 <thd4_execute.8738+0x48>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006d88:	b662      	cpsie	i

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 8006d8a:	20fa      	movs	r0, #250	; 0xfa
 8006d8c:	0080      	lsls	r0, r0, #2
 8006d8e:	f7fb fc8f 	bl	80026b0 <chThdSleep>
  test_assert_time_window(1,
 8006d92:	4e47      	ldr	r6, [pc, #284]	; (8006eb0 <thd4_execute.8738+0x150>)
 8006d94:	21fa      	movs	r1, #250	; 0xfa
 8006d96:	008a      	lsls	r2, r1, #2
 8006d98:	18a9      	adds	r1, r5, r2
 8006d9a:	2001      	movs	r0, #1
 8006d9c:	19aa      	adds	r2, r5, r6
 8006d9e:	f7fe f967 	bl	8005070 <_test_assert_time_window>
 8006da2:	2800      	cmp	r0, #0
 8006da4:	d004      	beq.n	8006db0 <thd4_execute.8738+0x50>
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 8006da6:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006da8:	b672      	cpsid	i
 8006daa:	4842      	ldr	r0, [pc, #264]	; (8006eb4 <thd4_execute.8738+0x154>)
 8006dac:	62e0      	str	r0, [r4, #44]	; 0x2c
 8006dae:	e7fe      	b.n	8006dae <thd4_execute.8738+0x4e>
 8006db0:	b672      	cpsid	i
 8006db2:	2580      	movs	r5, #128	; 0x80
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006db4:	f7fc fe74 	bl	8003aa0 <_dbg_check_lock>
 8006db8:	05eb      	lsls	r3, r5, #23
 8006dba:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006dbc:	f7fc fdd8 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006dc0:	6820      	ldr	r0, [r4, #0]
 8006dc2:	42a0      	cmp	r0, r4
 8006dc4:	d004      	beq.n	8006dd0 <thd4_execute.8738+0x70>
 8006dc6:	69a1      	ldr	r1, [r4, #24]
 8006dc8:	6885      	ldr	r5, [r0, #8]
 8006dca:	688a      	ldr	r2, [r1, #8]
 8006dcc:	42aa      	cmp	r2, r5
 8006dce:	d35c      	bcc.n	8006e8a <thd4_execute.8738+0x12a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006dd0:	b662      	cpsie	i
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 8006dd2:	23fa      	movs	r3, #250	; 0xfa
 8006dd4:	0098      	lsls	r0, r3, #2
 8006dd6:	f7fb fc6b 	bl	80026b0 <chThdSleep>
  test_assert_time_window(2,
 8006dda:	20fa      	movs	r0, #250	; 0xfa
 8006ddc:	4a34      	ldr	r2, [pc, #208]	; (8006eb0 <thd4_execute.8738+0x150>)
 8006dde:	0081      	lsls	r1, r0, #2
 8006de0:	1871      	adds	r1, r6, r1
 8006de2:	18b2      	adds	r2, r6, r2
 8006de4:	2002      	movs	r0, #2
 8006de6:	f7fe f943 	bl	8005070 <_test_assert_time_window>
 8006dea:	2800      	cmp	r0, #0
 8006dec:	d1db      	bne.n	8006da6 <thd4_execute.8738+0x46>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006dee:	b672      	cpsid	i
 8006df0:	2680      	movs	r6, #128	; 0x80
 8006df2:	05f5      	lsls	r5, r6, #23
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006df4:	f7fc fe54 	bl	8003aa0 <_dbg_check_lock>
 8006df8:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006dfa:	f7fc fdb9 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006dfe:	6823      	ldr	r3, [r4, #0]
 8006e00:	42a3      	cmp	r3, r4
 8006e02:	d004      	beq.n	8006e0e <thd4_execute.8738+0xae>
 8006e04:	69a0      	ldr	r0, [r4, #24]
 8006e06:	689a      	ldr	r2, [r3, #8]
 8006e08:	6881      	ldr	r1, [r0, #8]
 8006e0a:	4291      	cmp	r1, r2
 8006e0c:	d345      	bcc.n	8006e9a <thd4_execute.8738+0x13a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006e0e:	b662      	cpsie	i
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 8006e10:	4829      	ldr	r0, [pc, #164]	; (8006eb8 <thd4_execute.8738+0x158>)
 8006e12:	f7fb fc4d 	bl	80026b0 <chThdSleep>
  test_assert_time_window(3,
 8006e16:	4d28      	ldr	r5, [pc, #160]	; (8006eb8 <thd4_execute.8738+0x158>)
 8006e18:	4b28      	ldr	r3, [pc, #160]	; (8006ebc <thd4_execute.8738+0x15c>)
 8006e1a:	1971      	adds	r1, r6, r5
 8006e1c:	18f2      	adds	r2, r6, r3
 8006e1e:	2003      	movs	r0, #3
 8006e20:	f7fe f926 	bl	8005070 <_test_assert_time_window>
 8006e24:	2800      	cmp	r0, #0
 8006e26:	d1be      	bne.n	8006da6 <thd4_execute.8738+0x46>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006e28:	b672      	cpsid	i
 8006e2a:	2680      	movs	r6, #128	; 0x80
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006e2c:	f7fc fe38 	bl	8003aa0 <_dbg_check_lock>
 8006e30:	05f0      	lsls	r0, r6, #23
 8006e32:	6a46      	ldr	r6, [r0, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006e34:	f7fc fd9c 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006e38:	6821      	ldr	r1, [r4, #0]
 8006e3a:	42a1      	cmp	r1, r4
 8006e3c:	d004      	beq.n	8006e48 <thd4_execute.8738+0xe8>
 8006e3e:	69a2      	ldr	r2, [r4, #24]
 8006e40:	688b      	ldr	r3, [r1, #8]
 8006e42:	6895      	ldr	r5, [r2, #8]
 8006e44:	429d      	cmp	r5, r3
 8006e46:	d32c      	bcc.n	8006ea2 <thd4_execute.8738+0x142>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006e48:	b662      	cpsie	i
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 8006e4a:	20fa      	movs	r0, #250	; 0xfa
 8006e4c:	0081      	lsls	r1, r0, #2
 8006e4e:	1875      	adds	r5, r6, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006e50:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006e52:	f7fc fe25 	bl	8003aa0 <_dbg_check_lock>
 8006e56:	2280      	movs	r2, #128	; 0x80
 8006e58:	05d3      	lsls	r3, r2, #23
 8006e5a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
 8006e5c:	1a29      	subs	r1, r5, r0
  if (time > (systime_t)0) {
 8006e5e:	d002      	beq.n	8006e66 <thd4_execute.8738+0x106>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8006e60:	2008      	movs	r0, #8
 8006e62:	f7fa f8e5 	bl	8001030 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006e66:	f7fc fd83 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006e6a:	6821      	ldr	r1, [r4, #0]
 8006e6c:	42a1      	cmp	r1, r4
 8006e6e:	d004      	beq.n	8006e7a <thd4_execute.8738+0x11a>
 8006e70:	69a2      	ldr	r2, [r4, #24]
 8006e72:	688b      	ldr	r3, [r1, #8]
 8006e74:	6890      	ldr	r0, [r2, #8]
 8006e76:	4298      	cmp	r0, r3
 8006e78:	d30b      	bcc.n	8006e92 <thd4_execute.8738+0x132>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006e7a:	b662      	cpsie	i
  chThdSleepUntil(time);
  test_assert_time_window(4,
 8006e7c:	4c0c      	ldr	r4, [pc, #48]	; (8006eb0 <thd4_execute.8738+0x150>)
 8006e7e:	1c29      	adds	r1, r5, #0
 8006e80:	1932      	adds	r2, r6, r4
 8006e82:	2004      	movs	r0, #4
 8006e84:	f7fe f8f4 	bl	8005070 <_test_assert_time_window>
 8006e88:	e78d      	b.n	8006da6 <thd4_execute.8738+0x46>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006e8a:	b672      	cpsid	i
 8006e8c:	4a09      	ldr	r2, [pc, #36]	; (8006eb4 <thd4_execute.8738+0x154>)
 8006e8e:	62e2      	str	r2, [r4, #44]	; 0x2c
 8006e90:	e7fe      	b.n	8006e90 <thd4_execute.8738+0x130>
 8006e92:	b672      	cpsid	i
 8006e94:	4e0a      	ldr	r6, [pc, #40]	; (8006ec0 <thd4_execute.8738+0x160>)
 8006e96:	62e6      	str	r6, [r4, #44]	; 0x2c
 8006e98:	e7fe      	b.n	8006e98 <thd4_execute.8738+0x138>
 8006e9a:	b672      	cpsid	i
 8006e9c:	4905      	ldr	r1, [pc, #20]	; (8006eb4 <thd4_execute.8738+0x154>)
 8006e9e:	62e1      	str	r1, [r4, #44]	; 0x2c
 8006ea0:	e7fe      	b.n	8006ea0 <thd4_execute.8738+0x140>
 8006ea2:	b672      	cpsid	i
 8006ea4:	4d03      	ldr	r5, [pc, #12]	; (8006eb4 <thd4_execute.8738+0x154>)
 8006ea6:	62e5      	str	r5, [r4, #44]	; 0x2c
 8006ea8:	e7fe      	b.n	8006ea8 <thd4_execute.8738+0x148>
 8006eaa:	46c0      	nop			; (mov r8, r8)
 8006eac:	20001040 	.word	0x20001040
 8006eb0:	000003eb 	.word	0x000003eb
 8006eb4:	08008b60 	.word	0x08008b60
 8006eb8:	00002710 	.word	0x00002710
 8006ebc:	00002713 	.word	0x00002713
 8006ec0:	08008b00 	.word	0x08008b00
 8006ec4:	46c0      	nop			; (mov r8, r8)
 8006ec6:	46c0      	nop			; (mov r8, r8)
 8006ec8:	46c0      	nop			; (mov r8, r8)
 8006eca:	46c0      	nop			; (mov r8, r8)
 8006ecc:	46c0      	nop			; (mov r8, r8)
 8006ece:	46c0      	nop			; (mov r8, r8)

08006ed0 <queues1_execute.10396>:

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
}

static void queues1_execute(void) {
 8006ed0:	b570      	push	{r4, r5, r6, lr}
 8006ed2:	b082      	sub	sp, #8
 8006ed4:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006ed6:	f7fc fde3 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8006eda:	f7f9 fbc9 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8006ede:	4dd2      	ldr	r5, [pc, #840]	; (8007228 <queues1_execute.10396+0x358>)
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 8006ee0:	2001      	movs	r0, #1
 8006ee2:	68a9      	ldr	r1, [r5, #8]
 8006ee4:	424b      	negs	r3, r1
 8006ee6:	4159      	adcs	r1, r3
 8006ee8:	f7f9 fe3a 	bl	8000b60 <_test_assert>
 8006eec:	2800      	cmp	r0, #0
 8006eee:	d000      	beq.n	8006ef2 <queues1_execute.10396+0x22>
 8006ef0:	e1a8      	b.n	8007244 <queues1_execute.10396+0x374>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006ef2:	f7fc fd3d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006ef6:	4ccd      	ldr	r4, [pc, #820]	; (800722c <queues1_execute.10396+0x35c>)
 8006ef8:	6823      	ldr	r3, [r4, #0]
 8006efa:	42a3      	cmp	r3, r4
 8006efc:	d005      	beq.n	8006f0a <queues1_execute.10396+0x3a>
 8006efe:	69a2      	ldr	r2, [r4, #24]
 8006f00:	6899      	ldr	r1, [r3, #8]
 8006f02:	6890      	ldr	r0, [r2, #8]
 8006f04:	4288      	cmp	r0, r1
 8006f06:	d200      	bcs.n	8006f0a <queues1_execute.10396+0x3a>
 8006f08:	e1b2      	b.n	8007270 <queues1_execute.10396+0x3a0>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006f0a:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006f0c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006f0e:	f7fc fdc7 	bl	8003aa0 <_dbg_check_lock>

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8006f12:	2141      	movs	r1, #65	; 0x41
 8006f14:	1c28      	adds	r0, r5, #0
 8006f16:	f7fc f9cb 	bl	80032b0 <chIQPutI>
 8006f1a:	2142      	movs	r1, #66	; 0x42
 8006f1c:	1c28      	adds	r0, r5, #0
 8006f1e:	f7fc f9c7 	bl	80032b0 <chIQPutI>
 8006f22:	2143      	movs	r1, #67	; 0x43
 8006f24:	1c28      	adds	r0, r5, #0
 8006f26:	f7fc f9c3 	bl	80032b0 <chIQPutI>
 8006f2a:	2144      	movs	r1, #68	; 0x44
 8006f2c:	1c28      	adds	r0, r5, #0
 8006f2e:	f7fc f9bf 	bl	80032b0 <chIQPutI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006f32:	f7fc fd1d 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006f36:	6826      	ldr	r6, [r4, #0]
 8006f38:	42a6      	cmp	r6, r4
 8006f3a:	d005      	beq.n	8006f48 <queues1_execute.10396+0x78>
 8006f3c:	69a3      	ldr	r3, [r4, #24]
 8006f3e:	68b0      	ldr	r0, [r6, #8]
 8006f40:	689a      	ldr	r2, [r3, #8]
 8006f42:	4282      	cmp	r2, r0
 8006f44:	d200      	bcs.n	8006f48 <queues1_execute.10396+0x78>
 8006f46:	e18b      	b.n	8007260 <queues1_execute.10396+0x390>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006f48:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006f4a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006f4c:	f7fc fda8 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8006f50:	f7f9 fb8e 	bl	8000670 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8006f54:	696e      	ldr	r6, [r5, #20]
 8006f56:	69ab      	ldr	r3, [r5, #24]
 8006f58:	2100      	movs	r1, #0
 8006f5a:	429e      	cmp	r6, r3
 8006f5c:	d100      	bne.n	8006f60 <queues1_execute.10396+0x90>
 8006f5e:	e1c4      	b.n	80072ea <queues1_execute.10396+0x41a>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 8006f60:	2002      	movs	r0, #2
 8006f62:	f7f9 fdfd 	bl	8000b60 <_test_assert>
 8006f66:	2800      	cmp	r0, #0
 8006f68:	d000      	beq.n	8006f6c <queues1_execute.10396+0x9c>
 8006f6a:	e185      	b.n	8007278 <queues1_execute.10396+0x3a8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006f6c:	f7fc fd00 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006f70:	6821      	ldr	r1, [r4, #0]
 8006f72:	42a1      	cmp	r1, r4
 8006f74:	d005      	beq.n	8006f82 <queues1_execute.10396+0xb2>
 8006f76:	69a2      	ldr	r2, [r4, #24]
 8006f78:	688e      	ldr	r6, [r1, #8]
 8006f7a:	6890      	ldr	r0, [r2, #8]
 8006f7c:	42b0      	cmp	r0, r6
 8006f7e:	d200      	bcs.n	8006f82 <queues1_execute.10396+0xb2>
 8006f80:	e1b7      	b.n	80072f2 <queues1_execute.10396+0x422>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006f82:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006f84:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006f86:	f7fc fd8b 	bl	8003aa0 <_dbg_check_lock>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8006f8a:	2100      	movs	r1, #0
 8006f8c:	1c28      	adds	r0, r5, #0
 8006f8e:	f7fc f98f 	bl	80032b0 <chIQPutI>
 8006f92:	1d01      	adds	r1, r0, #4
 8006f94:	424b      	negs	r3, r1
 8006f96:	4159      	adcs	r1, r3
 8006f98:	2003      	movs	r0, #3
 8006f9a:	f7f9 fde1 	bl	8000b60 <_test_assert>
 8006f9e:	2800      	cmp	r0, #0
 8006fa0:	d000      	beq.n	8006fa4 <queues1_execute.10396+0xd4>
 8006fa2:	e1aa      	b.n	80072fa <queues1_execute.10396+0x42a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006fa4:	f7fc fce4 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006fa8:	6823      	ldr	r3, [r4, #0]
 8006faa:	42a3      	cmp	r3, r4
 8006fac:	d005      	beq.n	8006fba <queues1_execute.10396+0xea>
 8006fae:	69a1      	ldr	r1, [r4, #24]
 8006fb0:	6898      	ldr	r0, [r3, #8]
 8006fb2:	688a      	ldr	r2, [r1, #8]
 8006fb4:	4282      	cmp	r2, r0
 8006fb6:	d200      	bcs.n	8006fba <queues1_execute.10396+0xea>
 8006fb8:	e1ad      	b.n	8007316 <queues1_execute.10396+0x446>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8006fba:	b662      	cpsie	i
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8006fbc:	2601      	movs	r6, #1
 8006fbe:	4271      	negs	r1, r6
 8006fc0:	1c28      	adds	r0, r5, #0
 8006fc2:	f7ff f825 	bl	8006010 <chIQGetTimeout>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 8006fc6:	b2c0      	uxtb	r0, r0
 8006fc8:	f7fe f88a 	bl	80050e0 <test_emit_token>
 8006fcc:	2301      	movs	r3, #1
 8006fce:	4259      	negs	r1, r3
 8006fd0:	1c28      	adds	r0, r5, #0
 8006fd2:	f7ff f81d 	bl	8006010 <chIQGetTimeout>
 8006fd6:	b2c0      	uxtb	r0, r0
 8006fd8:	f7fe f882 	bl	80050e0 <test_emit_token>
 8006fdc:	2101      	movs	r1, #1
 8006fde:	4249      	negs	r1, r1
 8006fe0:	1c28      	adds	r0, r5, #0
 8006fe2:	f7ff f815 	bl	8006010 <chIQGetTimeout>
 8006fe6:	b2c0      	uxtb	r0, r0
 8006fe8:	f7fe f87a 	bl	80050e0 <test_emit_token>
 8006fec:	2201      	movs	r2, #1
 8006fee:	4251      	negs	r1, r2
 8006ff0:	1c28      	adds	r0, r5, #0
 8006ff2:	f7ff f80d 	bl	8006010 <chIQGetTimeout>
 8006ff6:	b2c0      	uxtb	r0, r0
 8006ff8:	f7fe f872 	bl	80050e0 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8006ffc:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006ffe:	f7fc fd4f 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8007002:	f7f9 fb35 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8007006:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 8007008:	2004      	movs	r0, #4
 800700a:	424b      	negs	r3, r1
 800700c:	4159      	adcs	r1, r3
 800700e:	f7f9 fda7 	bl	8000b60 <_test_assert>
 8007012:	2800      	cmp	r0, #0
 8007014:	d000      	beq.n	8007018 <queues1_execute.10396+0x148>
 8007016:	e182      	b.n	800731e <queues1_execute.10396+0x44e>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007018:	f7fc fcaa 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800701c:	6820      	ldr	r0, [r4, #0]
 800701e:	42a0      	cmp	r0, r4
 8007020:	d005      	beq.n	800702e <queues1_execute.10396+0x15e>
 8007022:	69a6      	ldr	r6, [r4, #24]
 8007024:	6883      	ldr	r3, [r0, #8]
 8007026:	68b1      	ldr	r1, [r6, #8]
 8007028:	4299      	cmp	r1, r3
 800702a:	d200      	bcs.n	800702e <queues1_execute.10396+0x15e>
 800702c:	e187      	b.n	800733e <queues1_execute.10396+0x46e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800702e:	b662      	cpsie	i
  test_assert_sequence(5, "ABCD");
 8007030:	2005      	movs	r0, #5
 8007032:	497f      	ldr	r1, [pc, #508]	; (8007230 <queues1_execute.10396+0x360>)
 8007034:	f7f9 fd44 	bl	8000ac0 <_test_assert_sequence>
 8007038:	2800      	cmp	r0, #0
 800703a:	d000      	beq.n	800703e <queues1_execute.10396+0x16e>
 800703c:	e10e      	b.n	800725c <queues1_execute.10396+0x38c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800703e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007040:	f7fc fd2e 	bl	8003aa0 <_dbg_check_lock>

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8007044:	2141      	movs	r1, #65	; 0x41
 8007046:	1c28      	adds	r0, r5, #0
 8007048:	f7fc f932 	bl	80032b0 <chIQPutI>
 800704c:	2142      	movs	r1, #66	; 0x42
 800704e:	1c28      	adds	r0, r5, #0
 8007050:	f7fc f92e 	bl	80032b0 <chIQPutI>
 8007054:	2143      	movs	r1, #67	; 0x43
 8007056:	1c28      	adds	r0, r5, #0
 8007058:	f7fc f92a 	bl	80032b0 <chIQPutI>
 800705c:	2144      	movs	r1, #68	; 0x44
 800705e:	1c28      	adds	r0, r5, #0
 8007060:	f7fc f926 	bl	80032b0 <chIQPutI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007064:	f7fc fc84 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007068:	6820      	ldr	r0, [r4, #0]
 800706a:	42a0      	cmp	r0, r4
 800706c:	d005      	beq.n	800707a <queues1_execute.10396+0x1aa>
 800706e:	69a2      	ldr	r2, [r4, #24]
 8007070:	6881      	ldr	r1, [r0, #8]
 8007072:	6896      	ldr	r6, [r2, #8]
 8007074:	428e      	cmp	r6, r1
 8007076:	d200      	bcs.n	800707a <queues1_execute.10396+0x1aa>
 8007078:	e165      	b.n	8007346 <queues1_execute.10396+0x476>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800707a:	b662      	cpsie	i
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800707c:	4e6d      	ldr	r6, [pc, #436]	; (8007234 <queues1_execute.10396+0x364>)
 800707e:	2300      	movs	r3, #0
 8007080:	1c31      	adds	r1, r6, #0
 8007082:	1c28      	adds	r0, r5, #0
 8007084:	2208      	movs	r2, #8
 8007086:	f7fe ff4b 	bl	8005f20 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800708a:	1f01      	subs	r1, r0, #4
 800708c:	424b      	negs	r3, r1
 800708e:	4159      	adcs	r1, r3
 8007090:	2006      	movs	r0, #6
 8007092:	f7f9 fd65 	bl	8000b60 <_test_assert>
 8007096:	2800      	cmp	r0, #0
 8007098:	d000      	beq.n	800709c <queues1_execute.10396+0x1cc>
 800709a:	e0df      	b.n	800725c <queues1_execute.10396+0x38c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800709c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800709e:	f7fc fcff 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80070a2:	f7f9 fae5 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 80070a6:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 80070a8:	2007      	movs	r0, #7
 80070aa:	424b      	negs	r3, r1
 80070ac:	4159      	adcs	r1, r3
 80070ae:	f7f9 fd57 	bl	8000b60 <_test_assert>
 80070b2:	2800      	cmp	r0, #0
 80070b4:	d000      	beq.n	80070b8 <queues1_execute.10396+0x1e8>
 80070b6:	e106      	b.n	80072c6 <queues1_execute.10396+0x3f6>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80070b8:	f7fc fc5a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80070bc:	6823      	ldr	r3, [r4, #0]
 80070be:	42a3      	cmp	r3, r4
 80070c0:	d005      	beq.n	80070ce <queues1_execute.10396+0x1fe>
 80070c2:	69a0      	ldr	r0, [r4, #24]
 80070c4:	6899      	ldr	r1, [r3, #8]
 80070c6:	6882      	ldr	r2, [r0, #8]
 80070c8:	428a      	cmp	r2, r1
 80070ca:	d200      	bcs.n	80070ce <queues1_execute.10396+0x1fe>
 80070cc:	e13f      	b.n	800734e <queues1_execute.10396+0x47e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80070ce:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80070d0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80070d2:	f7fc fce5 	bl	8003aa0 <_dbg_check_lock>

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 80070d6:	2141      	movs	r1, #65	; 0x41
 80070d8:	1c28      	adds	r0, r5, #0
 80070da:	f7fc f8e9 	bl	80032b0 <chIQPutI>
 80070de:	2142      	movs	r1, #66	; 0x42
 80070e0:	1c28      	adds	r0, r5, #0
 80070e2:	f7fc f8e5 	bl	80032b0 <chIQPutI>
 80070e6:	2143      	movs	r1, #67	; 0x43
 80070e8:	1c28      	adds	r0, r5, #0
 80070ea:	f7fc f8e1 	bl	80032b0 <chIQPutI>
 80070ee:	2144      	movs	r1, #68	; 0x44
 80070f0:	1c28      	adds	r0, r5, #0
 80070f2:	f7fc f8dd 	bl	80032b0 <chIQPutI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80070f6:	f7fc fc3b 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80070fa:	6823      	ldr	r3, [r4, #0]
 80070fc:	42a3      	cmp	r3, r4
 80070fe:	d005      	beq.n	800710c <queues1_execute.10396+0x23c>
 8007100:	69a0      	ldr	r0, [r4, #24]
 8007102:	6899      	ldr	r1, [r3, #8]
 8007104:	6882      	ldr	r2, [r0, #8]
 8007106:	428a      	cmp	r2, r1
 8007108:	d200      	bcs.n	800710c <queues1_execute.10396+0x23c>
 800710a:	e0ea      	b.n	80072e2 <queues1_execute.10396+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800710c:	b662      	cpsie	i
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800710e:	2300      	movs	r3, #0
 8007110:	1c31      	adds	r1, r6, #0
 8007112:	1c28      	adds	r0, r5, #0
 8007114:	2202      	movs	r2, #2
 8007116:	f7fe ff03 	bl	8005f20 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800711a:	1e81      	subs	r1, r0, #2
 800711c:	424b      	negs	r3, r1
 800711e:	4159      	adcs	r1, r3
 8007120:	2008      	movs	r0, #8
 8007122:	f7f9 fd1d 	bl	8000b60 <_test_assert>
 8007126:	2800      	cmp	r0, #0
 8007128:	d000      	beq.n	800712c <queues1_execute.10396+0x25c>
 800712a:	e097      	b.n	800725c <queues1_execute.10396+0x38c>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800712c:	1c31      	adds	r1, r6, #0
 800712e:	2300      	movs	r3, #0
 8007130:	1c28      	adds	r0, r5, #0
 8007132:	2202      	movs	r2, #2
 8007134:	f7fe fef4 	bl	8005f20 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8007138:	1e81      	subs	r1, r0, #2
 800713a:	424b      	negs	r3, r1
 800713c:	4159      	adcs	r1, r3
 800713e:	2009      	movs	r0, #9
 8007140:	f7f9 fd0e 	bl	8000b60 <_test_assert>
 8007144:	2800      	cmp	r0, #0
 8007146:	d000      	beq.n	800714a <queues1_execute.10396+0x27a>
 8007148:	e088      	b.n	800725c <queues1_execute.10396+0x38c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800714a:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800714c:	f7fc fca8 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8007150:	f7f9 fa8e 	bl	8000670 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8007154:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 8007156:	200a      	movs	r0, #10
 8007158:	424b      	negs	r3, r1
 800715a:	4159      	adcs	r1, r3
 800715c:	f7f9 fd00 	bl	8000b60 <_test_assert>
 8007160:	2800      	cmp	r0, #0
 8007162:	d000      	beq.n	8007166 <queues1_execute.10396+0x296>
 8007164:	e09d      	b.n	80072a2 <queues1_execute.10396+0x3d2>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007166:	f7fc fc03 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800716a:	6826      	ldr	r6, [r4, #0]
 800716c:	42a6      	cmp	r6, r4
 800716e:	d005      	beq.n	800717c <queues1_execute.10396+0x2ac>
 8007170:	69a3      	ldr	r3, [r4, #24]
 8007172:	68b2      	ldr	r2, [r6, #8]
 8007174:	6898      	ldr	r0, [r3, #8]
 8007176:	4290      	cmp	r0, r2
 8007178:	d200      	bcs.n	800717c <queues1_execute.10396+0x2ac>
 800717a:	e0a0      	b.n	80072be <queues1_execute.10396+0x3ee>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800717c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800717e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007180:	f7fc fc8e 	bl	8003aa0 <_dbg_check_lock>

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 8007184:	2100      	movs	r1, #0
 8007186:	1c28      	adds	r0, r5, #0
 8007188:	f7fc f892 	bl	80032b0 <chIQPutI>
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();
 800718c:	f7f9 fa70 	bl	8000670 <chDbgCheckClassI>

  iqp->q_rdptr = iqp->q_buffer;
 8007190:	68e9      	ldr	r1, [r5, #12]
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 8007192:	1c28      	adds	r0, r5, #0

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 8007194:	2600      	movs	r6, #0
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8007196:	61a9      	str	r1, [r5, #24]
  iqp->q_wrptr = iqp->q_buffer;
 8007198:	6169      	str	r1, [r5, #20]
  iqp->q_counter = 0;
 800719a:	60ae      	str	r6, [r5, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800719c:	f7fc f8c0 	bl	8003320 <chThdDequeueAllI.constprop.72>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80071a0:	f7fc fbe6 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80071a4:	6823      	ldr	r3, [r4, #0]
 80071a6:	42a3      	cmp	r3, r4
 80071a8:	d005      	beq.n	80071b6 <queues1_execute.10396+0x2e6>
 80071aa:	69a0      	ldr	r0, [r4, #24]
 80071ac:	6899      	ldr	r1, [r3, #8]
 80071ae:	6882      	ldr	r2, [r0, #8]
 80071b0:	428a      	cmp	r2, r1
 80071b2:	d200      	bcs.n	80071b6 <queues1_execute.10396+0x2e6>
 80071b4:	e06e      	b.n	8007294 <queues1_execute.10396+0x3c4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80071b6:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80071b8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80071ba:	f7fc fc71 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80071be:	f7f9 fa57 	bl	8000670 <chDbgCheckClassI>

  return (size_t)chQSpaceI(iqp);
 80071c2:	68a9      	ldr	r1, [r5, #8]
  chIQResetI(&iq);
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 80071c4:	200b      	movs	r0, #11
 80071c6:	424b      	negs	r3, r1
 80071c8:	4159      	adcs	r1, r3
 80071ca:	f7f9 fcc9 	bl	8000b60 <_test_assert>
 80071ce:	1e06      	subs	r6, r0, #0
 80071d0:	d000      	beq.n	80071d4 <queues1_execute.10396+0x304>
 80071d2:	e063      	b.n	800729c <queues1_execute.10396+0x3cc>
 80071d4:	f7fc fc4c 	bl	8003a70 <chSysUnlock.10381>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80071d8:	69a4      	ldr	r4, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 80071da:	23a8      	movs	r3, #168	; 0xa8
 80071dc:	68a2      	ldr	r2, [r4, #8]
 80071de:	0059      	lsls	r1, r3, #1
 80071e0:	3201      	adds	r2, #1
 80071e2:	9600      	str	r6, [sp, #0]
 80071e4:	4b14      	ldr	r3, [pc, #80]	; (8007238 <queues1_execute.10396+0x368>)
 80071e6:	4815      	ldr	r0, [pc, #84]	; (800723c <queues1_execute.10396+0x36c>)
 80071e8:	f7fb fe32 	bl	8002e50 <chThdCreateStatic>
 80071ec:	4a14      	ldr	r2, [pc, #80]	; (8007240 <queues1_execute.10396+0x370>)
 80071ee:	6010      	str	r0, [r2, #0]
 80071f0:	b672      	cpsid	i
 80071f2:	f7fc fc55 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 80071f6:	f7f9 fa3b 	bl	8000670 <chDbgCheckClassI>

  return (size_t)chQSpaceI(iqp);
 80071fa:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 80071fc:	200c      	movs	r0, #12
 80071fe:	424b      	negs	r3, r1
 8007200:	4159      	adcs	r1, r3
 8007202:	f7f9 fcad 	bl	8000b60 <_test_assert>
 8007206:	2800      	cmp	r0, #0
 8007208:	d148      	bne.n	800729c <queues1_execute.10396+0x3cc>
 800720a:	f7fc fc31 	bl	8003a70 <chSysUnlock.10381>
  test_wait_threads();
 800720e:	f7fa fc8f 	bl	8001b30 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8007212:	1c28      	adds	r0, r5, #0
 8007214:	210a      	movs	r1, #10
 8007216:	f7fe fefb 	bl	8006010 <chIQGetTimeout>
 800721a:	1c41      	adds	r1, r0, #1
 800721c:	424b      	negs	r3, r1
 800721e:	4159      	adcs	r1, r3
 8007220:	200d      	movs	r0, #13
 8007222:	f7f9 fc9d 	bl	8000b60 <_test_assert>
 8007226:	e019      	b.n	800725c <queues1_execute.10396+0x38c>
 8007228:	2000064c 	.word	0x2000064c
 800722c:	20001040 	.word	0x20001040
 8007230:	080085e0 	.word	0x080085e0
 8007234:	20000808 	.word	0x20000808
 8007238:	08006191 	.word	0x08006191
 800723c:	200006b8 	.word	0x200006b8
 8007240:	200015b8 	.word	0x200015b8
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007244:	f7fc fb94 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007248:	4c43      	ldr	r4, [pc, #268]	; (8007358 <queues1_execute.10396+0x488>)
 800724a:	6822      	ldr	r2, [r4, #0]
 800724c:	42a2      	cmp	r2, r4
 800724e:	d004      	beq.n	800725a <queues1_execute.10396+0x38a>
 8007250:	69a0      	ldr	r0, [r4, #24]
 8007252:	6891      	ldr	r1, [r2, #8]
 8007254:	6883      	ldr	r3, [r0, #8]
 8007256:	428b      	cmp	r3, r1
 8007258:	d306      	bcc.n	8007268 <queues1_execute.10396+0x398>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800725a:	b662      	cpsie	i
}
 800725c:	b002      	add	sp, #8
 800725e:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007260:	b672      	cpsid	i
 8007262:	4e3e      	ldr	r6, [pc, #248]	; (800735c <queues1_execute.10396+0x48c>)
 8007264:	62e6      	str	r6, [r4, #44]	; 0x2c
 8007266:	e7fe      	b.n	8007266 <queues1_execute.10396+0x396>
 8007268:	b672      	cpsid	i
 800726a:	4e3c      	ldr	r6, [pc, #240]	; (800735c <queues1_execute.10396+0x48c>)
 800726c:	62e6      	str	r6, [r4, #44]	; 0x2c
 800726e:	e7fe      	b.n	800726e <queues1_execute.10396+0x39e>
 8007270:	b672      	cpsid	i
 8007272:	4d3a      	ldr	r5, [pc, #232]	; (800735c <queues1_execute.10396+0x48c>)
 8007274:	62e5      	str	r5, [r4, #44]	; 0x2c
 8007276:	e7fe      	b.n	8007276 <queues1_execute.10396+0x3a6>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007278:	f7fc fb7a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800727c:	6825      	ldr	r5, [r4, #0]
 800727e:	42a5      	cmp	r5, r4
 8007280:	d0eb      	beq.n	800725a <queues1_execute.10396+0x38a>
 8007282:	69a2      	ldr	r2, [r4, #24]
 8007284:	68ab      	ldr	r3, [r5, #8]
 8007286:	6890      	ldr	r0, [r2, #8]
 8007288:	4298      	cmp	r0, r3
 800728a:	d2e6      	bcs.n	800725a <queues1_execute.10396+0x38a>
 800728c:	b672      	cpsid	i
 800728e:	4933      	ldr	r1, [pc, #204]	; (800735c <queues1_execute.10396+0x48c>)
 8007290:	62e1      	str	r1, [r4, #44]	; 0x2c
 8007292:	e7fe      	b.n	8007292 <queues1_execute.10396+0x3c2>
 8007294:	b672      	cpsid	i
 8007296:	4d31      	ldr	r5, [pc, #196]	; (800735c <queues1_execute.10396+0x48c>)
 8007298:	62e5      	str	r5, [r4, #44]	; 0x2c
 800729a:	e7fe      	b.n	800729a <queues1_execute.10396+0x3ca>
  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
  chIQResetI(&iq);
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 800729c:	f7fc fbe8 	bl	8003a70 <chSysUnlock.10381>
 80072a0:	e7dc      	b.n	800725c <queues1_execute.10396+0x38c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80072a2:	f7fc fb65 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80072a6:	6821      	ldr	r1, [r4, #0]
 80072a8:	42a1      	cmp	r1, r4
 80072aa:	d0d6      	beq.n	800725a <queues1_execute.10396+0x38a>
 80072ac:	69a6      	ldr	r6, [r4, #24]
 80072ae:	688b      	ldr	r3, [r1, #8]
 80072b0:	68b2      	ldr	r2, [r6, #8]
 80072b2:	429a      	cmp	r2, r3
 80072b4:	d2d1      	bcs.n	800725a <queues1_execute.10396+0x38a>
 80072b6:	b672      	cpsid	i
 80072b8:	4d28      	ldr	r5, [pc, #160]	; (800735c <queues1_execute.10396+0x48c>)
 80072ba:	62e5      	str	r5, [r4, #44]	; 0x2c
 80072bc:	e7fe      	b.n	80072bc <queues1_execute.10396+0x3ec>
 80072be:	b672      	cpsid	i
 80072c0:	4826      	ldr	r0, [pc, #152]	; (800735c <queues1_execute.10396+0x48c>)
 80072c2:	62e0      	str	r0, [r4, #44]	; 0x2c
 80072c4:	e7fe      	b.n	80072c4 <queues1_execute.10396+0x3f4>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80072c6:	f7fc fb53 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80072ca:	6826      	ldr	r6, [r4, #0]
 80072cc:	42a6      	cmp	r6, r4
 80072ce:	d0c4      	beq.n	800725a <queues1_execute.10396+0x38a>
 80072d0:	69a2      	ldr	r2, [r4, #24]
 80072d2:	68b3      	ldr	r3, [r6, #8]
 80072d4:	6895      	ldr	r5, [r2, #8]
 80072d6:	429d      	cmp	r5, r3
 80072d8:	d2bf      	bcs.n	800725a <queues1_execute.10396+0x38a>
 80072da:	b672      	cpsid	i
 80072dc:	481f      	ldr	r0, [pc, #124]	; (800735c <queues1_execute.10396+0x48c>)
 80072de:	62e0      	str	r0, [r4, #44]	; 0x2c
 80072e0:	e7fe      	b.n	80072e0 <queues1_execute.10396+0x410>
 80072e2:	b672      	cpsid	i
 80072e4:	481d      	ldr	r0, [pc, #116]	; (800735c <queues1_execute.10396+0x48c>)
 80072e6:	62e0      	str	r0, [r4, #44]	; 0x2c
 80072e8:	e7fe      	b.n	80072e8 <queues1_execute.10396+0x418>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80072ea:	68a9      	ldr	r1, [r5, #8]
 80072ec:	1e4b      	subs	r3, r1, #1
 80072ee:	4199      	sbcs	r1, r3
 80072f0:	e636      	b.n	8006f60 <queues1_execute.10396+0x90>
 80072f2:	b672      	cpsid	i
 80072f4:	4e19      	ldr	r6, [pc, #100]	; (800735c <queues1_execute.10396+0x48c>)
 80072f6:	62e6      	str	r6, [r4, #44]	; 0x2c
 80072f8:	e7fe      	b.n	80072f8 <queues1_execute.10396+0x428>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80072fa:	f7fc fb39 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80072fe:	6825      	ldr	r5, [r4, #0]
 8007300:	42a5      	cmp	r5, r4
 8007302:	d0aa      	beq.n	800725a <queues1_execute.10396+0x38a>
 8007304:	69a2      	ldr	r2, [r4, #24]
 8007306:	68ab      	ldr	r3, [r5, #8]
 8007308:	6890      	ldr	r0, [r2, #8]
 800730a:	4298      	cmp	r0, r3
 800730c:	d2a5      	bcs.n	800725a <queues1_execute.10396+0x38a>
 800730e:	b672      	cpsid	i
 8007310:	4912      	ldr	r1, [pc, #72]	; (800735c <queues1_execute.10396+0x48c>)
 8007312:	62e1      	str	r1, [r4, #44]	; 0x2c
 8007314:	e7fe      	b.n	8007314 <queues1_execute.10396+0x444>
 8007316:	b672      	cpsid	i
 8007318:	4e10      	ldr	r6, [pc, #64]	; (800735c <queues1_execute.10396+0x48c>)
 800731a:	62e6      	str	r6, [r4, #44]	; 0x2c
 800731c:	e7fe      	b.n	800731c <queues1_execute.10396+0x44c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800731e:	f7fc fb27 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007322:	6825      	ldr	r5, [r4, #0]
 8007324:	42a5      	cmp	r5, r4
 8007326:	d100      	bne.n	800732a <queues1_execute.10396+0x45a>
 8007328:	e797      	b.n	800725a <queues1_execute.10396+0x38a>
 800732a:	69a2      	ldr	r2, [r4, #24]
 800732c:	68ab      	ldr	r3, [r5, #8]
 800732e:	6890      	ldr	r0, [r2, #8]
 8007330:	4298      	cmp	r0, r3
 8007332:	d300      	bcc.n	8007336 <queues1_execute.10396+0x466>
 8007334:	e791      	b.n	800725a <queues1_execute.10396+0x38a>
 8007336:	b672      	cpsid	i
 8007338:	4908      	ldr	r1, [pc, #32]	; (800735c <queues1_execute.10396+0x48c>)
 800733a:	62e1      	str	r1, [r4, #44]	; 0x2c
 800733c:	e7fe      	b.n	800733c <queues1_execute.10396+0x46c>
 800733e:	b672      	cpsid	i
 8007340:	4e06      	ldr	r6, [pc, #24]	; (800735c <queues1_execute.10396+0x48c>)
 8007342:	62e6      	str	r6, [r4, #44]	; 0x2c
 8007344:	e7fe      	b.n	8007344 <queues1_execute.10396+0x474>
 8007346:	b672      	cpsid	i
 8007348:	4904      	ldr	r1, [pc, #16]	; (800735c <queues1_execute.10396+0x48c>)
 800734a:	62e1      	str	r1, [r4, #44]	; 0x2c
 800734c:	e7fe      	b.n	800734c <queues1_execute.10396+0x47c>
 800734e:	b672      	cpsid	i
 8007350:	4902      	ldr	r1, [pc, #8]	; (800735c <queues1_execute.10396+0x48c>)
 8007352:	62e1      	str	r1, [r4, #44]	; 0x2c
 8007354:	e7fe      	b.n	8007354 <queues1_execute.10396+0x484>
 8007356:	46c0      	nop			; (mov r8, r8)
 8007358:	20001040 	.word	0x20001040
 800735c:	080085f0 	.word	0x080085f0

08007360 <mtx5_execute.9263>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 8007360:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007362:	4d2e      	ldr	r5, [pc, #184]	; (800741c <mtx5_execute.9263+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007364:	69ab      	ldr	r3, [r5, #24]
 8007366:	689e      	ldr	r6, [r3, #8]

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
 8007368:	f7fe f85a 	bl	8005420 <chMtxTryLock.constprop.64>
 800736c:	1c01      	adds	r1, r0, #0
  test_assert(1, b, "already locked");
 800736e:	2001      	movs	r0, #1
 8007370:	f7f9 fbf6 	bl	8000b60 <_test_assert>
 8007374:	2800      	cmp	r0, #0
 8007376:	d000      	beq.n	800737a <mtx5_execute.9263+0x1a>
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
}
 8007378:	bd70      	pop	{r4, r5, r6, pc}
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
 800737a:	f7fe f851 	bl	8005420 <chMtxTryLock.constprop.64>
  test_assert(2, !b, "not locked");
 800737e:	2201      	movs	r2, #1
 8007380:	1c01      	adds	r1, r0, #0
 8007382:	4051      	eors	r1, r2
 8007384:	b2c9      	uxtb	r1, r1
 8007386:	2002      	movs	r0, #2
 8007388:	f7f9 fbea 	bl	8000b60 <_test_assert>
 800738c:	2800      	cmp	r0, #0
 800738e:	d1f3      	bne.n	8007378 <mtx5_execute.9263+0x18>
 8007390:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007392:	f7fc fb85 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  chMtxUnlockS(&m1);
 8007396:	4c22      	ldr	r4, [pc, #136]	; (8007420 <mtx5_execute.9263+0xc0>)
 8007398:	1c20      	adds	r0, r4, #0
 800739a:	f7fb fff1 	bl	8003380 <chMtxUnlockS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800739e:	f7fc fae7 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80073a2:	6828      	ldr	r0, [r5, #0]
 80073a4:	42a8      	cmp	r0, r5
 80073a6:	d004      	beq.n	80073b2 <mtx5_execute.9263+0x52>
 80073a8:	69ab      	ldr	r3, [r5, #24]
 80073aa:	6881      	ldr	r1, [r0, #8]
 80073ac:	689a      	ldr	r2, [r3, #8]
 80073ae:	428a      	cmp	r2, r1
 80073b0:	d330      	bcc.n	8007414 <mtx5_execute.9263+0xb4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80073b2:	b662      	cpsie	i
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 80073b4:	6820      	ldr	r0, [r4, #0]
 80073b6:	1b01      	subs	r1, r0, r4
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 80073b8:	424b      	negs	r3, r1
 80073ba:	4159      	adcs	r1, r3
 80073bc:	2003      	movs	r0, #3
 80073be:	f7f9 fbcf 	bl	8000b60 <_test_assert>
 80073c2:	2800      	cmp	r0, #0
 80073c4:	d1d8      	bne.n	8007378 <mtx5_execute.9263+0x18>
  test_assert(4, m1.m_owner == NULL, "still owned");
 80073c6:	68a3      	ldr	r3, [r4, #8]
 80073c8:	2004      	movs	r0, #4
 80073ca:	4259      	negs	r1, r3
 80073cc:	4159      	adcs	r1, r3
 80073ce:	f7f9 fbc7 	bl	8000b60 <_test_assert>
 80073d2:	2800      	cmp	r0, #0
 80073d4:	d1d0      	bne.n	8007378 <mtx5_execute.9263+0x18>
 80073d6:	69ad      	ldr	r5, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 80073d8:	2005      	movs	r0, #5
 80073da:	68aa      	ldr	r2, [r5, #8]
 80073dc:	1ab1      	subs	r1, r6, r2
 80073de:	424e      	negs	r6, r1
 80073e0:	4171      	adcs	r1, r6
 80073e2:	f7f9 fbbd 	bl	8000b60 <_test_assert>
 80073e6:	2800      	cmp	r0, #0
 80073e8:	d1c6      	bne.n	8007378 <mtx5_execute.9263+0x18>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 80073ea:	1c20      	adds	r0, r4, #0
 80073ec:	f7fb f9e0 	bl	80027b0 <chMtxLock>
  chMtxUnlockAll();
 80073f0:	f7fc fda6 	bl	8003f40 <chMtxUnlockAll>
 80073f4:	6826      	ldr	r6, [r4, #0]
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 80073f6:	2006      	movs	r0, #6
 80073f8:	1b31      	subs	r1, r6, r4
 80073fa:	424b      	negs	r3, r1
 80073fc:	4159      	adcs	r1, r3
 80073fe:	f7f9 fbaf 	bl	8000b60 <_test_assert>
 8007402:	2800      	cmp	r0, #0
 8007404:	d1b8      	bne.n	8007378 <mtx5_execute.9263+0x18>
  test_assert(7, m1.m_owner == NULL, "still owned");
 8007406:	68a1      	ldr	r1, [r4, #8]
 8007408:	2007      	movs	r0, #7
 800740a:	424b      	negs	r3, r1
 800740c:	4159      	adcs	r1, r3
 800740e:	f7f9 fba7 	bl	8000b60 <_test_assert>
 8007412:	e7b1      	b.n	8007378 <mtx5_execute.9263+0x18>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007414:	b672      	cpsid	i
 8007416:	4c03      	ldr	r4, [pc, #12]	; (8007424 <mtx5_execute.9263+0xc4>)
 8007418:	62ec      	str	r4, [r5, #44]	; 0x2c
 800741a:	e7fe      	b.n	800741a <mtx5_execute.9263+0xba>
 800741c:	20001040 	.word	0x20001040
 8007420:	20000694 	.word	0x20000694
 8007424:	08008b20 	.word	0x08008b20
 8007428:	46c0      	nop			; (mov r8, r8)
 800742a:	46c0      	nop			; (mov r8, r8)
 800742c:	46c0      	nop			; (mov r8, r8)
 800742e:	46c0      	nop			; (mov r8, r8)

08007430 <sem1_execute.9030>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8007430:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007432:	464f      	mov	r7, r9
 8007434:	4646      	mov	r6, r8
 8007436:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007438:	4d71      	ldr	r5, [pc, #452]	; (8007600 <sem1_execute.9030+0x1d0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800743a:	4a72      	ldr	r2, [pc, #456]	; (8007604 <sem1_execute.9030+0x1d4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800743c:	69ab      	ldr	r3, [r5, #24]
 800743e:	4690      	mov	r8, r2
 8007440:	4f71      	ldr	r7, [pc, #452]	; (8007608 <sem1_execute.9030+0x1d8>)
 8007442:	689a      	ldr	r2, [r3, #8]
 8007444:	4871      	ldr	r0, [pc, #452]	; (800760c <sem1_execute.9030+0x1dc>)

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8007446:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8007448:	21a8      	movs	r1, #168	; 0xa8
 800744a:	3205      	adds	r2, #5
 800744c:	9000      	str	r0, [sp, #0]
 800744e:	0049      	lsls	r1, r1, #1
 8007450:	1c3b      	adds	r3, r7, #0
 8007452:	4681      	mov	r9, r0
 8007454:	4640      	mov	r0, r8
 8007456:	f7fb fcfb 	bl	8002e50 <chThdCreateStatic>
 800745a:	4e6d      	ldr	r6, [pc, #436]	; (8007610 <sem1_execute.9030+0x1e0>)
 800745c:	69ac      	ldr	r4, [r5, #24]
 800745e:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8007460:	68a2      	ldr	r2, [r4, #8]
 8007462:	4b6c      	ldr	r3, [pc, #432]	; (8007614 <sem1_execute.9030+0x1e4>)
 8007464:	4640      	mov	r0, r8
 8007466:	3051      	adds	r0, #81	; 0x51
 8007468:	21a8      	movs	r1, #168	; 0xa8
 800746a:	3201      	adds	r2, #1
 800746c:	9300      	str	r3, [sp, #0]
 800746e:	0049      	lsls	r1, r1, #1
 8007470:	1c3b      	adds	r3, r7, #0
 8007472:	30ff      	adds	r0, #255	; 0xff
 8007474:	f7fb fcec 	bl	8002e50 <chThdCreateStatic>
 8007478:	69ac      	ldr	r4, [r5, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800747a:	22a8      	movs	r2, #168	; 0xa8
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800747c:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800747e:	4b66      	ldr	r3, [pc, #408]	; (8007618 <sem1_execute.9030+0x1e8>)
 8007480:	0090      	lsls	r0, r2, #2
 8007482:	68a2      	ldr	r2, [r4, #8]
 8007484:	21a8      	movs	r1, #168	; 0xa8
 8007486:	3203      	adds	r2, #3
 8007488:	9300      	str	r3, [sp, #0]
 800748a:	0049      	lsls	r1, r1, #1
 800748c:	1c3b      	adds	r3, r7, #0
 800748e:	4440      	add	r0, r8
 8007490:	f7fb fcde 	bl	8002e50 <chThdCreateStatic>
 8007494:	69ac      	ldr	r4, [r5, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8007496:	22fc      	movs	r2, #252	; 0xfc

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8007498:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800749a:	4b60      	ldr	r3, [pc, #384]	; (800761c <sem1_execute.9030+0x1ec>)
 800749c:	0090      	lsls	r0, r2, #2
 800749e:	68a2      	ldr	r2, [r4, #8]
 80074a0:	21a8      	movs	r1, #168	; 0xa8
 80074a2:	3204      	adds	r2, #4
 80074a4:	9300      	str	r3, [sp, #0]
 80074a6:	0049      	lsls	r1, r1, #1
 80074a8:	1c3b      	adds	r3, r7, #0
 80074aa:	4440      	add	r0, r8
 80074ac:	f7fb fcd0 	bl	8002e50 <chThdCreateStatic>
 80074b0:	69ac      	ldr	r4, [r5, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80074b2:	22a8      	movs	r2, #168	; 0xa8
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80074b4:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80074b6:	4b5a      	ldr	r3, [pc, #360]	; (8007620 <sem1_execute.9030+0x1f0>)
 80074b8:	00d0      	lsls	r0, r2, #3
 80074ba:	68a2      	ldr	r2, [r4, #8]
 80074bc:	21a8      	movs	r1, #168	; 0xa8
 80074be:	0049      	lsls	r1, r1, #1
 80074c0:	3202      	adds	r2, #2
 80074c2:	9300      	str	r3, [sp, #0]
 80074c4:	4440      	add	r0, r8
 80074c6:	1c3b      	adds	r3, r7, #0
 80074c8:	f7fb fcc2 	bl	8002e50 <chThdCreateStatic>
  chSemSignal(&sem1);
 80074cc:	4c55      	ldr	r4, [pc, #340]	; (8007624 <sem1_execute.9030+0x1f4>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80074ce:	6130      	str	r0, [r6, #16]
  chSemSignal(&sem1);
 80074d0:	1c20      	adds	r0, r4, #0
 80074d2:	f7fc fb4d 	bl	8003b70 <chSemSignal>
  chSemSignal(&sem1);
 80074d6:	1c20      	adds	r0, r4, #0
 80074d8:	f7fc fb4a 	bl	8003b70 <chSemSignal>
  chSemSignal(&sem1);
 80074dc:	1c20      	adds	r0, r4, #0
 80074de:	f7fc fb47 	bl	8003b70 <chSemSignal>
  chSemSignal(&sem1);
 80074e2:	1c20      	adds	r0, r4, #0
 80074e4:	f7fc fb44 	bl	8003b70 <chSemSignal>
  chSemSignal(&sem1);
 80074e8:	1c20      	adds	r0, r4, #0
 80074ea:	f7fc fb41 	bl	8003b70 <chSemSignal>
  test_wait_threads();
 80074ee:	f7fa fb1f 	bl	8001b30 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 80074f2:	2001      	movs	r0, #1
 80074f4:	494c      	ldr	r1, [pc, #304]	; (8007628 <sem1_execute.9030+0x1f8>)
 80074f6:	f7f9 fae3 	bl	8000ac0 <_test_assert_sequence>
 80074fa:	2800      	cmp	r0, #0
 80074fc:	d004      	beq.n	8007508 <sem1_execute.9030+0xd8>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 80074fe:	b003      	add	sp, #12
 8007500:	bc0c      	pop	{r2, r3}
 8007502:	4690      	mov	r8, r2
 8007504:	4699      	mov	r9, r3
 8007506:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007508:	69aa      	ldr	r2, [r5, #24]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800750a:	4648      	mov	r0, r9
 800750c:	6892      	ldr	r2, [r2, #8]
 800750e:	23a8      	movs	r3, #168	; 0xa8
 8007510:	9000      	str	r0, [sp, #0]
 8007512:	0059      	lsls	r1, r3, #1
 8007514:	3205      	adds	r2, #5
 8007516:	4640      	mov	r0, r8
 8007518:	1c3b      	adds	r3, r7, #0
 800751a:	f7fb fc99 	bl	8002e50 <chThdCreateStatic>
 800751e:	6030      	str	r0, [r6, #0]
 8007520:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007522:	f7fc fabd 	bl	8003aa0 <_dbg_check_lock>
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {

  chDbgCheckClassI();
 8007526:	f7f9 f8a3 	bl	8000670 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800752a:	68a7      	ldr	r7, [r4, #8]
 800752c:	6826      	ldr	r6, [r4, #0]
 800752e:	2f00      	cmp	r7, #0
 8007530:	db05      	blt.n	800753e <sem1_execute.9030+0x10e>
 8007532:	42a6      	cmp	r6, r4
 8007534:	d005      	beq.n	8007542 <sem1_execute.9030+0x112>
 8007536:	b672      	cpsid	i
 8007538:	493c      	ldr	r1, [pc, #240]	; (800762c <sem1_execute.9030+0x1fc>)
 800753a:	62e9      	str	r1, [r5, #44]	; 0x2c
 800753c:	e7fe      	b.n	800753c <sem1_execute.9030+0x10c>
 800753e:	42a6      	cmp	r6, r4
 8007540:	d0f9      	beq.n	8007536 <sem1_execute.9030+0x106>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 8007542:	3701      	adds	r7, #1
 8007544:	60a7      	str	r7, [r4, #8]
 8007546:	2f00      	cmp	r7, #0
 8007548:	dd2f      	ble.n	80075aa <sem1_execute.9030+0x17a>
 800754a:	68a0      	ldr	r0, [r4, #8]
 800754c:	3001      	adds	r0, #1
 800754e:	60a0      	str	r0, [r4, #8]
 8007550:	2800      	cmp	r0, #0
 8007552:	dd37      	ble.n	80075c4 <sem1_execute.9030+0x194>
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
 8007554:	f7fb ff94 	bl	8003480 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007558:	f7fc fa0a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800755c:	682e      	ldr	r6, [r5, #0]
 800755e:	42ae      	cmp	r6, r5
 8007560:	d004      	beq.n	800756c <sem1_execute.9030+0x13c>
 8007562:	69a9      	ldr	r1, [r5, #24]
 8007564:	68b0      	ldr	r0, [r6, #8]
 8007566:	688a      	ldr	r2, [r1, #8]
 8007568:	4282      	cmp	r2, r0
 800756a:	d344      	bcc.n	80075f6 <sem1_execute.9030+0x1c6>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800756c:	b662      	cpsie	i
  chSysUnlock();
  test_wait_threads();
 800756e:	f7fa fadf 	bl	8001b30 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007572:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007574:	f7fc fa94 	bl	8003aa0 <_dbg_check_lock>
 8007578:	f7f9 f87a 	bl	8000670 <chDbgCheckClassI>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 800757c:	68a1      	ldr	r1, [r4, #8]
 800757e:	2002      	movs	r0, #2
 8007580:	3901      	subs	r1, #1
 8007582:	424b      	negs	r3, r1
 8007584:	4159      	adcs	r1, r3
 8007586:	f7f9 faeb 	bl	8000b60 <_test_assert>
 800758a:	2800      	cmp	r0, #0
 800758c:	d125      	bne.n	80075da <sem1_execute.9030+0x1aa>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800758e:	f7fc f9ef 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007592:	682c      	ldr	r4, [r5, #0]
 8007594:	42ac      	cmp	r4, r5
 8007596:	d01e      	beq.n	80075d6 <sem1_execute.9030+0x1a6>
 8007598:	69ab      	ldr	r3, [r5, #24]
 800759a:	68a6      	ldr	r6, [r4, #8]
 800759c:	689f      	ldr	r7, [r3, #8]
 800759e:	42b7      	cmp	r7, r6
 80075a0:	d219      	bcs.n	80075d6 <sem1_execute.9030+0x1a6>
 80075a2:	b672      	cpsid	i
 80075a4:	4922      	ldr	r1, [pc, #136]	; (8007630 <sem1_execute.9030+0x200>)
 80075a6:	62e9      	str	r1, [r5, #44]	; 0x2c
 80075a8:	e7fe      	b.n	80075a8 <sem1_execute.9030+0x178>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80075aa:	6820      	ldr	r0, [r4, #0]

  tqp->p_next = tp->p_next;
 80075ac:	6801      	ldr	r1, [r0, #0]
 80075ae:	6021      	str	r1, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80075b0:	604c      	str	r4, [r1, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 80075b2:	f7f9 f8bd 	bl	8000730 <chSchReadyI>
 80075b6:	2200      	movs	r2, #0
 80075b8:	6242      	str	r2, [r0, #36]	; 0x24
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 80075ba:	68a0      	ldr	r0, [r4, #8]
 80075bc:	3001      	adds	r0, #1
 80075be:	60a0      	str	r0, [r4, #8]
 80075c0:	2800      	cmp	r0, #0
 80075c2:	dcc7      	bgt.n	8007554 <sem1_execute.9030+0x124>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80075c4:	6820      	ldr	r0, [r4, #0]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 80075c6:	2700      	movs	r7, #0

  tqp->p_next = tp->p_next;
 80075c8:	6803      	ldr	r3, [r0, #0]
 80075ca:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80075cc:	605c      	str	r4, [r3, #4]
 80075ce:	f7f9 f8af 	bl	8000730 <chSchReadyI>
 80075d2:	6247      	str	r7, [r0, #36]	; 0x24
 80075d4:	e7be      	b.n	8007554 <sem1_execute.9030+0x124>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80075d6:	b662      	cpsie	i
 80075d8:	e791      	b.n	80074fe <sem1_execute.9030+0xce>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80075da:	f7fc f9c9 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80075de:	6828      	ldr	r0, [r5, #0]
 80075e0:	42a8      	cmp	r0, r5
 80075e2:	d0f8      	beq.n	80075d6 <sem1_execute.9030+0x1a6>
 80075e4:	69aa      	ldr	r2, [r5, #24]
 80075e6:	6883      	ldr	r3, [r0, #8]
 80075e8:	6894      	ldr	r4, [r2, #8]
 80075ea:	429c      	cmp	r4, r3
 80075ec:	d2f3      	bcs.n	80075d6 <sem1_execute.9030+0x1a6>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80075ee:	b672      	cpsid	i
 80075f0:	4f0f      	ldr	r7, [pc, #60]	; (8007630 <sem1_execute.9030+0x200>)
 80075f2:	62ef      	str	r7, [r5, #44]	; 0x2c
 80075f4:	e7fe      	b.n	80075f4 <sem1_execute.9030+0x1c4>
 80075f6:	b672      	cpsid	i
 80075f8:	4e0d      	ldr	r6, [pc, #52]	; (8007630 <sem1_execute.9030+0x200>)
 80075fa:	62ee      	str	r6, [r5, #44]	; 0x2c
 80075fc:	e7fe      	b.n	80075fc <sem1_execute.9030+0x1cc>
 80075fe:	46c0      	nop			; (mov r8, r8)
 8007600:	20001040 	.word	0x20001040
 8007604:	200006b8 	.word	0x200006b8
 8007608:	08005141 	.word	0x08005141
 800760c:	08008698 	.word	0x08008698
 8007610:	200015b8 	.word	0x200015b8
 8007614:	080089a4 	.word	0x080089a4
 8007618:	080089a0 	.word	0x080089a0
 800761c:	080089a8 	.word	0x080089a8
 8007620:	080089b0 	.word	0x080089b0
 8007624:	200006a4 	.word	0x200006a4
 8007628:	080089ac 	.word	0x080089ac
 800762c:	08008b30 	.word	0x08008b30
 8007630:	080085d0 	.word	0x080085d0
 8007634:	46c0      	nop			; (mov r8, r8)
 8007636:	46c0      	nop			; (mov r8, r8)
 8007638:	46c0      	nop			; (mov r8, r8)
 800763a:	46c0      	nop			; (mov r8, r8)
 800763c:	46c0      	nop			; (mov r8, r8)
 800763e:	46c0      	nop			; (mov r8, r8)

08007640 <evt2_execute.9782>:

static void evt2_execute(void) {
 8007640:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007642:	4657      	mov	r7, sl
 8007644:	464e      	mov	r6, r9
 8007646:	4645      	mov	r5, r8
 8007648:	b4e0      	push	{r5, r6, r7}
 800764a:	b08c      	sub	sp, #48	; 0x30
 800764c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800764e:	f7fc fa27 	bl	8003aa0 <_dbg_check_lock>
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->p_epending |= events;
 8007652:	4ca8      	ldr	r4, [pc, #672]	; (80078f4 <evt2_execute.9782+0x2b4>)
 8007654:	2207      	movs	r2, #7
 8007656:	69a3      	ldr	r3, [r4, #24]
 8007658:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800765a:	430a      	orrs	r2, r1
 800765c:	639a      	str	r2, [r3, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800765e:	f7fc f987 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007662:	6820      	ldr	r0, [r4, #0]
 8007664:	42a0      	cmp	r0, r4
 8007666:	d004      	beq.n	8007672 <evt2_execute.9782+0x32>
 8007668:	69a5      	ldr	r5, [r4, #24]
 800766a:	6887      	ldr	r7, [r0, #8]
 800766c:	68ae      	ldr	r6, [r5, #8]
 800766e:	42be      	cmp	r6, r7
 8007670:	d310      	bcc.n	8007694 <evt2_execute.9782+0x54>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007672:	b662      	cpsie	i

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
 8007674:	f7fa fea4 	bl	80023c0 <chEvtWaitOne.constprop.49>
  test_assert(1, m == 1, "single event error");
 8007678:	1e41      	subs	r1, r0, #1
 800767a:	424b      	negs	r3, r1
 800767c:	4159      	adcs	r1, r3
 800767e:	2001      	movs	r0, #1
 8007680:	f7f9 fa6e 	bl	8000b60 <_test_assert>
 8007684:	2800      	cmp	r0, #0
 8007686:	d009      	beq.n	800769c <evt2_execute.9782+0x5c>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 8007688:	b00c      	add	sp, #48	; 0x30
 800768a:	bc1c      	pop	{r2, r3, r4}
 800768c:	4690      	mov	r8, r2
 800768e:	4699      	mov	r9, r3
 8007690:	46a2      	mov	sl, r4
 8007692:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007694:	b672      	cpsid	i
 8007696:	4a98      	ldr	r2, [pc, #608]	; (80078f8 <evt2_execute.9782+0x2b8>)
 8007698:	62e2      	str	r2, [r4, #44]	; 0x2c
 800769a:	e7fe      	b.n	800769a <evt2_execute.9782+0x5a>
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 800769c:	f7fa fe90 	bl	80023c0 <chEvtWaitOne.constprop.49>
  test_assert(2, m == 2, "single event error");
 80076a0:	1e81      	subs	r1, r0, #2
 80076a2:	424b      	negs	r3, r1
 80076a4:	4159      	adcs	r1, r3
 80076a6:	2002      	movs	r0, #2
 80076a8:	f7f9 fa5a 	bl	8000b60 <_test_assert>
 80076ac:	2800      	cmp	r0, #0
 80076ae:	d1eb      	bne.n	8007688 <evt2_execute.9782+0x48>
  m = chEvtWaitOne(ALL_EVENTS);
 80076b0:	f7fa fe86 	bl	80023c0 <chEvtWaitOne.constprop.49>
  test_assert(3, m == 4, "single event error");
 80076b4:	1f01      	subs	r1, r0, #4
 80076b6:	424b      	negs	r3, r1
 80076b8:	4159      	adcs	r1, r3
 80076ba:	2003      	movs	r0, #3
 80076bc:	f7f9 fa50 	bl	8000b60 <_test_assert>
 80076c0:	2800      	cmp	r0, #0
 80076c2:	d1e1      	bne.n	8007688 <evt2_execute.9782+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80076c4:	f7fd fedc 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
  test_assert(4, m == 0, "stuck event");
 80076c8:	4241      	negs	r1, r0
 80076ca:	4141      	adcs	r1, r0
 80076cc:	2004      	movs	r0, #4
 80076ce:	f7f9 fa47 	bl	8000b60 <_test_assert>
 80076d2:	2800      	cmp	r0, #0
 80076d4:	d1d8      	bne.n	8007688 <evt2_execute.9782+0x48>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 80076d6:	f7fb f813 	bl	8002700 <test_wait_tick>
 80076da:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80076dc:	f7fc f9e0 	bl	8003aa0 <_dbg_check_lock>
 80076e0:	2380      	movs	r3, #128	; 0x80
 80076e2:	05da      	lsls	r2, r3, #23
 80076e4:	6a55      	ldr	r5, [r2, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80076e6:	f7fc f943 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80076ea:	6821      	ldr	r1, [r4, #0]
 80076ec:	42a1      	cmp	r1, r4
 80076ee:	d005      	beq.n	80076fc <evt2_execute.9782+0xbc>
 80076f0:	69a0      	ldr	r0, [r4, #24]
 80076f2:	688f      	ldr	r7, [r1, #8]
 80076f4:	6886      	ldr	r6, [r0, #8]
 80076f6:	42be      	cmp	r6, r7
 80076f8:	d200      	bcs.n	80076fc <evt2_execute.9782+0xbc>
 80076fa:	e0f3      	b.n	80078e4 <evt2_execute.9782+0x2a4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80076fc:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80076fe:	4a7f      	ldr	r2, [pc, #508]	; (80078fc <evt2_execute.9782+0x2bc>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007700:	69a3      	ldr	r3, [r4, #24]
 8007702:	4690      	mov	r8, r2
 8007704:	4e7e      	ldr	r6, [pc, #504]	; (8007900 <evt2_execute.9782+0x2c0>)
 8007706:	689a      	ldr	r2, [r3, #8]
 8007708:	21a8      	movs	r1, #168	; 0xa8
 800770a:	3a01      	subs	r2, #1
 800770c:	0049      	lsls	r1, r1, #1
 800770e:	9300      	str	r3, [sp, #0]
 8007710:	4640      	mov	r0, r8
 8007712:	1c33      	adds	r3, r6, #0
 8007714:	f7fb fb9c 	bl	8002e50 <chThdCreateStatic>
 8007718:	4f7a      	ldr	r7, [pc, #488]	; (8007904 <evt2_execute.9782+0x2c4>)
 800771a:	6038      	str	r0, [r7, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800771c:	f7fa fe50 	bl	80023c0 <chEvtWaitOne.constprop.49>
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8007720:	4a79      	ldr	r2, [pc, #484]	; (8007908 <evt2_execute.9782+0x2c8>)
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8007722:	4681      	mov	r9, r0

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007724:	20fa      	movs	r0, #250	; 0xfa
 8007726:	0043      	lsls	r3, r0, #1
 8007728:	18e9      	adds	r1, r5, r3
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800772a:	18aa      	adds	r2, r5, r2
 800772c:	2005      	movs	r0, #5
 800772e:	f7fd fc9f 	bl	8005070 <_test_assert_time_window>
 8007732:	2800      	cmp	r0, #0
 8007734:	d1a8      	bne.n	8007688 <evt2_execute.9782+0x48>
  test_assert(6, m == 1, "single event error");
 8007736:	4649      	mov	r1, r9
 8007738:	3901      	subs	r1, #1
 800773a:	424b      	negs	r3, r1
 800773c:	4159      	adcs	r1, r3
 800773e:	2006      	movs	r0, #6
 8007740:	f7f9 fa0e 	bl	8000b60 <_test_assert>
 8007744:	2800      	cmp	r0, #0
 8007746:	d19f      	bne.n	8007688 <evt2_execute.9782+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007748:	f7fd fe9a 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
  test_assert(7, m == 0, "stuck event");
 800774c:	4241      	negs	r1, r0
 800774e:	4141      	adcs	r1, r0
 8007750:	2007      	movs	r0, #7
 8007752:	f7f9 fa05 	bl	8000b60 <_test_assert>
 8007756:	2800      	cmp	r0, #0
 8007758:	d196      	bne.n	8007688 <evt2_execute.9782+0x48>
  test_wait_threads();
 800775a:	f7fa f9e9 	bl	8001b30 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800775e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007760:	f7fc f99e 	bl	8003aa0 <_dbg_check_lock>
 8007764:	69a5      	ldr	r5, [r4, #24]
 8007766:	2005      	movs	r0, #5
 8007768:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 800776a:	4308      	orrs	r0, r1
 800776c:	63a8      	str	r0, [r5, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800776e:	f7fc f8ff 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007772:	6823      	ldr	r3, [r4, #0]
 8007774:	42a3      	cmp	r3, r4
 8007776:	d005      	beq.n	8007784 <evt2_execute.9782+0x144>
 8007778:	69a2      	ldr	r2, [r4, #24]
 800777a:	6898      	ldr	r0, [r3, #8]
 800777c:	6895      	ldr	r5, [r2, #8]
 800777e:	4285      	cmp	r5, r0
 8007780:	d200      	bcs.n	8007784 <evt2_execute.9782+0x144>
 8007782:	e0b3      	b.n	80078ec <evt2_execute.9782+0x2ac>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007784:	b662      	cpsie	i

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitAny(ALL_EVENTS);
 8007786:	f7fc fc43 	bl	8004010 <chEvtWaitAny.constprop.48>
  test_assert(8, m == 5, "unexpected pending bit");
 800778a:	1f41      	subs	r1, r0, #5
 800778c:	424b      	negs	r3, r1
 800778e:	4159      	adcs	r1, r3
 8007790:	2008      	movs	r0, #8
 8007792:	f7f9 f9e5 	bl	8000b60 <_test_assert>
 8007796:	2800      	cmp	r0, #0
 8007798:	d000      	beq.n	800779c <evt2_execute.9782+0x15c>
 800779a:	e775      	b.n	8007688 <evt2_execute.9782+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800779c:	f7fd fe70 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
  test_assert(9, m == 0, "stuck event");
 80077a0:	4241      	negs	r1, r0
 80077a2:	4141      	adcs	r1, r0
 80077a4:	2009      	movs	r0, #9
 80077a6:	f7f9 f9db 	bl	8000b60 <_test_assert>
 80077aa:	2800      	cmp	r0, #0
 80077ac:	d000      	beq.n	80077b0 <evt2_execute.9782+0x170>
 80077ae:	e76b      	b.n	8007688 <evt2_execute.9782+0x48>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 80077b0:	f7fa ffa6 	bl	8002700 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 80077b4:	f7fc fd2c 	bl	8004210 <chVTGetSystemTime.9780>
 80077b8:	69a1      	ldr	r1, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80077ba:	23a8      	movs	r3, #168	; 0xa8
 80077bc:	688a      	ldr	r2, [r1, #8]

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 80077be:	1c05      	adds	r5, r0, #0
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80077c0:	3a01      	subs	r2, #1
 80077c2:	9100      	str	r1, [sp, #0]
 80077c4:	4640      	mov	r0, r8
 80077c6:	0059      	lsls	r1, r3, #1
 80077c8:	1c33      	adds	r3, r6, #0
 80077ca:	f7fb fb41 	bl	8002e50 <chThdCreateStatic>
 80077ce:	6038      	str	r0, [r7, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80077d0:	f7fc fc1e 	bl	8004010 <chEvtWaitAny.constprop.48>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 80077d4:	22fa      	movs	r2, #250	; 0xfa
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80077d6:	4b4c      	ldr	r3, [pc, #304]	; (8007908 <evt2_execute.9782+0x2c8>)
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80077d8:	1c06      	adds	r6, r0, #0

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 80077da:	0050      	lsls	r0, r2, #1
 80077dc:	1829      	adds	r1, r5, r0
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80077de:	18ea      	adds	r2, r5, r3
 80077e0:	200a      	movs	r0, #10
 80077e2:	f7fd fc45 	bl	8005070 <_test_assert_time_window>
 80077e6:	2800      	cmp	r0, #0
 80077e8:	d000      	beq.n	80077ec <evt2_execute.9782+0x1ac>
 80077ea:	e74d      	b.n	8007688 <evt2_execute.9782+0x48>
  test_assert(11, m == 1, "single event error");
 80077ec:	1e71      	subs	r1, r6, #1
 80077ee:	424e      	negs	r6, r1
 80077f0:	4171      	adcs	r1, r6
 80077f2:	200b      	movs	r0, #11
 80077f4:	f7f9 f9b4 	bl	8000b60 <_test_assert>
 80077f8:	2800      	cmp	r0, #0
 80077fa:	d000      	beq.n	80077fe <evt2_execute.9782+0x1be>
 80077fc:	e744      	b.n	8007688 <evt2_execute.9782+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80077fe:	f7fd fe3f 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
  test_assert(12, m == 0, "stuck event");
 8007802:	4241      	negs	r1, r0
 8007804:	4141      	adcs	r1, r0
 8007806:	200c      	movs	r0, #12
 8007808:	f7f9 f9aa 	bl	8000b60 <_test_assert>
 800780c:	2800      	cmp	r0, #0
 800780e:	d000      	beq.n	8007812 <evt2_execute.9782+0x1d2>
 8007810:	e73a      	b.n	8007688 <evt2_execute.9782+0x48>
  test_wait_threads();
 8007812:	f7fa f98d 	bl	8001b30 <test_wait_threads>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8007816:	4e3d      	ldr	r6, [pc, #244]	; (800790c <evt2_execute.9782+0x2cc>)
 8007818:	4d3d      	ldr	r5, [pc, #244]	; (8007910 <evt2_execute.9782+0x2d0>)
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800781a:	1c30      	adds	r0, r6, #0
 800781c:	a902      	add	r1, sp, #8
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 800781e:	6036      	str	r6, [r6, #0]
 8007820:	602d      	str	r5, [r5, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007822:	2201      	movs	r2, #1
 8007824:	f7fd ffdc 	bl	80057e0 <chEvtRegisterMaskWithFlags.constprop.54>
 8007828:	a907      	add	r1, sp, #28
 800782a:	2204      	movs	r2, #4
 800782c:	1c28      	adds	r0, r5, #0
 800782e:	f7fd ffd7 	bl	80057e0 <chEvtRegisterMaskWithFlags.constprop.54>
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 8007832:	f7fa ff65 	bl	8002700 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007836:	f7fc fceb 	bl	8004210 <chVTGetSystemTime.9780>
 800783a:	21fa      	movs	r1, #250	; 0xfa
 800783c:	4681      	mov	r9, r0
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800783e:	69a0      	ldr	r0, [r4, #24]
 8007840:	004a      	lsls	r2, r1, #1
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007842:	4b34      	ldr	r3, [pc, #208]	; (8007914 <evt2_execute.9782+0x2d4>)
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007844:	4692      	mov	sl, r2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007846:	6882      	ldr	r2, [r0, #8]
 8007848:	21a8      	movs	r1, #168	; 0xa8
 800784a:	9300      	str	r3, [sp, #0]
 800784c:	3a01      	subs	r2, #1
 800784e:	4640      	mov	r0, r8
 8007850:	0049      	lsls	r1, r1, #1
 8007852:	4b31      	ldr	r3, [pc, #196]	; (8007918 <evt2_execute.9782+0x2d8>)
 8007854:	f7fb fafc 	bl	8002e50 <chThdCreateStatic>
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007858:	44ca      	add	sl, r9
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800785a:	6038      	str	r0, [r7, #0]
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 800785c:	69a4      	ldr	r4, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800785e:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007860:	f7fc f91e 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 8007864:	2705      	movs	r7, #5
 8007866:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8007868:	1c3a      	adds	r2, r7, #0
 800786a:	4002      	ands	r2, r0
 800786c:	2a05      	cmp	r2, #5
 800786e:	d004      	beq.n	800787a <evt2_execute.9782+0x23a>
    ctp->p_u.ewmask = events;
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8007870:	200b      	movs	r0, #11
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;

  chSysLock();
  if ((ctp->p_epending & events) != events) {
    ctp->p_u.ewmask = events;
 8007872:	6267      	str	r7, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8007874:	f7f9 fb2c 	bl	8000ed0 <chSchGoSleepS>
 8007878:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  }
  ctp->p_epending &= ~events;
 800787a:	2305      	movs	r3, #5
 800787c:	4398      	bics	r0, r3
 800787e:	63a0      	str	r0, [r4, #56]	; 0x38
  chSysUnlock();
 8007880:	f7fc f8ae 	bl	80039e0 <chSysUnlock.6142>
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 8007884:	4920      	ldr	r1, [pc, #128]	; (8007908 <evt2_execute.9782+0x2c8>)
 8007886:	200d      	movs	r0, #13
 8007888:	1c0a      	adds	r2, r1, #0
 800788a:	444a      	add	r2, r9
 800788c:	4651      	mov	r1, sl
 800788e:	f7fd fbef 	bl	8005070 <_test_assert_time_window>
 8007892:	2800      	cmp	r0, #0
 8007894:	d000      	beq.n	8007898 <evt2_execute.9782+0x258>
 8007896:	e6f7      	b.n	8007688 <evt2_execute.9782+0x48>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007898:	f7fd fdf2 	bl	8005480 <chEvtGetAndClearEvents.constprop.53>
  test_assert(14, m == 0, "stuck event");
 800789c:	4241      	negs	r1, r0
 800789e:	4141      	adcs	r1, r0
 80078a0:	200e      	movs	r0, #14
 80078a2:	f7f9 f95d 	bl	8000b60 <_test_assert>
 80078a6:	2800      	cmp	r0, #0
 80078a8:	d000      	beq.n	80078ac <evt2_execute.9782+0x26c>
 80078aa:	e6ed      	b.n	8007688 <evt2_execute.9782+0x48>
  test_wait_threads();
 80078ac:	f7fa f940 	bl	8001b30 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 80078b0:	1c30      	adds	r0, r6, #0
 80078b2:	a902      	add	r1, sp, #8
 80078b4:	f7fb fa04 	bl	8002cc0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 80078b8:	1c28      	adds	r0, r5, #0
 80078ba:	a907      	add	r1, sp, #28
 80078bc:	f7fb fa00 	bl	8002cc0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 80078c0:	6834      	ldr	r4, [r6, #0]
 80078c2:	200f      	movs	r0, #15
 80078c4:	1ba1      	subs	r1, r4, r6
 80078c6:	424e      	negs	r6, r1
 80078c8:	4171      	adcs	r1, r6
 80078ca:	f7f9 f949 	bl	8000b60 <_test_assert>
 80078ce:	2800      	cmp	r0, #0
 80078d0:	d000      	beq.n	80078d4 <evt2_execute.9782+0x294>
 80078d2:	e6d9      	b.n	8007688 <evt2_execute.9782+0x48>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 80078d4:	682e      	ldr	r6, [r5, #0]
 80078d6:	2010      	movs	r0, #16
 80078d8:	1b71      	subs	r1, r6, r5
 80078da:	424d      	negs	r5, r1
 80078dc:	4169      	adcs	r1, r5
 80078de:	f7f9 f93f 	bl	8000b60 <_test_assert>
 80078e2:	e6d1      	b.n	8007688 <evt2_execute.9782+0x48>
 80078e4:	b672      	cpsid	i
 80078e6:	4f0d      	ldr	r7, [pc, #52]	; (800791c <evt2_execute.9782+0x2dc>)
 80078e8:	62e7      	str	r7, [r4, #44]	; 0x2c
 80078ea:	e7fe      	b.n	80078ea <evt2_execute.9782+0x2aa>
 80078ec:	b672      	cpsid	i
 80078ee:	4d02      	ldr	r5, [pc, #8]	; (80078f8 <evt2_execute.9782+0x2b8>)
 80078f0:	62e5      	str	r5, [r4, #44]	; 0x2c
 80078f2:	e7fe      	b.n	80078f2 <evt2_execute.9782+0x2b2>
 80078f4:	20001040 	.word	0x20001040
 80078f8:	08008b50 	.word	0x08008b50
 80078fc:	200006b8 	.word	0x200006b8
 8007900:	08005851 	.word	0x08005851
 8007904:	200015b8 	.word	0x200015b8
 8007908:	00000226 	.word	0x00000226
 800790c:	200006b4 	.word	0x200006b4
 8007910:	200006b0 	.word	0x200006b0
 8007914:	08008698 	.word	0x08008698
 8007918:	080058b1 	.word	0x080058b1
 800791c:	08008b70 	.word	0x08008b70

08007920 <chEvtWaitAnyTimeout.constprop.45.4136>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8007920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8007922:	4c22      	ldr	r4, [pc, #136]	; (80079ac <chEvtWaitAnyTimeout.constprop.45.4136+0x8c>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8007924:	1c07      	adds	r7, r0, #0
  thread_t *ctp = currp;
 8007926:	69a5      	ldr	r5, [r4, #24]
 8007928:	b672      	cpsid	i
 800792a:	f7fc f8b9 	bl	8003aa0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800792e:	6bae      	ldr	r6, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
 8007930:	2e00      	cmp	r6, #0
 8007932:	d10b      	bne.n	800794c <chEvtWaitAnyTimeout.constprop.45.4136+0x2c>
    if (TIME_IMMEDIATE == time) {
 8007934:	2f00      	cmp	r7, #0
 8007936:	d018      	beq.n	800796a <chEvtWaitAnyTimeout.constprop.45.4136+0x4a>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8007938:	2301      	movs	r3, #1
 800793a:	4258      	negs	r0, r3
 800793c:	6268      	str	r0, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800793e:	1c39      	adds	r1, r7, #0
 8007940:	200a      	movs	r0, #10
 8007942:	f7f9 fb75 	bl	8001030 <chSchGoSleepTimeoutS>
 8007946:	2800      	cmp	r0, #0
 8007948:	db21      	blt.n	800798e <chEvtWaitAnyTimeout.constprop.45.4136+0x6e>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800794a:	6bae      	ldr	r6, [r5, #56]	; 0x38
  }
  ctp->p_epending &= ~m;
 800794c:	2100      	movs	r1, #0
 800794e:	63a9      	str	r1, [r5, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007950:	f7fc f80e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007954:	6827      	ldr	r7, [r4, #0]
 8007956:	42a7      	cmp	r7, r4
 8007958:	d004      	beq.n	8007964 <chEvtWaitAnyTimeout.constprop.45.4136+0x44>
 800795a:	69a2      	ldr	r2, [r4, #24]
 800795c:	68bb      	ldr	r3, [r7, #8]
 800795e:	6895      	ldr	r5, [r2, #8]
 8007960:	429d      	cmp	r5, r3
 8007962:	d310      	bcc.n	8007986 <chEvtWaitAnyTimeout.constprop.45.4136+0x66>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007964:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8007966:	1c30      	adds	r0, r6, #0
 8007968:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800796a:	f7fc f801 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800796e:	6823      	ldr	r3, [r4, #0]
 8007970:	42a3      	cmp	r3, r4
 8007972:	d0f7      	beq.n	8007964 <chEvtWaitAnyTimeout.constprop.45.4136+0x44>
 8007974:	69a0      	ldr	r0, [r4, #24]
 8007976:	689f      	ldr	r7, [r3, #8]
 8007978:	6881      	ldr	r1, [r0, #8]
 800797a:	42b9      	cmp	r1, r7
 800797c:	d2f2      	bcs.n	8007964 <chEvtWaitAnyTimeout.constprop.45.4136+0x44>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800797e:	b672      	cpsid	i
 8007980:	4a0b      	ldr	r2, [pc, #44]	; (80079b0 <chEvtWaitAnyTimeout.constprop.45.4136+0x90>)
 8007982:	62e2      	str	r2, [r4, #44]	; 0x2c
 8007984:	e7fe      	b.n	8007984 <chEvtWaitAnyTimeout.constprop.45.4136+0x64>
 8007986:	b672      	cpsid	i
 8007988:	4809      	ldr	r0, [pc, #36]	; (80079b0 <chEvtWaitAnyTimeout.constprop.45.4136+0x90>)
 800798a:	62e0      	str	r0, [r4, #44]	; 0x2c
 800798c:	e7fe      	b.n	800798c <chEvtWaitAnyTimeout.constprop.45.4136+0x6c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800798e:	f7fb ffef 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007992:	6821      	ldr	r1, [r4, #0]
 8007994:	42a1      	cmp	r1, r4
 8007996:	d0e5      	beq.n	8007964 <chEvtWaitAnyTimeout.constprop.45.4136+0x44>
 8007998:	69a7      	ldr	r7, [r4, #24]
 800799a:	688d      	ldr	r5, [r1, #8]
 800799c:	68ba      	ldr	r2, [r7, #8]
 800799e:	42aa      	cmp	r2, r5
 80079a0:	d2e0      	bcs.n	8007964 <chEvtWaitAnyTimeout.constprop.45.4136+0x44>
 80079a2:	b672      	cpsid	i
 80079a4:	4e02      	ldr	r6, [pc, #8]	; (80079b0 <chEvtWaitAnyTimeout.constprop.45.4136+0x90>)
 80079a6:	62e6      	str	r6, [r4, #44]	; 0x2c
 80079a8:	e7fe      	b.n	80079a8 <chEvtWaitAnyTimeout.constprop.45.4136+0x88>
 80079aa:	46c0      	nop			; (mov r8, r8)
 80079ac:	20001040 	.word	0x20001040
 80079b0:	08008b50 	.word	0x08008b50
 80079b4:	46c0      	nop			; (mov r8, r8)
 80079b6:	46c0      	nop			; (mov r8, r8)
 80079b8:	46c0      	nop			; (mov r8, r8)
 80079ba:	46c0      	nop			; (mov r8, r8)
 80079bc:	46c0      	nop			; (mov r8, r8)
 80079be:	46c0      	nop			; (mov r8, r8)

080079c0 <thd3_execute.8730>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 80079c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80079c2:	4c54      	ldr	r4, [pc, #336]	; (8007b14 <thd3_execute.8730+0x154>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80079c4:	69a3      	ldr	r3, [r4, #24]
 80079c6:	689d      	ldr	r5, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80079c8:	1c6e      	adds	r6, r5, #1
 80079ca:	1c30      	adds	r0, r6, #0
 80079cc:	f7fc fa88 	bl	8003ee0 <chThdSetPriority>
  test_assert(1, p1 == prio,
 80079d0:	1b41      	subs	r1, r0, r5

static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80079d2:	1c07      	adds	r7, r0, #0
  test_assert(1, p1 == prio,
 80079d4:	424b      	negs	r3, r1
 80079d6:	4159      	adcs	r1, r3
 80079d8:	2001      	movs	r0, #1
 80079da:	f7f9 f8c1 	bl	8000b60 <_test_assert>
 80079de:	2800      	cmp	r0, #0
 80079e0:	d000      	beq.n	80079e4 <thd3_execute.8730+0x24>
  chSysLock();
  chThdGetSelfX()->p_prio = prio;
  chThdGetSelfX()->p_realprio = prio;
  chSysUnlock();
#endif
}
 80079e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80079e4:	69a0      	ldr	r0, [r4, #24]

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
  test_assert(1, p1 == prio,
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 80079e6:	6881      	ldr	r1, [r0, #8]
 80079e8:	2002      	movs	r0, #2
 80079ea:	1a71      	subs	r1, r6, r1
 80079ec:	424b      	negs	r3, r1
 80079ee:	4159      	adcs	r1, r3
 80079f0:	f7f9 f8b6 	bl	8000b60 <_test_assert>
 80079f4:	2800      	cmp	r0, #0
 80079f6:	d1f4      	bne.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 80079f8:	1c38      	adds	r0, r7, #0
 80079fa:	f7fc fa71 	bl	8003ee0 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 80079fe:	1a31      	subs	r1, r6, r0
 8007a00:	424b      	negs	r3, r1
 8007a02:	4159      	adcs	r1, r3
 8007a04:	2003      	movs	r0, #3
 8007a06:	f7f9 f8ab 	bl	8000b60 <_test_assert>
 8007a0a:	2800      	cmp	r0, #0
 8007a0c:	d1e9      	bne.n	80079e2 <thd3_execute.8730+0x22>
 8007a0e:	69a2      	ldr	r2, [r4, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8007a10:	2004      	movs	r0, #4
 8007a12:	6893      	ldr	r3, [r2, #8]
 8007a14:	1ae9      	subs	r1, r5, r3
 8007a16:	424b      	negs	r3, r1
 8007a18:	4159      	adcs	r1, r3
 8007a1a:	f7f9 f8a1 	bl	8000b60 <_test_assert>
 8007a1e:	2800      	cmp	r0, #0
 8007a20:	d1df      	bne.n	80079e2 <thd3_execute.8730+0x22>
 8007a22:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007a24:	f7fc f83c 	bl	8003aa0 <_dbg_check_lock>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007a28:	69a7      	ldr	r7, [r4, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 8007a2a:	68b8      	ldr	r0, [r7, #8]
 8007a2c:	3002      	adds	r0, #2
 8007a2e:	60b8      	str	r0, [r7, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007a30:	f7fb ff9e 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007a34:	6821      	ldr	r1, [r4, #0]
 8007a36:	42a1      	cmp	r1, r4
 8007a38:	d004      	beq.n	8007a44 <thd3_execute.8730+0x84>
 8007a3a:	69a2      	ldr	r2, [r4, #24]
 8007a3c:	688b      	ldr	r3, [r1, #8]
 8007a3e:	6897      	ldr	r7, [r2, #8]
 8007a40:	429f      	cmp	r7, r3
 8007a42:	d35e      	bcc.n	8007b02 <thd3_execute.8730+0x142>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007a44:	b662      	cpsie	i
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007a46:	69a0      	ldr	r0, [r4, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 8007a48:	1caf      	adds	r7, r5, #2
 8007a4a:	6881      	ldr	r1, [r0, #8]
 8007a4c:	2005      	movs	r0, #5
 8007a4e:	1a79      	subs	r1, r7, r1
 8007a50:	424b      	negs	r3, r1
 8007a52:	4159      	adcs	r1, r3
 8007a54:	f7f9 f884 	bl	8000b60 <_test_assert>
 8007a58:	2800      	cmp	r0, #0
 8007a5a:	d1c2      	bne.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 8007a5c:	1c30      	adds	r0, r6, #0
 8007a5e:	f7fc fa3f 	bl	8003ee0 <chThdSetPriority>
  test_assert(6, p1 == prio,
 8007a62:	1b41      	subs	r1, r0, r5
 8007a64:	424b      	negs	r3, r1
 8007a66:	4159      	adcs	r1, r3
 8007a68:	2006      	movs	r0, #6
 8007a6a:	f7f9 f879 	bl	8000b60 <_test_assert>
 8007a6e:	2800      	cmp	r0, #0
 8007a70:	d1b7      	bne.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 8007a72:	69a2      	ldr	r2, [r4, #24]
 8007a74:	2007      	movs	r0, #7
 8007a76:	6893      	ldr	r3, [r2, #8]
 8007a78:	1af9      	subs	r1, r7, r3
 8007a7a:	424f      	negs	r7, r1
 8007a7c:	4179      	adcs	r1, r7
 8007a7e:	f7f9 f86f 	bl	8000b60 <_test_assert>
 8007a82:	2800      	cmp	r0, #0
 8007a84:	d1ad      	bne.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 8007a86:	69a7      	ldr	r7, [r4, #24]
 8007a88:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8007a8a:	1a31      	subs	r1, r6, r0
 8007a8c:	424b      	negs	r3, r1
 8007a8e:	4159      	adcs	r1, r3
 8007a90:	2008      	movs	r0, #8
 8007a92:	f7f9 f865 	bl	8000b60 <_test_assert>
 8007a96:	2800      	cmp	r0, #0
 8007a98:	d1a3      	bne.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 8007a9a:	1cef      	adds	r7, r5, #3
 8007a9c:	1c38      	adds	r0, r7, #0
 8007a9e:	f7fc fa1f 	bl	8003ee0 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 8007aa2:	1a31      	subs	r1, r6, r0
 8007aa4:	424e      	negs	r6, r1
 8007aa6:	4171      	adcs	r1, r6
 8007aa8:	2009      	movs	r0, #9
 8007aaa:	f7f9 f859 	bl	8000b60 <_test_assert>
 8007aae:	2800      	cmp	r0, #0
 8007ab0:	d197      	bne.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 8007ab2:	69a6      	ldr	r6, [r4, #24]
 8007ab4:	200a      	movs	r0, #10
 8007ab6:	68b1      	ldr	r1, [r6, #8]
 8007ab8:	1a79      	subs	r1, r7, r1
 8007aba:	424b      	negs	r3, r1
 8007abc:	4159      	adcs	r1, r3
 8007abe:	f7f9 f84f 	bl	8000b60 <_test_assert>
 8007ac2:	2800      	cmp	r0, #0
 8007ac4:	d000      	beq.n	8007ac8 <thd3_execute.8730+0x108>
 8007ac6:	e78c      	b.n	80079e2 <thd3_execute.8730+0x22>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 8007ac8:	69a2      	ldr	r2, [r4, #24]
 8007aca:	200b      	movs	r0, #11
 8007acc:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8007ace:	1af9      	subs	r1, r7, r3
 8007ad0:	424f      	negs	r7, r1
 8007ad2:	4179      	adcs	r1, r7
 8007ad4:	f7f9 f844 	bl	8000b60 <_test_assert>
 8007ad8:	2800      	cmp	r0, #0
 8007ada:	d000      	beq.n	8007ade <thd3_execute.8730+0x11e>
 8007adc:	e781      	b.n	80079e2 <thd3_execute.8730+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007ade:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007ae0:	f7fb ffde 	bl	8003aa0 <_dbg_check_lock>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007ae4:	69a0      	ldr	r0, [r4, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 8007ae6:	6085      	str	r5, [r0, #8]
  chThdGetSelfX()->p_realprio = prio;
 8007ae8:	6405      	str	r5, [r0, #64]	; 0x40
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007aea:	f7fb ff41 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007aee:	6825      	ldr	r5, [r4, #0]
 8007af0:	42a5      	cmp	r5, r4
 8007af2:	d004      	beq.n	8007afe <thd3_execute.8730+0x13e>
 8007af4:	69a7      	ldr	r7, [r4, #24]
 8007af6:	68a9      	ldr	r1, [r5, #8]
 8007af8:	68be      	ldr	r6, [r7, #8]
 8007afa:	428e      	cmp	r6, r1
 8007afc:	d305      	bcc.n	8007b0a <thd3_execute.8730+0x14a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007afe:	b662      	cpsie	i
 8007b00:	e76f      	b.n	80079e2 <thd3_execute.8730+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007b02:	b672      	cpsid	i
 8007b04:	4b04      	ldr	r3, [pc, #16]	; (8007b18 <thd3_execute.8730+0x158>)
 8007b06:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007b08:	e7fe      	b.n	8007b08 <thd3_execute.8730+0x148>
 8007b0a:	b672      	cpsid	i
 8007b0c:	4a02      	ldr	r2, [pc, #8]	; (8007b18 <thd3_execute.8730+0x158>)
 8007b0e:	62e2      	str	r2, [r4, #44]	; 0x2c
 8007b10:	e7fe      	b.n	8007b10 <thd3_execute.8730+0x150>
 8007b12:	46c0      	nop			; (mov r8, r8)
 8007b14:	20001040 	.word	0x20001040
 8007b18:	08008b60 	.word	0x08008b60
 8007b1c:	46c0      	nop			; (mov r8, r8)
 8007b1e:	46c0      	nop			; (mov r8, r8)

08007b20 <chEvtWaitAllTimeout.constprop.44.4148>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8007b20:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8007b22:	4c23      	ldr	r4, [pc, #140]	; (8007bb0 <chEvtWaitAllTimeout.constprop.44.4148+0x90>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8007b24:	1c06      	adds	r6, r0, #0
  thread_t *ctp = currp;
 8007b26:	69a5      	ldr	r5, [r4, #24]
 8007b28:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007b2a:	f7fb ffb9 	bl	8003aa0 <_dbg_check_lock>

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 8007b2e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8007b30:	3301      	adds	r3, #1
 8007b32:	d00a      	beq.n	8007b4a <chEvtWaitAllTimeout.constprop.44.4148+0x2a>
    if (TIME_IMMEDIATE == time) {
 8007b34:	2e00      	cmp	r6, #0
 8007b36:	d018      	beq.n	8007b6a <chEvtWaitAllTimeout.constprop.44.4148+0x4a>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8007b38:	2001      	movs	r0, #1
 8007b3a:	4241      	negs	r1, r0
 8007b3c:	6269      	str	r1, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8007b3e:	200b      	movs	r0, #11
 8007b40:	1c31      	adds	r1, r6, #0
 8007b42:	f7f9 fa75 	bl	8001030 <chSchGoSleepTimeoutS>
 8007b46:	2800      	cmp	r0, #0
 8007b48:	db24      	blt.n	8007b94 <chEvtWaitAllTimeout.constprop.44.4148+0x74>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 8007b4a:	2200      	movs	r2, #0
 8007b4c:	63aa      	str	r2, [r5, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007b4e:	f7fb ff0f 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007b52:	6826      	ldr	r6, [r4, #0]
 8007b54:	42a6      	cmp	r6, r4
 8007b56:	d004      	beq.n	8007b62 <chEvtWaitAllTimeout.constprop.44.4148+0x42>
 8007b58:	69a5      	ldr	r5, [r4, #24]
 8007b5a:	68b3      	ldr	r3, [r6, #8]
 8007b5c:	68a8      	ldr	r0, [r5, #8]
 8007b5e:	4298      	cmp	r0, r3
 8007b60:	d310      	bcc.n	8007b84 <chEvtWaitAllTimeout.constprop.44.4148+0x64>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007b62:	b662      	cpsie	i
  chSysUnlock();

  return events;
 8007b64:	2401      	movs	r4, #1
 8007b66:	4260      	negs	r0, r4
}
 8007b68:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007b6a:	f7fb ff01 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007b6e:	6821      	ldr	r1, [r4, #0]
 8007b70:	42a1      	cmp	r1, r4
 8007b72:	d004      	beq.n	8007b7e <chEvtWaitAllTimeout.constprop.44.4148+0x5e>
 8007b74:	69a6      	ldr	r6, [r4, #24]
 8007b76:	688d      	ldr	r5, [r1, #8]
 8007b78:	68b2      	ldr	r2, [r6, #8]
 8007b7a:	42aa      	cmp	r2, r5
 8007b7c:	d306      	bcc.n	8007b8c <chEvtWaitAllTimeout.constprop.44.4148+0x6c>
 8007b7e:	b662      	cpsie	i
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8007b80:	2000      	movs	r0, #0
 8007b82:	e7f1      	b.n	8007b68 <chEvtWaitAllTimeout.constprop.44.4148+0x48>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007b84:	b672      	cpsid	i
 8007b86:	490b      	ldr	r1, [pc, #44]	; (8007bb4 <chEvtWaitAllTimeout.constprop.44.4148+0x94>)
 8007b88:	62e1      	str	r1, [r4, #44]	; 0x2c
 8007b8a:	e7fe      	b.n	8007b8a <chEvtWaitAllTimeout.constprop.44.4148+0x6a>
 8007b8c:	b672      	cpsid	i
 8007b8e:	4809      	ldr	r0, [pc, #36]	; (8007bb4 <chEvtWaitAllTimeout.constprop.44.4148+0x94>)
 8007b90:	62e0      	str	r0, [r4, #44]	; 0x2c
 8007b92:	e7fe      	b.n	8007b92 <chEvtWaitAllTimeout.constprop.44.4148+0x72>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007b94:	f7fb feec 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007b98:	6826      	ldr	r6, [r4, #0]
 8007b9a:	42a6      	cmp	r6, r4
 8007b9c:	d0ef      	beq.n	8007b7e <chEvtWaitAllTimeout.constprop.44.4148+0x5e>
 8007b9e:	69a2      	ldr	r2, [r4, #24]
 8007ba0:	68b0      	ldr	r0, [r6, #8]
 8007ba2:	6895      	ldr	r5, [r2, #8]
 8007ba4:	4285      	cmp	r5, r0
 8007ba6:	d2ea      	bcs.n	8007b7e <chEvtWaitAllTimeout.constprop.44.4148+0x5e>
 8007ba8:	b672      	cpsid	i
 8007baa:	4b02      	ldr	r3, [pc, #8]	; (8007bb4 <chEvtWaitAllTimeout.constprop.44.4148+0x94>)
 8007bac:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007bae:	e7fe      	b.n	8007bae <chEvtWaitAllTimeout.constprop.44.4148+0x8e>
 8007bb0:	20001040 	.word	0x20001040
 8007bb4:	08008b50 	.word	0x08008b50
 8007bb8:	46c0      	nop			; (mov r8, r8)
 8007bba:	46c0      	nop			; (mov r8, r8)
 8007bbc:	46c0      	nop			; (mov r8, r8)
 8007bbe:	46c0      	nop			; (mov r8, r8)

08007bc0 <chEvtWaitOneTimeout.constprop.46.4153>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8007bc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8007bc2:	4c24      	ldr	r4, [pc, #144]	; (8007c54 <chEvtWaitOneTimeout.constprop.46.4153+0x94>)
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8007bc4:	1c07      	adds	r7, r0, #0
  thread_t *ctp = currp;
 8007bc6:	69a6      	ldr	r6, [r4, #24]
 8007bc8:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007bca:	f7fb ff69 	bl	8003aa0 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8007bce:	6bb5      	ldr	r5, [r6, #56]	; 0x38
  if (m == (eventmask_t)0) {
 8007bd0:	2d00      	cmp	r5, #0
 8007bd2:	d10b      	bne.n	8007bec <chEvtWaitOneTimeout.constprop.46.4153+0x2c>
    if (TIME_IMMEDIATE == time) {
 8007bd4:	2f00      	cmp	r7, #0
 8007bd6:	d01b      	beq.n	8007c10 <chEvtWaitOneTimeout.constprop.46.4153+0x50>
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8007bd8:	2301      	movs	r3, #1
 8007bda:	4258      	negs	r0, r3
 8007bdc:	6270      	str	r0, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8007bde:	1c39      	adds	r1, r7, #0
 8007be0:	200a      	movs	r0, #10
 8007be2:	f7f9 fa25 	bl	8001030 <chSchGoSleepTimeoutS>
 8007be6:	2800      	cmp	r0, #0
 8007be8:	db26      	blt.n	8007c38 <chEvtWaitOneTimeout.constprop.46.4153+0x78>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 8007bea:	6bb5      	ldr	r5, [r6, #56]	; 0x38
  }
  m ^= m & (m - (eventmask_t)1);
 8007bec:	426f      	negs	r7, r5
 8007bee:	402f      	ands	r7, r5
  ctp->p_epending &= ~m;
 8007bf0:	43bd      	bics	r5, r7
 8007bf2:	63b5      	str	r5, [r6, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007bf4:	f7fb febc 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007bf8:	6821      	ldr	r1, [r4, #0]
 8007bfa:	42a1      	cmp	r1, r4
 8007bfc:	d004      	beq.n	8007c08 <chEvtWaitOneTimeout.constprop.46.4153+0x48>
 8007bfe:	69a2      	ldr	r2, [r4, #24]
 8007c00:	688e      	ldr	r6, [r1, #8]
 8007c02:	6895      	ldr	r5, [r2, #8]
 8007c04:	42b5      	cmp	r5, r6
 8007c06:	d30f      	bcc.n	8007c28 <chEvtWaitOneTimeout.constprop.46.4153+0x68>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007c08:	b662      	cpsie	i
  chSysUnlock();

  return m;
 8007c0a:	1c3d      	adds	r5, r7, #0
}
 8007c0c:	1c28      	adds	r0, r5, #0
 8007c0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007c10:	f7fb feae 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007c14:	6823      	ldr	r3, [r4, #0]
 8007c16:	42a3      	cmp	r3, r4
 8007c18:	d004      	beq.n	8007c24 <chEvtWaitOneTimeout.constprop.46.4153+0x64>
 8007c1a:	69a0      	ldr	r0, [r4, #24]
 8007c1c:	6899      	ldr	r1, [r3, #8]
 8007c1e:	6887      	ldr	r7, [r0, #8]
 8007c20:	428f      	cmp	r7, r1
 8007c22:	d305      	bcc.n	8007c30 <chEvtWaitOneTimeout.constprop.46.4153+0x70>
 8007c24:	b662      	cpsie	i
 8007c26:	e7f1      	b.n	8007c0c <chEvtWaitOneTimeout.constprop.46.4153+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007c28:	b672      	cpsid	i
 8007c2a:	4b0b      	ldr	r3, [pc, #44]	; (8007c58 <chEvtWaitOneTimeout.constprop.46.4153+0x98>)
 8007c2c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8007c2e:	e7fe      	b.n	8007c2e <chEvtWaitOneTimeout.constprop.46.4153+0x6e>
 8007c30:	b672      	cpsid	i
 8007c32:	4d09      	ldr	r5, [pc, #36]	; (8007c58 <chEvtWaitOneTimeout.constprop.46.4153+0x98>)
 8007c34:	62e5      	str	r5, [r4, #44]	; 0x2c
 8007c36:	e7fe      	b.n	8007c36 <chEvtWaitOneTimeout.constprop.46.4153+0x76>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007c38:	f7fb fe9a 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007c3c:	6820      	ldr	r0, [r4, #0]
 8007c3e:	42a0      	cmp	r0, r4
 8007c40:	d0f0      	beq.n	8007c24 <chEvtWaitOneTimeout.constprop.46.4153+0x64>
 8007c42:	69a7      	ldr	r7, [r4, #24]
 8007c44:	6882      	ldr	r2, [r0, #8]
 8007c46:	68b9      	ldr	r1, [r7, #8]
 8007c48:	4291      	cmp	r1, r2
 8007c4a:	d2eb      	bcs.n	8007c24 <chEvtWaitOneTimeout.constprop.46.4153+0x64>
 8007c4c:	b672      	cpsid	i
 8007c4e:	4e02      	ldr	r6, [pc, #8]	; (8007c58 <chEvtWaitOneTimeout.constprop.46.4153+0x98>)
 8007c50:	62e6      	str	r6, [r4, #44]	; 0x2c
 8007c52:	e7fe      	b.n	8007c52 <chEvtWaitOneTimeout.constprop.46.4153+0x92>
 8007c54:	20001040 	.word	0x20001040
 8007c58:	08008b50 	.word	0x08008b50
 8007c5c:	46c0      	nop			; (mov r8, r8)
 8007c5e:	46c0      	nop			; (mov r8, r8)

08007c60 <evt3_execute.9800>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8007c60:	b508      	push	{r3, lr}
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007c62:	2000      	movs	r0, #0
 8007c64:	f7ff ffac 	bl	8007bc0 <chEvtWaitOneTimeout.constprop.46.4153>
  test_assert(1, m == 0, "spurious event");
 8007c68:	4241      	negs	r1, r0
 8007c6a:	4141      	adcs	r1, r0
 8007c6c:	2001      	movs	r0, #1
 8007c6e:	f7f8 ff77 	bl	8000b60 <_test_assert>
 8007c72:	2800      	cmp	r0, #0
 8007c74:	d000      	beq.n	8007c78 <evt3_execute.9800+0x18>
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
}
 8007c76:	bd08      	pop	{r3, pc}
  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007c78:	f7ff fe52 	bl	8007920 <chEvtWaitAnyTimeout.constprop.45.4136>
  test_assert(2, m == 0, "spurious event");
 8007c7c:	4241      	negs	r1, r0
 8007c7e:	4141      	adcs	r1, r0
 8007c80:	2002      	movs	r0, #2
 8007c82:	f7f8 ff6d 	bl	8000b60 <_test_assert>
 8007c86:	2800      	cmp	r0, #0
 8007c88:	d1f5      	bne.n	8007c76 <evt3_execute.9800+0x16>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007c8a:	f7ff ff49 	bl	8007b20 <chEvtWaitAllTimeout.constprop.44.4148>
  test_assert(3, m == 0, "spurious event");
 8007c8e:	4241      	negs	r1, r0
 8007c90:	4141      	adcs	r1, r0
 8007c92:	2003      	movs	r0, #3
 8007c94:	f7f8 ff64 	bl	8000b60 <_test_assert>
 8007c98:	2800      	cmp	r0, #0
 8007c9a:	d1ec      	bne.n	8007c76 <evt3_execute.9800+0x16>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 8007c9c:	200a      	movs	r0, #10
 8007c9e:	f7ff ff8f 	bl	8007bc0 <chEvtWaitOneTimeout.constprop.46.4153>
  test_assert(4, m == 0, "spurious event");
 8007ca2:	4241      	negs	r1, r0
 8007ca4:	4141      	adcs	r1, r0
 8007ca6:	2004      	movs	r0, #4
 8007ca8:	f7f8 ff5a 	bl	8000b60 <_test_assert>
 8007cac:	2800      	cmp	r0, #0
 8007cae:	d1e2      	bne.n	8007c76 <evt3_execute.9800+0x16>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 8007cb0:	200a      	movs	r0, #10
 8007cb2:	f7ff fe35 	bl	8007920 <chEvtWaitAnyTimeout.constprop.45.4136>
  test_assert(5, m == 0, "spurious event");
 8007cb6:	4241      	negs	r1, r0
 8007cb8:	4141      	adcs	r1, r0
 8007cba:	2005      	movs	r0, #5
 8007cbc:	f7f8 ff50 	bl	8000b60 <_test_assert>
 8007cc0:	2800      	cmp	r0, #0
 8007cc2:	d1d8      	bne.n	8007c76 <evt3_execute.9800+0x16>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 8007cc4:	200a      	movs	r0, #10
 8007cc6:	f7ff ff2b 	bl	8007b20 <chEvtWaitAllTimeout.constprop.44.4148>
  test_assert(6, m == 0, "spurious event");
 8007cca:	4241      	negs	r1, r0
 8007ccc:	4141      	adcs	r1, r0
 8007cce:	2006      	movs	r0, #6
 8007cd0:	f7f8 ff46 	bl	8000b60 <_test_assert>
 8007cd4:	e7cf      	b.n	8007c76 <evt3_execute.9800+0x16>
 8007cd6:	46c0      	nop			; (mov r8, r8)
 8007cd8:	46c0      	nop			; (mov r8, r8)
 8007cda:	46c0      	nop			; (mov r8, r8)
 8007cdc:	46c0      	nop			; (mov r8, r8)
 8007cde:	46c0      	nop			; (mov r8, r8)

08007ce0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8007ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8007ce2:	4bce      	ldr	r3, [pc, #824]	; (800801c <main+0x33c>)
 8007ce4:	465f      	mov	r7, fp
 8007ce6:	4656      	mov	r6, sl
 8007ce8:	464d      	mov	r5, r9
 8007cea:	4644      	mov	r4, r8
 8007cec:	2101      	movs	r1, #1
 8007cee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8007cf0:	b4f0      	push	{r4, r5, r6, r7}
 8007cf2:	2200      	movs	r2, #0
 8007cf4:	424c      	negs	r4, r1
 8007cf6:	629c      	str	r4, [r3, #40]	; 0x28
 8007cf8:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8007cfa:	6918      	ldr	r0, [r3, #16]
 8007cfc:	611c      	str	r4, [r3, #16]
 8007cfe:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8007d00:	68dd      	ldr	r5, [r3, #12]
 8007d02:	48c7      	ldr	r0, [pc, #796]	; (8008020 <main+0x340>)

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8007d04:	2780      	movs	r7, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8007d06:	4305      	orrs	r5, r0
 8007d08:	60dd      	str	r5, [r3, #12]
 8007d0a:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8007d0c:	69de      	ldr	r6, [r3, #28]
 8007d0e:	0579      	lsls	r1, r7, #21
 8007d10:	4331      	orrs	r1, r6
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8007d12:	4dc4      	ldr	r5, [pc, #784]	; (8008024 <main+0x344>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8007d14:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8007d16:	682c      	ldr	r4, [r5, #0]
 8007d18:	2080      	movs	r0, #128	; 0x80
 8007d1a:	0046      	lsls	r6, r0, #1
 8007d1c:	4326      	orrs	r6, r4
 8007d1e:	602e      	str	r6, [r5, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8007d20:	6a1f      	ldr	r7, [r3, #32]
 8007d22:	21c0      	movs	r1, #192	; 0xc0
 8007d24:	008d      	lsls	r5, r1, #2
 8007d26:	2480      	movs	r4, #128	; 0x80
 8007d28:	b087      	sub	sp, #28
 8007d2a:	402f      	ands	r7, r5
 8007d2c:	00a0      	lsls	r0, r4, #2
 8007d2e:	4287      	cmp	r7, r0
 8007d30:	d003      	beq.n	8007d3a <main+0x5a>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007d32:	2680      	movs	r6, #128	; 0x80
 8007d34:	0277      	lsls	r7, r6, #9
 8007d36:	621f      	str	r7, [r3, #32]
    RCC->BDCR = 0;
 8007d38:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8007d3a:	4bb8      	ldr	r3, [pc, #736]	; (800801c <main+0x33c>)
 8007d3c:	2280      	movs	r2, #128	; 0x80
 8007d3e:	6a19      	ldr	r1, [r3, #32]
 8007d40:	0215      	lsls	r5, r2, #8
 8007d42:	4229      	tst	r1, r5
 8007d44:	d107      	bne.n	8007d56 <main+0x76>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8007d46:	6a1c      	ldr	r4, [r3, #32]
 8007d48:	2080      	movs	r0, #128	; 0x80
 8007d4a:	0086      	lsls	r6, r0, #2
 8007d4c:	4326      	orrs	r6, r4
 8007d4e:	621e      	str	r6, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8007d50:	6a1f      	ldr	r7, [r3, #32]
 8007d52:	433d      	orrs	r5, r7
 8007d54:	621d      	str	r5, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8007d56:	4eb1      	ldr	r6, [pc, #708]	; (800801c <main+0x33c>)
 8007d58:	23fc      	movs	r3, #252	; 0xfc
 8007d5a:	6971      	ldr	r1, [r6, #20]
 8007d5c:	03da      	lsls	r2, r3, #15
 8007d5e:	430a      	orrs	r2, r1
 8007d60:	6172      	str	r2, [r6, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007d62:	2590      	movs	r5, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8007d64:	4ab0      	ldr	r2, [pc, #704]	; (8008028 <main+0x348>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007d66:	20fc      	movs	r0, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
 8007d68:	49b0      	ldr	r1, [pc, #704]	; (800802c <main+0x34c>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007d6a:	23a0      	movs	r3, #160	; 0xa0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007d6c:	05ec      	lsls	r4, r5, #23
  gpiop->OSPEEDR = config->ospeedr;
 8007d6e:	0607      	lsls	r7, r0, #24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007d70:	2500      	movs	r5, #0
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007d72:	0598      	lsls	r0, r3, #22
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007d74:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8007d76:	4bae      	ldr	r3, [pc, #696]	; (8008030 <main+0x350>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007d78:	60a7      	str	r7, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007d7a:	60e1      	str	r1, [r4, #12]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007d7c:	27fc      	movs	r7, #252	; 0xfc
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8007d7e:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8007d80:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8007d82:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007d84:	6020      	str	r0, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007d86:	4cab      	ldr	r4, [pc, #684]	; (8008034 <main+0x354>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007d88:	20a8      	movs	r0, #168	; 0xa8
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007d8a:	00b9      	lsls	r1, r7, #2
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007d8c:	0607      	lsls	r7, r0, #24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007d8e:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8007d90:	48a9      	ldr	r0, [pc, #676]	; (8008038 <main+0x358>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007d92:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007d94:	60e3      	str	r3, [r4, #12]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007d96:	49a9      	ldr	r1, [pc, #676]	; (800803c <main+0x35c>)
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8007d98:	6162      	str	r2, [r4, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8007d9a:	4ba9      	ldr	r3, [pc, #676]	; (8008040 <main+0x360>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8007d9c:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8007d9e:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007da0:	6027      	str	r7, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007da2:	4ca8      	ldr	r4, [pc, #672]	; (8008044 <main+0x364>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007da4:	4fa8      	ldr	r7, [pc, #672]	; (8008048 <main+0x368>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007da6:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007da8:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007daa:	60e3      	str	r3, [r4, #12]
 8007dac:	49a7      	ldr	r1, [pc, #668]	; (800804c <main+0x36c>)
  gpiop->ODR     = config->odr;
 8007dae:	6160      	str	r0, [r4, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007db0:	4ba7      	ldr	r3, [pc, #668]	; (8008050 <main+0x370>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8007db2:	6225      	str	r5, [r4, #32]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007db4:	48a7      	ldr	r0, [pc, #668]	; (8008054 <main+0x374>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8007db6:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007db8:	6027      	str	r7, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007dba:	4ca7      	ldr	r4, [pc, #668]	; (8008058 <main+0x378>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8007dbc:	4fa7      	ldr	r7, [pc, #668]	; (800805c <main+0x37c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007dbe:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007dc0:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007dc2:	60e1      	str	r1, [r4, #12]
  gpiop->ODR     = config->odr;
 8007dc4:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8007dc6:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8007dc8:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007dca:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007dcc:	605d      	str	r5, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007dce:	609d      	str	r5, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8007dd0:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8007dd2:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8007dd4:	621d      	str	r5, [r3, #32]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8007dd6:	4ca2      	ldr	r4, [pc, #648]	; (8008060 <main+0x380>)
  gpiop->AFRH    = config->afrh;
 8007dd8:	625d      	str	r5, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007dda:	601d      	str	r5, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007ddc:	6045      	str	r5, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007dde:	6085      	str	r5, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8007de0:	60c7      	str	r7, [r0, #12]
  gpiop->ODR     = config->odr;
 8007de2:	6142      	str	r2, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8007de4:	6205      	str	r5, [r0, #32]
 8007de6:	4a9f      	ldr	r2, [pc, #636]	; (8008064 <main+0x384>)
  gpiop->AFRH    = config->afrh;
 8007de8:	6245      	str	r5, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007dea:	6005      	str	r5, [r0, #0]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8007dec:	489c      	ldr	r0, [pc, #624]	; (8008060 <main+0x380>)
 8007dee:	c404      	stmia	r4!, {r2}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8007df0:	1c03      	adds	r3, r0, #0
 8007df2:	6044      	str	r4, [r0, #4]
 8007df4:	330c      	adds	r3, #12
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8007df6:	1c07      	adds	r7, r0, #0
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8007df8:	1c04      	adds	r4, r0, #0
 8007dfa:	1c02      	adds	r2, r0, #0
 8007dfc:	3464      	adds	r4, #100	; 0x64
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8007dfe:	3754      	adds	r7, #84	; 0x54
 8007e00:	60c3      	str	r3, [r0, #12]
  tqp->p_prev = (thread_t *)tqp;
 8007e02:	6103      	str	r3, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8007e04:	3230      	adds	r2, #48	; 0x30
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8007e06:	2310      	movs	r3, #16
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8007e08:	6145      	str	r5, [r0, #20]
  iqp->q_buffer  = bp;
 8007e0a:	6187      	str	r7, [r0, #24]
  iqp->q_rdptr   = bp;
 8007e0c:	6247      	str	r7, [r0, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8007e0e:	6207      	str	r7, [r0, #32]
  iqp->q_top     = bp + size;
 8007e10:	61c4      	str	r4, [r0, #28]
 8007e12:	6302      	str	r2, [r0, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8007e14:	6342      	str	r2, [r0, #52]	; 0x34
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8007e16:	6383      	str	r3, [r0, #56]	; 0x38
  oqp->q_buffer  = bp;
 8007e18:	63c4      	str	r4, [r0, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8007e1a:	6484      	str	r4, [r0, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8007e1c:	6444      	str	r4, [r0, #68]	; 0x44
  oqp->q_top     = bp + size;
 8007e1e:	1c07      	adds	r7, r0, #0
  oqp->q_notify  = onfy;
 8007e20:	4c91      	ldr	r4, [pc, #580]	; (8008068 <main+0x388>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8007e22:	4a92      	ldr	r2, [pc, #584]	; (800806c <main+0x38c>)
  SD1.clock = STM32_USART1CLK;
 8007e24:	4b92      	ldr	r3, [pc, #584]	; (8008070 <main+0x390>)
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8007e26:	2101      	movs	r1, #1
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8007e28:	3774      	adds	r7, #116	; 0x74
 8007e2a:	7201      	strb	r1, [r0, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8007e2c:	6285      	str	r5, [r0, #40]	; 0x28
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8007e2e:	6407      	str	r7, [r0, #64]	; 0x40
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8007e30:	62c0      	str	r0, [r0, #44]	; 0x2c
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8007e32:	64c4      	str	r4, [r0, #76]	; 0x4c
 8007e34:	6783      	str	r3, [r0, #120]	; 0x78
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8007e36:	6742      	str	r2, [r0, #116]	; 0x74
  oqp->q_link    = link;
 8007e38:	6500      	str	r0, [r0, #80]	; 0x50
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8007e3a:	4b8e      	ldr	r3, [pc, #568]	; (8008074 <main+0x394>)
 8007e3c:	20c6      	movs	r0, #198	; 0xc6
 8007e3e:	0087      	lsls	r7, r0, #2
 8007e40:	59dc      	ldr	r4, [r3, r7]
 8007e42:	20c0      	movs	r0, #192	; 0xc0
 8007e44:	0222      	lsls	r2, r4, #8
 8007e46:	0a14      	lsrs	r4, r2, #8
 8007e48:	0602      	lsls	r2, r0, #24
 8007e4a:	4322      	orrs	r2, r4
 8007e4c:	51da      	str	r2, [r3, r7]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007e4e:	2080      	movs	r0, #128	; 0x80
 8007e50:	27c0      	movs	r7, #192	; 0xc0
 8007e52:	007c      	lsls	r4, r7, #1
 8007e54:	0502      	lsls	r2, r0, #20
 8007e56:	511a      	str	r2, [r3, r4]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007e58:	601a      	str	r2, [r3, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8007e5a:	69f7      	ldr	r7, [r6, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8007e5c:	4a86      	ldr	r2, [pc, #536]	; (8008078 <main+0x398>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8007e5e:	430f      	orrs	r7, r1
 8007e60:	61f7      	str	r7, [r6, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8007e62:	6890      	ldr	r0, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8007e64:	2780      	movs	r7, #128	; 0x80

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8007e66:	4308      	orrs	r0, r1
 8007e68:	6090      	str	r0, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8007e6a:	4884      	ldr	r0, [pc, #528]	; (800807c <main+0x39c>)
 8007e6c:	05fa      	lsls	r2, r7, #23
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8007e6e:	2701      	movs	r7, #1

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8007e70:	6290      	str	r0, [r2, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8007e72:	4278      	negs	r0, r7
 8007e74:	62d0      	str	r0, [r2, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8007e76:	6195      	str	r5, [r2, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8007e78:	6355      	str	r5, [r2, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8007e7a:	60d5      	str	r5, [r2, #12]
  STM32_ST_TIM->CR2    = 0;
 8007e7c:	6055      	str	r5, [r2, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8007e7e:	6151      	str	r1, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8007e80:	6011      	str	r1, [r2, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8007e82:	22c3      	movs	r2, #195	; 0xc3
 8007e84:	0097      	lsls	r7, r2, #2
 8007e86:	59da      	ldr	r2, [r3, r7]
 8007e88:	46b9      	mov	r9, r7
 8007e8a:	0217      	lsls	r7, r2, #8
 8007e8c:	0a3a      	lsrs	r2, r7, #8
 8007e8e:	4690      	mov	r8, r2
 8007e90:	2780      	movs	r7, #128	; 0x80
 8007e92:	063f      	lsls	r7, r7, #24
 8007e94:	4642      	mov	r2, r8
 8007e96:	433a      	orrs	r2, r7
 8007e98:	464f      	mov	r7, r9
 8007e9a:	51da      	str	r2, [r3, r7]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007e9c:	2280      	movs	r2, #128	; 0x80
 8007e9e:	0217      	lsls	r7, r2, #8
 8007ea0:	511f      	str	r7, [r3, r4]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007ea2:	601f      	str	r7, [r3, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007ea4:	4b76      	ldr	r3, [pc, #472]	; (8008080 <main+0x3a0>)
 8007ea6:	4a77      	ldr	r2, [pc, #476]	; (8008084 <main+0x3a4>)
 8007ea8:	6a1c      	ldr	r4, [r3, #32]
 8007eaa:	4022      	ands	r2, r4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8007eac:	4c76      	ldr	r4, [pc, #472]	; (8008088 <main+0x3a8>)
 8007eae:	621a      	str	r2, [r3, #32]
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8007eb0:	6260      	str	r0, [r4, #36]	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8007eb2:	4876      	ldr	r0, [pc, #472]	; (800808c <main+0x3ac>)
 8007eb4:	2307      	movs	r3, #7
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8007eb6:	1c27      	adds	r7, r4, #0
 8007eb8:	4a75      	ldr	r2, [pc, #468]	; (8008090 <main+0x3b0>)
 8007eba:	3007      	adds	r0, #7
 8007ebc:	371c      	adds	r7, #28
 8007ebe:	4398      	bics	r0, r3
 8007ec0:	61e7      	str	r7, [r4, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8007ec2:	6227      	str	r7, [r4, #32]
 8007ec4:	6024      	str	r4, [r4, #0]
  tqp->p_prev = (thread_t *)tqp;
 8007ec6:	6064      	str	r4, [r4, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8007ec8:	60a5      	str	r5, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8007eca:	62a5      	str	r5, [r4, #40]	; 0x28
 8007ecc:	6010      	str	r0, [r2, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8007ece:	4f71      	ldr	r7, [pc, #452]	; (8008094 <main+0x3b4>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8007ed0:	4871      	ldr	r0, [pc, #452]	; (8008098 <main+0x3b8>)
 8007ed2:	439f      	bics	r7, r3
 8007ed4:	4b71      	ldr	r3, [pc, #452]	; (800809c <main+0x3bc>)
 8007ed6:	4a72      	ldr	r2, [pc, #456]	; (80080a0 <main+0x3c0>)
 8007ed8:	601f      	str	r7, [r3, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8007eda:	1c07      	adds	r7, r0, #0
 8007edc:	3710      	adds	r7, #16
 8007ede:	6002      	str	r2, [r0, #0]
  default_heap.h_free.h.u.next = NULL;
 8007ee0:	6085      	str	r5, [r0, #8]
  default_heap.h_free.h.size = 0;
 8007ee2:	60c5      	str	r5, [r0, #12]
 8007ee4:	6107      	str	r7, [r0, #16]
  tqp->p_prev = (thread_t *)tqp;
 8007ee6:	6147      	str	r7, [r0, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8007ee8:	6185      	str	r5, [r0, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8007eea:	2289      	movs	r2, #137	; 0x89
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8007eec:	1c20      	adds	r0, r4, #0
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8007eee:	2340      	movs	r3, #64	; 0x40
 8007ef0:	00d7      	lsls	r7, r2, #3
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8007ef2:	3040      	adds	r0, #64	; 0x40
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8007ef4:	2290      	movs	r2, #144	; 0x90
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8007ef6:	51e3      	str	r3, [r4, r7]
 8007ef8:	63e0      	str	r0, [r4, #60]	; 0x3c
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8007efa:	00d7      	lsls	r7, r2, #3
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8007efc:	4869      	ldr	r0, [pc, #420]	; (80080a4 <main+0x3c4>)
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8007efe:	51e3      	str	r3, [r4, r7]
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8007f00:	63a3      	str	r3, [r4, #56]	; 0x38
  tp->p_mtxlist = NULL;
 8007f02:	4b69      	ldr	r3, [pc, #420]	; (80080a8 <main+0x3c8>)
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8007f04:	5425      	strb	r5, [r4, r0]
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8007f06:	208f      	movs	r0, #143	; 0x8f
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8007f08:	50e5      	str	r5, [r4, r3]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8007f0a:	00c2      	lsls	r2, r0, #3
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8007f0c:	4f67      	ldr	r7, [pc, #412]	; (80080ac <main+0x3cc>)
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8007f0e:	238b      	movs	r3, #139	; 0x8b
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8007f10:	50a5      	str	r5, [r4, r2]
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8007f12:	00d8      	lsls	r0, r3, #3
  REG_INSERT(tp);
 8007f14:	228a      	movs	r2, #138	; 0x8a
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8007f16:	55e1      	strb	r1, [r4, r7]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8007f18:	5025      	str	r5, [r4, r0]
  REG_INSERT(tp);
 8007f1a:	00d7      	lsls	r7, r2, #3
 8007f1c:	4b64      	ldr	r3, [pc, #400]	; (80080b0 <main+0x3d0>)
 8007f1e:	2088      	movs	r0, #136	; 0x88
 8007f20:	51e4      	str	r4, [r4, r7]
 8007f22:	00c2      	lsls	r2, r0, #3
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8007f24:	278d      	movs	r7, #141	; 0x8d
 8007f26:	50e4      	str	r4, [r4, r3]
 8007f28:	00f8      	lsls	r0, r7, #3
 8007f2a:	18a3      	adds	r3, r4, r2
 8007f2c:	228d      	movs	r2, #141	; 0x8d
 8007f2e:	1827      	adds	r7, r4, r0
 8007f30:	00d0      	lsls	r0, r2, #3
 8007f32:	5027      	str	r7, [r4, r0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8007f34:	4f5f      	ldr	r7, [pc, #380]	; (80080b4 <main+0x3d4>)
 8007f36:	6123      	str	r3, [r4, #16]
 8007f38:	19e2      	adds	r2, r4, r7
 8007f3a:	51e2      	str	r2, [r4, r7]
  tqp->p_prev = (thread_t *)tqp;
 8007f3c:	278e      	movs	r7, #142	; 0x8e
 8007f3e:	00f8      	lsls	r0, r7, #3
 8007f40:	6163      	str	r3, [r4, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8007f42:	61a3      	str	r3, [r4, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8007f44:	238c      	movs	r3, #140	; 0x8c
 8007f46:	5022      	str	r2, [r4, r0]
 8007f48:	00da      	lsls	r2, r3, #3
 8007f4a:	54a1      	strb	r1, [r4, r2]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8007f4c:	4f5a      	ldr	r7, [pc, #360]	; (80080b8 <main+0x3d8>)
 8007f4e:	495b      	ldr	r1, [pc, #364]	; (80080bc <main+0x3dc>)
 8007f50:	51e1      	str	r1, [r4, r7]
 *
 * @special
 */
static inline void chSysEnable(void) {

  _dbg_check_enable();
 8007f52:	f7f8 fb1d 	bl	8000590 <_dbg_check_enable>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007f56:	b662      	cpsie	i
 8007f58:	4b59      	ldr	r3, [pc, #356]	; (80080c0 <main+0x3e0>)
 8007f5a:	69a0      	ldr	r0, [r4, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8007f5c:	2291      	movs	r2, #145	; 0x91
 8007f5e:	00d1      	lsls	r1, r2, #3
 8007f60:	6183      	str	r3, [r0, #24]
 8007f62:	2201      	movs	r2, #1
 8007f64:	1860      	adds	r0, r4, r1
 8007f66:	9500      	str	r5, [sp, #0]
 8007f68:	21e0      	movs	r1, #224	; 0xe0
 8007f6a:	4b56      	ldr	r3, [pc, #344]	; (80080c4 <main+0x3e4>)
 8007f6c:	f7fa ff70 	bl	8002e50 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8007f70:	4d55      	ldr	r5, [pc, #340]	; (80080c8 <main+0x3e8>)
 8007f72:	6185      	str	r5, [r0, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007f74:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007f76:	f7fb fd93 	bl	8003aa0 <_dbg_check_lock>
void sdStart(SerialDriver *sdp, const SerialConfig *config) {

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8007f7a:	4f39      	ldr	r7, [pc, #228]	; (8008060 <main+0x380>)
 8007f7c:	7a38      	ldrb	r0, [r7, #8]
 8007f7e:	1e43      	subs	r3, r0, #1
 8007f80:	2b01      	cmp	r3, #1
 8007f82:	d903      	bls.n	8007f8c <main+0x2ac>
 8007f84:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8007f86:	4f51      	ldr	r7, [pc, #324]	; (80080cc <main+0x3ec>)
 8007f88:	62e7      	str	r7, [r4, #44]	; 0x2c
 8007f8a:	e7fe      	b.n	8007f8a <main+0x2aa>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8007f8c:	2801      	cmp	r0, #1
 8007f8e:	d104      	bne.n	8007f9a <main+0x2ba>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 8007f90:	69b2      	ldr	r2, [r6, #24]
 8007f92:	2180      	movs	r1, #128	; 0x80
 8007f94:	01cd      	lsls	r5, r1, #7
 8007f96:	4315      	orrs	r5, r2
 8007f98:	61b5      	str	r5, [r6, #24]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8007f9a:	4e31      	ldr	r6, [pc, #196]	; (8008060 <main+0x380>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8007f9c:	2396      	movs	r3, #150	; 0x96
 8007f9e:	6fb0      	ldr	r0, [r6, #120]	; 0x78
 8007fa0:	0219      	lsls	r1, r3, #8
 8007fa2:	9003      	str	r0, [sp, #12]
 8007fa4:	f7f8 f93c 	bl	8000220 <__aeabi_uidiv>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8007fa8:	6f77      	ldr	r7, [r6, #116]	; 0x74
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8007faa:	4949      	ldr	r1, [pc, #292]	; (80080d0 <main+0x3f0>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8007fac:	60f8      	str	r0, [r7, #12]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8007fae:	2501      	movs	r5, #1
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8007fb0:	4848      	ldr	r0, [pc, #288]	; (80080d4 <main+0x3f4>)
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007fb2:	2201      	movs	r2, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8007fb4:	426b      	negs	r3, r5
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8007fb6:	6078      	str	r0, [r7, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007fb8:	60ba      	str	r2, [r7, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8007fba:	6039      	str	r1, [r7, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8007fbc:	623b      	str	r3, [r7, #32]
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8007fbe:	2702      	movs	r7, #2
 8007fc0:	7237      	strb	r7, [r6, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007fc2:	f7fb fcd5 	bl	8003970 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8007fc6:	6826      	ldr	r6, [r4, #0]
 8007fc8:	42a6      	cmp	r6, r4
 8007fca:	d005      	beq.n	8007fd8 <main+0x2f8>
 8007fcc:	69a0      	ldr	r0, [r4, #24]
 8007fce:	68b1      	ldr	r1, [r6, #8]
 8007fd0:	6882      	ldr	r2, [r0, #8]
 8007fd2:	428a      	cmp	r2, r1
 8007fd4:	d200      	bcs.n	8007fd8 <main+0x2f8>
 8007fd6:	e1d9      	b.n	800838c <main+0x6ac>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007fd8:	b662      	cpsie	i
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8007fda:	2480      	movs	r4, #128	; 0x80
 8007fdc:	00a0      	lsls	r0, r4, #2
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 8007fde:	2580      	movs	r5, #128	; 0x80
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8007fe0:	f7f8 fd06 	bl	80009f0 <_pal_lld_setgroupmode.constprop.18>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 8007fe4:	00e8      	lsls	r0, r5, #3
 8007fe6:	f7f8 fd03 	bl	80009f0 <_pal_lld_setgroupmode.constprop.18>

  /*
   * Creates the blinker threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8007fea:	2700      	movs	r7, #0
 8007fec:	23a8      	movs	r3, #168	; 0xa8
 8007fee:	0059      	lsls	r1, r3, #1
 8007ff0:	2240      	movs	r2, #64	; 0x40
 8007ff2:	4b39      	ldr	r3, [pc, #228]	; (80080d8 <main+0x3f8>)
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
 8007ff4:	26a8      	movs	r6, #168	; 0xa8
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */

  /*
   * Creates the blinker threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8007ff6:	9700      	str	r7, [sp, #0]
 8007ff8:	4838      	ldr	r0, [pc, #224]	; (80080dc <main+0x3fc>)
 8007ffa:	f7fa ff29 	bl	8002e50 <chThdCreateStatic>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
 8007ffe:	0071      	lsls	r1, r6, #1
 8008000:	2240      	movs	r2, #64	; 0x40
 8008002:	9700      	str	r7, [sp, #0]
 8008004:	4836      	ldr	r0, [pc, #216]	; (80080e0 <main+0x400>)
 8008006:	4b37      	ldr	r3, [pc, #220]	; (80080e4 <main+0x404>)
 8008008:	f7fa ff22 	bl	8002e50 <chThdCreateStatic>
 800800c:	4836      	ldr	r0, [pc, #216]	; (80080e8 <main+0x408>)
 800800e:	4a37      	ldr	r2, [pc, #220]	; (80080ec <main+0x40c>)
 8008010:	4c37      	ldr	r4, [pc, #220]	; (80080f0 <main+0x410>)
 8008012:	4e38      	ldr	r6, [pc, #224]	; (80080f4 <main+0x414>)
 8008014:	4682      	mov	sl, r0
 8008016:	4693      	mov	fp, r2
 8008018:	e071      	b.n	80080fe <main+0x41e>
 800801a:	46c0      	nop			; (mov r8, r8)
 800801c:	40021000 	.word	0x40021000
 8008020:	ffbfffff 	.word	0xffbfffff
 8008024:	40007000 	.word	0x40007000
 8008028:	0000ffff 	.word	0x0000ffff
 800802c:	64155554 	.word	0x64155554
 8008030:	01555555 	.word	0x01555555
 8008034:	48000400 	.word	0x48000400
 8008038:	0000fc3f 	.word	0x0000fc3f
 800803c:	f00ff003 	.word	0xf00ff003
 8008040:	05500554 	.word	0x05500554
 8008044:	48000800 	.word	0x48000800
 8008048:	00055001 	.word	0x00055001
 800804c:	55555555 	.word	0x55555555
 8008050:	48001000 	.word	0x48001000
 8008054:	48001400 	.word	0x48001400
 8008058:	48000c00 	.word	0x48000c00
 800805c:	55555550 	.word	0x55555550
 8008060:	20000fc0 	.word	0x20000fc0
 8008064:	08008be0 	.word	0x08008be0
 8008068:	080004f1 	.word	0x080004f1
 800806c:	40013800 	.word	0x40013800
 8008070:	02dc6c00 	.word	0x02dc6c00
 8008074:	e000e100 	.word	0xe000e100
 8008078:	40015800 	.word	0x40015800
 800807c:	000012bf 	.word	0x000012bf
 8008080:	e000ed00 	.word	0xe000ed00
 8008084:	ff00ffff 	.word	0xff00ffff
 8008088:	20001040 	.word	0x20001040
 800808c:	20001720 	.word	0x20001720
 8008090:	20000fac 	.word	0x20000fac
 8008094:	20004000 	.word	0x20004000
 8008098:	20000f88 	.word	0x20000f88
 800809c:	20000fa8 	.word	0x20000fa8
 80080a0:	08004141 	.word	0x08004141
 80080a4:	00000461 	.word	0x00000461
 80080a8:	0000047c 	.word	0x0000047c
 80080ac:	00000462 	.word	0x00000462
 80080b0:	00000454 	.word	0x00000454
 80080b4:	0000046c 	.word	0x0000046c
 80080b8:	0000045c 	.word	0x0000045c
 80080bc:	20000400 	.word	0x20000400
 80080c0:	08008c00 	.word	0x08008c00
 80080c4:	08000511 	.word	0x08000511
 80080c8:	08008fe0 	.word	0x08008fe0
 80080cc:	08008e90 	.word	0x08008e90
 80080d0:	0000012d 	.word	0x0000012d
 80080d4:	00004040 	.word	0x00004040
 80080d8:	08002781 	.word	0x08002781
 80080dc:	200015d0 	.word	0x200015d0
 80080e0:	20000e30 	.word	0x20000e30
 80080e4:	08002741 	.word	0x08002741
 80080e8:	200015b8 	.word	0x200015b8
 80080ec:	20000fb4 	.word	0x20000fb4
 80080f0:	20000fbc 	.word	0x20000fbc
 80080f4:	20000fb8 	.word	0x20000fb8
   * driver 1.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
      TestThread(&SD1);
    chThdSleepMilliseconds(500);
 80080f8:	48a6      	ldr	r0, [pc, #664]	; (8008394 <main+0x6b4>)
 80080fa:	f7fa fad9 	bl	80026b0 <chThdSleep>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched with output on the serial
   * driver 1.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
 80080fe:	2190      	movs	r1, #144	; 0x90
 8008100:	05cd      	lsls	r5, r1, #23
 8008102:	692f      	ldr	r7, [r5, #16]
 8008104:	2301      	movs	r3, #1
 8008106:	423b      	tst	r3, r7
 8008108:	d0f6      	beq.n	80080f8 <main+0x418>
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 800810a:	48a3      	ldr	r0, [pc, #652]	; (8008398 <main+0x6b8>)
 800810c:	6020      	str	r0, [r4, #0]
  test_println("");
 800810e:	48a3      	ldr	r0, [pc, #652]	; (800839c <main+0x6bc>)
 8008110:	f7f8 fd3e 	bl	8000b90 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8008114:	48a2      	ldr	r0, [pc, #648]	; (80083a0 <main+0x6c0>)
 8008116:	f7f8 fd3b 	bl	8000b90 <test_println>
  test_println("***");
 800811a:	48a2      	ldr	r0, [pc, #648]	; (80083a4 <main+0x6c4>)
 800811c:	f7f8 fd38 	bl	8000b90 <test_println>
 8008120:	4da1      	ldr	r5, [pc, #644]	; (80083a8 <main+0x6c8>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008122:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8008124:	6820      	ldr	r0, [r4, #0]
 8008126:	3501      	adds	r5, #1
 8008128:	6802      	ldr	r2, [r0, #0]
 800812a:	6897      	ldr	r7, [r2, #8]
 800812c:	47b8      	blx	r7
}

/*
 * Application entry point.
 */
int main(void) {
 800812e:	1e69      	subs	r1, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008130:	7809      	ldrb	r1, [r1, #0]
 8008132:	2900      	cmp	r1, #0
 8008134:	d1f6      	bne.n	8008124 <main+0x444>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 8008136:	489d      	ldr	r0, [pc, #628]	; (80083ac <main+0x6cc>)
 8008138:	f7f8 fd2a 	bl	8000b90 <test_println>
 800813c:	4d9c      	ldr	r5, [pc, #624]	; (80083b0 <main+0x6d0>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800813e:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8008140:	6820      	ldr	r0, [r4, #0]
 8008142:	3501      	adds	r5, #1
 8008144:	6803      	ldr	r3, [r0, #0]
 8008146:	689a      	ldr	r2, [r3, #8]
 8008148:	4790      	blx	r2
 800814a:	1e68      	subs	r0, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800814c:	7801      	ldrb	r1, [r0, #0]
 800814e:	2900      	cmp	r1, #0
 8008150:	d1f6      	bne.n	8008140 <main+0x460>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8008152:	4898      	ldr	r0, [pc, #608]	; (80083b4 <main+0x6d4>)
 8008154:	f7f8 fd1c 	bl	8000b90 <test_println>
 8008158:	4f97      	ldr	r7, [pc, #604]	; (80083b8 <main+0x6d8>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800815a:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 800815c:	6820      	ldr	r0, [r4, #0]
 800815e:	3701      	adds	r7, #1
 8008160:	6805      	ldr	r5, [r0, #0]
 8008162:	68ab      	ldr	r3, [r5, #8]
 8008164:	4798      	blx	r3
 8008166:	1e79      	subs	r1, r7, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008168:	7809      	ldrb	r1, [r1, #0]
 800816a:	2900      	cmp	r1, #0
 800816c:	d1f6      	bne.n	800815c <main+0x47c>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 800816e:	4893      	ldr	r0, [pc, #588]	; (80083bc <main+0x6dc>)
 8008170:	f7f8 fd0e 	bl	8000b90 <test_println>
 8008174:	4f92      	ldr	r7, [pc, #584]	; (80083c0 <main+0x6e0>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008176:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8008178:	6820      	ldr	r0, [r4, #0]
 800817a:	3701      	adds	r7, #1
 800817c:	6802      	ldr	r2, [r0, #0]
 800817e:	6895      	ldr	r5, [r2, #8]
 8008180:	47a8      	blx	r5
 8008182:	1e78      	subs	r0, r7, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008184:	7801      	ldrb	r1, [r0, #0]
 8008186:	2900      	cmp	r1, #0
 8008188:	d1f6      	bne.n	8008178 <main+0x498>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 800818a:	488e      	ldr	r0, [pc, #568]	; (80083c4 <main+0x6e4>)
 800818c:	f7f8 fd00 	bl	8000b90 <test_println>
 8008190:	4f8d      	ldr	r7, [pc, #564]	; (80083c8 <main+0x6e8>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008192:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8008194:	6820      	ldr	r0, [r4, #0]
 8008196:	3701      	adds	r7, #1
 8008198:	6803      	ldr	r3, [r0, #0]
 800819a:	689a      	ldr	r2, [r3, #8]
 800819c:	4790      	blx	r2
 800819e:	1e79      	subs	r1, r7, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081a0:	7809      	ldrb	r1, [r1, #0]
 80081a2:	2900      	cmp	r1, #0
 80081a4:	d1f6      	bne.n	8008194 <main+0x4b4>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 80081a6:	4889      	ldr	r0, [pc, #548]	; (80083cc <main+0x6ec>)
 80081a8:	f7f8 fcf2 	bl	8000b90 <test_println>
 80081ac:	4d88      	ldr	r5, [pc, #544]	; (80083d0 <main+0x6f0>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081ae:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 80081b0:	6820      	ldr	r0, [r4, #0]
 80081b2:	3501      	adds	r5, #1
 80081b4:	6807      	ldr	r7, [r0, #0]
 80081b6:	68bb      	ldr	r3, [r7, #8]
 80081b8:	4798      	blx	r3
 80081ba:	1e68      	subs	r0, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081bc:	7801      	ldrb	r1, [r0, #0]
 80081be:	2900      	cmp	r1, #0
 80081c0:	d1f6      	bne.n	80081b0 <main+0x4d0>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 80081c2:	4884      	ldr	r0, [pc, #528]	; (80083d4 <main+0x6f4>)
 80081c4:	f7f8 fce4 	bl	8000b90 <test_println>
 80081c8:	4d83      	ldr	r5, [pc, #524]	; (80083d8 <main+0x6f8>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081ca:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 80081cc:	6820      	ldr	r0, [r4, #0]
 80081ce:	3501      	adds	r5, #1
 80081d0:	6802      	ldr	r2, [r0, #0]
 80081d2:	6897      	ldr	r7, [r2, #8]
 80081d4:	47b8      	blx	r7
 80081d6:	1e69      	subs	r1, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081d8:	7809      	ldrb	r1, [r1, #0]
 80081da:	2900      	cmp	r1, #0
 80081dc:	d1f6      	bne.n	80081cc <main+0x4ec>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 80081de:	487f      	ldr	r0, [pc, #508]	; (80083dc <main+0x6fc>)
 80081e0:	f7f8 fcd6 	bl	8000b90 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081e4:	232a      	movs	r3, #42	; 0x2a
 80081e6:	4f7e      	ldr	r7, [pc, #504]	; (80083e0 <main+0x700>)
 80081e8:	1c19      	adds	r1, r3, #0
    chSequentialStreamPut(chp, *msgp++);
 80081ea:	6820      	ldr	r0, [r4, #0]
 80081ec:	3701      	adds	r7, #1
 80081ee:	6805      	ldr	r5, [r0, #0]
 80081f0:	68aa      	ldr	r2, [r5, #8]
 80081f2:	4790      	blx	r2
 80081f4:	1e78      	subs	r0, r7, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80081f6:	7801      	ldrb	r1, [r0, #0]
 80081f8:	2900      	cmp	r1, #0
 80081fa:	d1f6      	bne.n	80081ea <main+0x50a>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 80081fc:	4879      	ldr	r0, [pc, #484]	; (80083e4 <main+0x704>)
 80081fe:	1c0d      	adds	r5, r1, #0
 8008200:	f7f8 fcc6 	bl	8000b90 <test_println>
#endif
  test_println("");
 8008204:	4865      	ldr	r0, [pc, #404]	; (800839c <main+0x6bc>)
 8008206:	f7f8 fcc3 	bl	8000b90 <test_println>
 800820a:	4f77      	ldr	r7, [pc, #476]	; (80083e8 <main+0x708>)

  test_global_fail = FALSE;
 800820c:	4977      	ldr	r1, [pc, #476]	; (80083ec <main+0x70c>)
 800820e:	3704      	adds	r7, #4
 8008210:	9705      	str	r7, [sp, #20]
 8008212:	4b77      	ldr	r3, [pc, #476]	; (80083f0 <main+0x710>)
  i = 0;
 8008214:	2700      	movs	r7, #0
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
#endif
  test_println("");

  test_global_fail = FALSE;
 8008216:	700d      	strb	r5, [r1, #0]
  i = 0;
 8008218:	9704      	str	r7, [sp, #16]
 800821a:	9a04      	ldr	r2, [sp, #16]
 800821c:	4698      	mov	r8, r3
 800821e:	3201      	adds	r2, #1
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8008220:	2300      	movs	r3, #0
 8008222:	9204      	str	r2, [sp, #16]
 8008224:	4699      	mov	r9, r3

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8008226:	4640      	mov	r0, r8
 8008228:	6805      	ldr	r5, [r0, #0]
 800822a:	2d00      	cmp	r5, #0
 800822c:	d100      	bne.n	8008230 <main+0x550>
 800822e:	e087      	b.n	8008340 <main+0x660>
      print_line();
 8008230:	f7f8 fdae 	bl	8000d90 <print_line.8460>
 8008234:	4d6f      	ldr	r5, [pc, #444]	; (80083f4 <main+0x714>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008236:	212d      	movs	r1, #45	; 0x2d
    chSequentialStreamPut(chp, *msgp++);
 8008238:	6820      	ldr	r0, [r4, #0]
 800823a:	3501      	adds	r5, #1
 800823c:	6802      	ldr	r2, [r0, #0]
 800823e:	6893      	ldr	r3, [r2, #8]
 8008240:	4798      	blx	r3
 8008242:	1e68      	subs	r0, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008244:	7801      	ldrb	r1, [r0, #0]
 8008246:	2900      	cmp	r1, #0
 8008248:	d1f6      	bne.n	8008238 <main+0x558>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 800824a:	9804      	ldr	r0, [sp, #16]
 800824c:	f7f8 fcd8 	bl	8000c00 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8008250:	6820      	ldr	r0, [r4, #0]
 8008252:	6801      	ldr	r1, [r0, #0]
 8008254:	688d      	ldr	r5, [r1, #8]
 8008256:	212e      	movs	r1, #46	; 0x2e
 8008258:	47a8      	blx	r5
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 800825a:	2201      	movs	r2, #1
 800825c:	4491      	add	r9, r2
 800825e:	4648      	mov	r0, r9
 8008260:	f7f8 fcce 	bl	8000c00 <test_printn>
 8008264:	4d64      	ldr	r5, [pc, #400]	; (80083f8 <main+0x718>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008266:	2120      	movs	r1, #32
    chSequentialStreamPut(chp, *msgp++);
 8008268:	6820      	ldr	r0, [r4, #0]
 800826a:	3501      	adds	r5, #1
 800826c:	6803      	ldr	r3, [r0, #0]
 800826e:	689a      	ldr	r2, [r3, #8]
 8008270:	4790      	blx	r2
 8008272:	1e68      	subs	r0, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008274:	7801      	ldrb	r1, [r0, #0]
 8008276:	2900      	cmp	r1, #0
 8008278:	d1f6      	bne.n	8008268 <main+0x588>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 800827a:	4641      	mov	r1, r8
 800827c:	680d      	ldr	r5, [r1, #0]
 800827e:	682d      	ldr	r5, [r5, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008280:	7829      	ldrb	r1, [r5, #0]
 8008282:	2900      	cmp	r1, #0
 8008284:	d007      	beq.n	8008296 <main+0x5b6>
    chSequentialStreamPut(chp, *msgp++);
 8008286:	6820      	ldr	r0, [r4, #0]
 8008288:	3501      	adds	r5, #1
 800828a:	6803      	ldr	r3, [r0, #0]
 800828c:	689a      	ldr	r2, [r3, #8]
 800828e:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008290:	7829      	ldrb	r1, [r5, #0]
 8008292:	2900      	cmp	r1, #0
 8008294:	d1f7      	bne.n	8008286 <main+0x5a6>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8008296:	4859      	ldr	r0, [pc, #356]	; (80083fc <main+0x71c>)
 8008298:	f7f8 fc7a 	bl	8000b90 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 800829c:	20fa      	movs	r0, #250	; 0xfa
 800829e:	00c0      	lsls	r0, r0, #3
 80082a0:	f7fa fa06 	bl	80026b0 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 80082a4:	4641      	mov	r1, r8
 80082a6:	3104      	adds	r1, #4
 80082a8:	4688      	mov	r8, r1
 80082aa:	3904      	subs	r1, #4
 80082ac:	c920      	ldmia	r1!, {r5}

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 80082ae:	4650      	mov	r0, sl
 80082b0:	6007      	str	r7, [r0, #0]
 80082b2:	6047      	str	r7, [r0, #4]
 80082b4:	6087      	str	r7, [r0, #8]
 80082b6:	60c7      	str	r7, [r0, #12]
 80082b8:	6107      	str	r7, [r0, #16]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 80082ba:	4b51      	ldr	r3, [pc, #324]	; (8008400 <main+0x720>)
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 80082bc:	4a51      	ldr	r2, [pc, #324]	; (8008404 <main+0x724>)
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 80082be:	6869      	ldr	r1, [r5, #4]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 80082c0:	6033      	str	r3, [r6, #0]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 80082c2:	7017      	strb	r7, [r2, #0]
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 80082c4:	2900      	cmp	r1, #0
 80082c6:	d000      	beq.n	80082ca <main+0x5ea>
    tcp->setup();
 80082c8:	4788      	blx	r1
  tcp->execute();
 80082ca:	68eb      	ldr	r3, [r5, #12]
 80082cc:	4798      	blx	r3
  if (tcp->teardown != NULL)
 80082ce:	68ad      	ldr	r5, [r5, #8]
 80082d0:	2d00      	cmp	r5, #0
 80082d2:	d000      	beq.n	80082d6 <main+0x5f6>
    tcp->teardown();
 80082d4:	47a8      	blx	r5

  test_wait_threads();
 80082d6:	f7f9 fc2b 	bl	8001b30 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 80082da:	4a4a      	ldr	r2, [pc, #296]	; (8008404 <main+0x724>)
 80082dc:	7810      	ldrb	r0, [r2, #0]
 80082de:	2800      	cmp	r0, #0
 80082e0:	d04c      	beq.n	800837c <main+0x69c>
 80082e2:	4d49      	ldr	r5, [pc, #292]	; (8008408 <main+0x728>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80082e4:	212d      	movs	r1, #45	; 0x2d
    chSequentialStreamPut(chp, *msgp++);
 80082e6:	6820      	ldr	r0, [r4, #0]
 80082e8:	3501      	adds	r5, #1
 80082ea:	6803      	ldr	r3, [r0, #0]
 80082ec:	689a      	ldr	r2, [r3, #8]
 80082ee:	4790      	blx	r2
 80082f0:	1e69      	subs	r1, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80082f2:	7809      	ldrb	r1, [r1, #0]
 80082f4:	2900      	cmp	r1, #0
 80082f6:	d1f6      	bne.n	80082e6 <main+0x606>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 80082f8:	4658      	mov	r0, fp
 80082fa:	6800      	ldr	r0, [r0, #0]
 80082fc:	f7f8 fc80 	bl	8000c00 <test_printn>
 8008300:	4d42      	ldr	r5, [pc, #264]	; (800840c <main+0x72c>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008302:	2120      	movs	r1, #32
    chSequentialStreamPut(chp, *msgp++);
 8008304:	6820      	ldr	r0, [r4, #0]
 8008306:	3501      	adds	r5, #1
 8008308:	6803      	ldr	r3, [r0, #0]
 800830a:	689a      	ldr	r2, [r3, #8]
 800830c:	4790      	blx	r2
 800830e:	1e69      	subs	r1, r5, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008310:	7809      	ldrb	r1, [r1, #0]
 8008312:	2900      	cmp	r1, #0
 8008314:	d1f6      	bne.n	8008304 <main+0x624>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8008316:	6830      	ldr	r0, [r6, #0]
 8008318:	4d39      	ldr	r5, [pc, #228]	; (8008400 <main+0x720>)
 800831a:	42a8      	cmp	r0, r5
 800831c:	d908      	bls.n	8008330 <main+0x650>
    chSequentialStreamPut(chp, *cp++);
 800831e:	6820      	ldr	r0, [r4, #0]
 8008320:	7829      	ldrb	r1, [r5, #0]
 8008322:	6803      	ldr	r3, [r0, #0]
 8008324:	3501      	adds	r5, #1
 8008326:	689a      	ldr	r2, [r3, #8]
 8008328:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800832a:	6831      	ldr	r1, [r6, #0]
 800832c:	428d      	cmp	r5, r1
 800832e:	d3f6      	bcc.n	800831e <main+0x63e>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8008330:	4837      	ldr	r0, [pc, #220]	; (8008410 <main+0x730>)
 8008332:	f7f8 fc2d 	bl	8000b90 <test_println>

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8008336:	4640      	mov	r0, r8
 8008338:	6805      	ldr	r5, [r0, #0]
 800833a:	2d00      	cmp	r5, #0
 800833c:	d000      	beq.n	8008340 <main+0x660>
 800833e:	e777      	b.n	8008230 <main+0x550>
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8008340:	9905      	ldr	r1, [sp, #20]
 8008342:	c908      	ldmia	r1!, {r3}
 8008344:	9105      	str	r1, [sp, #20]
 8008346:	2b00      	cmp	r3, #0
 8008348:	d000      	beq.n	800834c <main+0x66c>
 800834a:	e766      	b.n	800821a <main+0x53a>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800834c:	f7f8 fd20 	bl	8000d90 <print_line.8460>
  test_println("");
 8008350:	4812      	ldr	r0, [pc, #72]	; (800839c <main+0x6bc>)
 8008352:	f7f8 fc1d 	bl	8000b90 <test_println>
 8008356:	4f2f      	ldr	r7, [pc, #188]	; (8008414 <main+0x734>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008358:	2146      	movs	r1, #70	; 0x46
    chSequentialStreamPut(chp, *msgp++);
 800835a:	6820      	ldr	r0, [r4, #0]
 800835c:	3701      	adds	r7, #1
 800835e:	6802      	ldr	r2, [r0, #0]
 8008360:	6895      	ldr	r5, [r2, #8]
 8008362:	47a8      	blx	r5
 8008364:	1e78      	subs	r0, r7, #1
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8008366:	7801      	ldrb	r1, [r0, #0]
 8008368:	2900      	cmp	r1, #0
 800836a:	d1f6      	bne.n	800835a <main+0x67a>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 800836c:	491f      	ldr	r1, [pc, #124]	; (80083ec <main+0x70c>)
 800836e:	780b      	ldrb	r3, [r1, #0]
 8008370:	2b00      	cmp	r3, #0
 8008372:	d107      	bne.n	8008384 <main+0x6a4>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8008374:	4828      	ldr	r0, [pc, #160]	; (8008418 <main+0x738>)
 8008376:	f7f8 fc0b 	bl	8000b90 <test_println>
 800837a:	e6bd      	b.n	80080f8 <main+0x418>
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 800837c:	4827      	ldr	r0, [pc, #156]	; (800841c <main+0x73c>)
 800837e:	f7f8 fc07 	bl	8000b90 <test_println>
 8008382:	e750      	b.n	8008226 <main+0x546>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8008384:	4826      	ldr	r0, [pc, #152]	; (8008420 <main+0x740>)
 8008386:	f7f8 fc03 	bl	8000b90 <test_println>
 800838a:	e6b5      	b.n	80080f8 <main+0x418>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800838c:	b672      	cpsid	i
 800838e:	4e25      	ldr	r6, [pc, #148]	; (8008424 <main+0x744>)
 8008390:	62e6      	str	r6, [r4, #44]	; 0x2c
 8008392:	e7fe      	b.n	8008392 <main+0x6b2>
 8008394:	00001388 	.word	0x00001388
 8008398:	20000fc0 	.word	0x20000fc0
 800839c:	08008670 	.word	0x08008670
 80083a0:	08008fe8 	.word	0x08008fe8
 80083a4:	08009004 	.word	0x08009004
 80083a8:	08009009 	.word	0x08009009
 80083ac:	08009068 	.word	0x08009068
 80083b0:	08009071 	.word	0x08009071
 80083b4:	08009084 	.word	0x08009084
 80083b8:	0800909d 	.word	0x0800909d
 80083bc:	080090b0 	.word	0x080090b0
 80083c0:	080090f9 	.word	0x080090f9
 80083c4:	0800910c 	.word	0x0800910c
 80083c8:	08009115 	.word	0x08009115
 80083cc:	08009128 	.word	0x08009128
 80083d0:	08009135 	.word	0x08009135
 80083d4:	08009148 	.word	0x08009148
 80083d8:	08009161 	.word	0x08009161
 80083dc:	08009174 	.word	0x08009174
 80083e0:	080091a5 	.word	0x080091a5
 80083e4:	080091b8 	.word	0x080091b8
 80083e8:	08008c90 	.word	0x08008c90
 80083ec:	20000fb0 	.word	0x20000fb0
 80083f0:	08008e10 	.word	0x08008e10
 80083f4:	0800901d 	.word	0x0800901d
 80083f8:	080091d1 	.word	0x080091d1
 80083fc:	0800902c 	.word	0x0800902c
 8008400:	200015a8 	.word	0x200015a8
 8008404:	20000f80 	.word	0x20000f80
 8008408:	08009031 	.word	0x08009031
 800840c:	080091d5 	.word	0x080091d5
 8008410:	08009048 	.word	0x08009048
 8008414:	080091d9 	.word	0x080091d9
 8008418:	08009058 	.word	0x08009058
 800841c:	0800904c 	.word	0x0800904c
 8008420:	08009060 	.word	0x08009060
 8008424:	08008e20 	.word	0x08008e20
 8008428:	46c0      	nop			; (mov r8, r8)
 800842a:	46c0      	nop			; (mov r8, r8)
 800842c:	46c0      	nop			; (mov r8, r8)
 800842e:	46c0      	nop			; (mov r8, r8)

08008430 <__func__.5770.7160.4544>:
 8008430:	6863 6f50 6c6f 7246 6565 0049 0000 0000     chPoolFreeI.....

08008440 <__func__.5749.4850.4543>:
 8008440:	6863 6353 5268 6165 7964 0049 0000 0000     chSchReadyI.....

08008450 <__func__.6261.7347.4541>:
 8008450:	7473 7453 7261 4174 616c 6d72 0000 0000     stStartAlarm....

08008460 <__func__.5752.4588.4540>:
 8008460:	6863 5456 6f44 6553 4974 0000 0000 0000     chVTDoSetI......
 8008470:	5653 3223 0000 0000 5653 3323 0000 0000     SV#2....SV#3....
 8008480:	5653 3623 0000 0000 5653 3723 0000 0000     SV#6....SV#7....
 8008490:	5653 3823 0000 0000 5653 3923 0000 0000     SV#8....SV#9....
 80084a0:	5653 3123 0030 0000 5653 3123 0031 0000     SV#10...SV#11...
 80084b0:	0a0d 0000 2d2d 202d 7953 7473 6d65 203a     ....--- System: 
 80084c0:	0000 0000 6220 7479 7365 0000 2d2d 202d     .... bytes..--- 
 80084d0:	6854 6572 6461 203a 0000 0000 2d2d 202d     Thread: ....--- 
 80084e0:	6954 656d 2072 203a 0000 0000 2d2d 202d     Timer : ....--- 
 80084f0:	6553 616d 6870 203a 0000 0000 2d2d 202d     Semaph: ....--- 
 8008500:	7645 6e65 5374 203a 0000 0000 2d2d 202d     EventS: ....--- 
 8008510:	7645 6e65 4c74 203a 0000 0000 2d2d 202d     EventL: ....--- 
 8008520:	754d 6574 2078 203a 0000 0000 2d2d 202d     Mutex : ....--- 
 8008530:	6f43 646e 2e56 203a 0000 0000 2d2d 202d     CondV.: ....--- 
 8008540:	7551 7565 2065 203a 0000 0000 2d2d 202d     Queue : ....--- 
 8008550:	614d 6c69 2e42 203a 0000 0000 7473 6361     MailB.: ....stac
 8008560:	206b 766f 7265 6c66 776f 0000 0000 0000     k overflow......

08008570 <__func__.5752.5823.4523>:
 8008570:	6863 744d 4c78 636f 536b 0000 0000 0000     chMtxLockS......

08008580 <__func__.5786.6219.4483>:
 8008580:	6863 7645 5374 6769 616e 496c 0000 0000     chEvtSignalI....

08008590 <__func__.6268.7348.4545>:
 8008590:	7473 6553 4174 616c 6d72 0000 0000 0000     stSetAlarm......

080085a0 <__func__.5760.4589.4538>:
 80085a0:	6863 5456 6f44 6552 6573 4974 0000 0000     chVTDoResetI....

080085b0 <__func__.5777.4851.4542>:
 80085b0:	6863 6353 5768 6b61 7565 5370 0000 0000     chSchWakeupS....

080085c0 <__func__.5805.5093.4332>:
 80085c0:	6863 6854 4564 6978 5374 0000 0000 0000     chThdExitS......

080085d0 <__func__.5046.9064>:
 80085d0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....
 80085e0:	4241 4443 0000 0000 0000 0000 0000 0000     ABCD............

080085f0 <__func__.5046.10429>:
 80085f0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008600 <__func__.5046.5651>:
 8008600:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008610 <__func__.5810.5094.4430>:
 8008610:	6863 6854 5764 6961 0074 0000 0000 0000     chThdWait.......

08008620 <__func__.5750.5442.4434>:
 8008620:	6863 6552 4e67 7865 5474 7268 6165 0064     chRegNextThread.

08008630 <__func__.5046.5441.4435>:
 8008630:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008640 <__func__.5749.5302.4436>:
 8008640:	6863 6854 5264 6c65 6165 6573 0000 0000     chThdRelease....
 8008650:	2d2d 202d 6353 726f 2065 203a 0000 0000     --- Score : ....
 8008660:	7220 7365 6863 6465 6c75 7365 532f 202c      reschedules/S, 
 8008670:	0000 0000 6320 7874 7773 2f63 0053 0000     .... ctxswc/S...
 8008680:	6d20 6773 2f73 2c53 0020 0000 7420 7268      msgs/S, ... thr
 8008690:	6165 7364 532f 0000 0041 0000 0000 0000     eads/S..A.......

080086a0 <__func__.5046.5300.4433>:
 80086a0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

080086b0 <__func__.5744.5301.4432>:
 80086b0:	6863 6854 4164 6464 6552 0066 0000 0000     chThdAddRef.....

080086c0 <__func__.5753.6218.4390>:
 80086c0:	6863 7645 5574 726e 6765 7369 6574 0072     chEvtUnregister.

080086d0 <__func__.5800.6222.4327>:
 80086d0:	6863 7645 4474 7369 6170 6374 0068 0000     chEvtDispatch...

080086e0 <__func__.5768.7113.4387>:
 80086e0:	6863 6548 7061 7246 6565 0000 0000 0000     chHeapFree......
 80086f0:	6c62 6e69 656b 3272 0000 0000 6c62 6e69     blinker2....blin
 8008700:	656b 3172 0000 0000 4241 0043 0000 0000     ker1....ABC.....

08008710 <__func__.5775.5825.4389>:
 8008710:	6863 744d 5578 6c6e 636f 006b 0000 0000     chMtxUnlock.....

08008720 <__func__.5766.5654.4379>:
 8008720:	6863 6553 576d 6961 5374 0000 0000 0000     chSemWaitS......
 8008730:	2fcc 0800 2fc0 0800 2fc0 0800 2fd4 0800     ./.../.../.../..
 8008740:	2fb6 0800 2faa 0800 2fc0 0800 2fb6 0800     ./.../.../.../..

08008750 <__func__.5776.5655.4563>:
 8008750:	6863 6553 576d 6961 5474 6d69 6f65 7475     chSemWaitTimeout
 8008760:	0053 0000 0000 0000 0000 0000 0000 0000     S...............

08008770 <__func__.5769.6221.4567>:
 8008770:	6863 7645 4274 6f72 6461 6163 7473 6c46     chEvtBroadcastFl
 8008780:	6761 4973 0000 0000 0000 0000 0000 0000     agsI............

08008790 <__func__.5786.5826.4560>:
 8008790:	6863 744d 5578 6c6e 636f 536b 0000 0000     chMtxUnlockS....

080087a0 <__func__.5135.4318.4561>:
 80087a0:	6863 5456 6f44 6954 6b63 0049 0000 0000     chVTDoTickI.....

080087b0 <ram_areas.4018.4467>:
 80087b0:	9780 0800 1720 2000 1720 2000 1720 2000     .... ..  ..  .. 
 80087c0:	9780 0800 0000 0000 0000 0000 0000 0000     ................
 80087d0:	9780 0800 0000 0000 0000 0000 0000 0000     ................
 80087e0:	9780 0800 0000 0000 0000 0000 0000 0000     ................
 80087f0:	9780 0800 0000 0000 0000 0000 0000 0000     ................
 8008800:	9780 0800 0000 0000 0000 0000 0000 0000     ................
 8008810:	9780 0800 0000 0000 0000 0000 0000 0000     ................
 8008820:	9780 0800 0000 0000 0000 0000 0000 0000     ................

08008830 <__func__.5761.5091.4562>:
 8008830:	6863 6854 4364 6572 7461 4965 0000 0000     chThdCreateI....
 8008840:	5653 3123 0000 0000 0000 0000 0000 0000     SV#1............

08008850 <__func__.5807.6595.4558>:
 8008850:	6863 424d 6546 6374 4968 0000 0000 0000     chMBFetchI......

08008860 <__func__.5232.5087.4554>:
 8008860:	6863 6854 4464 446f 7165 6575 6575 654e     chThdDoDequeueNe
 8008870:	7478 0049 0000 0000 0000 0000 0000 0000     xtI.............

08008880 <__func__.5784.5657.4565>:
 8008880:	6863 6553 536d 6769 616e 496c 0000 0000     chSemSignalI....

08008890 <__func__.5755.5653.4566>:
 8008890:	6863 6553 526d 7365 7465 0049 0000 0000     chSemResetI.....

080088a0 <__func__.5046.4317.4424>:
 80088a0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

080088b0 <__func__.5760.7159.4434>:
 80088b0:	6863 6f50 6c6f 6c41 6f6c 4963 0000 0000     chPoolAllocI....

080088c0 <__func__.5046.6877.4432>:
 80088c0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

080088d0 <__func__.5808.6805.4422>:
 80088d0:	6863 514f 7257 7469 5465 6d69 6f65 7475     chOQWriteTimeout
	...

080088f0 <__func__.5780.5656.4417>:
 80088f0:	6863 6553 536d 6769 616e 006c 0000 0000     chSemSignal.....

08008900 <__func__.5799.5659.4368>:
 8008900:	6863 6553 536d 6769 616e 576c 6961 0074     chSemSignalWait.

08008910 <__func__.5746.6373.4420>:
 8008910:	6863 734d 5367 6e65 0064 0000 0000 0000     chMsgSend.......
 8008920:	5653 3523 0000 0000 5653 3423 0000 0000     SV#5....SV#4....

08008930 <__func__.5777.5092.4425>:
 8008930:	6863 6854 5364 7465 7250 6f69 6972 7974     chThdSetPriority
	...

08008950 <__func__.5802.6594.4430>:
 8008950:	6863 424d 6546 6374 5368 0000 0000 0000     chMBFetchS......

08008960 <__func__.5755.6374.4418>:
 8008960:	6863 734d 5267 6c65 6165 6573 0000 0000     chMsgRelease....

08008970 <__func__.5046.6372.4419>:
 8008970:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008980 <__func__.5046.7157>:
 8008980:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008990 <__func__.5046.6000>:
 8008990:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....
 80089a0:	0043 0000 0042 0000 0044 0000 4241 4443     C...B...D...ABCD
 80089b0:	0045 0000 4241 0000 0000 0000 0000 0000     E...AB..........

080089c0 <__func__.5774.6005.4504>:
 80089c0:	6863 6f43 646e 6157 7469 0053 0000 0000     chCondWaitS.....

080089d0 <__func__.5786.6006.4506>:
 80089d0:	6863 6f43 646e 6157 7469 6954 656d 756f     chCondWaitTimeou
 80089e0:	5374 0000 0000 0000 0000 0000 0000 0000     tS..............

080089f0 <__func__.5046.5821>:
 80089f0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008a00 <__func__.5046.8614>:
 8008a00:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008a10 <__func__.5747.6217>:
 8008a10:	6863 7645 5274 6765 7369 6574 4d72 7361     chEvtRegisterMas
 8008a20:	576b 7469 4668 616c 7367 0000 0000 0000     kWithFlags......
 8008a30:	7420 6d69 7265 2f73 0053 0000 7720 6961      timers/S... wai
 8008a40:	2b74 6973 6e67 6c61 532f 0000 6c20 636f     t+signal/S.. loc
 8008a50:	2b6b 6e75 6f6c 6b63 532f 0000 0000 0000     k+unlock/S......

08008a60 <evhndl.9832>:
 8008a60:	53b1 0800 53a1 0800 5391 0800 0000 0000     .S...S...S......

08008a70 <__func__.5781.6220.4526>:
 8008a70:	6863 7645 5374 6769 616e 006c 0000 0000     chEvtSignal.....

08008a80 <__func__.5046.10565.4376>:
 8008a80:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008a90 <__func__.5216.5088.4395>:
 8008a90:	6863 6854 5364 6174 7472 0049 0000 0000     chThdStartI.....

08008aa0 <__func__.5772.6804.4377>:
 8008aa0:	6863 5149 6552 6461 6954 656d 756f 0074     chIQReadTimeout.

08008ab0 <__func__.5046.10873>:
 8008ab0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....
 8008ac0:	6220 7479 7365 532f 0000 0000 0000 0000      bytes/S........

08008ad0 <__func__.5046.6803>:
 8008ad0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008ae0 <__func__.5046.9616>:
 8008ae0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008af0 <__func__.5220.5089>:
 8008af0:	6863 6854 5364 656c 7065 0053 0000 0000     chThdSleepS.....

08008b00 <__func__.5046.5090>:
 8008b00:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008b10 <__func__.5046.6587>:
 8008b10:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008b20 <__func__.5046.9296>:
 8008b20:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008b30 <__func__.5790.5658.4286>:
 8008b30:	6863 6553 416d 6464 6f43 6e75 6574 4972     chSemAddCounterI
	...

08008b50 <__func__.5046.6216>:
 8008b50:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008b60 <__func__.5046.8827>:
 8008b60:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008b70 <__func__.5046.9829>:
 8008b70:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008b80 <testbmk3.4725>:
 8008b80:	9544 0800 0000 0000 0000 0000 1de1 0800     D...............

08008b90 <testthd3.4649>:
 8008b90:	9268 0800 0000 0000 0000 0000 79c1 0800     h............y..

08008ba0 <testpools1.4698>:
 8008ba0:	9444 0800 0431 0800 0000 0000 54f1 0800     D...1........T..

08008bb0 <testsys3.4641>:
 8008bb0:	921c 0800 0000 0000 0000 0000 5e21 0800     ............!^..

08008bc0 <testmsg1.4672>:
 8008bc0:	9398 0800 0000 0000 0000 0000 5311 0800     .............S..

08008bd0 <testbmk10.4732>:
 8008bd0:	9630 0800 0000 0000 0000 0000 5a51 0800     0...........QZ..

08008be0 <vmt.7998.4801>:
 8008be0:	3ed1 0800 6001 0800 6261 0800 6181 0800     .>...`..ab...a..
 8008bf0:	6251 0800 6171 0800 3ec1 0800 5ff1 0800     Qb..qa...>..._..

08008c00 <ch_debug.4741>:
 8008c00:	616d 6e69 1600 1844 0404 0848 100c 1814     main..D...H.....
 8008c10:	201c 2221 0000 0000 0000 0000 0000 0000     . !"............

08008c20 <testmtx4.4666>:
 8008c20:	9328 0800 0351 0800 0000 0000 4c21 0800     (...Q.......!L..

08008c30 <testevt1.4684>:
 8008c30:	93c8 0800 54c1 0800 0000 0000 2d21 0800     .....T......!-..

08008c40 <testsem2.4657>:
 8008c40:	92ac 0800 03d1 0800 0000 0000 4661 0800     ............aF..

08008c50 <testbmk13.4735>:
 8008c50:	9698 0800 0000 0000 0000 0000 0ca1 0800     ................

08008c60 <testdyn1.4704>:
 8008c60:	9460 0800 0541 0800 0000 0000 4491 0800     `...A........D..

08008c70 <testsem1.4652>:
 8008c70:	9294 0800 03e1 0800 0000 0000 7431 0800     ............1t..

08008c80 <testdyn3.4710>:
 8008c80:	94bc 0800 3021 0800 0000 0000 2271 0800     ....!0......q"..

08008c90 <patterns.8671.4633>:
 8008c90:	8e10 0800 8ce0 0800 8fa0 0800 8d90 0800     ................
 8008ca0:	8dd0 0800 8d50 0800 8fc0 0800 8cd0 0800     ....P...........
 8008cb0:	96c0 0800 8e70 0800 8f90 0800 8e30 0800     ....p.......0...
	...

08008cd0 <patternheap.4691>:
 8008cd0:	8f60 0800 0000 0000 0000 0000 0000 0000     `...............

08008ce0 <patternthd.4642>:
 8008ce0:	8ed0 0800 8f00 0800 8b90 0800 8f30 0800     ............0...
	...

08008d00 <testbmk7.4729>:
 8008d00:	95b8 0800 0401 0800 0000 0000 1b81 0800     ................

08008d10 <testsys1.4635>:
 8008d10:	91e8 0800 0000 0000 0000 0000 5cc1 0800     .............\..

08008d20 <testbmk1.4719>:
 8008d20:	9514 0800 0000 0000 0000 0000 1f41 0800     ............A...

08008d30 <testbmk4.4726>:
 8008d30:	955c 0800 0000 0000 0000 0000 1cf1 0800     \...............

08008d40 <testbmk9.4731>:
 8008d40:	960c 0800 0000 0000 0000 0000 60a1 0800     .............`..

08008d50 <patternmbox.4677>:
 8008d50:	8df0 0800 0000 0000 0000 0000 0000 0000     ................

08008d60 <testmtx1.4661>:
 8008d60:	9304 0800 0371 0800 0000 0000 4391 0800     ....q........C..

08008d70 <testsys2.4640>:
 8008d70:	9200 0800 0000 0000 0000 0000 3051 0800     ............Q0..

08008d80 <testbmk11.4733>:
 8008d80:	9654 0800 03f1 0800 0000 0000 5b01 0800     T............[..

08008d90 <patternmtx.4660>:
 8008d90:	8d60 0800 8c20 0800 8dc0 0800 8f50 0800     `... .......P...
 8008da0:	8e80 0800 8f80 0800 0000 0000 0000 0000     ................

08008db0 <testdyn2.4709>:
 8008db0:	948c 0800 0411 0800 0000 0000 4eb1 0800     .............N..

08008dc0 <testmtx5.4667>:
 8008dc0:	9344 0800 0341 0800 0000 0000 7361 0800     D...A.......as..

08008dd0 <patternmsg.4671>:
 8008dd0:	8bc0 0800 0000 0000 0000 0000 0000 0000     ................

08008de0 <testsem3.4658>:
 8008de0:	92c0 0800 03c1 0800 0000 0000 2f01 0800     ............./..

08008df0 <testmbox1.4678>:
 8008df0:	93a8 0800 0391 0800 0000 0000 63d1 0800     .............c..

08008e00 <testqueues2.4717>:
 8008e00:	94fc 0800 0461 0800 0000 0000 14f1 0800     ....a...........

08008e10 <patternsys.4634>:
 8008e10:	8d10 0800 8d70 0800 8bb0 0800 0000 0000     ....p...........

08008e20 <__func__.5046.7946.4739>:
 8008e20:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

08008e30 <patternbmk.4718>:
 8008e30:	8d20 0800 8ee0 0800 8b80 0800 8d30 0800      ...........0...
 8008e40:	8ec0 0800 8fd0 0800 8d00 0800 8f40 0800     ............@...
 8008e50:	8d40 0800 8bd0 0800 8d80 0800 8f10 0800     @...............
 8008e60:	8c50 0800 0000 0000 0000 0000 0000 0000     P...............

08008e70 <patterndyn.4703>:
 8008e70:	8c60 0800 8db0 0800 8c80 0800 0000 0000     `...............

08008e80 <testmtx7.4669>:
 8008e80:	936c 0800 0301 0800 0000 0000 49f1 0800     l............I..

08008e90 <__func__.6306.7947.4737>:
 8008e90:	6473 7453 7261 0074 0000 0000 0000 0000     sdStart.........

08008ea0 <testqueues1.4712>:
 8008ea0:	94e4 0800 0491 0800 0000 0000 6ed1 0800     .............n..

08008eb0 <testevt3.4690>:
 8008eb0:	9408 0800 54e1 0800 0000 0000 7c61 0800     .....T......a|..

08008ec0 <testbmk5.4727>:
 8008ec0:	9578 0800 0000 0000 0000 0000 1fb1 0800     x...............

08008ed0 <testthd1.4643>:
 8008ed0:	9230 0800 0000 0000 0000 0000 5be1 0800     0............[..

08008ee0 <testbmk2.4724>:
 8008ee0:	952c 0800 0000 0000 0000 0000 1ed1 0800     ,...............

08008ef0 <__func__.5744.5822>:
 8008ef0:	6863 744d 4f78 6a62 6365 4974 696e 0074     chMtxObjectInit.

08008f00 <testthd2.4648>:
 8008f00:	924c 0800 0000 0000 0000 0000 6291 0800     L............b..

08008f10 <testbmk12.4734>:
 8008f10:	9678 0800 0381 0800 0000 0000 5b71 0800     x...........q[..

08008f20 <testevt2.4689>:
 8008f20:	93ec 0800 54d1 0800 0000 0000 7641 0800     .....T......Av..

08008f30 <testthd4.4650>:
 8008f30:	9284 0800 0000 0000 0000 0000 6d61 0800     ............am..

08008f40 <testbmk8.4730>:
 8008f40:	95e0 0800 0000 0000 0000 0000 4571 0800     ............qE..

08008f50 <testmtx6.4668>:
 8008f50:	9354 0800 0321 0800 0000 0000 4b11 0800     T...!........K..

08008f60 <testheap1.4692>:
 8008f60:	941c 0800 2ff1 0800 0000 0000 2a91 0800     ...../.......*..

08008f70 <testsem4.4659>:
 8008f70:	92e0 0800 0000 0000 0000 0000 11e1 0800     ................

08008f80 <testmtx8.4670>:
 8008f80:	9384 0800 02d1 0800 0000 0000 4301 0800     .............C..

08008f90 <patternqueues.4711>:
 8008f90:	8ea0 0800 8e00 0800 0000 0000 0000 0000     ................

08008fa0 <patternsem.4651>:
 8008fa0:	8c70 0800 8c40 0800 8de0 0800 8f70 0800     p...@.......p...
	...

08008fc0 <patternevt.4683>:
 8008fc0:	8c30 0800 8f20 0800 8eb0 0800 0000 0000     0... ...........

08008fd0 <testbmk6.4728>:
 8008fd0:	9598 0800 0000 0000 0000 0000 59d1 0800     .............Y..
 8008fe0:	6469 656c 0000 0000 2a2a 202a 6843 6269     idle....*** Chib
 8008ff0:	4f69 2f53 5452 7420 7365 2074 7573 7469     iOS/RT test suit
 8009000:	0065 0000 2a2a 002a 2a2a 202a 654b 6e72     e...***.*** Kern
 8009010:	6c65 203a 2020 2020 2020 0000 2d2d 202d     el:       ..--- 
 8009020:	6554 7473 4320 7361 2065 0000 0029 0000     Test Case ..)...
 8009030:	2d2d 202d 6552 7573 746c 203a 4146 4c49     --- Result: FAIL
 8009040:	5255 2045 2328 0000 295d 0000 2d2d 202d     URE (#..])..--- 
 8009050:	6552 7573 746c 203a 5553 4343 5345 0053     Result: SUCCESS.
 8009060:	4146 4c49 5255 0045 2e33 2e31 0034 0000     FAILURE.3.1.4...
 8009070:	2a2a 202a 6f43 706d 6c69 6465 203a 2020     *** Compiled:   
 8009080:	2020 0000 754a 206c 3331 3220 3130 2036       ..Jul 13 2016 
 8009090:	202d 3332 333a 3a38 3732 0000 2a2a 202a     - 23:38:27..*** 
 80090a0:	6f43 706d 6c69 7265 203a 2020 2020 0000     Compiler:     ..
 80090b0:	4347 2043 2e34 2e37 2034 3032 3331 3930     GCC 4.7.4 201309
 80090c0:	3331 2820 6572 656c 7361 2965 5b20 5241     13 (release) [AR
 80090d0:	2f4d 6d65 6562 6464 6465 342d 375f 622d     M/embedded-4_7-b
 80090e0:	6172 636e 2068 6572 6976 6973 6e6f 3220     ranch revision 2
 80090f0:	3230 3036 5d31 0000 2a2a 202a 7241 6863     02601]..*** Arch
 8009100:	7469 6365 7574 6572 203a 0000 5241 764d     itecture: ..ARMv
 8009110:	2d36 004d 2a2a 202a 6f43 6572 5620 7261     6-M.*** Core Var
 8009120:	6169 746e 203a 0000 6f43 7472 7865 4d2d     iant: ..Cortex-M
 8009130:	0030 0000 2a2a 202a 6f50 7472 4920 666e     0...*** Port Inf
 8009140:	3a6f 2020 2020 0000 7250 6565 706d 6974     o:    ..Preempti
 8009150:	6e6f 7420 7268 756f 6867 4e20 494d 0000     on through NMI..
 8009160:	2a2a 202a 6c50 7461 6f66 6d72 203a 2020     *** Platform:   
 8009170:	2020 0000 5453 334d 4632 3730 7832 2042       ..STM32F072xB 
 8009180:	6e45 7274 2079 654c 6576 206c 654d 6964     Entry Level Medi
 8009190:	6d75 4420 6e65 6973 7974 6420 7665 6369     um Density devic
 80091a0:	7365 0000 2a2a 202a 6554 7473 4220 616f     es..*** Test Boa
 80091b0:	6472 203a 2020 0000 5453 5320 4d54 3233     rd:   ..ST STM32
 80091c0:	3046 3237 2d42 6944 6373 766f 7265 0079     F072B-Discovery.
 80091d0:	2820 0000 5b20 0000 6946 616e 206c 6572      (.. [..Final re
 80091e0:	7573 746c 203a 0000 7953 7473 6d65 202c     sult: ..System, 
 80091f0:	7263 7469 6369 6c61 7a20 6e6f 7365 0000     critical zones..
 8009200:	7953 7473 6d65 202c 6e69 6574 7272 7075     System, interrup
 8009210:	7374 6820 6e61 6c64 6e69 0067 7953 7473     ts handling.Syst
 8009220:	6d65 202c 6e69 6574 7267 7469 0079 0000     em, integrity...
 8009230:	6854 6572 6461 2c73 6520 716e 6575 6975     Threads, enqueui
 8009240:	676e 7420 7365 2074 3123 0000 6854 6572     ng test #1..Thre
 8009250:	6461 2c73 6520 716e 6575 6975 676e 7420     ads, enqueuing t
 8009260:	7365 2074 3223 0000 6854 6572 6461 2c73     est #2..Threads,
 8009270:	7020 6972 726f 7469 2079 6863 6e61 6567      priority change
 8009280:	0000 0000 6854 6572 6461 2c73 6420 6c65     ....Threads, del
 8009290:	7961 0073 6553 616d 6870 726f 7365 202c     ays.Semaphores, 
 80092a0:	6e65 7571 7565 6e69 0067 0000 6553 616d     enqueuing...Sema
 80092b0:	6870 726f 7365 202c 6974 656d 756f 0074     phores, timeout.
 80092c0:	6553 616d 6870 726f 7365 202c 7461 6d6f     Semaphores, atom
 80092d0:	6369 7320 6769 616e 2d6c 6177 7469 0000     ic signal-wait..
 80092e0:	6942 616e 7972 5320 6d65 7061 6f68 6572     Binary Semaphore
 80092f0:	2c73 6620 6e75 7463 6f69 616e 696c 7974     s, functionality
 8009300:	0000 0000 754d 6574 6578 2c73 7020 6972     ....Mutexes, pri
 8009310:	726f 7469 2079 6e65 7571 7565 6e69 2067     ority enqueuing 
 8009320:	6574 7473 0000 0000 754d 6574 6578 2c73     test....Mutexes,
 8009330:	7020 6972 726f 7469 2079 6572 7574 6e72      priority return
 8009340:	0000 0000 754d 6574 6578 2c73 7320 6174     ....Mutexes, sta
 8009350:	7574 0073 6f43 646e 6156 2c72 7320 6769     tus.CondVar, sig
 8009360:	616e 206c 6574 7473 0000 0000 6f43 646e     nal test....Cond
 8009370:	6156 2c72 6220 6f72 6461 6163 7473 7420     Var, broadcast t
 8009380:	7365 0074 6f43 646e 6156 2c72 6220 6f6f     est.CondVar, boo
 8009390:	7473 7420 7365 0074 654d 7373 6761 7365     st test.Messages
 80093a0:	202c 6f6c 706f 0000 614d 6c69 6f62 6578     , loop..Mailboxe
 80093b0:	2c73 7120 6575 6975 676e 6120 646e 7420     s, queuing and t
 80093c0:	6d69 6f65 7475 0073 7645 6e65 7374 202c     imeouts.Events, 
 80093d0:	6572 6967 7473 6172 6974 6e6f 6120 646e     registration and
 80093e0:	6420 7369 6170 6374 0068 0000 7645 6e65      dispatch...Even
 80093f0:	7374 202c 6177 7469 6120 646e 6220 6f72     ts, wait and bro
 8009400:	6461 6163 7473 0000 7645 6e65 7374 202c     adcast..Events, 
 8009410:	6974 656d 756f 7374 0000 0000 6548 7061     timeouts....Heap
 8009420:	202c 6c61 6f6c 6163 6974 6e6f 6120 646e     , allocation and
 8009430:	6620 6172 6d67 6e65 6174 6974 6e6f 7420      fragmentation t
 8009440:	7365 0074 654d 6f6d 7972 5020 6f6f 736c     est.Memory Pools
 8009450:	202c 7571 7565 2f65 6564 7571 7565 0065     , queue/dequeue.
 8009460:	7944 616e 696d 2063 5041 7349 202c 6874     Dynamic APIs, th
 8009470:	6572 6461 2073 7263 6165 6974 6e6f 6620     reads creation f
 8009480:	6f72 206d 6568 7061 0000 0000 7944 616e     rom heap....Dyna
 8009490:	696d 2063 5041 7349 202c 6874 6572 6461     mic APIs, thread
 80094a0:	2073 7263 6165 6974 6e6f 6620 6f72 206d     s creation from 
 80094b0:	656d 6f6d 7972 7020 6f6f 006c 7944 616e     memory pool.Dyna
 80094c0:	696d 2063 5041 7349 202c 6572 6967 7473     mic APIs, regist
 80094d0:	7972 6120 646e 7220 6665 7265 6e65 6563     ry and reference
 80094e0:	0073 0000 7551 7565 7365 202c 6e69 7570     s...Queues, inpu
 80094f0:	2074 7571 7565 7365 0000 0000 7551 7565     t queues....Queu
 8009500:	7365 202c 756f 7074 7475 7120 6575 6575     es, output queue
 8009510:	0073 0000 6542 636e 6d68 7261 2c6b 6d20     s...Benchmark, m
 8009520:	7365 6173 6567 2073 3123 0000 6542 636e     essages #1..Benc
 8009530:	6d68 7261 2c6b 6d20 7365 6173 6567 2073     hmark, messages 
 8009540:	3223 0000 6542 636e 6d68 7261 2c6b 6d20     #2..Benchmark, m
 8009550:	7365 6173 6567 2073 3323 0000 6542 636e     essages #3..Benc
 8009560:	6d68 7261 2c6b 6320 6e6f 6574 7478 7320     hmark, context s
 8009570:	6977 6374 0068 0000 6542 636e 6d68 7261     witch...Benchmar
 8009580:	2c6b 7420 7268 6165 7364 202c 7566 6c6c     k, threads, full
 8009590:	6320 6379 656c 0000 6542 636e 6d68 7261      cycle..Benchmar
 80095a0:	2c6b 7420 7268 6165 7364 202c 7263 6165     k, threads, crea
 80095b0:	6574 6f20 6c6e 0079 6542 636e 6d68 7261     te only.Benchmar
 80095c0:	2c6b 6d20 7361 2073 6572 6373 6568 7564     k, mass reschedu
 80095d0:	656c 202c 2035 6874 6572 6461 0073 0000     le, 5 threads...
 80095e0:	6542 636e 6d68 7261 2c6b 7220 756f 646e     Benchmark, round
 80095f0:	7220 626f 6e69 6320 6e6f 6574 7478 7320      robin context s
 8009600:	6977 6374 6968 676e 0000 0000 6542 636e     witching....Benc
 8009610:	6d68 7261 2c6b 4920 4f2f 5120 6575 6575     hmark, I/O Queue
 8009620:	2073 6874 6f72 6775 7068 7475 0000 0000     s throughput....
 8009630:	6542 636e 6d68 7261 2c6b 7620 7269 7574     Benchmark, virtu
 8009640:	6c61 7420 6d69 7265 2073 6573 2f74 6572     al timers set/re
 8009650:	6573 0074 6542 636e 6d68 7261 2c6b 7320     set.Benchmark, s
 8009660:	6d65 7061 6f68 6572 2073 6177 7469 732f     emaphores wait/s
 8009670:	6769 616e 006c 0000 6542 636e 6d68 7261     ignal...Benchmar
 8009680:	2c6b 6d20 7475 7865 7365 6c20 636f 2f6b     k, mutexes lock/
 8009690:	6e75 6f6c 6b63 0000 6542 636e 6d68 7261     unlock..Benchmar
 80096a0:	2c6b 5220 4d41 6620 6f6f 7074 6972 746e     k, RAM footprint
	...

080096c0 <patternpools.4697>:
 80096c0:	8ba0 0800 0000 0000                         ........
